/*! For license information please see app.c9ab37d4f97a43ade0d4.js.LICENSE.txt */
!function() {
    var v, E, k, R, U, H = {
        "7210": function(v, E, k) {
            "use strict";
            k.d(E, {
                "mv": function() {
                    return Mt
                },
                "AA": function() {
                    return St
                },
                "yM": function() {
                    return createEvent
                },
                "h": function() {
                    return h
                },
                "GH": function() {
                    return proxyCustomElement
                }
            });
            const R = !1
              , U = !0
              , H = !1
              , G = !0
              , W = !0
              , Z = !0
              , Y = !0
              , J = !0
              , K = !0
              , X = !0
              , Q = !0
              , ee = !0
              , te = !0
              , ne = !0
              , re = !0
              , oe = !1
              , ie = !0
              , ae = !0
              , se = !0
              , ce = !0
              , le = !0
              , ue = !0
              , de = !0
              , pe = !0
              , fe = !0
              , he = !0
              , me = !0
              , ge = !0
              , _e = !0
              , ve = !0
              , ye = !0
              , be = !0
              , Se = !0
              , we = !0
              , Ee = !0
              , Ce = !0
              , Te = !0
              , xe = !0
              , Ae = !0
              , Ie = !0
              , ke = !0
              , Oe = !0
              , Pe = !0
              , Re = !0
              , Me = !1
              , Ne = !1
              , De = !1
              , $e = !1
              , Le = !1
              , Fe = !1
              , je = !1
              , Be = !1
              , Ue = !1
              , He = !0
              , ze = !1
              , qe = !0
              , Ge = !1
              , Ve = !0
              , We = !0
              , Ze = !0
              , Ye = !1
              , Je = !0
              , Ke = !0
              , Xe = !0
              , Qe = !1
              , et = !1
              , tt = !1
              , nt = !0
              , rt = "app";
            let ot, it, at, st, ct = 0, lt = !1, ut = !1, dt = !1, pt = !1, ft = null, ht = 0, mt = !1;
            const createTime = (v, E="") => {
                if (Ue && performance.mark) {
                    const k = `st:${v}:${E}:${ct++}`;
                    return performance.mark(k),
                    () => performance.measure(`[Stencil] ${v}() <${E}>`, k)
                }
                return () => {}
            }
              , gt = "s-id"
              , _t = "sty-id"
              , vt = "c-id"
              , yt = "http://www.w3.org/1999/xlink"
              , bt = {}
              , isComplexType = v => "object" === (v = typeof v) || "function" === v;
            function queryNonceMetaTagContent(v) {
                var E, k, R;
                return null !== (R = null === (k = null === (E = v.head) || void 0 === E ? void 0 : E.querySelector('meta[name="csp-nonce"]')) || void 0 === k ? void 0 : k.getAttribute("content")) && void 0 !== R ? R : void 0
            }
            const h = (v, E, ...k) => {
                let R = null
                  , U = null
                  , H = null
                  , G = !1
                  , W = !1;
                const Z = []
                  , walk = E => {
                    for (let k = 0; k < E.length; k++)
                        R = E[k],
                        Array.isArray(R) ? walk(R) : null != R && "boolean" != typeof R && ((G = "function" != typeof v && !isComplexType(R)) ? R = String(R) : De && "function" != typeof v && void 0 === R.$flags$ && consoleDevError("vNode passed as children has unexpected type.\nMake sure it's using the correct h() function.\nEmpty objects can also be the cause, look for JSX comments that became objects."),
                        G && W ? Z[Z.length - 1].$text$ += R : Z.push(G ? newVNode(null, R) : R),
                        W = G)
                }
                ;
                if (walk(k),
                E && (De && "input" === v && validateInputProperties(E),
                Ce && E.key && (U = E.key),
                He && E.name && (H = E.name),
                we)) {
                    const v = E.className || E.class;
                    v && (E.class = "object" != typeof v ? v : Object.keys(v).filter((E => v[E])).join(" "))
                }
                if (De && Z.some(isHost) && consoleDevError("The <Host> must be the single root component. Make sure:\n- You are NOT using hostData() and <Host> in the same component.\n- <Host> is used once, and it's the single root component of the render() function."),
                Ee && "function" == typeof v)
                    return v(null === E ? {} : E, Z, wt);
                const Y = newVNode(v, null);
                return Y.$attrs$ = E,
                Z.length > 0 && (Y.$children$ = Z),
                Ce && (Y.$key$ = U),
                He && (Y.$name$ = H),
                Y
            }
              , newVNode = (v, E) => {
                const k = {
                    "$flags$": 0,
                    "$tag$": v,
                    "$text$": E,
                    "$elm$": null,
                    "$children$": null
                };
                return be && (k.$attrs$ = null),
                Ce && (k.$key$ = null),
                He && (k.$name$ = null),
                k
            }
              , St = {}
              , isHost = v => v && v.$tag$ === St
              , wt = {
                "forEach": (v, E) => v.map(convertToPublic).forEach(E),
                "map": (v, E) => v.map(convertToPublic).map(E).map(convertToPrivate)
            }
              , convertToPublic = v => ({
                "vattrs": v.$attrs$,
                "vchildren": v.$children$,
                "vkey": v.$key$,
                "vname": v.$name$,
                "vtag": v.$tag$,
                "vtext": v.$text$
            })
              , convertToPrivate = v => {
                if ("function" == typeof v.vtag) {
                    const E = Object.assign({}, v.vattrs);
                    return v.vkey && (E.key = v.vkey),
                    v.vname && (E.name = v.vname),
                    h(v.vtag, E, ...v.vchildren || [])
                }
                const E = newVNode(v.vtag, v.vtext);
                return E.$attrs$ = v.vattrs,
                E.$children$ = v.vchildren,
                E.$key$ = v.vkey,
                E.$name$ = v.vname,
                E
            }
              , validateInputProperties = v => {
                const E = Object.keys(v)
                  , k = E.indexOf("value");
                if (-1 === k)
                    return;
                const R = E.indexOf("type")
                  , U = E.indexOf("min")
                  , H = E.indexOf("max")
                  , G = E.indexOf("step");
                (k < R || k < U || k < H || k < G) && consoleDevWarn('The "value" prop of <input> should be set after "min", "max", "type" and "step"')
            }
              , clientHydrate = (v, E, k, R, U, H, G) => {
                let W, Z, Y, J;
                if (1 === H.nodeType) {
                    for (W = H.getAttribute(vt),
                    W && (Z = W.split("."),
                    Z[0] !== G && "0" !== Z[0] || (Y = {
                        "$flags$": 0,
                        "$hostId$": Z[0],
                        "$nodeId$": Z[1],
                        "$depth$": Z[2],
                        "$index$": Z[3],
                        "$tag$": H.tagName.toLowerCase(),
                        "$elm$": H,
                        "$attrs$": null,
                        "$children$": null,
                        "$key$": null,
                        "$name$": null,
                        "$text$": null
                    },
                    E.push(Y),
                    H.removeAttribute(vt),
                    v.$children$ || (v.$children$ = []),
                    v.$children$[Y.$index$] = Y,
                    v = Y,
                    R && "0" === Y.$depth$ && (R[Y.$index$] = Y.$elm$))),
                    J = H.childNodes.length - 1; J >= 0; J--)
                        clientHydrate(v, E, k, R, U, H.childNodes[J], G);
                    if (H.shadowRoot)
                        for (J = H.shadowRoot.childNodes.length - 1; J >= 0; J--)
                            clientHydrate(v, E, k, R, U, H.shadowRoot.childNodes[J], G)
                } else if (8 === H.nodeType)
                    Z = H.nodeValue.split("."),
                    Z[1] !== G && "0" !== Z[1] || (W = Z[0],
                    Y = {
                        "$flags$": 0,
                        "$hostId$": Z[1],
                        "$nodeId$": Z[2],
                        "$depth$": Z[3],
                        "$index$": Z[4],
                        "$elm$": H,
                        "$attrs$": null,
                        "$children$": null,
                        "$key$": null,
                        "$name$": null,
                        "$tag$": null,
                        "$text$": null
                    },
                    "t" === W ? (Y.$elm$ = H.nextSibling,
                    Y.$elm$ && 3 === Y.$elm$.nodeType && (Y.$text$ = Y.$elm$.textContent,
                    E.push(Y),
                    H.remove(),
                    v.$children$ || (v.$children$ = []),
                    v.$children$[Y.$index$] = Y,
                    R && "0" === Y.$depth$ && (R[Y.$index$] = Y.$elm$))) : Y.$hostId$ === G && ("s" === W ? (Y.$tag$ = "slot",
                    Z[5] ? H["s-sn"] = Y.$name$ = Z[5] : H["s-sn"] = "",
                    H["s-sr"] = !0,
                    fe && R && (Y.$elm$ = Rt.createElement(Y.$tag$),
                    Y.$name$ && Y.$elm$.setAttribute("name", Y.$name$),
                    H.parentNode.insertBefore(Y.$elm$, H),
                    H.remove(),
                    "0" === Y.$depth$ && (R[Y.$index$] = Y.$elm$)),
                    k.push(Y),
                    v.$children$ || (v.$children$ = []),
                    v.$children$[Y.$index$] = Y) : "r" === W && (fe && R ? H.remove() : He && (U["s-cr"] = H,
                    H["s-cn"] = !0))));
                else if (v && "style" === v.$tag$) {
                    const E = newVNode(null, H.textContent);
                    E.$elm$ = H,
                    E.$index$ = "0",
                    v.$children$ = [E]
                }
            }
              , initializeDocumentHydrate = (v, E) => {
                if (1 === v.nodeType) {
                    let k = 0;
                    for (; k < v.childNodes.length; k++)
                        initializeDocumentHydrate(v.childNodes[k], E);
                    if (v.shadowRoot)
                        for (k = 0; k < v.shadowRoot.childNodes.length; k++)
                            initializeDocumentHydrate(v.shadowRoot.childNodes[k], E)
                } else if (8 === v.nodeType) {
                    const k = v.nodeValue.split(".");
                    "o" === k[0] && (E.set(k[1] + "." + k[2], v),
                    v.nodeValue = "",
                    v["s-en"] = k[3])
                }
            }
              , computeMode = v => Ot.map((E => E(v))).find((v => !!v))
              , createEvent = (v, E, k) => {
                const R = (v => Be ? getHostRef(v).$hostElement$ : v)(v);
                return {
                    "emit": v => (De && !R.isConnected && consoleDevWarn(`The "${E}" event was emitted, but the dispatcher node is no longer connected to the dom.`),
                    emitEvent(R, E, {
                        "bubbles": !!(4 & k),
                        "composed": !!(2 & k),
                        "cancelable": !!(1 & k),
                        "detail": v
                    }))
                }
            }
              , emitEvent = (v, E, k) => {
                const R = Nt.ce(E, k);
                return v.dispatchEvent(R),
                R
            }
              , Et = new WeakMap
              , registerStyle = (v, E, k) => {
                let R = kt.get(v);
                Lt && k ? (R = R || new CSSStyleSheet,
                "string" == typeof R ? R = E : R.replaceSync(E)) : R = E,
                kt.set(v, R)
            }
              , addStyle = (v, E, k, R) => {
                var U;
                let H = getScopeId(E, k);
                const G = kt.get(H);
                if (!nt)
                    return H;
                if (v = 11 === v.nodeType ? v : Rt,
                G)
                    if ("string" == typeof G) {
                        v = v.head || v;
                        let k, W = Et.get(v);
                        if (W || Et.set(v, W = new Set),
                        !W.has(H)) {
                            if (Fe && v.host && (k = v.querySelector(`[${_t}="${H}"]`)))
                                k.innerHTML = G;
                            else {
                                if (Ye && Nt.$cssShim$) {
                                    k = Nt.$cssShim$.createHostStyle(R, H, G, !!(10 & E.$flags$));
                                    const v = k["s-sc"];
                                    v && (H = v,
                                    W = null)
                                } else
                                    k = Rt.createElement("style"),
                                    k.innerHTML = G;
                                const Z = null !== (U = Nt.$nonce$) && void 0 !== U ? U : queryNonceMetaTagContent(Rt);
                                null != Z && k.setAttribute("nonce", Z),
                                (Le || Me) && k.setAttribute(_t, H),
                                v.insertBefore(k, v.querySelector("link"))
                            }
                            W && W.add(H)
                        }
                    } else
                        Je && !v.adoptedStyleSheets.includes(G) && (v.adoptedStyleSheets = [...v.adoptedStyleSheets, G]);
                return H
            }
              , attachStyles = v => {
                const E = v.$cmpMeta$
                  , k = v.$hostElement$
                  , R = E.$flags$
                  , U = createTime("attachStyles", E.$tagName$)
                  , H = addStyle(fe && Dt && k.shadowRoot ? k.shadowRoot : k.getRootNode(), E, v.$modeName$, k);
                (fe || pe) && me && 10 & R && (k["s-sc"] = H,
                k.classList.add(H + "-h"),
                pe && 2 & R && k.classList.add(H + "-s")),
                U()
            }
              , getScopeId = (v, E) => "sc-" + (ce && E && 32 & v.$flags$ ? v.$tagName$ + "-" + E : v.$tagName$)
              , setAccessor = (v, E, k, R, U, H) => {
                if (k !== R) {
                    let G = isMemberInElement(v, E)
                      , W = E.toLowerCase();
                    if (we && "class" === E) {
                        const E = v.classList
                          , U = parseClassList(k)
                          , H = parseClassList(R);
                        E.remove(...U.filter((v => v && !H.includes(v)))),
                        E.add(...H.filter((v => v && !U.includes(v))))
                    } else if (ke && "style" === E) {
                        if (ye)
                            for (const E in k)
                                R && null != R[E] || (!Le && E.includes("-") ? v.style.removeProperty(E) : v.style[E] = "");
                        for (const E in R)
                            k && R[E] === k[E] || (!Le && E.includes("-") ? v.style.setProperty(E, R[E]) : v.style[E] = R[E])
                    } else if (Ce && "key" === E)
                        ;
                    else if (xe && "ref" === E)
                        R && R(v);
                    else if (!Te || (Be ? G : v.__lookupSetter__(E)) || "o" !== E[0] || "n" !== E[1]) {
                        if (Ae) {
                            const Z = isComplexType(R);
                            if ((G || Z && null !== R) && !U)
                                try {
                                    if (v.tagName.includes("-"))
                                        v[E] = R;
                                    else {
                                        const U = null == R ? "" : R;
                                        "list" === E ? G = !1 : null != k && v[E] == U || (v[E] = U)
                                    }
                                } catch (v) {}
                            let Y = !1;
                            Se && W !== (W = W.replace(/^xlink\:?/, "")) && (E = W,
                            Y = !0),
                            null == R || !1 === R ? !1 === R && "" !== v.getAttribute(E) || (Se && Y ? v.removeAttributeNS(yt, E) : v.removeAttribute(E)) : (!G || 4 & H || U) && !Z && (R = !0 === R ? "" : R,
                            Se && Y ? v.setAttributeNS(yt, E, R) : v.setAttribute(E, R))
                        }
                    } else
                        E = "-" === E[2] ? E.slice(3) : isMemberInElement(Pt, W) ? W.slice(2) : W[2] + E.slice(3),
                        k && Nt.rel(v, E, k, !1),
                        R && Nt.ael(v, E, R, !1)
                }
            }
              , Ct = /\s/
              , parseClassList = v => v ? v.split(Ct) : []
              , updateElement = (v, E, k, R) => {
                const U = 11 === E.$elm$.nodeType && E.$elm$.host ? E.$elm$.host : E.$elm$
                  , H = v && v.$attrs$ || bt
                  , G = E.$attrs$ || bt;
                if (ye)
                    for (R in H)
                        R in G || setAccessor(U, R, H[R], void 0, k, E.$flags$);
                for (R in G)
                    setAccessor(U, R, H[R], G[R], k, E.$flags$)
            }
              , createElm = (v, E, k, R) => {
                const U = E.$children$[k];
                let H, G, W, Z = 0;
                if (He && !lt && (dt = !0,
                "slot" === U.$tag$ && (ot && R.classList.add(ot + "-s"),
                U.$flags$ |= U.$children$ ? 2 : 1)),
                De && U.$elm$ && consoleDevError(`The JSX ${null !== U.$text$ ? `"${U.$text$}" text` : `"${U.$tag$}" element`} node should not be shared within the same renderer. The renderer caches element lookups in order to improve performance. However, a side effect from this is that the exact same JSX node should not be reused. For more information please see https://stenciljs.com/docs/templating-jsx#avoid-shared-jsx-nodes`),
                Oe && null !== U.$text$)
                    H = U.$elm$ = Rt.createTextNode(U.$text$);
                else if (He && 1 & U.$flags$)
                    H = U.$elm$ = Ne || Le ? slotReferenceDebugNode(U) : Rt.createTextNode("");
                else {
                    if (ve && !pt && (pt = "svg" === U.$tag$),
                    H = U.$elm$ = ve ? Rt.createElementNS(pt ? "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml", He && 2 & U.$flags$ ? "slot-fb" : U.$tag$) : Rt.createElement(He && 2 & U.$flags$ ? "slot-fb" : U.$tag$),
                    ve && pt && "foreignObject" === U.$tag$ && (pt = !1),
                    be && updateElement(null, U, pt),
                    (fe || pe) && null != ot && H["s-si"] !== ot && H.classList.add(H["s-si"] = ot),
                    U.$children$)
                        for (Z = 0; Z < U.$children$.length; ++Z)
                            G = createElm(v, U, Z, H),
                            G && H.appendChild(G);
                    ve && ("svg" === U.$tag$ ? pt = !1 : "foreignObject" === H.tagName && (pt = !0))
                }
                return He && (H["s-hn"] = at,
                3 & U.$flags$ && (H["s-sr"] = !0,
                H["s-cr"] = it,
                H["s-sn"] = U.$name$ || "",
                W = v && v.$children$ && v.$children$[k],
                W && W.$tag$ === U.$tag$ && v.$elm$ && putBackInOriginalLocation(v.$elm$, !1))),
                H
            }
              , putBackInOriginalLocation = (v, E) => {
                Nt.$flags$ |= 1;
                const k = v.childNodes;
                for (let v = k.length - 1; v >= 0; v--) {
                    const R = k[v];
                    R["s-hn"] !== at && R["s-ol"] && (parentReferenceNode(R).insertBefore(R, referenceNode(R)),
                    R["s-ol"].remove(),
                    R["s-ol"] = void 0,
                    dt = !0),
                    E && putBackInOriginalLocation(R, E)
                }
                Nt.$flags$ &= -2
            }
              , addVnodes = (v, E, k, R, U, H) => {
                let G, W = He && v["s-cr"] && v["s-cr"].parentNode || v;
                for (fe && W.shadowRoot && W.tagName === at && (W = W.shadowRoot); U <= H; ++U)
                    R[U] && (G = createElm(null, k, U, v),
                    G && (R[U].$elm$ = G,
                    W.insertBefore(G, He ? referenceNode(E) : E)))
            }
              , removeVnodes = (v, E, k, R, U) => {
                for (; E <= k; ++E)
                    (R = v[E]) && (U = R.$elm$,
                    callNodeRefs(R),
                    He && (ut = !0,
                    U["s-ol"] ? U["s-ol"].remove() : putBackInOriginalLocation(U, !0)),
                    U.remove())
            }
              , isSameVnode = (v, E) => v.$tag$ === E.$tag$ && (He && "slot" === v.$tag$ ? v.$name$ === E.$name$ : !Ce || v.$key$ === E.$key$)
              , referenceNode = v => v && v["s-ol"] || v
              , parentReferenceNode = v => (v["s-ol"] ? v["s-ol"] : v).parentNode
              , patch = (v, E) => {
                const k = E.$elm$ = v.$elm$
                  , R = v.$children$
                  , U = E.$children$
                  , H = E.$tag$
                  , G = E.$text$;
                let W;
                Oe && null !== G ? Oe && He && (W = k["s-cr"]) ? W.parentNode.textContent = G : Oe && v.$text$ !== G && (k.data = G) : (ve && (pt = "svg" === H || "foreignObject" !== H && pt),
                (be || de) && (he && "slot" === H || updateElement(v, E, pt)),
                ye && null !== R && null !== U ? ( (v, E, k, R) => {
                    let U, H, G = 0, W = 0, Z = 0, Y = 0, J = E.length - 1, K = E[0], X = E[J], Q = R.length - 1, ee = R[0], te = R[Q];
                    for (; G <= J && W <= Q; )
                        if (null == K)
                            K = E[++G];
                        else if (null == X)
                            X = E[--J];
                        else if (null == ee)
                            ee = R[++W];
                        else if (null == te)
                            te = R[--Q];
                        else if (isSameVnode(K, ee))
                            patch(K, ee),
                            K = E[++G],
                            ee = R[++W];
                        else if (isSameVnode(X, te))
                            patch(X, te),
                            X = E[--J],
                            te = R[--Q];
                        else if (isSameVnode(K, te))
                            !He || "slot" !== K.$tag$ && "slot" !== te.$tag$ || putBackInOriginalLocation(K.$elm$.parentNode, !1),
                            patch(K, te),
                            v.insertBefore(K.$elm$, X.$elm$.nextSibling),
                            K = E[++G],
                            te = R[--Q];
                        else if (isSameVnode(X, ee))
                            !He || "slot" !== K.$tag$ && "slot" !== te.$tag$ || putBackInOriginalLocation(X.$elm$.parentNode, !1),
                            patch(X, ee),
                            v.insertBefore(X.$elm$, K.$elm$),
                            X = E[--J],
                            ee = R[++W];
                        else {
                            if (Z = -1,
                            Ce)
                                for (Y = G; Y <= J; ++Y)
                                    if (E[Y] && null !== E[Y].$key$ && E[Y].$key$ === ee.$key$) {
                                        Z = Y;
                                        break
                                    }
                            Ce && Z >= 0 ? (H = E[Z],
                            H.$tag$ !== ee.$tag$ ? U = createElm(E && E[W], k, Z, v) : (patch(H, ee),
                            E[Z] = void 0,
                            U = H.$elm$),
                            ee = R[++W]) : (U = createElm(E && E[W], k, W, v),
                            ee = R[++W]),
                            U && (He ? parentReferenceNode(K.$elm$).insertBefore(U, referenceNode(K.$elm$)) : K.$elm$.parentNode.insertBefore(U, K.$elm$))
                        }
                    G > J ? addVnodes(v, null == R[Q + 1] ? null : R[Q + 1].$elm$, k, R, W, Q) : ye && W > Q && removeVnodes(E, G, J)
                }
                )(k, R, E, U) : null !== U ? (ye && Oe && null !== v.$text$ && (k.textContent = ""),
                addVnodes(k, null, E, U, 0, U.length - 1)) : ye && null !== R && removeVnodes(R, 0, R.length - 1),
                ve && pt && "svg" === H && (pt = !1))
            }
              , updateFallbackSlotVisibility = v => {
                const E = v.childNodes;
                let k, R, U, H, G, W;
                for (R = 0,
                U = E.length; R < U; R++)
                    if (k = E[R],
                    1 === k.nodeType) {
                        if (k["s-sr"])
                            for (G = k["s-sn"],
                            k.hidden = !1,
                            H = 0; H < U; H++)
                                if (W = E[H].nodeType,
                                E[H]["s-hn"] !== k["s-hn"] || "" !== G) {
                                    if (1 === W && G === E[H].getAttribute("slot")) {
                                        k.hidden = !0;
                                        break
                                    }
                                } else if (1 === W || 3 === W && "" !== E[H].textContent.trim()) {
                                    k.hidden = !0;
                                    break
                                }
                        updateFallbackSlotVisibility(k)
                    }
            }
              , Tt = []
              , relocateSlotContent = v => {
                let E, k, R, U, H, G, W = 0;
                const Z = v.childNodes
                  , Y = Z.length;
                for (; W < Y; W++) {
                    if (E = Z[W],
                    E["s-sr"] && (k = E["s-cr"]) && k.parentNode)
                        for (R = k.parentNode.childNodes,
                        U = E["s-sn"],
                        G = R.length - 1; G >= 0; G--)
                            k = R[G],
                            k["s-cn"] || k["s-nr"] || k["s-hn"] === E["s-hn"] || (isNodeLocatedInSlot(k, U) ? (H = Tt.find((v => v.$nodeToRelocate$ === k)),
                            ut = !0,
                            k["s-sn"] = k["s-sn"] || U,
                            H ? H.$slotRefNode$ = E : Tt.push({
                                "$slotRefNode$": E,
                                "$nodeToRelocate$": k
                            }),
                            k["s-sr"] && Tt.map((v => {
                                isNodeLocatedInSlot(v.$nodeToRelocate$, k["s-sn"]) && (H = Tt.find((v => v.$nodeToRelocate$ === k)),
                                H && !v.$slotRefNode$ && (v.$slotRefNode$ = H.$slotRefNode$))
                            }
                            ))) : Tt.some((v => v.$nodeToRelocate$ === k)) || Tt.push({
                                "$nodeToRelocate$": k
                            }));
                    1 === E.nodeType && relocateSlotContent(E)
                }
            }
              , isNodeLocatedInSlot = (v, E) => 1 === v.nodeType ? null === v.getAttribute("slot") && "" === E || v.getAttribute("slot") === E : v["s-sn"] === E || "" === E
              , callNodeRefs = v => {
                xe && (v.$attrs$ && v.$attrs$.ref && v.$attrs$.ref(null),
                v.$children$ && v.$children$.map(callNodeRefs))
            }
              , renderVdom = (v, E) => {
                const k = v.$hostElement$
                  , R = v.$cmpMeta$
                  , U = v.$vnode$ || newVNode(null, null)
                  , H = isHost(E) ? E : h(null, null, E);
                if (at = k.tagName,
                De && Array.isArray(E) && E.some(isHost))
                    throw new Error(`The <Host> must be the single root component.\nLooks like the render() function of "${at.toLowerCase()}" is returning an array that contains the <Host>.\n\nThe render() function should look like this instead:\n\nrender() {\n  // Do not return an array\n  return (\n    <Host>{content}</Host>\n  );\n}\n  `);
                if (de && R.$attrsToReflect$ && (H.$attrs$ = H.$attrs$ || {},
                R.$attrsToReflect$.map(( ([v,E]) => H.$attrs$[E] = k[v]))),
                H.$tag$ = null,
                H.$flags$ |= 4,
                v.$vnode$ = H,
                H.$elm$ = U.$elm$ = fe && k.shadowRoot || k,
                (pe || fe) && (ot = k["s-sc"]),
                He && (it = k["s-cr"],
                lt = Dt && !!(1 & R.$flags$),
                ut = !1),
                patch(U, H),
                He) {
                    if (Nt.$flags$ |= 1,
                    dt) {
                        let v, E, k, R, U, G;
                        relocateSlotContent(H.$elm$);
                        let W = 0;
                        for (; W < Tt.length; W++)
                            v = Tt[W],
                            E = v.$nodeToRelocate$,
                            E["s-ol"] || (k = Ne || Le ? originalLocationDebugNode(E) : Rt.createTextNode(""),
                            k["s-nr"] = E,
                            E.parentNode.insertBefore(E["s-ol"] = k, E));
                        for (W = 0; W < Tt.length; W++)
                            if (v = Tt[W],
                            E = v.$nodeToRelocate$,
                            v.$slotRefNode$) {
                                for (R = v.$slotRefNode$.parentNode,
                                U = v.$slotRefNode$.nextSibling,
                                k = E["s-ol"]; k = k.previousSibling; )
                                    if (G = k["s-nr"],
                                    G && G["s-sn"] === E["s-sn"] && R === G.parentNode && (G = G.nextSibling,
                                    !G || !G["s-nr"])) {
                                        U = G;
                                        break
                                    }
                                (!U && R !== E.parentNode || E.nextSibling !== U) && E !== U && (!E["s-hn"] && E["s-ol"] && (E["s-hn"] = E["s-ol"].parentNode.nodeName),
                                R.insertBefore(E, U))
                            } else
                                1 === E.nodeType && (E.hidden = !0)
                    }
                    ut && updateFallbackSlotVisibility(H.$elm$),
                    Nt.$flags$ &= -2,
                    Tt.length = 0
                }
            }
              , slotReferenceDebugNode = v => Rt.createComment(`<slot${v.$name$ ? ' name="' + v.$name$ + '"' : ""}> (host=${at.toLowerCase()})`)
              , originalLocationDebugNode = v => Rt.createComment("org-location for " + (v.localName ? `<${v.localName}> (host=${v["s-hn"]})` : `[${v.textContent}]`))
              , attachToAncestor = (v, E) => {
                et && E && !v.$onRenderResolve$ && E["s-p"] && E["s-p"].push(new Promise((E => v.$onRenderResolve$ = E)))
            }
              , scheduleUpdate = (v, E) => {
                if (Re && ye && (v.$flags$ |= 16),
                et && 4 & v.$flags$)
                    return void (v.$flags$ |= 512);
                attachToAncestor(v, v.$ancestorComponent$);
                const dispatch = () => dispatchHooks(v, E);
                return Re ? Ut(dispatch) : dispatch()
            }
              , dispatchHooks = (v, E) => {
                const k = v.$hostElement$
                  , R = createTime("scheduleUpdate", v.$cmpMeta$.$tagName$)
                  , U = Be ? v.$lazyInstance$ : k;
                let H;
                return E ? (Be && ee && (v.$flags$ |= 256,
                v.$queuedListeners$ && (v.$queuedListeners$.map(( ([v,E]) => safeCall(U, v, E))),
                v.$queuedListeners$ = null)),
                emitLifecycleEvent(k, "componentWillLoad"),
                Z && (H = safeCall(U, "componentWillLoad"))) : (emitLifecycleEvent(k, "componentWillUpdate"),
                Y && (H = safeCall(U, "componentWillUpdate"))),
                emitLifecycleEvent(k, "componentWillRender"),
                J && (H = then(H, ( () => safeCall(U, "componentWillRender")))),
                R(),
                then(H, ( () => updateComponent(v, U, E)))
            }
              , updateComponent = async (v, E, k) => {
                const R = v.$hostElement$
                  , U = createTime("update", v.$cmpMeta$.$tagName$)
                  , H = R["s-rc"];
                _e && k && attachStyles(v);
                const G = createTime("render", v.$cmpMeta$.$tagName$);
                if (De && (v.$flags$ |= 1024),
                Le ? await callRender(v, E, R) : callRender(v, E, R),
                Ye && Nt.$cssShim$ && Nt.$cssShim$.updateHost(R),
                De && (v.$renderCount$++,
                v.$flags$ &= -1025),
                Le)
                    try {
                        serverSideConnected(R),
                        k && (1 & v.$cmpMeta$.$flags$ ? R["s-en"] = "" : 2 & v.$cmpMeta$.$flags$ && (R["s-en"] = "c"))
                    } catch (v) {
                        consoleError(v, R)
                    }
                if (et && H && (H.map((v => v())),
                R["s-rc"] = void 0),
                G(),
                U(),
                et) {
                    const E = R["s-p"]
                      , postUpdate = () => postUpdateComponent(v);
                    0 === E.length ? postUpdate() : (Promise.all(E).then(postUpdate),
                    v.$flags$ |= 4,
                    E.length = 0)
                } else
                    postUpdateComponent(v)
            }
              , callRender = (v, E, k) => {
                const U = !!R
                  , H = !!Be
                  , G = !!Re
                  , W = !!ye;
                try {
                    if (ft = E,
                    E = (U || E.render) && E.render(),
                    W && G && (v.$flags$ &= -17),
                    (W || H) && (v.$flags$ |= 2),
                    Q || de)
                        if (Ie || de) {
                            if (Le)
                                return Promise.resolve(E).then((E => renderVdom(v, E)));
                            renderVdom(v, E)
                        } else
                            k.textContent = E
                } catch (E) {
                    consoleError(E, v.$hostElement$)
                }
                return ft = null,
                null
            }
              , postUpdateComponent = v => {
                const E = v.$cmpMeta$.$tagName$
                  , k = v.$hostElement$
                  , R = createTime("postUpdate", E)
                  , H = Be ? v.$lazyInstance$ : k
                  , Z = v.$ancestorComponent$;
                W && (De && (v.$flags$ |= 1024),
                safeCall(H, "componentDidRender"),
                De && (v.$flags$ &= -1025)),
                emitLifecycleEvent(k, "componentDidRender"),
                64 & v.$flags$ ? (G && (De && (v.$flags$ |= 1024),
                safeCall(H, "componentDidUpdate"),
                De && (v.$flags$ &= -1025)),
                emitLifecycleEvent(k, "componentDidUpdate"),
                R()) : (v.$flags$ |= 64,
                et && me && addHydratedFlag(k),
                U && (De && (v.$flags$ |= 2048),
                safeCall(H, "componentDidLoad"),
                De && (v.$flags$ &= -2049)),
                emitLifecycleEvent(k, "componentDidLoad"),
                R(),
                et && (v.$onReadyResolve$(k),
                Z || appDidLoad(E))),
                Me && k["s-hmr-load"] && k["s-hmr-load"](),
                se && Be && v.$onInstanceResolve$(k),
                et && (v.$onRenderResolve$ && (v.$onRenderResolve$(),
                v.$onRenderResolve$ = void 0),
                512 & v.$flags$ && nextTick(( () => scheduleUpdate(v, !1))),
                v.$flags$ &= -517)
            }
              , appDidLoad = v => {
                me && addHydratedFlag(Rt.documentElement),
                tt && (Nt.$flags$ |= 2),
                nextTick(( () => emitEvent(Pt, "appload", {
                    "detail": {
                        "namespace": rt
                    }
                }))),
                Ue && performance.measure && performance.measure(`[Stencil] ${rt} initial load (by ${v})`, "st:app:start")
            }
              , safeCall = (v, E, k) => {
                if (v && v[E])
                    try {
                        return v[E](k)
                    } catch (v) {
                        consoleError(v)
                    }
            }
              , then = (v, E) => v && v.then ? v.then(E) : E()
              , emitLifecycleEvent = (v, E) => {
                je && emitEvent(v, "stencil_" + E, {
                    "bubbles": !0,
                    "composed": !0,
                    "detail": {
                        "namespace": rt
                    }
                })
            }
              , addHydratedFlag = v => qe ? v.classList.add("hydrated") : ze ? v.setAttribute("hydrated", "") : void 0
              , serverSideConnected = v => {
                const E = v.children;
                if (null != E)
                    for (let v = 0, k = E.length; v < k; v++) {
                        const k = E[v];
                        "function" == typeof k.connectedCallback && k.connectedCallback(),
                        serverSideConnected(k)
                    }
            }
              , setValue = (v, E, k, R) => {
                const U = getHostRef(v)
                  , H = Be ? U.$hostElement$ : v
                  , G = U.$instanceValues$.get(E)
                  , W = U.$flags$
                  , Z = Be ? U.$lazyInstance$ : H;
                var Y, J;
                Y = k,
                J = R.$members$[E][0],
                k = null == Y || isComplexType(Y) ? Y : Ve && 4 & J ? "false" !== Y && ("" === Y || !!Y) : We && 2 & J ? parseFloat(Y) : Ze && 1 & J ? String(Y) : Y;
                const K = Number.isNaN(G) && Number.isNaN(k);
                if ((!Be || !(8 & W) || void 0 === G) && (k !== G && !K) && (U.$instanceValues$.set(E, k),
                De && (1024 & U.$flags$ ? consoleDevWarn(`The state/prop "${E}" changed during rendering. This can potentially lead to infinite-loops and other bugs.`, "\nElement", H, "\nNew value", k, "\nOld value", G) : 2048 & U.$flags$ && consoleDevWarn(`The state/prop "${E}" changed during "componentDidLoad()", this triggers extra re-renders, try to setup on "componentWillLoad()"`, "\nElement", H, "\nNew value", k, "\nOld value", G)),
                !Be || Z)) {
                    if (Pe && R.$watchers$ && 128 & W) {
                        const v = R.$watchers$[E];
                        v && v.map((v => {
                            try {
                                Z[v](k, G, E)
                            } catch (v) {
                                consoleError(v, H)
                            }
                        }
                        ))
                    }
                    if (ye && 2 == (18 & W)) {
                        if (Ke && Z.componentShouldUpdate && !1 === Z.componentShouldUpdate(k, G, E))
                            return;
                        scheduleUpdate(U, !1)
                    }
                }
            }
              , proxyComponent = (v, E, k) => {
                if (ae && E.$members$) {
                    Pe && v.watchers && (E.$watchers$ = v.watchers);
                    const R = Object.entries(E.$members$)
                      , U = v.prototype;
                    if (R.map(( ([v,[R]]) => {
                        (ue || ge) && (31 & R || (!Be || 2 & k) && 32 & R) ? Object.defineProperty(U, v, {
                            "get"() {
                                return ( (v, E) => getHostRef(v).$instanceValues$.get(E))(this, v)
                            },
                            "set"(U) {
                                if (De) {
                                    const U = getHostRef(this);
                                    1 & k || 8 & U.$flags$ || !(31 & R) || 1024 & R || consoleDevWarn(`@Prop() "${v}" on <${E.$tagName$}> is immutable but was modified from within the component.\nMore information: https://stenciljs.com/docs/properties#prop-mutability`)
                                }
                                setValue(this, v, U, E)
                            },
                            "configurable": !0,
                            "enumerable": !0
                        }) : Be && se && 1 & k && 64 & R && Object.defineProperty(U, v, {
                            "value"(...E) {
                                const k = getHostRef(this);
                                return k.$onInstancePromise$.then(( () => k.$lazyInstance$[v](...E)))
                            }
                        })
                    }
                    )),
                    le && (!Be || 1 & k)) {
                        const k = new Map;
                        U.attributeChangedCallback = function(v, E, R) {
                            Nt.jmp(( () => {
                                const E = k.get(v);
                                if (this.hasOwnProperty(E))
                                    R = this[E],
                                    delete this[E];
                                else if (U.hasOwnProperty(E) && "number" == typeof this[E] && this[E] == R)
                                    return;
                                this[E] = (null !== R || "boolean" != typeof this[E]) && R
                            }
                            ))
                        }
                        ,
                        v.observedAttributes = R.filter(( ([v,E]) => 15 & E[0])).map(( ([v,R]) => {
                            const U = R[1] || v;
                            return k.set(U, v),
                            de && 512 & R[0] && E.$attrsToReflect$.push([v, U]),
                            U
                        }
                        ))
                    }
                }
                return v
            }
              , initializeComponent = async (v, E, R, U, H) => {
                if ((Be || Le || _e) && !(32 & E.$flags$)) {
                    if (Be || Fe) {
                        if (E.$flags$ |= 32,
                        (H = loadModule(R, E, U)).then) {
                            const v = (G = `st:load:${R.$tagName$}:${E.$modeName$}`,
                            W = `[Stencil] Load module for <${R.$tagName$}>`,
                            Ue && performance.mark ? (0 === performance.getEntriesByName(G, "mark").length && performance.mark(G),
                            () => {
                                0 === performance.getEntriesByName(W, "measure").length && performance.measure(W, G)
                            }
                            ) : () => {}
                            );
                            H = await H,
                            v()
                        }
                        if ((De || Ne) && !H)
                            throw new Error(`Constructor for "${R.$tagName$}#${E.$modeName$}" was not found`);
                        ae && !H.isProxied && (Pe && (R.$watchers$ = H.watchers),
                        proxyComponent(H, R, 2),
                        H.isProxied = !0);
                        const v = createTime("createInstance", R.$tagName$);
                        ae && (E.$flags$ |= 8);
                        try {
                            new H(E)
                        } catch (v) {
                            consoleError(v)
                        }
                        ae && (E.$flags$ &= -9),
                        Pe && (E.$flags$ |= 128),
                        v(),
                        fireConnectedCallback(E.$lazyInstance$)
                    } else
                        H = v.constructor,
                        E.$flags$ |= 32,
                        customElements.whenDefined(R.$tagName$).then(( () => E.$flags$ |= 128));
                    if (_e && H.style) {
                        let U = H.style;
                        ce && "string" != typeof U && (U = U[E.$modeName$ = computeMode(v)],
                        Le && E.$modeName$ && v.setAttribute("s-mode", E.$modeName$));
                        const G = getScopeId(R, E.$modeName$);
                        if (!kt.has(G)) {
                            const v = createTime("registerStyles", R.$tagName$);
                            !Le && fe && Ge && 8 & R.$flags$ && (U = await k.e(576).then(k.bind(k, 576)).then((v => v.scopeCss(U, G, !1)))),
                            registerStyle(G, U, !!(1 & R.$flags$)),
                            v()
                        }
                    }
                }
                var G, W;
                const Z = E.$ancestorComponent$
                  , schedule = () => scheduleUpdate(E, !0);
                et && Z && Z["s-rc"] ? Z["s-rc"].push(schedule) : schedule()
            }
              , fireConnectedCallback = v => {
                Be && K && safeCall(v, "connectedCallback")
            }
              , connectedCallback = v => {
                if (!(1 & Nt.$flags$)) {
                    const E = getHostRef(v)
                      , k = E.$cmpMeta$
                      , R = createTime("connectedCallback", k.$tagName$);
                    if (oe && addHostEventListeners(v, E, k.$listeners$, !0),
                    1 & E.$flags$)
                        addHostEventListeners(v, E, k.$listeners$, !1),
                        fireConnectedCallback(E.$lazyInstance$);
                    else {
                        let R;
                        if (E.$flags$ |= 1,
                        Fe && (R = v.getAttribute(gt),
                        R)) {
                            if (fe && Dt && 1 & k.$flags$) {
                                const E = ce ? addStyle(v.shadowRoot, k, v.getAttribute("s-mode")) : addStyle(v.shadowRoot, k);
                                v.classList.remove(E + "-h", E + "-s")
                            }
                            ( (v, E, k, R) => {
                                const U = createTime("hydrateClient", E)
                                  , H = v.shadowRoot
                                  , G = []
                                  , W = fe && H ? [] : null
                                  , Z = R.$vnode$ = newVNode(E, null);
                                Nt.$orgLocNodes$ || initializeDocumentHydrate(Rt.body, Nt.$orgLocNodes$ = new Map),
                                v[gt] = k,
                                v.removeAttribute(gt),
                                clientHydrate(Z, G, [], W, v, v, k),
                                G.map((v => {
                                    const k = v.$hostId$ + "." + v.$nodeId$
                                      , R = Nt.$orgLocNodes$.get(k)
                                      , U = v.$elm$;
                                    R && Dt && "" === R["s-en"] && R.parentNode.insertBefore(U, R.nextSibling),
                                    H || (U["s-hn"] = E,
                                    R && (U["s-ol"] = R,
                                    U["s-ol"]["s-nr"] = U)),
                                    Nt.$orgLocNodes$.delete(k)
                                }
                                )),
                                fe && H && W.map((v => {
                                    v && H.appendChild(v)
                                }
                                )),
                                U()
                            }
                            )(v, k.$tagName$, R, E)
                        }
                        if (He && !R && (Le || (he || fe) && 12 & k.$flags$) && setContentReference(v),
                        et) {
                            let k = v;
                            for (; k = k.parentNode || k.host; )
                                if (Fe && 1 === k.nodeType && k.hasAttribute("s-id") && k["s-p"] || k["s-p"]) {
                                    attachToAncestor(E, E.$ancestorComponent$ = k);
                                    break
                                }
                        }
                        ue && !Le && k.$members$ && Object.entries(k.$members$).map(( ([E,[k]]) => {
                            if (31 & k && v.hasOwnProperty(E)) {
                                const k = v[E];
                                delete v[E],
                                v[E] = k
                            }
                        }
                        )),
                        Qe ? nextTick(( () => initializeComponent(v, E, k))) : initializeComponent(v, E, k)
                    }
                    R()
                }
            }
              , setContentReference = v => {
                const E = v["s-cr"] = Rt.createComment(Ne ? `content-ref (host=${v.localName})` : "");
                E["s-cn"] = !0,
                v.insertBefore(E, v.firstChild)
            }
              , disconnectedCallback = v => {
                if (!(1 & Nt.$flags$)) {
                    const E = getHostRef(v)
                      , k = Be ? E.$lazyInstance$ : v;
                    ee && E.$rmListeners$ && (E.$rmListeners$.map((v => v())),
                    E.$rmListeners$ = void 0),
                    Ye && Nt.$cssShim$ && Nt.$cssShim$.removeHost(v),
                    Be && X && safeCall(k, "disconnectedCallback"),
                    H && safeCall(k, "componentDidUnload")
                }
            }
              , proxyCustomElement = (v, E) => {
                const k = {
                    "$flags$": E[0],
                    "$tagName$": E[1]
                };
                ae && (k.$members$ = E[2]),
                ee && (k.$listeners$ = E[3]),
                Pe && (k.$watchers$ = v.$watchers$),
                de && (k.$attrsToReflect$ = []),
                fe && !Dt && 1 & k.$flags$ && (k.$flags$ |= 8);
                const R = v.prototype.connectedCallback
                  , U = v.prototype.disconnectedCallback;
                return Object.assign(v.prototype, {
                    "__registerHost"() {
                        registerHost(this, k)
                    },
                    "connectedCallback"() {
                        connectedCallback(this),
                        K && R && R.call(this)
                    },
                    "disconnectedCallback"() {
                        disconnectedCallback(this),
                        X && U && U.call(this)
                    },
                    "__attachShadow"() {
                        Dt ? Xe ? this.attachShadow({
                            "mode": "open",
                            "delegatesFocus": !!(16 & k.$flags$)
                        }) : this.attachShadow({
                            "mode": "open"
                        }) : this.shadowRoot = this
                    }
                }),
                v.is = k.$tagName$,
                proxyComponent(v, k, 3)
            }
              , addHostEventListeners = (v, E, k, R) => {
                ee && k && (oe && (k = R ? k.filter(( ([v]) => 32 & v)) : k.filter(( ([v]) => !(32 & v)))),
                k.map(( ([k,R,U]) => {
                    const H = ie ? getHostListenerTarget(v, k) : v
                      , G = hostListenerProxy(E, U)
                      , W = hostListenerOpts(k);
                    Nt.ael(H, R, G, W),
                    (E.$rmListeners$ = E.$rmListeners$ || []).push(( () => Nt.rel(H, R, G, W)))
                }
                )))
            }
              , hostListenerProxy = (v, E) => k => {
                try {
                    Be ? 256 & v.$flags$ ? v.$lazyInstance$[E](k) : (v.$queuedListeners$ = v.$queuedListeners$ || []).push([E, k]) : v.$hostElement$[E](k)
                } catch (v) {
                    consoleError(v)
                }
            }
              , getHostListenerTarget = (v, E) => ne && 4 & E ? Rt : te && 8 & E ? Pt : re && 16 & E ? Rt.body : oe && 32 & E ? v.parentElement : v
              , hostListenerOpts = v => $t ? {
                "passive": !!(1 & v),
                "capture": !!(2 & v)
            } : !!(2 & v)
              , xt = new WeakMap
              , getHostRef = v => xt.get(v)
              , registerHost = (v, E) => {
                const k = {
                    "$flags$": 0,
                    "$hostElement$": v,
                    "$cmpMeta$": E,
                    "$instanceValues$": new Map
                };
                return De && (k.$renderCount$ = 0),
                se && Be && (k.$onInstancePromise$ = new Promise((v => k.$onInstanceResolve$ = v))),
                et && (k.$onReadyPromise$ = new Promise((v => k.$onReadyResolve$ = v)),
                v["s-p"] = [],
                v["s-rc"] = []),
                addHostEventListeners(v, k, E.$listeners$, !1),
                xt.set(v, k)
            }
              , isMemberInElement = (v, E) => E in v
              , consoleError = (v, E) => (st || console.error)(v, E)
              , At = $e ? ["STENCIL:"] : ["%cstencil", "color: white;background:#4c47ff;font-weight: bold; font-size:10px; padding:2px 6px; border-radius: 5px"]
              , consoleDevError = (...v) => console.error(...At, ...v)
              , consoleDevWarn = (...v) => console.warn(...At, ...v)
              , It = new Map
              , loadModule = (v, E, R) => {
                const U = v.$tagName$.replace(/-/g, "_")
                  , H = v.$lazyBundleId$;
                if (De && "string" != typeof H)
                    return void consoleDevError(`Trying to lazily load component <${v.$tagName$}> with style mode "${E.$modeName$}", but it does not exist.`);
                const G = !Me && It.get(H);
                return G ? G[U] : k(1993)(`./${H}.entry.js${Me && R ? "?s-hmr=" + R : ""}`).then((v => (Me || It.set(H, v),
                v[U])), consoleError)
            }
              , kt = new Map
              , Ot = []
              , Pt = "undefined" != typeof window ? window : {}
              , Rt = (Ye && Pt.CSS,
            Pt.document || {
                "head": {}
            })
              , Mt = Pt.HTMLElement || class {
            }
              , Nt = {
                "$flags$": 0,
                "$resourcesUrl$": "",
                "jmp": v => v(),
                "raf": v => requestAnimationFrame(v),
                "ael": (v, E, k, R) => v.addEventListener(E, k, R),
                "rel": (v, E, k, R) => v.removeEventListener(E, k, R),
                "ce": (v, E) => new CustomEvent(v,E)
            }
              , Dt = !Ge || !fe || ( () => (Rt.head.attachShadow + "").indexOf("[native") > -1)()
              , $t = ( () => {
                let v = !1;
                try {
                    Rt.addEventListener("e", null, Object.defineProperty({}, "passive", {
                        "get"() {
                            v = !0
                        }
                    }))
                } catch (v) {}
                return v
            }
            )()
              , Lt = !!Je && ( () => {
                try {
                    return new CSSStyleSheet,
                    "function" == typeof (new CSSStyleSheet).replaceSync
                } catch (v) {}
                return !1
            }
            )()
              , Ft = []
              , jt = []
              , Bt = []
              , queueTask = (v, E) => k => {
                v.push(k),
                mt || (mt = !0,
                E && 4 & Nt.$flags$ ? nextTick(flush) : Nt.raf(flush))
            }
              , consume = v => {
                for (let E = 0; E < v.length; E++)
                    try {
                        v[E](performance.now())
                    } catch (v) {
                        consoleError(v)
                    }
                v.length = 0
            }
              , consumeTimeout = (v, E) => {
                let k = 0
                  , R = 0;
                for (; k < v.length && (R = performance.now()) < E; )
                    try {
                        v[k++](R)
                    } catch (v) {
                        consoleError(v)
                    }
                k === v.length ? v.length = 0 : 0 !== k && v.splice(0, k)
            }
              , flush = () => {
                if (tt && ht++,
                consume(Ft),
                tt) {
                    const v = 2 == (6 & Nt.$flags$) ? performance.now() + 14 * Math.ceil(.1 * ht) : 1 / 0;
                    consumeTimeout(jt, v),
                    consumeTimeout(Bt, v),
                    jt.length > 0 && (Bt.push(...jt),
                    jt.length = 0),
                    (mt = Ft.length + jt.length + Bt.length > 0) ? Nt.raf(flush) : ht = 0
                } else
                    consume(jt),
                    (mt = Ft.length > 0) && Nt.raf(flush)
            }
              , nextTick = v => {
                return Promise.resolve(E).then(v);
                var E
            }
              , Ut = queueTask(jt, !0)
        },
        "1993": function(v) {
            function webpackEmptyAsyncContext(v) {
                return Promise.resolve().then((function() {
                    var E = new Error("Cannot find module '" + v + "'");
                    throw E.code = "MODULE_NOT_FOUND",
                    E
                }
                ))
            }
            webpackEmptyAsyncContext.keys = function() {
                return []
            }
            ,
            webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext,
            webpackEmptyAsyncContext.id = 1993,
            v.exports = webpackEmptyAsyncContext
        },
        "6252": function(v, E, k) {
            "use strict";
            k.d(E, {
                "$d": function() {
                    return callWithAsyncErrorHandling
                },
                "Ah": function() {
                    return _e
                },
                "FN": function() {
                    return getCurrentInstance
                },
                "Fl": function() {
                    return computed
                },
                "HY": function() {
                    return ke
                },
                "JJ": function() {
                    return provide
                },
                "Ko": function() {
                    return renderList
                },
                "LL": function() {
                    return resolveDynamicComponent
                },
                "Nv": function() {
                    return createSlots
                },
                "P$": function() {
                    return de
                },
                "Q2": function() {
                    return resolveDirective
                },
                "Q6": function() {
                    return getTransitionRawChildren
                },
                "Rr": function() {
                    return useSlots
                },
                "U2": function() {
                    return resolveTransitionHooks
                },
                "Uk": function() {
                    return createTextVNode
                },
                "Us": function() {
                    return createRenderer
                },
                "WI": function() {
                    return renderSlot
                },
                "Wm": function() {
                    return $e
                },
                "Y3": function() {
                    return nextTick
                },
                "Y8": function() {
                    return useTransitionState
                },
                "YP": function() {
                    return watch
                },
                "_": function() {
                    return createBaseVNode
                },
                "aZ": function() {
                    return defineComponent
                },
                "bv": function() {
                    return fe
                },
                "f3": function() {
                    return inject
                },
                "h": function() {
                    return h
                },
                "iD": function() {
                    return createElementBlock
                },
                "ic": function() {
                    return me
                },
                "j4": function() {
                    return createBlock
                },
                "kq": function() {
                    return createCommentVNode
                },
                "l1": function() {
                    return useAttrs
                },
                "nJ": function() {
                    return ue
                },
                "nK": function() {
                    return setTransitionHooks
                },
                "uE": function() {
                    return createStaticVNode
                },
                "up": function() {
                    return resolveComponent
                },
                "w5": function() {
                    return withCtx
                },
                "wg": function() {
                    return openBlock
                },
                "wy": function() {
                    return withDirectives
                }
            });
            var R = k(2610)
              , U = k(3577);
            function callWithErrorHandling(v, E, k, R) {
                try {
                    return R ? v(...R) : v()
                } catch (v) {
                    handleError(v, E, k)
                }
            }
            function callWithAsyncErrorHandling(v, E, k, R) {
                if ((0,
                U.mf)(v)) {
                    const H = callWithErrorHandling(v, E, k, R);
                    return H && (0,
                    U.tI)(H) && H.catch((v => {
                        handleError(v, E, k)
                    }
                    )),
                    H
                }
                if ((0,
                U.kJ)(v)) {
                    const U = [];
                    for (let H = 0; H < v.length; H++)
                        U.push(callWithAsyncErrorHandling(v[H], E, k, R));
                    return U
                }
            }
            function handleError(v, E, k, U=!0) {
                E && E.vnode;
                if (E) {
                    let U = E.parent;
                    const H = E.proxy
                      , G = `https://vuejs.org/error-reference/#runtime-${k}`;
                    for (; U; ) {
                        const E = U.ec;
                        if (E)
                            for (let k = 0; k < E.length; k++)
                                if (!1 === E[k](v, H, G))
                                    return;
                        U = U.parent
                    }
                    const W = E.appContext.config.errorHandler;
                    if (W)
                        return (0,
                        R.Jd)(),
                        callWithErrorHandling(W, null, 10, [v, H, G]),
                        void (0,
                        R.lk)()
                }
                !function logError(v, E, k, R=!0) {
                    console.error(v)
                }(v, 0, 0, U)
            }
            let H = !1
              , G = !1;
            const W = [];
            let Z = 0;
            const Y = [];
            let J = null
              , K = 0;
            const X = Promise.resolve();
            let Q = null;
            function nextTick(v) {
                const E = Q || X;
                return v ? E.then(this ? v.bind(this) : v) : E
            }
            function queueJob(v) {
                W.length && W.includes(v, H && v.allowRecurse ? Z + 1 : Z) || (null == v.id ? W.push(v) : W.splice(function findInsertionIndex(v) {
                    let E = Z + 1
                      , k = W.length;
                    for (; E < k; ) {
                        const R = E + k >>> 1
                          , U = W[R]
                          , H = getId(U);
                        H < v || H === v && U.pre ? E = R + 1 : k = R
                    }
                    return E
                }(v.id), 0, v),
                queueFlush())
            }
            function queueFlush() {
                H || G || (G = !0,
                Q = X.then(flushJobs))
            }
            function queuePostFlushCb(v) {
                (0,
                U.kJ)(v) ? Y.push(...v) : J && J.includes(v, v.allowRecurse ? K + 1 : K) || Y.push(v),
                queueFlush()
            }
            function flushPreFlushCbs(v, E, k=(H ? Z + 1 : 0)) {
                for (0; k < W.length; k++) {
                    const E = W[k];
                    if (E && E.pre) {
                        if (v && E.id !== v.uid)
                            continue;
                        0,
                        W.splice(k, 1),
                        k--,
                        E()
                    }
                }
            }
            function flushPostFlushCbs(v) {
                if (Y.length) {
                    const v = [...new Set(Y)].sort(( (v, E) => getId(v) - getId(E)));
                    if (Y.length = 0,
                    J)
                        return void J.push(...v);
                    for (J = v,
                    K = 0; K < J.length; K++)
                        J[K]();
                    J = null,
                    K = 0
                }
            }
            const getId = v => null == v.id ? 1 / 0 : v.id
              , comparator = (v, E) => {
                const k = getId(v) - getId(E);
                if (0 === k) {
                    if (v.pre && !E.pre)
                        return -1;
                    if (E.pre && !v.pre)
                        return 1
                }
                return k
            }
            ;
            function flushJobs(v) {
                G = !1,
                H = !0,
                W.sort(comparator);
                U.dG;
                try {
                    for (Z = 0; Z < W.length; Z++) {
                        const v = W[Z];
                        v && !1 !== v.active && callWithErrorHandling(v, null, 14)
                    }
                } finally {
                    Z = 0,
                    W.length = 0,
                    flushPostFlushCbs(),
                    H = !1,
                    Q = null,
                    (W.length || Y.length) && flushJobs(v)
                }
            }
            function emit(v, E, ...k) {
                if (v.isUnmounted)
                    return;
                const R = v.vnode.props || U.kT;
                let H = k;
                const G = E.startsWith("update:")
                  , W = G && E.slice(7);
                if (W && W in R) {
                    const v = `${"modelValue" === W ? "model" : W}Modifiers`
                      , {"number": E, "trim": G} = R[v] || U.kT;
                    G && (H = k.map((v => (0,
                    U.HD)(v) ? v.trim() : v))),
                    E && (H = k.map(U.h5))
                }
                let Z;
                let Y = R[Z = (0,
                U.hR)(E)] || R[Z = (0,
                U.hR)((0,
                U._A)(E))];
                !Y && G && (Y = R[Z = (0,
                U.hR)((0,
                U.rs)(E))]),
                Y && callWithAsyncErrorHandling(Y, v, 6, H);
                const J = R[Z + "Once"];
                if (J) {
                    if (v.emitted) {
                        if (v.emitted[Z])
                            return
                    } else
                        v.emitted = {};
                    v.emitted[Z] = !0,
                    callWithAsyncErrorHandling(J, v, 6, H)
                }
            }
            function normalizeEmitsOptions(v, E, k=!1) {
                const R = E.emitsCache
                  , H = R.get(v);
                if (void 0 !== H)
                    return H;
                const G = v.emits;
                let W = {}
                  , Z = !1;
                if (!(0,
                U.mf)(v)) {
                    const extendEmits = v => {
                        const k = normalizeEmitsOptions(v, E, !0);
                        k && (Z = !0,
                        (0,
                        U.l7)(W, k))
                    }
                    ;
                    !k && E.mixins.length && E.mixins.forEach(extendEmits),
                    v.extends && extendEmits(v.extends),
                    v.mixins && v.mixins.forEach(extendEmits)
                }
                return G || Z ? ((0,
                U.kJ)(G) ? G.forEach((v => W[v] = null)) : (0,
                U.l7)(W, G),
                (0,
                U.Kn)(v) && R.set(v, W),
                W) : ((0,
                U.Kn)(v) && R.set(v, null),
                null)
            }
            function isEmitListener(v, E) {
                return !(!v || !(0,
                U.F7)(E)) && (E = E.slice(2).replace(/Once$/, ""),
                (0,
                U.RI)(v, E[0].toLowerCase() + E.slice(1)) || (0,
                U.RI)(v, (0,
                U.rs)(E)) || (0,
                U.RI)(v, E))
            }
            let ee = null
              , te = null;
            function setCurrentRenderingInstance(v) {
                const E = ee;
                return ee = v,
                te = v && v.type.__scopeId || null,
                E
            }
            function withCtx(v, E=ee, k) {
                if (!E)
                    return v;
                if (v._n)
                    return v;
                const renderFnWithContext = (...k) => {
                    renderFnWithContext._d && setBlockTracking(-1);
                    const R = setCurrentRenderingInstance(E);
                    let U;
                    try {
                        U = v(...k)
                    } finally {
                        setCurrentRenderingInstance(R),
                        renderFnWithContext._d && setBlockTracking(1)
                    }
                    return U
                }
                ;
                return renderFnWithContext._n = !0,
                renderFnWithContext._c = !0,
                renderFnWithContext._d = !0,
                renderFnWithContext
            }
            function renderComponentRoot(v) {
                const {"type": E, "vnode": k, "proxy": R, "withProxy": H, "propsOptions": [G], "slots": W, "attrs": Z, "emit": Y, "render": J, "renderCache": K, "props": X, "data": Q, "setupState": ee, "ctx": te, "inheritAttrs": ne} = v
                  , re = setCurrentRenderingInstance(v);
                let oe, ie;
                try {
                    if (4 & k.shapeFlag) {
                        const v = H || R
                          , E = v;
                        oe = normalizeVNode(J.call(E, v, K, X, ee, Q, te)),
                        ie = Z
                    } else {
                        const v = E;
                        0,
                        oe = normalizeVNode(v.length > 1 ? v(X, {
                            "attrs": Z,
                            "slots": W,
                            "emit": Y
                        }) : v(X, null)),
                        ie = E.props ? Z : getFunctionalFallthrough(Z)
                    }
                } catch (E) {
                    Me.length = 0,
                    handleError(E, v, 1),
                    oe = $e(Pe)
                }
                let ae = oe;
                if (ie && !1 !== ne) {
                    const v = Object.keys(ie)
                      , {"shapeFlag": E} = ae;
                    v.length && 7 & E && (G && v.some(U.tR) && (ie = filterModelListeners(ie, G)),
                    ae = cloneVNode(ae, ie, !1, !0))
                }
                return k.dirs && (ae = cloneVNode(ae, null, !1, !0),
                ae.dirs = ae.dirs ? ae.dirs.concat(k.dirs) : k.dirs),
                k.transition && (ae.transition = k.transition),
                oe = ae,
                setCurrentRenderingInstance(re),
                oe
            }
            const getFunctionalFallthrough = v => {
                let E;
                for (const k in v)
                    ("class" === k || "style" === k || (0,
                    U.F7)(k)) && ((E || (E = {}))[k] = v[k]);
                return E
            }
              , filterModelListeners = (v, E) => {
                const k = {};
                for (const R in v)
                    (0,
                    U.tR)(R) && R.slice(9)in E || (k[R] = v[R]);
                return k
            }
            ;
            function hasPropsChanged(v, E, k) {
                const R = Object.keys(E);
                if (R.length !== Object.keys(v).length)
                    return !0;
                for (let U = 0; U < R.length; U++) {
                    const H = R[U];
                    if (E[H] !== v[H] && !isEmitListener(k, H))
                        return !0
                }
                return !1
            }
            function updateHOCHostEl({"vnode": v, "parent": E}, k) {
                for (; E; ) {
                    const R = E.subTree;
                    if (R.suspense && R.suspense.activeBranch === v && (R.el = v.el),
                    R !== v)
                        break;
                    (v = E.vnode).el = k,
                    E = E.parent
                }
            }
            const ne = "components"
              , re = "directives";
            function resolveComponent(v, E) {
                return resolveAsset(ne, v, !0, E) || v
            }
            const oe = Symbol.for("v-ndc");
            function resolveDynamicComponent(v) {
                return (0,
                U.HD)(v) ? resolveAsset(ne, v, !1) || v : v || oe
            }
            function resolveDirective(v) {
                return resolveAsset(re, v)
            }
            function resolveAsset(v, E, k=!0, R=!1) {
                const H = ee || je;
                if (H) {
                    const k = H.type;
                    if (v === ne) {
                        const v = getComponentName(k, !1);
                        if (v && (v === E || v === (0,
                        U._A)(E) || v === (0,
                        U.kC)((0,
                        U._A)(E))))
                            return k
                    }
                    const G = resolve(H[v] || k[v], E) || resolve(H.appContext[v], E);
                    return !G && R ? k : G
                }
            }
            function resolve(v, E) {
                return v && (v[E] || v[(0,
                U._A)(E)] || v[(0,
                U.kC)((0,
                U._A)(E))])
            }
            const isSuspense = v => v.__isSuspense;
            function queueEffectWithSuspense(v, E) {
                E && E.pendingBranch ? (0,
                U.kJ)(v) ? E.effects.push(...v) : E.effects.push(v) : queuePostFlushCb(v)
            }
            const ie = Symbol.for("v-scx")
              , useSSRContext = () => {
                {
                    const v = inject(ie);
                    return v
                }
            }
            ;
            const ae = {};
            function watch(v, E, k) {
                return doWatch(v, E, k)
            }
            function doWatch(v, E, {"immediate": k, "deep": H, "flush": G, "once": W, "onTrack": Z, "onTrigger": Y}=U.kT) {
                if (E && W) {
                    const v = E;
                    E = (...E) => {
                        v(...E),
                        unwatch()
                    }
                }
                const J = je
                  , reactiveGetter = v => !0 === H ? v : traverse(v, !1 === H ? 1 : void 0);
                let K, X, Q = !1, ee = !1;
                if ((0,
                R.dq)(v) ? (K = () => v.value,
                Q = (0,
                R.yT)(v)) : (0,
                R.PG)(v) ? (K = () => reactiveGetter(v),
                Q = !0) : (0,
                U.kJ)(v) ? (ee = !0,
                Q = v.some((v => (0,
                R.PG)(v) || (0,
                R.yT)(v))),
                K = () => v.map((v => (0,
                R.dq)(v) ? v.value : (0,
                R.PG)(v) ? reactiveGetter(v) : (0,
                U.mf)(v) ? callWithErrorHandling(v, J, 2) : void 0))) : K = (0,
                U.mf)(v) ? E ? () => callWithErrorHandling(v, J, 2) : () => (X && X(),
                callWithAsyncErrorHandling(v, J, 3, [onCleanup])) : U.dG,
                E && H) {
                    const v = K;
                    K = () => traverse(v())
                }
                let te, onCleanup = v => {
                    X = oe.onStop = () => {
                        callWithErrorHandling(v, J, 4),
                        X = oe.onStop = void 0
                    }
                }
                ;
                if (qe) {
                    if (onCleanup = U.dG,
                    E ? k && callWithAsyncErrorHandling(E, J, 3, [K(), ee ? [] : void 0, onCleanup]) : K(),
                    "sync" !== G)
                        return U.dG;
                    {
                        const v = useSSRContext();
                        te = v.__watcherHandles || (v.__watcherHandles = [])
                    }
                }
                let ne = ee ? new Array(v.length).fill(ae) : ae;
                const job = () => {
                    if (oe.active && oe.dirty)
                        if (E) {
                            const v = oe.run();
                            (H || Q || (ee ? v.some(( (v, E) => (0,
                            U.aU)(v, ne[E]))) : (0,
                            U.aU)(v, ne))) && (X && X(),
                            callWithAsyncErrorHandling(E, J, 3, [v, ne === ae ? void 0 : ee && ne[0] === ae ? [] : ne, onCleanup]),
                            ne = v)
                        } else
                            oe.run()
                }
                ;
                let re;
                job.allowRecurse = !!E,
                "sync" === G ? re = job : "post" === G ? re = () => Ie(job, J && J.suspense) : (job.pre = !0,
                J && (job.id = J.uid),
                re = () => queueJob(job));
                const oe = new R.qq(K,U.dG,re)
                  , ie = (0,
                R.nZ)()
                  , unwatch = () => {
                    oe.stop(),
                    ie && (0,
                    U.Od)(ie.effects, oe)
                }
                ;
                return E ? k ? job() : ne = oe.run() : "post" === G ? Ie(oe.run.bind(oe), J && J.suspense) : oe.run(),
                te && te.push(unwatch),
                unwatch
            }
            function instanceWatch(v, E, k) {
                const R = this.proxy
                  , H = (0,
                U.HD)(v) ? v.includes(".") ? createPathGetter(R, v) : () => R[v] : v.bind(R, R);
                let G;
                (0,
                U.mf)(E) ? G = E : (G = E.handler,
                k = E);
                const W = setCurrentInstance(this)
                  , Z = doWatch(H, G.bind(R), k);
                return W(),
                Z
            }
            function createPathGetter(v, E) {
                const k = E.split(".");
                return () => {
                    let E = v;
                    for (let v = 0; v < k.length && E; v++)
                        E = E[k[v]];
                    return E
                }
            }
            function traverse(v, E=1 / 0, k) {
                if (E <= 0 || !(0,
                U.Kn)(v) || v.__v_skip)
                    return v;
                if ((k = k || new Set).has(v))
                    return v;
                if (k.add(v),
                E--,
                (0,
                R.dq)(v))
                    traverse(v.value, E, k);
                else if ((0,
                U.kJ)(v))
                    for (let R = 0; R < v.length; R++)
                        traverse(v[R], E, k);
                else if ((0,
                U.DM)(v) || (0,
                U._N)(v))
                    v.forEach((v => {
                        traverse(v, E, k)
                    }
                    ));
                else if ((0,
                U.PO)(v))
                    for (const R in v)
                        traverse(v[R], E, k);
                return v
            }
            function withDirectives(v, E) {
                if (null === ee)
                    return v;
                const k = getExposeProxy(ee) || ee.proxy
                  , R = v.dirs || (v.dirs = []);
                for (let v = 0; v < E.length; v++) {
                    let[H,G,W,Z=U.kT] = E[v];
                    H && ((0,
                    U.mf)(H) && (H = {
                        "mounted": H,
                        "updated": H
                    }),
                    H.deep && traverse(G),
                    R.push({
                        "dir": H,
                        "instance": k,
                        "value": G,
                        "oldValue": void 0,
                        "arg": W,
                        "modifiers": Z
                    }))
                }
                return v
            }
            function invokeDirectiveHook(v, E, k, U) {
                const H = v.dirs
                  , G = E && E.dirs;
                for (let W = 0; W < H.length; W++) {
                    const Z = H[W];
                    G && (Z.oldValue = G[W].value);
                    let Y = Z.dir[U];
                    Y && ((0,
                    R.Jd)(),
                    callWithAsyncErrorHandling(Y, k, 8, [v.el, Z, v, E]),
                    (0,
                    R.lk)())
                }
            }
            const se = Symbol("_leaveCb")
              , ce = Symbol("_enterCb");
            function useTransitionState() {
                const v = {
                    "isMounted": !1,
                    "isLeaving": !1,
                    "isUnmounting": !1,
                    "leavingVNodes": new Map
                };
                return fe(( () => {
                    v.isMounted = !0
                }
                )),
                ge(( () => {
                    v.isUnmounting = !0
                }
                )),
                v
            }
            const le = [Function, Array]
              , ue = {
                "mode": String,
                "appear": Boolean,
                "persisted": Boolean,
                "onBeforeEnter": le,
                "onEnter": le,
                "onAfterEnter": le,
                "onEnterCancelled": le,
                "onBeforeLeave": le,
                "onLeave": le,
                "onAfterLeave": le,
                "onLeaveCancelled": le,
                "onBeforeAppear": le,
                "onAppear": le,
                "onAfterAppear": le,
                "onAppearCancelled": le
            }
              , de = {
                "name": "BaseTransition",
                "props": ue,
                "setup"(v, {"slots": E}) {
                    const k = getCurrentInstance()
                      , U = useTransitionState();
                    return () => {
                        const H = E.default && getTransitionRawChildren(E.default(), !0);
                        if (!H || !H.length)
                            return;
                        let G = H[0];
                        if (H.length > 1) {
                            let v = !1;
                            for (const E of H)
                                if (E.type !== Pe) {
                                    0,
                                    G = E,
                                    v = !0;
                                    break
                                }
                        }
                        const W = (0,
                        R.IU)(v)
                          , {"mode": Z} = W;
                        if (U.isLeaving)
                            return emptyPlaceholder(G);
                        const Y = getKeepAliveChild(G);
                        if (!Y)
                            return emptyPlaceholder(G);
                        const J = resolveTransitionHooks(Y, W, U, k);
                        setTransitionHooks(Y, J);
                        const K = k.subTree
                          , X = K && getKeepAliveChild(K);
                        if (X && X.type !== Pe && !isSameVNodeType(Y, X)) {
                            const v = resolveTransitionHooks(X, W, U, k);
                            if (setTransitionHooks(X, v),
                            "out-in" === Z && Y.type !== Pe)
                                return U.isLeaving = !0,
                                v.afterLeave = () => {
                                    U.isLeaving = !1,
                                    !1 !== k.update.active && (k.effect.dirty = !0,
                                    k.update())
                                }
                                ,
                                emptyPlaceholder(G);
                            "in-out" === Z && Y.type !== Pe && (v.delayLeave = (v, E, k) => {
                                getLeavingNodesForType(U, X)[String(X.key)] = X,
                                v[se] = () => {
                                    E(),
                                    v[se] = void 0,
                                    delete J.delayedLeave
                                }
                                ,
                                J.delayedLeave = k
                            }
                            )
                        }
                        return G
                    }
                }
            };
            function getLeavingNodesForType(v, E) {
                const {"leavingVNodes": k} = v;
                let R = k.get(E.type);
                return R || (R = Object.create(null),
                k.set(E.type, R)),
                R
            }
            function resolveTransitionHooks(v, E, k, R) {
                const {"appear": H, "mode": G, "persisted": W=!1, "onBeforeEnter": Z, "onEnter": Y, "onAfterEnter": J, "onEnterCancelled": K, "onBeforeLeave": X, "onLeave": Q, "onAfterLeave": ee, "onLeaveCancelled": te, "onBeforeAppear": ne, "onAppear": re, "onAfterAppear": oe, "onAppearCancelled": ie} = E
                  , ae = String(v.key)
                  , le = getLeavingNodesForType(k, v)
                  , callHook = (v, E) => {
                    v && callWithAsyncErrorHandling(v, R, 9, E)
                }
                  , callAsyncHook = (v, E) => {
                    const k = E[1];
                    callHook(v, E),
                    (0,
                    U.kJ)(v) ? v.every((v => v.length <= 1)) && k() : v.length <= 1 && k()
                }
                  , ue = {
                    "mode": G,
                    "persisted": W,
                    "beforeEnter"(E) {
                        let R = Z;
                        if (!k.isMounted) {
                            if (!H)
                                return;
                            R = ne || Z
                        }
                        E[se] && E[se](!0);
                        const U = le[ae];
                        U && isSameVNodeType(v, U) && U.el[se] && U.el[se](),
                        callHook(R, [E])
                    },
                    "enter"(v) {
                        let E = Y
                          , R = J
                          , U = K;
                        if (!k.isMounted) {
                            if (!H)
                                return;
                            E = re || Y,
                            R = oe || J,
                            U = ie || K
                        }
                        let G = !1;
                        const W = v[ce] = E => {
                            G || (G = !0,
                            callHook(E ? U : R, [v]),
                            ue.delayedLeave && ue.delayedLeave(),
                            v[ce] = void 0)
                        }
                        ;
                        E ? callAsyncHook(E, [v, W]) : W()
                    },
                    "leave"(E, R) {
                        const U = String(v.key);
                        if (E[ce] && E[ce](!0),
                        k.isUnmounting)
                            return R();
                        callHook(X, [E]);
                        let H = !1;
                        const G = E[se] = k => {
                            H || (H = !0,
                            R(),
                            callHook(k ? te : ee, [E]),
                            E[se] = void 0,
                            le[U] === v && delete le[U])
                        }
                        ;
                        le[U] = v,
                        Q ? callAsyncHook(Q, [E, G]) : G()
                    },
                    "clone"(v) {
                        return resolveTransitionHooks(v, E, k, R)
                    }
                };
                return ue
            }
            function emptyPlaceholder(v) {
                if (isKeepAlive(v))
                    return (v = cloneVNode(v)).children = null,
                    v
            }
            function getKeepAliveChild(v) {
                if (!isKeepAlive(v))
                    return v;
                const {"shapeFlag": E, "children": k} = v;
                if (k) {
                    if (16 & E)
                        return k[0];
                    if (32 & E && (0,
                    U.mf)(k.default))
                        return k.default()
                }
            }
            function setTransitionHooks(v, E) {
                6 & v.shapeFlag && v.component ? setTransitionHooks(v.component.subTree, E) : 128 & v.shapeFlag ? (v.ssContent.transition = E.clone(v.ssContent),
                v.ssFallback.transition = E.clone(v.ssFallback)) : v.transition = E
            }
            function getTransitionRawChildren(v, E=!1, k) {
                let R = []
                  , U = 0;
                for (let H = 0; H < v.length; H++) {
                    let G = v[H];
                    const W = null == k ? G.key : String(k) + String(null != G.key ? G.key : H);
                    G.type === ke ? (128 & G.patchFlag && U++,
                    R = R.concat(getTransitionRawChildren(G.children, E, W))) : (E || G.type !== Pe) && R.push(null != W ? cloneVNode(G, {
                        "key": W
                    }) : G)
                }
                if (U > 1)
                    for (let v = 0; v < R.length; v++)
                        R[v].patchFlag = -2;
                return R
            }
            function defineComponent(v, E) {
                return (0,
                U.mf)(v) ? ( () => (0,
                U.l7)({
                    "name": v.name
                }, E, {
                    "setup": v
                }))() : v
            }
            const isAsyncWrapper = v => !!v.type.__asyncLoader;
            const isKeepAlive = v => v.type.__isKeepAlive;
            RegExp,
            RegExp;
            function matches(v, E) {
                return (0,
                U.kJ)(v) ? v.some((v => matches(v, E))) : (0,
                U.HD)(v) ? v.split(",").includes(E) : !!(0,
                U.Kj)(v) && v.test(E)
            }
            function onActivated(v, E) {
                registerKeepAliveHook(v, "a", E)
            }
            function onDeactivated(v, E) {
                registerKeepAliveHook(v, "da", E)
            }
            function registerKeepAliveHook(v, E, k=je) {
                const R = v.__wdc || (v.__wdc = () => {
                    let E = k;
                    for (; E; ) {
                        if (E.isDeactivated)
                            return;
                        E = E.parent
                    }
                    return v()
                }
                );
                if (injectHook(E, R, k),
                k) {
                    let v = k.parent;
                    for (; v && v.parent; )
                        isKeepAlive(v.parent.vnode) && injectToKeepAliveRoot(R, E, k, v),
                        v = v.parent
                }
            }
            function injectToKeepAliveRoot(v, E, k, R) {
                const H = injectHook(E, v, R, !0);
                _e(( () => {
                    (0,
                    U.Od)(R[E], H)
                }
                ), k)
            }
            function resetShapeFlag(v) {
                v.shapeFlag &= -257,
                v.shapeFlag &= -513
            }
            function getInnerChild(v) {
                return 128 & v.shapeFlag ? v.ssContent : v
            }
            function injectHook(v, E, k=je, U=!1) {
                if (k) {
                    const H = k[v] || (k[v] = [])
                      , G = E.__weh || (E.__weh = (...U) => {
                        if (k.isUnmounted)
                            return;
                        (0,
                        R.Jd)();
                        const H = setCurrentInstance(k)
                          , G = callWithAsyncErrorHandling(E, k, v, U);
                        return H(),
                        (0,
                        R.lk)(),
                        G
                    }
                    );
                    return U ? H.unshift(G) : H.push(G),
                    G
                }
            }
            const createHook = v => (E, k=je) => (!qe || "sp" === v) && injectHook(v, ( (...v) => E(...v)), k)
              , pe = createHook("bm")
              , fe = createHook("m")
              , he = createHook("bu")
              , me = createHook("u")
              , ge = createHook("bum")
              , _e = createHook("um")
              , ve = createHook("sp")
              , ye = createHook("rtg")
              , be = createHook("rtc");
            function onErrorCaptured(v, E=je) {
                injectHook("ec", v, E)
            }
            function renderList(v, E, k, R) {
                let H;
                const G = k && k[R];
                if ((0,
                U.kJ)(v) || (0,
                U.HD)(v)) {
                    H = new Array(v.length);
                    for (let k = 0, R = v.length; k < R; k++)
                        H[k] = E(v[k], k, void 0, G && G[k])
                } else if ("number" == typeof v) {
                    0,
                    H = new Array(v);
                    for (let k = 0; k < v; k++)
                        H[k] = E(k + 1, k, void 0, G && G[k])
                } else if ((0,
                U.Kn)(v))
                    if (v[Symbol.iterator])
                        H = Array.from(v, ( (v, k) => E(v, k, void 0, G && G[k])));
                    else {
                        const k = Object.keys(v);
                        H = new Array(k.length);
                        for (let R = 0, U = k.length; R < U; R++) {
                            const U = k[R];
                            H[R] = E(v[U], U, R, G && G[R])
                        }
                    }
                else
                    H = [];
                return k && (k[R] = H),
                H
            }
            function createSlots(v, E) {
                for (let k = 0; k < E.length; k++) {
                    const R = E[k];
                    if ((0,
                    U.kJ)(R))
                        for (let E = 0; E < R.length; E++)
                            v[R[E].name] = R[E].fn;
                    else
                        R && (v[R.name] = R.key ? (...v) => {
                            const E = R.fn(...v);
                            return E && (E.key = R.key),
                            E
                        }
                        : R.fn)
                }
                return v
            }
            function renderSlot(v, E, k={}, R, U) {
                if (ee.isCE || ee.parent && isAsyncWrapper(ee.parent) && ee.parent.isCE)
                    return "default" !== E && (k.name = E),
                    $e("slot", k, R && R());
                let H = v[E];
                H && H._c && (H._d = !1),
                openBlock();
                const G = H && ensureValidVNode(H(k))
                  , W = createBlock(ke, {
                    "key": k.key || G && G.key || `_${E}`
                }, G || (R ? R() : []), G && 1 === v._ ? 64 : -2);
                return !U && W.scopeId && (W.slotScopeIds = [W.scopeId + "-s"]),
                H && H._c && (H._d = !0),
                W
            }
            function ensureValidVNode(v) {
                return v.some((v => !isVNode(v) || v.type !== Pe && !(v.type === ke && !ensureValidVNode(v.children)))) ? v : null
            }
            const getPublicInstance = v => v ? isStatefulComponent(v) ? getExposeProxy(v) || v.proxy : getPublicInstance(v.parent) : null
              , Se = (0,
            U.l7)(Object.create(null), {
                "$": v => v,
                "$el": v => v.vnode.el,
                "$data": v => v.data,
                "$props": v => v.props,
                "$attrs": v => v.attrs,
                "$slots": v => v.slots,
                "$refs": v => v.refs,
                "$parent": v => getPublicInstance(v.parent),
                "$root": v => getPublicInstance(v.root),
                "$emit": v => v.emit,
                "$options": v => resolveMergedOptions(v),
                "$forceUpdate": v => v.f || (v.f = () => {
                    v.effect.dirty = !0,
                    queueJob(v.update)
                }
                ),
                "$nextTick": v => v.n || (v.n = nextTick.bind(v.proxy)),
                "$watch": v => instanceWatch.bind(v)
            })
              , hasSetupBinding = (v, E) => v !== U.kT && !v.__isScriptSetup && (0,
            U.RI)(v, E)
              , we = {
                "get"({"_": v}, E) {
                    if ("__v_skip" === E)
                        return !0;
                    const {"ctx": k, "setupState": H, "data": G, "props": W, "accessCache": Z, "type": Y, "appContext": J} = v;
                    let K;
                    if ("$" !== E[0]) {
                        const R = Z[E];
                        if (void 0 !== R)
                            switch (R) {
                            case 1:
                                return H[E];
                            case 2:
                                return G[E];
                            case 4:
                                return k[E];
                            case 3:
                                return W[E]
                            }
                        else {
                            if (hasSetupBinding(H, E))
                                return Z[E] = 1,
                                H[E];
                            if (G !== U.kT && (0,
                            U.RI)(G, E))
                                return Z[E] = 2,
                                G[E];
                            if ((K = v.propsOptions[0]) && (0,
                            U.RI)(K, E))
                                return Z[E] = 3,
                                W[E];
                            if (k !== U.kT && (0,
                            U.RI)(k, E))
                                return Z[E] = 4,
                                k[E];
                            Ee && (Z[E] = 0)
                        }
                    }
                    const X = Se[E];
                    let Q, ee;
                    return X ? ("$attrs" === E && (0,
                    R.j)(v.attrs, "get", ""),
                    X(v)) : (Q = Y.__cssModules) && (Q = Q[E]) ? Q : k !== U.kT && (0,
                    U.RI)(k, E) ? (Z[E] = 4,
                    k[E]) : (ee = J.config.globalProperties,
                    (0,
                    U.RI)(ee, E) ? ee[E] : void 0)
                },
                "set"({"_": v}, E, k) {
                    const {"data": R, "setupState": H, "ctx": G} = v;
                    return hasSetupBinding(H, E) ? (H[E] = k,
                    !0) : R !== U.kT && (0,
                    U.RI)(R, E) ? (R[E] = k,
                    !0) : !(0,
                    U.RI)(v.props, E) && (("$" !== E[0] || !(E.slice(1)in v)) && (G[E] = k,
                    !0))
                },
                "has"({"_": {"data": v, "setupState": E, "accessCache": k, "ctx": R, "appContext": H, "propsOptions": G}}, W) {
                    let Z;
                    return !!k[W] || v !== U.kT && (0,
                    U.RI)(v, W) || hasSetupBinding(E, W) || (Z = G[0]) && (0,
                    U.RI)(Z, W) || (0,
                    U.RI)(R, W) || (0,
                    U.RI)(Se, W) || (0,
                    U.RI)(H.config.globalProperties, W)
                },
                "defineProperty"(v, E, k) {
                    return null != k.get ? v._.accessCache[E] = 0 : (0,
                    U.RI)(k, "value") && this.set(v, E, k.value, null),
                    Reflect.defineProperty(v, E, k)
                }
            };
            function useSlots() {
                return getContext().slots
            }
            function useAttrs() {
                return getContext().attrs
            }
            function getContext() {
                const v = getCurrentInstance();
                return v.setupContext || (v.setupContext = createSetupContext(v))
            }
            function normalizePropsOrEmits(v) {
                return (0,
                U.kJ)(v) ? v.reduce(( (v, E) => (v[E] = null,
                v)), {}) : v
            }
            let Ee = !0;
            function applyOptions(v) {
                const E = resolveMergedOptions(v)
                  , k = v.proxy
                  , H = v.ctx;
                Ee = !1,
                E.beforeCreate && callHook(E.beforeCreate, v, "bc");
                const {"data": G, "computed": W, "methods": Z, "watch": Y, "provide": J, "inject": K, "created": X, "beforeMount": Q, "mounted": ee, "beforeUpdate": te, "updated": ne, "activated": re, "deactivated": oe, "beforeDestroy": ie, "beforeUnmount": ae, "destroyed": se, "unmounted": ce, "render": le, "renderTracked": ue, "renderTriggered": de, "errorCaptured": Se, "serverPrefetch": we, "expose": Ce, "inheritAttrs": Te, "components": xe, "directives": Ae, "filters": Ie} = E;
                if (K && function resolveInjections(v, E, k=U.dG) {
                    (0,
                    U.kJ)(v) && (v = normalizeInject(v));
                    for (const k in v) {
                        const H = v[k];
                        let G;
                        G = (0,
                        U.Kn)(H) ? "default"in H ? inject(H.from || k, H.default, !0) : inject(H.from || k) : inject(H),
                        (0,
                        R.dq)(G) ? Object.defineProperty(E, k, {
                            "enumerable": !0,
                            "configurable": !0,
                            "get": () => G.value,
                            "set": v => G.value = v
                        }) : E[k] = G
                    }
                }(K, H, null),
                Z)
                    for (const v in Z) {
                        const E = Z[v];
                        (0,
                        U.mf)(E) && (H[v] = E.bind(k))
                    }
                if (G) {
                    0;
                    const E = G.call(k, k);
                    0,
                    (0,
                    U.Kn)(E) && (v.data = (0,
                    R.qj)(E))
                }
                if (Ee = !0,
                W)
                    for (const v in W) {
                        const E = W[v]
                          , R = (0,
                        U.mf)(E) ? E.bind(k, k) : (0,
                        U.mf)(E.get) ? E.get.bind(k, k) : U.dG;
                        0;
                        const G = !(0,
                        U.mf)(E) && (0,
                        U.mf)(E.set) ? E.set.bind(k) : U.dG
                          , Z = computed({
                            "get": R,
                            "set": G
                        });
                        Object.defineProperty(H, v, {
                            "enumerable": !0,
                            "configurable": !0,
                            "get": () => Z.value,
                            "set": v => Z.value = v
                        })
                    }
                if (Y)
                    for (const v in Y)
                        createWatcher(Y[v], H, k, v);
                if (J) {
                    const v = (0,
                    U.mf)(J) ? J.call(k) : J;
                    Reflect.ownKeys(v).forEach((E => {
                        provide(E, v[E])
                    }
                    ))
                }
                function registerLifecycleHook(v, E) {
                    (0,
                    U.kJ)(E) ? E.forEach((E => v(E.bind(k)))) : E && v(E.bind(k))
                }
                if (X && callHook(X, v, "c"),
                registerLifecycleHook(pe, Q),
                registerLifecycleHook(fe, ee),
                registerLifecycleHook(he, te),
                registerLifecycleHook(me, ne),
                registerLifecycleHook(onActivated, re),
                registerLifecycleHook(onDeactivated, oe),
                registerLifecycleHook(onErrorCaptured, Se),
                registerLifecycleHook(be, ue),
                registerLifecycleHook(ye, de),
                registerLifecycleHook(ge, ae),
                registerLifecycleHook(_e, ce),
                registerLifecycleHook(ve, we),
                (0,
                U.kJ)(Ce))
                    if (Ce.length) {
                        const E = v.exposed || (v.exposed = {});
                        Ce.forEach((v => {
                            Object.defineProperty(E, v, {
                                "get": () => k[v],
                                "set": E => k[v] = E
                            })
                        }
                        ))
                    } else
                        v.exposed || (v.exposed = {});
                le && v.render === U.dG && (v.render = le),
                null != Te && (v.inheritAttrs = Te),
                xe && (v.components = xe),
                Ae && (v.directives = Ae)
            }
            function callHook(v, E, k) {
                callWithAsyncErrorHandling((0,
                U.kJ)(v) ? v.map((v => v.bind(E.proxy))) : v.bind(E.proxy), E, k)
            }
            function createWatcher(v, E, k, R) {
                const H = R.includes(".") ? createPathGetter(k, R) : () => k[R];
                if ((0,
                U.HD)(v)) {
                    const k = E[v];
                    (0,
                    U.mf)(k) && watch(H, k)
                } else if ((0,
                U.mf)(v))
                    watch(H, v.bind(k));
                else if ((0,
                U.Kn)(v))
                    if ((0,
                    U.kJ)(v))
                        v.forEach((v => createWatcher(v, E, k, R)));
                    else {
                        const R = (0,
                        U.mf)(v.handler) ? v.handler.bind(k) : E[v.handler];
                        (0,
                        U.mf)(R) && watch(H, R, v)
                    }
                else
                    0
            }
            function resolveMergedOptions(v) {
                const E = v.type
                  , {"mixins": k, "extends": R} = E
                  , {"mixins": H, "optionsCache": G, "config": {"optionMergeStrategies": W}} = v.appContext
                  , Z = G.get(E);
                let Y;
                return Z ? Y = Z : H.length || k || R ? (Y = {},
                H.length && H.forEach((v => mergeOptions(Y, v, W, !0))),
                mergeOptions(Y, E, W)) : Y = E,
                (0,
                U.Kn)(E) && G.set(E, Y),
                Y
            }
            function mergeOptions(v, E, k, R=!1) {
                const {"mixins": U, "extends": H} = E;
                H && mergeOptions(v, H, k, !0),
                U && U.forEach((E => mergeOptions(v, E, k, !0)));
                for (const U in E)
                    if (R && "expose" === U)
                        ;
                    else {
                        const R = Ce[U] || k && k[U];
                        v[U] = R ? R(v[U], E[U]) : E[U]
                    }
                return v
            }
            const Ce = {
                "data": mergeDataFn,
                "props": mergeEmitsOrPropsOptions,
                "emits": mergeEmitsOrPropsOptions,
                "methods": mergeObjectOptions,
                "computed": mergeObjectOptions,
                "beforeCreate": mergeAsArray,
                "created": mergeAsArray,
                "beforeMount": mergeAsArray,
                "mounted": mergeAsArray,
                "beforeUpdate": mergeAsArray,
                "updated": mergeAsArray,
                "beforeDestroy": mergeAsArray,
                "beforeUnmount": mergeAsArray,
                "destroyed": mergeAsArray,
                "unmounted": mergeAsArray,
                "activated": mergeAsArray,
                "deactivated": mergeAsArray,
                "errorCaptured": mergeAsArray,
                "serverPrefetch": mergeAsArray,
                "components": mergeObjectOptions,
                "directives": mergeObjectOptions,
                "watch": function mergeWatchOptions(v, E) {
                    if (!v)
                        return E;
                    if (!E)
                        return v;
                    const k = (0,
                    U.l7)(Object.create(null), v);
                    for (const R in E)
                        k[R] = mergeAsArray(v[R], E[R]);
                    return k
                },
                "provide": mergeDataFn,
                "inject": function mergeInject(v, E) {
                    return mergeObjectOptions(normalizeInject(v), normalizeInject(E))
                }
            };
            function mergeDataFn(v, E) {
                return E ? v ? function mergedDataFn() {
                    return (0,
                    U.l7)((0,
                    U.mf)(v) ? v.call(this, this) : v, (0,
                    U.mf)(E) ? E.call(this, this) : E)
                }
                : E : v
            }
            function normalizeInject(v) {
                if ((0,
                U.kJ)(v)) {
                    const E = {};
                    for (let k = 0; k < v.length; k++)
                        E[v[k]] = v[k];
                    return E
                }
                return v
            }
            function mergeAsArray(v, E) {
                return v ? [...new Set([].concat(v, E))] : E
            }
            function mergeObjectOptions(v, E) {
                return v ? (0,
                U.l7)(Object.create(null), v, E) : E
            }
            function mergeEmitsOrPropsOptions(v, E) {
                return v ? (0,
                U.kJ)(v) && (0,
                U.kJ)(E) ? [...new Set([...v, ...E])] : (0,
                U.l7)(Object.create(null), normalizePropsOrEmits(v), normalizePropsOrEmits(null != E ? E : {})) : E
            }
            function createAppContext() {
                return {
                    "app": null,
                    "config": {
                        "isNativeTag": U.NO,
                        "performance": !1,
                        "globalProperties": {},
                        "optionMergeStrategies": {},
                        "errorHandler": void 0,
                        "warnHandler": void 0,
                        "compilerOptions": {}
                    },
                    "mixins": [],
                    "components": {},
                    "directives": {},
                    "provides": Object.create(null),
                    "optionsCache": new WeakMap,
                    "propsCache": new WeakMap,
                    "emitsCache": new WeakMap
                }
            }
            let Te = 0;
            function createAppAPI(v, E) {
                return function createApp(k, R=null) {
                    (0,
                    U.mf)(k) || (k = (0,
                    U.l7)({}, k)),
                    null == R || (0,
                    U.Kn)(R) || (R = null);
                    const H = createAppContext()
                      , G = new WeakSet;
                    let W = !1;
                    const Z = H.app = {
                        "_uid": Te++,
                        "_component": k,
                        "_props": R,
                        "_container": null,
                        "_context": H,
                        "_instance": null,
                        "version": Ve,
                        get "config"() {
                            return H.config
                        },
                        set "config"(v) {
                            0
                        },
                        "use"(v, ...E) {
                            return G.has(v) || (v && (0,
                            U.mf)(v.install) ? (G.add(v),
                            v.install(Z, ...E)) : (0,
                            U.mf)(v) && (G.add(v),
                            v(Z, ...E))),
                            Z
                        },
                        "mixin"(v) {
                            return H.mixins.includes(v) || H.mixins.push(v),
                            Z
                        },
                        "component"(v, E) {
                            return E ? (H.components[v] = E,
                            Z) : H.components[v]
                        },
                        "directive"(v, E) {
                            return E ? (H.directives[v] = E,
                            Z) : H.directives[v]
                        },
                        "mount"(U, G, Y) {
                            if (!W) {
                                0;
                                const J = $e(k, R);
                                return J.appContext = H,
                                !0 === Y ? Y = "svg" : !1 === Y && (Y = void 0),
                                G && E ? E(J, U) : v(J, U, Y),
                                W = !0,
                                Z._container = U,
                                U.__vue_app__ = Z,
                                getExposeProxy(J.component) || J.component.proxy
                            }
                        },
                        "unmount"() {
                            W && (v(null, Z._container),
                            delete Z._container.__vue_app__)
                        },
                        "provide"(v, E) {
                            return H.provides[v] = E,
                            Z
                        },
                        "runWithContext"(v) {
                            const E = xe;
                            xe = Z;
                            try {
                                return v()
                            } finally {
                                xe = E
                            }
                        }
                    };
                    return Z
                }
            }
            let xe = null;
            function provide(v, E) {
                if (je) {
                    let k = je.provides;
                    const R = je.parent && je.parent.provides;
                    R === k && (k = je.provides = Object.create(R)),
                    k[v] = E
                } else
                    0
            }
            function inject(v, E, k=!1) {
                const R = je || ee;
                if (R || xe) {
                    const H = R ? null == R.parent ? R.vnode.appContext && R.vnode.appContext.provides : R.parent.provides : xe._context.provides;
                    if (H && v in H)
                        return H[v];
                    if (arguments.length > 1)
                        return k && (0,
                        U.mf)(E) ? E.call(R && R.proxy) : E
                } else
                    0
            }
            const Ae = {}
              , createInternalObject = () => Object.create(Ae)
              , isInternalObject = v => Object.getPrototypeOf(v) === Ae;
            function setFullProps(v, E, k, H) {
                const [G,W] = v.propsOptions;
                let Z, Y = !1;
                if (E)
                    for (let R in E) {
                        if ((0,
                        U.Gg)(R))
                            continue;
                        const J = E[R];
                        let K;
                        G && (0,
                        U.RI)(G, K = (0,
                        U._A)(R)) ? W && W.includes(K) ? (Z || (Z = {}))[K] = J : k[K] = J : isEmitListener(v.emitsOptions, R) || R in H && J === H[R] || (H[R] = J,
                        Y = !0)
                    }
                if (W) {
                    const E = (0,
                    R.IU)(k)
                      , H = Z || U.kT;
                    for (let R = 0; R < W.length; R++) {
                        const Z = W[R];
                        k[Z] = resolvePropValue(G, E, Z, H[Z], v, !(0,
                        U.RI)(H, Z))
                    }
                }
                return Y
            }
            function resolvePropValue(v, E, k, R, H, G) {
                const W = v[k];
                if (null != W) {
                    const v = (0,
                    U.RI)(W, "default");
                    if (v && void 0 === R) {
                        const v = W.default;
                        if (W.type !== Function && !W.skipFactory && (0,
                        U.mf)(v)) {
                            const {"propsDefaults": U} = H;
                            if (k in U)
                                R = U[k];
                            else {
                                const G = setCurrentInstance(H);
                                R = U[k] = v.call(null, E),
                                G()
                            }
                        } else
                            R = v
                    }
                    W[0] && (G && !v ? R = !1 : !W[1] || "" !== R && R !== (0,
                    U.rs)(k) || (R = !0))
                }
                return R
            }
            function normalizePropsOptions(v, E, k=!1) {
                const R = E.propsCache
                  , H = R.get(v);
                if (H)
                    return H;
                const G = v.props
                  , W = {}
                  , Z = [];
                let Y = !1;
                if (!(0,
                U.mf)(v)) {
                    const extendProps = v => {
                        Y = !0;
                        const [k,R] = normalizePropsOptions(v, E, !0);
                        (0,
                        U.l7)(W, k),
                        R && Z.push(...R)
                    }
                    ;
                    !k && E.mixins.length && E.mixins.forEach(extendProps),
                    v.extends && extendProps(v.extends),
                    v.mixins && v.mixins.forEach(extendProps)
                }
                if (!G && !Y)
                    return (0,
                    U.Kn)(v) && R.set(v, U.Z6),
                    U.Z6;
                if ((0,
                U.kJ)(G))
                    for (let v = 0; v < G.length; v++) {
                        0;
                        const E = (0,
                        U._A)(G[v]);
                        validatePropName(E) && (W[E] = U.kT)
                    }
                else if (G) {
                    0;
                    for (const v in G) {
                        const E = (0,
                        U._A)(v);
                        if (validatePropName(E)) {
                            const k = G[v]
                              , R = W[E] = (0,
                            U.kJ)(k) || (0,
                            U.mf)(k) ? {
                                "type": k
                            } : (0,
                            U.l7)({}, k);
                            if (R) {
                                const v = getTypeIndex(Boolean, R.type)
                                  , k = getTypeIndex(String, R.type);
                                R[0] = v > -1,
                                R[1] = k < 0 || v < k,
                                (v > -1 || (0,
                                U.RI)(R, "default")) && Z.push(E)
                            }
                        }
                    }
                }
                const J = [W, Z];
                return (0,
                U.Kn)(v) && R.set(v, J),
                J
            }
            function validatePropName(v) {
                return "$" !== v[0] && !(0,
                U.Gg)(v)
            }
            function getType(v) {
                if (null === v)
                    return "null";
                if ("function" == typeof v)
                    return v.name || "";
                if ("object" == typeof v) {
                    return v.constructor && v.constructor.name || ""
                }
                return ""
            }
            function isSameType(v, E) {
                return getType(v) === getType(E)
            }
            function getTypeIndex(v, E) {
                return (0,
                U.kJ)(E) ? E.findIndex((E => isSameType(E, v))) : (0,
                U.mf)(E) && isSameType(E, v) ? 0 : -1
            }
            const isInternalKey = v => "_" === v[0] || "$stable" === v
              , normalizeSlotValue = v => (0,
            U.kJ)(v) ? v.map(normalizeVNode) : [normalizeVNode(v)]
              , normalizeSlot = (v, E, k) => {
                if (E._n)
                    return E;
                const R = withCtx(( (...v) => normalizeSlotValue(E(...v))), k);
                return R._c = !1,
                R
            }
              , normalizeObjectSlots = (v, E, k) => {
                const R = v._ctx;
                for (const k in v) {
                    if (isInternalKey(k))
                        continue;
                    const H = v[k];
                    if ((0,
                    U.mf)(H))
                        E[k] = normalizeSlot(0, H, R);
                    else if (null != H) {
                        0;
                        const v = normalizeSlotValue(H);
                        E[k] = () => v
                    }
                }
            }
              , normalizeVNodeSlots = (v, E) => {
                const k = normalizeSlotValue(E);
                v.slots.default = () => k
            }
              , initSlots = (v, E) => {
                const k = v.slots = createInternalObject();
                if (32 & v.vnode.shapeFlag) {
                    const v = E._;
                    v ? ((0,
                    U.l7)(k, E),
                    (0,
                    U.Nj)(k, "_", v, !0)) : normalizeObjectSlots(E, k)
                } else
                    E && normalizeVNodeSlots(v, E)
            }
              , updateSlots = (v, E, k) => {
                const {"vnode": R, "slots": H} = v;
                let G = !0
                  , W = U.kT;
                if (32 & R.shapeFlag) {
                    const v = E._;
                    v ? k && 1 === v ? G = !1 : ((0,
                    U.l7)(H, E),
                    k || 1 !== v || delete H._) : (G = !E.$stable,
                    normalizeObjectSlots(E, H)),
                    W = E
                } else
                    E && (normalizeVNodeSlots(v, E),
                    W = {
                        "default": 1
                    });
                if (G)
                    for (const v in H)
                        isInternalKey(v) || null != W[v] || delete H[v]
            }
            ;
            function setRef(v, E, k, H, G=!1) {
                if ((0,
                U.kJ)(v))
                    return void v.forEach(( (v, R) => setRef(v, E && ((0,
                    U.kJ)(E) ? E[R] : E), k, H, G)));
                if (isAsyncWrapper(H) && !G)
                    return;
                const W = 4 & H.shapeFlag ? getExposeProxy(H.component) || H.component.proxy : H.el
                  , Z = G ? null : W
                  , {"i": Y, "r": J} = v;
                const K = E && E.r
                  , X = Y.refs === U.kT ? Y.refs = {} : Y.refs
                  , Q = Y.setupState;
                if (null != K && K !== J && ((0,
                U.HD)(K) ? (X[K] = null,
                (0,
                U.RI)(Q, K) && (Q[K] = null)) : (0,
                R.dq)(K) && (K.value = null)),
                (0,
                U.mf)(J))
                    callWithErrorHandling(J, Y, 12, [Z, X]);
                else {
                    const E = (0,
                    U.HD)(J)
                      , H = (0,
                    R.dq)(J);
                    if (E || H) {
                        const doSet = () => {
                            if (v.f) {
                                const k = E ? (0,
                                U.RI)(Q, J) ? Q[J] : X[J] : J.value;
                                G ? (0,
                                U.kJ)(k) && (0,
                                U.Od)(k, W) : (0,
                                U.kJ)(k) ? k.includes(W) || k.push(W) : E ? (X[J] = [W],
                                (0,
                                U.RI)(Q, J) && (Q[J] = X[J])) : (J.value = [W],
                                v.k && (X[v.k] = J.value))
                            } else
                                E ? (X[J] = Z,
                                (0,
                                U.RI)(Q, J) && (Q[J] = Z)) : H && (J.value = Z,
                                v.k && (X[v.k] = Z))
                        }
                        ;
                        Z ? (doSet.id = -1,
                        Ie(doSet, k)) : doSet()
                    } else
                        0
                }
            }
            const Ie = queueEffectWithSuspense;
            function createRenderer(v) {
                return baseCreateRenderer(v)
            }
            function baseCreateRenderer(v, E) {
                !function initFeatureFlags() {
                    "boolean" != typeof __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ && ((0,
                    U.E9)().__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ = !1)
                }();
                (0,
                U.E9)().__VUE__ = !0;
                const {"insert": k, "remove": H, "patchProp": G, "createElement": Y, "createText": J, "createComment": K, "setText": X, "setElementText": Q, "parentNode": ee, "nextSibling": te, "setScopeId": ne=U.dG, "insertStaticContent": re} = v
                  , patch = (v, E, k, R=null, U=null, H=null, G=void 0, W=null, Z=!!E.dynamicChildren) => {
                    if (v === E)
                        return;
                    v && !isSameVNodeType(v, E) && (R = getNextHostNode(v),
                    unmount(v, U, H, !0),
                    v = null),
                    -2 === E.patchFlag && (Z = !1,
                    E.dynamicChildren = null);
                    const {"type": Y, "ref": J, "shapeFlag": K} = E;
                    switch (Y) {
                    case Oe:
                        processText(v, E, k, R);
                        break;
                    case Pe:
                        processCommentNode(v, E, k, R);
                        break;
                    case Re:
                        null == v && mountStaticNode(E, k, R, G);
                        break;
                    case ke:
                        processFragment(v, E, k, R, U, H, G, W, Z);
                        break;
                    default:
                        1 & K ? processElement(v, E, k, R, U, H, G, W, Z) : 6 & K ? processComponent(v, E, k, R, U, H, G, W, Z) : (64 & K || 128 & K) && Y.process(v, E, k, R, U, H, G, W, Z, ie)
                    }
                    null != J && U && setRef(J, v && v.ref, H, E || v, !E)
                }
                  , processText = (v, E, R, U) => {
                    if (null == v)
                        k(E.el = J(E.children), R, U);
                    else {
                        const k = E.el = v.el;
                        E.children !== v.children && X(k, E.children)
                    }
                }
                  , processCommentNode = (v, E, R, U) => {
                    null == v ? k(E.el = K(E.children || ""), R, U) : E.el = v.el
                }
                  , mountStaticNode = (v, E, k, R) => {
                    [v.el,v.anchor] = re(v.children, E, k, R, v.el, v.anchor)
                }
                  , removeStaticNode = ({"el": v, "anchor": E}) => {
                    let k;
                    for (; v && v !== E; )
                        k = te(v),
                        H(v),
                        v = k;
                    H(E)
                }
                  , processElement = (v, E, k, R, U, H, G, W, Z) => {
                    "svg" === E.type ? G = "svg" : "math" === E.type && (G = "mathml"),
                    null == v ? mountElement(E, k, R, U, H, G, W, Z) : patchElement(v, E, U, H, G, W, Z)
                }
                  , mountElement = (v, E, R, H, W, Z, J, K) => {
                    let X, ee;
                    const {"props": te, "shapeFlag": ne, "transition": re, "dirs": oe} = v;
                    if (X = v.el = Y(v.type, Z, te && te.is, te),
                    8 & ne ? Q(X, v.children) : 16 & ne && mountChildren(v.children, X, null, H, W, resolveChildrenNamespace(v, Z), J, K),
                    oe && invokeDirectiveHook(v, null, H, "created"),
                    setScopeId(X, v, v.scopeId, J, H),
                    te) {
                        for (const E in te)
                            "value" === E || (0,
                            U.Gg)(E) || G(X, E, null, te[E], Z, v.children, H, W, unmountChildren);
                        "value"in te && G(X, "value", null, te.value, Z),
                        (ee = te.onVnodeBeforeMount) && invokeVNodeHook(ee, H, v)
                    }
                    oe && invokeDirectiveHook(v, null, H, "beforeMount");
                    const ie = needTransition(W, re);
                    ie && re.beforeEnter(X),
                    k(X, E, R),
                    ((ee = te && te.onVnodeMounted) || ie || oe) && Ie(( () => {
                        ee && invokeVNodeHook(ee, H, v),
                        ie && re.enter(X),
                        oe && invokeDirectiveHook(v, null, H, "mounted")
                    }
                    ), W)
                }
                  , setScopeId = (v, E, k, R, U) => {
                    if (k && ne(v, k),
                    R)
                        for (let E = 0; E < R.length; E++)
                            ne(v, R[E]);
                    if (U) {
                        if (E === U.subTree) {
                            const E = U.vnode;
                            setScopeId(v, E, E.scopeId, E.slotScopeIds, U.parent)
                        }
                    }
                }
                  , mountChildren = (v, E, k, R, U, H, G, W, Z=0) => {
                    for (let Y = Z; Y < v.length; Y++) {
                        const Z = v[Y] = W ? cloneIfMounted(v[Y]) : normalizeVNode(v[Y]);
                        patch(null, Z, E, k, R, U, H, G, W)
                    }
                }
                  , patchElement = (v, E, k, R, H, W, Z) => {
                    const Y = E.el = v.el;
                    let {"patchFlag": J, "dynamicChildren": K, "dirs": X} = E;
                    J |= 16 & v.patchFlag;
                    const ee = v.props || U.kT
                      , te = E.props || U.kT;
                    let ne;
                    if (k && toggleRecurse(k, !1),
                    (ne = te.onVnodeBeforeUpdate) && invokeVNodeHook(ne, k, E, v),
                    X && invokeDirectiveHook(E, v, k, "beforeUpdate"),
                    k && toggleRecurse(k, !0),
                    K ? patchBlockChildren(v.dynamicChildren, K, Y, k, R, resolveChildrenNamespace(E, H), W) : Z || patchChildren(v, E, Y, null, k, R, resolveChildrenNamespace(E, H), W, !1),
                    J > 0) {
                        if (16 & J)
                            patchProps(Y, E, ee, te, k, R, H);
                        else if (2 & J && ee.class !== te.class && G(Y, "class", null, te.class, H),
                        4 & J && G(Y, "style", ee.style, te.style, H),
                        8 & J) {
                            const U = E.dynamicProps;
                            for (let E = 0; E < U.length; E++) {
                                const W = U[E]
                                  , Z = ee[W]
                                  , J = te[W];
                                J === Z && "value" !== W || G(Y, W, Z, J, H, v.children, k, R, unmountChildren)
                            }
                        }
                        1 & J && v.children !== E.children && Q(Y, E.children)
                    } else
                        Z || null != K || patchProps(Y, E, ee, te, k, R, H);
                    ((ne = te.onVnodeUpdated) || X) && Ie(( () => {
                        ne && invokeVNodeHook(ne, k, E, v),
                        X && invokeDirectiveHook(E, v, k, "updated")
                    }
                    ), R)
                }
                  , patchBlockChildren = (v, E, k, R, U, H, G) => {
                    for (let W = 0; W < E.length; W++) {
                        const Z = v[W]
                          , Y = E[W]
                          , J = Z.el && (Z.type === ke || !isSameVNodeType(Z, Y) || 70 & Z.shapeFlag) ? ee(Z.el) : k;
                        patch(Z, Y, J, null, R, U, H, G, !0)
                    }
                }
                  , patchProps = (v, E, k, R, H, W, Z) => {
                    if (k !== R) {
                        if (k !== U.kT)
                            for (const Y in k)
                                (0,
                                U.Gg)(Y) || Y in R || G(v, Y, k[Y], null, Z, E.children, H, W, unmountChildren);
                        for (const Y in R) {
                            if ((0,
                            U.Gg)(Y))
                                continue;
                            const J = R[Y]
                              , K = k[Y];
                            J !== K && "value" !== Y && G(v, Y, K, J, Z, E.children, H, W, unmountChildren)
                        }
                        "value"in R && G(v, "value", k.value, R.value, Z)
                    }
                }
                  , processFragment = (v, E, R, U, H, G, W, Z, Y) => {
                    const K = E.el = v ? v.el : J("")
                      , X = E.anchor = v ? v.anchor : J("");
                    let {"patchFlag": Q, "dynamicChildren": ee, "slotScopeIds": te} = E;
                    te && (Z = Z ? Z.concat(te) : te),
                    null == v ? (k(K, R, U),
                    k(X, R, U),
                    mountChildren(E.children || [], R, X, H, G, W, Z, Y)) : Q > 0 && 64 & Q && ee && v.dynamicChildren ? (patchBlockChildren(v.dynamicChildren, ee, R, H, G, W, Z),
                    (null != E.key || H && E === H.subTree) && traverseStaticChildren(v, E, !0)) : patchChildren(v, E, R, X, H, G, W, Z, Y)
                }
                  , processComponent = (v, E, k, R, U, H, G, W, Z) => {
                    E.slotScopeIds = W,
                    null == v ? 512 & E.shapeFlag ? U.ctx.activate(E, k, R, G, Z) : mountComponent(E, k, R, U, H, G, Z) : updateComponent(v, E, Z)
                }
                  , mountComponent = (v, E, k, R, U, H, G) => {
                    const W = v.component = createComponentInstance(v, R, U);
                    if (isKeepAlive(v) && (W.ctx.renderer = ie),
                    setupComponent(W),
                    W.asyncDep) {
                        if (U && U.registerDep(W, setupRenderEffect),
                        !v.el) {
                            const v = W.subTree = $e(Pe);
                            processCommentNode(null, v, E, k)
                        }
                    } else
                        setupRenderEffect(W, v, E, k, U, H, G)
                }
                  , updateComponent = (v, E, k) => {
                    const R = E.component = v.component;
                    if (function shouldUpdateComponent(v, E, k) {
                        const {"props": R, "children": U, "component": H} = v
                          , {"props": G, "children": W, "patchFlag": Z} = E
                          , Y = H.emitsOptions;
                        if (E.dirs || E.transition)
                            return !0;
                        if (!(k && Z >= 0))
                            return !(!U && !W || W && W.$stable) || R !== G && (R ? !G || hasPropsChanged(R, G, Y) : !!G);
                        if (1024 & Z)
                            return !0;
                        if (16 & Z)
                            return R ? hasPropsChanged(R, G, Y) : !!G;
                        if (8 & Z) {
                            const v = E.dynamicProps;
                            for (let E = 0; E < v.length; E++) {
                                const k = v[E];
                                if (G[k] !== R[k] && !isEmitListener(Y, k))
                                    return !0
                            }
                        }
                        return !1
                    }(v, E, k)) {
                        if (R.asyncDep && !R.asyncResolved)
                            return void updateComponentPreRender(R, E, k);
                        R.next = E,
                        function invalidateJob(v) {
                            const E = W.indexOf(v);
                            E > Z && W.splice(E, 1)
                        }(R.update),
                        R.effect.dirty = !0,
                        R.update()
                    } else
                        E.el = v.el,
                        R.vnode = E
                }
                  , setupRenderEffect = (v, E, k, H, G, W, Z) => {
                    const componentUpdateFn = () => {
                        if (v.isMounted) {
                            let {"next": E, "bu": k, "u": R, "parent": H, "vnode": Y} = v;
                            {
                                const k = locateNonHydratedAsyncRoot(v);
                                if (k)
                                    return E && (E.el = Y.el,
                                    updateComponentPreRender(v, E, Z)),
                                    void k.asyncDep.then(( () => {
                                        v.isUnmounted || componentUpdateFn()
                                    }
                                    ))
                            }
                            let J, K = E;
                            0,
                            toggleRecurse(v, !1),
                            E ? (E.el = Y.el,
                            updateComponentPreRender(v, E, Z)) : E = Y,
                            k && (0,
                            U.ir)(k),
                            (J = E.props && E.props.onVnodeBeforeUpdate) && invokeVNodeHook(J, H, E, Y),
                            toggleRecurse(v, !0);
                            const X = renderComponentRoot(v);
                            0;
                            const Q = v.subTree;
                            v.subTree = X,
                            patch(Q, X, ee(Q.el), getNextHostNode(Q), v, G, W),
                            E.el = X.el,
                            null === K && updateHOCHostEl(v, X.el),
                            R && Ie(R, G),
                            (J = E.props && E.props.onVnodeUpdated) && Ie(( () => invokeVNodeHook(J, H, E, Y)), G)
                        } else {
                            let R;
                            const {"el": Z, "props": Y} = E
                              , {"bm": J, "m": K, "parent": X} = v
                              , Q = isAsyncWrapper(E);
                            if (toggleRecurse(v, !1),
                            J && (0,
                            U.ir)(J),
                            !Q && (R = Y && Y.onVnodeBeforeMount) && invokeVNodeHook(R, X, E),
                            toggleRecurse(v, !0),
                            Z && se) {
                                const hydrateSubTree = () => {
                                    v.subTree = renderComponentRoot(v),
                                    se(Z, v.subTree, v, G, null)
                                }
                                ;
                                Q ? E.type.__asyncLoader().then(( () => !v.isUnmounted && hydrateSubTree())) : hydrateSubTree()
                            } else {
                                0;
                                const R = v.subTree = renderComponentRoot(v);
                                0,
                                patch(null, R, k, H, v, G, W),
                                E.el = R.el
                            }
                            if (K && Ie(K, G),
                            !Q && (R = Y && Y.onVnodeMounted)) {
                                const v = E;
                                Ie(( () => invokeVNodeHook(R, X, v)), G)
                            }
                            (256 & E.shapeFlag || X && isAsyncWrapper(X.vnode) && 256 & X.vnode.shapeFlag) && v.a && Ie(v.a, G),
                            v.isMounted = !0,
                            E = k = H = null
                        }
                    }
                      , Y = v.effect = new R.qq(componentUpdateFn,U.dG,( () => queueJob(J)),v.scope)
                      , J = v.update = () => {
                        Y.dirty && Y.run()
                    }
                    ;
                    J.id = v.uid,
                    toggleRecurse(v, !0),
                    J()
                }
                  , updateComponentPreRender = (v, E, k) => {
                    E.component = v;
                    const H = v.vnode.props;
                    v.vnode = E,
                    v.next = null,
                    function updateProps(v, E, k, H) {
                        const {"props": G, "attrs": W, "vnode": {"patchFlag": Z}} = v
                          , Y = (0,
                        R.IU)(G)
                          , [J] = v.propsOptions;
                        let K = !1;
                        if (!(H || Z > 0) || 16 & Z) {
                            let R;
                            setFullProps(v, E, G, W) && (K = !0);
                            for (const H in Y)
                                E && ((0,
                                U.RI)(E, H) || (R = (0,
                                U.rs)(H)) !== H && (0,
                                U.RI)(E, R)) || (J ? !k || void 0 === k[H] && void 0 === k[R] || (G[H] = resolvePropValue(J, Y, H, void 0, v, !0)) : delete G[H]);
                            if (W !== Y)
                                for (const v in W)
                                    E && (0,
                                    U.RI)(E, v) || (delete W[v],
                                    K = !0)
                        } else if (8 & Z) {
                            const k = v.vnode.dynamicProps;
                            for (let R = 0; R < k.length; R++) {
                                let H = k[R];
                                if (isEmitListener(v.emitsOptions, H))
                                    continue;
                                const Z = E[H];
                                if (J)
                                    if ((0,
                                    U.RI)(W, H))
                                        Z !== W[H] && (W[H] = Z,
                                        K = !0);
                                    else {
                                        const E = (0,
                                        U._A)(H);
                                        G[E] = resolvePropValue(J, Y, E, Z, v, !1)
                                    }
                                else
                                    Z !== W[H] && (W[H] = Z,
                                    K = !0)
                            }
                        }
                        K && (0,
                        R.X$)(v.attrs, "set", "")
                    }(v, E.props, H, k),
                    updateSlots(v, E.children, k),
                    (0,
                    R.Jd)(),
                    flushPreFlushCbs(v),
                    (0,
                    R.lk)()
                }
                  , patchChildren = (v, E, k, R, U, H, G, W, Z=!1) => {
                    const Y = v && v.children
                      , J = v ? v.shapeFlag : 0
                      , K = E.children
                      , {"patchFlag": X, "shapeFlag": ee} = E;
                    if (X > 0) {
                        if (128 & X)
                            return void patchKeyedChildren(Y, K, k, R, U, H, G, W, Z);
                        if (256 & X)
                            return void patchUnkeyedChildren(Y, K, k, R, U, H, G, W, Z)
                    }
                    8 & ee ? (16 & J && unmountChildren(Y, U, H),
                    K !== Y && Q(k, K)) : 16 & J ? 16 & ee ? patchKeyedChildren(Y, K, k, R, U, H, G, W, Z) : unmountChildren(Y, U, H, !0) : (8 & J && Q(k, ""),
                    16 & ee && mountChildren(K, k, R, U, H, G, W, Z))
                }
                  , patchUnkeyedChildren = (v, E, k, R, H, G, W, Z, Y) => {
                    v = v || U.Z6,
                    E = E || U.Z6;
                    const J = v.length
                      , K = E.length
                      , X = Math.min(J, K);
                    let Q;
                    for (Q = 0; Q < X; Q++) {
                        const R = E[Q] = Y ? cloneIfMounted(E[Q]) : normalizeVNode(E[Q]);
                        patch(v[Q], R, k, null, H, G, W, Z, Y)
                    }
                    J > K ? unmountChildren(v, H, G, !0, !1, X) : mountChildren(E, k, R, H, G, W, Z, Y, X)
                }
                  , patchKeyedChildren = (v, E, k, R, H, G, W, Z, Y) => {
                    let J = 0;
                    const K = E.length;
                    let X = v.length - 1
                      , Q = K - 1;
                    for (; J <= X && J <= Q; ) {
                        const R = v[J]
                          , U = E[J] = Y ? cloneIfMounted(E[J]) : normalizeVNode(E[J]);
                        if (!isSameVNodeType(R, U))
                            break;
                        patch(R, U, k, null, H, G, W, Z, Y),
                        J++
                    }
                    for (; J <= X && J <= Q; ) {
                        const R = v[X]
                          , U = E[Q] = Y ? cloneIfMounted(E[Q]) : normalizeVNode(E[Q]);
                        if (!isSameVNodeType(R, U))
                            break;
                        patch(R, U, k, null, H, G, W, Z, Y),
                        X--,
                        Q--
                    }
                    if (J > X) {
                        if (J <= Q) {
                            const v = Q + 1
                              , U = v < K ? E[v].el : R;
                            for (; J <= Q; )
                                patch(null, E[J] = Y ? cloneIfMounted(E[J]) : normalizeVNode(E[J]), k, U, H, G, W, Z, Y),
                                J++
                        }
                    } else if (J > Q)
                        for (; J <= X; )
                            unmount(v[J], H, G, !0),
                            J++;
                    else {
                        const ee = J
                          , te = J
                          , ne = new Map;
                        for (J = te; J <= Q; J++) {
                            const v = E[J] = Y ? cloneIfMounted(E[J]) : normalizeVNode(E[J]);
                            null != v.key && ne.set(v.key, J)
                        }
                        let re, oe = 0;
                        const ie = Q - te + 1;
                        let ae = !1
                          , se = 0;
                        const ce = new Array(ie);
                        for (J = 0; J < ie; J++)
                            ce[J] = 0;
                        for (J = ee; J <= X; J++) {
                            const R = v[J];
                            if (oe >= ie) {
                                unmount(R, H, G, !0);
                                continue
                            }
                            let U;
                            if (null != R.key)
                                U = ne.get(R.key);
                            else
                                for (re = te; re <= Q; re++)
                                    if (0 === ce[re - te] && isSameVNodeType(R, E[re])) {
                                        U = re;
                                        break
                                    }
                            void 0 === U ? unmount(R, H, G, !0) : (ce[U - te] = J + 1,
                            U >= se ? se = U : ae = !0,
                            patch(R, E[U], k, null, H, G, W, Z, Y),
                            oe++)
                        }
                        const le = ae ? function getSequence(v) {
                            const E = v.slice()
                              , k = [0];
                            let R, U, H, G, W;
                            const Z = v.length;
                            for (R = 0; R < Z; R++) {
                                const Z = v[R];
                                if (0 !== Z) {
                                    if (U = k[k.length - 1],
                                    v[U] < Z) {
                                        E[R] = U,
                                        k.push(R);
                                        continue
                                    }
                                    for (H = 0,
                                    G = k.length - 1; H < G; )
                                        W = H + G >> 1,
                                        v[k[W]] < Z ? H = W + 1 : G = W;
                                    Z < v[k[H]] && (H > 0 && (E[R] = k[H - 1]),
                                    k[H] = R)
                                }
                            }
                            H = k.length,
                            G = k[H - 1];
                            for (; H-- > 0; )
                                k[H] = G,
                                G = E[G];
                            return k
                        }(ce) : U.Z6;
                        for (re = le.length - 1,
                        J = ie - 1; J >= 0; J--) {
                            const v = te + J
                              , U = E[v]
                              , X = v + 1 < K ? E[v + 1].el : R;
                            0 === ce[J] ? patch(null, U, k, X, H, G, W, Z, Y) : ae && (re < 0 || J !== le[re] ? move(U, k, X, 2) : re--)
                        }
                    }
                }
                  , move = (v, E, R, U, H=null) => {
                    const {"el": G, "type": W, "transition": Z, "children": Y, "shapeFlag": J} = v;
                    if (6 & J)
                        return void move(v.component.subTree, E, R, U);
                    if (128 & J)
                        return void v.suspense.move(E, R, U);
                    if (64 & J)
                        return void W.move(v, E, R, ie);
                    if (W === ke) {
                        k(G, E, R);
                        for (let v = 0; v < Y.length; v++)
                            move(Y[v], E, R, U);
                        return void k(v.anchor, E, R)
                    }
                    if (W === Re)
                        return void ( ({"el": v, "anchor": E}, R, U) => {
                            let H;
                            for (; v && v !== E; )
                                H = te(v),
                                k(v, R, U),
                                v = H;
                            k(E, R, U)
                        }
                        )(v, E, R);
                    if (2 !== U && 1 & J && Z)
                        if (0 === U)
                            Z.beforeEnter(G),
                            k(G, E, R),
                            Ie(( () => Z.enter(G)), H);
                        else {
                            const {"leave": v, "delayLeave": U, "afterLeave": H} = Z
                              , remove2 = () => k(G, E, R)
                              , performLeave = () => {
                                v(G, ( () => {
                                    remove2(),
                                    H && H()
                                }
                                ))
                            }
                            ;
                            U ? U(G, remove2, performLeave) : performLeave()
                        }
                    else
                        k(G, E, R)
                }
                  , unmount = (v, E, k, R=!1, U=!1) => {
                    const {"type": H, "props": G, "ref": W, "children": Z, "dynamicChildren": Y, "shapeFlag": J, "patchFlag": K, "dirs": X} = v;
                    if (null != W && setRef(W, null, k, v, !0),
                    256 & J)
                        return void E.ctx.deactivate(v);
                    const Q = 1 & J && X
                      , ee = !isAsyncWrapper(v);
                    let te;
                    if (ee && (te = G && G.onVnodeBeforeUnmount) && invokeVNodeHook(te, E, v),
                    6 & J)
                        unmountComponent(v.component, k, R);
                    else {
                        if (128 & J)
                            return void v.suspense.unmount(k, R);
                        Q && invokeDirectiveHook(v, null, E, "beforeUnmount"),
                        64 & J ? v.type.remove(v, E, k, U, ie, R) : Y && (H !== ke || K > 0 && 64 & K) ? unmountChildren(Y, E, k, !1, !0) : (H === ke && 384 & K || !U && 16 & J) && unmountChildren(Z, E, k),
                        R && remove(v)
                    }
                    (ee && (te = G && G.onVnodeUnmounted) || Q) && Ie(( () => {
                        te && invokeVNodeHook(te, E, v),
                        Q && invokeDirectiveHook(v, null, E, "unmounted")
                    }
                    ), k)
                }
                  , remove = v => {
                    const {"type": E, "el": k, "anchor": R, "transition": U} = v;
                    if (E === ke)
                        return void removeFragment(k, R);
                    if (E === Re)
                        return void removeStaticNode(v);
                    const performRemove = () => {
                        H(k),
                        U && !U.persisted && U.afterLeave && U.afterLeave()
                    }
                    ;
                    if (1 & v.shapeFlag && U && !U.persisted) {
                        const {"leave": E, "delayLeave": R} = U
                          , performLeave = () => E(k, performRemove);
                        R ? R(v.el, performRemove, performLeave) : performLeave()
                    } else
                        performRemove()
                }
                  , removeFragment = (v, E) => {
                    let k;
                    for (; v !== E; )
                        k = te(v),
                        H(v),
                        v = k;
                    H(E)
                }
                  , unmountComponent = (v, E, k) => {
                    const {"bum": R, "scope": H, "update": G, "subTree": W, "um": Z} = v;
                    R && (0,
                    U.ir)(R),
                    H.stop(),
                    G && (G.active = !1,
                    unmount(W, v, E, k)),
                    Z && Ie(Z, E),
                    Ie(( () => {
                        v.isUnmounted = !0
                    }
                    ), E),
                    E && E.pendingBranch && !E.isUnmounted && v.asyncDep && !v.asyncResolved && v.suspenseId === E.pendingId && (E.deps--,
                    0 === E.deps && E.resolve())
                }
                  , unmountChildren = (v, E, k, R=!1, U=!1, H=0) => {
                    for (let G = H; G < v.length; G++)
                        unmount(v[G], E, k, R, U)
                }
                  , getNextHostNode = v => 6 & v.shapeFlag ? getNextHostNode(v.component.subTree) : 128 & v.shapeFlag ? v.suspense.next() : te(v.anchor || v.el);
                let oe = !1;
                const render = (v, E, k) => {
                    null == v ? E._vnode && unmount(E._vnode, null, null, !0) : patch(E._vnode || null, v, E, null, null, null, k),
                    oe || (oe = !0,
                    flushPreFlushCbs(),
                    flushPostFlushCbs(),
                    oe = !1),
                    E._vnode = v
                }
                  , ie = {
                    "p": patch,
                    "um": unmount,
                    "m": move,
                    "r": remove,
                    "mt": mountComponent,
                    "mc": mountChildren,
                    "pc": patchChildren,
                    "pbc": patchBlockChildren,
                    "n": getNextHostNode,
                    "o": v
                };
                let ae, se;
                return E && ([ae,se] = E(ie)),
                {
                    "render": render,
                    "hydrate": ae,
                    "createApp": createAppAPI(render, ae)
                }
            }
            function resolveChildrenNamespace({"type": v, "props": E}, k) {
                return "svg" === k && "foreignObject" === v || "mathml" === k && "annotation-xml" === v && E && E.encoding && E.encoding.includes("html") ? void 0 : k
            }
            function toggleRecurse({"effect": v, "update": E}, k) {
                v.allowRecurse = E.allowRecurse = k
            }
            function needTransition(v, E) {
                return (!v || v && !v.pendingBranch) && E && !E.persisted
            }
            function traverseStaticChildren(v, E, k=!1) {
                const R = v.children
                  , H = E.children;
                if ((0,
                U.kJ)(R) && (0,
                U.kJ)(H))
                    for (let v = 0; v < R.length; v++) {
                        const E = R[v];
                        let U = H[v];
                        1 & U.shapeFlag && !U.dynamicChildren && ((U.patchFlag <= 0 || 32 === U.patchFlag) && (U = H[v] = cloneIfMounted(H[v]),
                        U.el = E.el),
                        k || traverseStaticChildren(E, U)),
                        U.type === Oe && (U.el = E.el)
                    }
            }
            function locateNonHydratedAsyncRoot(v) {
                const E = v.subTree.component;
                if (E)
                    return E.asyncDep && !E.asyncResolved ? E : locateNonHydratedAsyncRoot(E)
            }
            const ke = Symbol.for("v-fgt")
              , Oe = Symbol.for("v-txt")
              , Pe = Symbol.for("v-cmt")
              , Re = Symbol.for("v-stc")
              , Me = [];
            let Ne = null;
            function openBlock(v=!1) {
                Me.push(Ne = v ? null : [])
            }
            function closeBlock() {
                Me.pop(),
                Ne = Me[Me.length - 1] || null
            }
            let De = 1;
            function setBlockTracking(v) {
                De += v
            }
            function setupBlock(v) {
                return v.dynamicChildren = De > 0 ? Ne || U.Z6 : null,
                closeBlock(),
                De > 0 && Ne && Ne.push(v),
                v
            }
            function createElementBlock(v, E, k, R, U, H) {
                return setupBlock(createBaseVNode(v, E, k, R, U, H, !0))
            }
            function createBlock(v, E, k, R, U) {
                return setupBlock($e(v, E, k, R, U, !0))
            }
            function isVNode(v) {
                return !!v && !0 === v.__v_isVNode
            }
            function isSameVNodeType(v, E) {
                return v.type === E.type && v.key === E.key
            }
            const normalizeKey = ({"key": v}) => null != v ? v : null
              , normalizeRef = ({"ref": v, "ref_key": E, "ref_for": k}) => ("number" == typeof v && (v = "" + v),
            null != v ? (0,
            U.HD)(v) || (0,
            R.dq)(v) || (0,
            U.mf)(v) ? {
                "i": ee,
                "r": v,
                "k": E,
                "f": !!k
            } : v : null);
            function createBaseVNode(v, E=null, k=null, R=0, H=null, G=(v === ke ? 0 : 1), W=!1, Z=!1) {
                const Y = {
                    "__v_isVNode": !0,
                    "__v_skip": !0,
                    "type": v,
                    "props": E,
                    "key": E && normalizeKey(E),
                    "ref": E && normalizeRef(E),
                    "scopeId": te,
                    "slotScopeIds": null,
                    "children": k,
                    "component": null,
                    "suspense": null,
                    "ssContent": null,
                    "ssFallback": null,
                    "dirs": null,
                    "transition": null,
                    "el": null,
                    "anchor": null,
                    "target": null,
                    "targetAnchor": null,
                    "staticCount": 0,
                    "shapeFlag": G,
                    "patchFlag": R,
                    "dynamicProps": H,
                    "dynamicChildren": null,
                    "appContext": null,
                    "ctx": ee
                };
                return Z ? (normalizeChildren(Y, k),
                128 & G && v.normalize(Y)) : k && (Y.shapeFlag |= (0,
                U.HD)(k) ? 8 : 16),
                De > 0 && !W && Ne && (Y.patchFlag > 0 || 6 & G) && 32 !== Y.patchFlag && Ne.push(Y),
                Y
            }
            const $e = _createVNode;
            function _createVNode(v, E=null, k=null, H=0, G=null, W=!1) {
                if (v && v !== oe || (v = Pe),
                isVNode(v)) {
                    const R = cloneVNode(v, E, !0);
                    return k && normalizeChildren(R, k),
                    De > 0 && !W && Ne && (6 & R.shapeFlag ? Ne[Ne.indexOf(v)] = R : Ne.push(R)),
                    R.patchFlag |= -2,
                    R
                }
                if (isClassComponent(v) && (v = v.__vccOpts),
                E) {
                    E = function guardReactiveProps(v) {
                        return v ? (0,
                        R.X3)(v) || isInternalObject(v) ? (0,
                        U.l7)({}, v) : v : null
                    }(E);
                    let {"class": v, "style": k} = E;
                    v && !(0,
                    U.HD)(v) && (E.class = (0,
                    U.C_)(v)),
                    (0,
                    U.Kn)(k) && ((0,
                    R.X3)(k) && !(0,
                    U.kJ)(k) && (k = (0,
                    U.l7)({}, k)),
                    E.style = (0,
                    U.j5)(k))
                }
                return createBaseVNode(v, E, k, H, G, (0,
                U.HD)(v) ? 1 : isSuspense(v) ? 128 : (v => v.__isTeleport)(v) ? 64 : (0,
                U.Kn)(v) ? 4 : (0,
                U.mf)(v) ? 2 : 0, W, !0)
            }
            function cloneVNode(v, E, k=!1, R=!1) {
                const {"props": H, "ref": G, "patchFlag": W, "children": Z, "transition": Y} = v
                  , J = E ? function mergeProps(...v) {
                    const E = {};
                    for (let k = 0; k < v.length; k++) {
                        const R = v[k];
                        for (const v in R)
                            if ("class" === v)
                                E.class !== R.class && (E.class = (0,
                                U.C_)([E.class, R.class]));
                            else if ("style" === v)
                                E.style = (0,
                                U.j5)([E.style, R.style]);
                            else if ((0,
                            U.F7)(v)) {
                                const k = E[v]
                                  , H = R[v];
                                !H || k === H || (0,
                                U.kJ)(k) && k.includes(H) || (E[v] = k ? [].concat(k, H) : H)
                            } else
                                "" !== v && (E[v] = R[v])
                    }
                    return E
                }(H || {}, E) : H
                  , K = {
                    "__v_isVNode": !0,
                    "__v_skip": !0,
                    "type": v.type,
                    "props": J,
                    "key": J && normalizeKey(J),
                    "ref": E && E.ref ? k && G ? (0,
                    U.kJ)(G) ? G.concat(normalizeRef(E)) : [G, normalizeRef(E)] : normalizeRef(E) : G,
                    "scopeId": v.scopeId,
                    "slotScopeIds": v.slotScopeIds,
                    "children": Z,
                    "target": v.target,
                    "targetAnchor": v.targetAnchor,
                    "staticCount": v.staticCount,
                    "shapeFlag": v.shapeFlag,
                    "patchFlag": E && v.type !== ke ? -1 === W ? 16 : 16 | W : W,
                    "dynamicProps": v.dynamicProps,
                    "dynamicChildren": v.dynamicChildren,
                    "appContext": v.appContext,
                    "dirs": v.dirs,
                    "transition": Y,
                    "component": v.component,
                    "suspense": v.suspense,
                    "ssContent": v.ssContent && cloneVNode(v.ssContent),
                    "ssFallback": v.ssFallback && cloneVNode(v.ssFallback),
                    "el": v.el,
                    "anchor": v.anchor,
                    "ctx": v.ctx,
                    "ce": v.ce
                };
                return Y && R && (K.transition = Y.clone(K)),
                K
            }
            function createTextVNode(v=" ", E=0) {
                return $e(Oe, null, v, E)
            }
            function createStaticVNode(v, E) {
                const k = $e(Re, null, v);
                return k.staticCount = E,
                k
            }
            function createCommentVNode(v="", E=!1) {
                return E ? (openBlock(),
                createBlock(Pe, null, v)) : $e(Pe, null, v)
            }
            function normalizeVNode(v) {
                return null == v || "boolean" == typeof v ? $e(Pe) : (0,
                U.kJ)(v) ? $e(ke, null, v.slice()) : "object" == typeof v ? cloneIfMounted(v) : $e(Oe, null, String(v))
            }
            function cloneIfMounted(v) {
                return null === v.el && -1 !== v.patchFlag || v.memo ? v : cloneVNode(v)
            }
            function normalizeChildren(v, E) {
                let k = 0;
                const {"shapeFlag": R} = v;
                if (null == E)
                    E = null;
                else if ((0,
                U.kJ)(E))
                    k = 16;
                else if ("object" == typeof E) {
                    if (65 & R) {
                        const k = E.default;
                        return void (k && (k._c && (k._d = !1),
                        normalizeChildren(v, k()),
                        k._c && (k._d = !0)))
                    }
                    {
                        k = 32;
                        const R = E._;
                        R || isInternalObject(E) ? 3 === R && ee && (1 === ee.slots._ ? E._ = 1 : (E._ = 2,
                        v.patchFlag |= 1024)) : E._ctx = ee
                    }
                } else
                    (0,
                    U.mf)(E) ? (E = {
                        "default": E,
                        "_ctx": ee
                    },
                    k = 32) : (E = String(E),
                    64 & R ? (k = 16,
                    E = [createTextVNode(E)]) : k = 8);
                v.children = E,
                v.shapeFlag |= k
            }
            function invokeVNodeHook(v, E, k, R=null) {
                callWithAsyncErrorHandling(v, E, 7, [k, R])
            }
            const Le = createAppContext();
            let Fe = 0;
            function createComponentInstance(v, E, k) {
                const H = v.type
                  , G = (E ? E.appContext : v.appContext) || Le
                  , W = {
                    "uid": Fe++,
                    "vnode": v,
                    "type": H,
                    "parent": E,
                    "appContext": G,
                    "root": null,
                    "next": null,
                    "subTree": null,
                    "effect": null,
                    "update": null,
                    "scope": new R.Bj(!0),
                    "render": null,
                    "proxy": null,
                    "exposed": null,
                    "exposeProxy": null,
                    "withProxy": null,
                    "provides": E ? E.provides : Object.create(G.provides),
                    "accessCache": null,
                    "renderCache": [],
                    "components": null,
                    "directives": null,
                    "propsOptions": normalizePropsOptions(H, G),
                    "emitsOptions": normalizeEmitsOptions(H, G),
                    "emit": null,
                    "emitted": null,
                    "propsDefaults": U.kT,
                    "inheritAttrs": H.inheritAttrs,
                    "ctx": U.kT,
                    "data": U.kT,
                    "props": U.kT,
                    "attrs": U.kT,
                    "slots": U.kT,
                    "refs": U.kT,
                    "setupState": U.kT,
                    "setupContext": null,
                    "attrsProxy": null,
                    "slotsProxy": null,
                    "suspense": k,
                    "suspenseId": k ? k.pendingId : 0,
                    "asyncDep": null,
                    "asyncResolved": !1,
                    "isMounted": !1,
                    "isUnmounted": !1,
                    "isDeactivated": !1,
                    "bc": null,
                    "c": null,
                    "bm": null,
                    "m": null,
                    "bu": null,
                    "u": null,
                    "um": null,
                    "bum": null,
                    "da": null,
                    "a": null,
                    "rtg": null,
                    "rtc": null,
                    "ec": null,
                    "sp": null
                };
                return W.ctx = {
                    "_": W
                },
                W.root = E ? E.root : W,
                W.emit = emit.bind(null, W),
                v.ce && v.ce(W),
                W
            }
            let je = null;
            const getCurrentInstance = () => je || ee;
            let Be, Ue;
            {
                const v = (0,
                U.E9)()
                  , registerGlobalSetter = (E, k) => {
                    let R;
                    return (R = v[E]) || (R = v[E] = []),
                    R.push(k),
                    v => {
                        R.length > 1 ? R.forEach((E => E(v))) : R[0](v)
                    }
                }
                ;
                Be = registerGlobalSetter("__VUE_INSTANCE_SETTERS__", (v => je = v)),
                Ue = registerGlobalSetter("__VUE_SSR_SETTERS__", (v => qe = v))
            }
            const setCurrentInstance = v => {
                const E = je;
                return Be(v),
                v.scope.on(),
                () => {
                    v.scope.off(),
                    Be(E)
                }
            }
              , unsetCurrentInstance = () => {
                je && je.scope.off(),
                Be(null)
            }
            ;
            function isStatefulComponent(v) {
                return 4 & v.vnode.shapeFlag
            }
            let He, ze, qe = !1;
            function setupComponent(v, E=!1) {
                E && Ue(E);
                const {"props": k, "children": H} = v.vnode
                  , G = isStatefulComponent(v);
                !function initProps(v, E, k, U=!1) {
                    const H = {}
                      , G = createInternalObject();
                    v.propsDefaults = Object.create(null),
                    setFullProps(v, E, H, G);
                    for (const E in v.propsOptions[0])
                        E in H || (H[E] = void 0);
                    k ? v.props = U ? H : (0,
                    R.Um)(H) : v.type.props ? v.props = H : v.props = G,
                    v.attrs = G
                }(v, k, G, E),
                initSlots(v, H);
                const W = G ? function setupStatefulComponent(v, E) {
                    const k = v.type;
                    0;
                    v.accessCache = Object.create(null),
                    v.proxy = new Proxy(v.ctx,we),
                    !1;
                    const {"setup": H} = k;
                    if (H) {
                        const k = v.setupContext = H.length > 1 ? createSetupContext(v) : null
                          , G = setCurrentInstance(v);
                        (0,
                        R.Jd)();
                        const W = callWithErrorHandling(H, v, 0, [v.props, k]);
                        if ((0,
                        R.lk)(),
                        G(),
                        (0,
                        U.tI)(W)) {
                            if (W.then(unsetCurrentInstance, unsetCurrentInstance),
                            E)
                                return W.then((k => {
                                    handleSetupResult(v, k, E)
                                }
                                )).catch((E => {
                                    handleError(E, v, 0)
                                }
                                ));
                            v.asyncDep = W
                        } else
                            handleSetupResult(v, W, E)
                    } else
                        finishComponentSetup(v, E)
                }(v, E) : void 0;
                return E && Ue(!1),
                W
            }
            function handleSetupResult(v, E, k) {
                (0,
                U.mf)(E) ? v.type.__ssrInlineRender ? v.ssrRender = E : v.render = E : (0,
                U.Kn)(E) && (v.setupState = (0,
                R.WL)(E)),
                finishComponentSetup(v, k)
            }
            function finishComponentSetup(v, E, k) {
                const H = v.type;
                if (!v.render) {
                    if (!E && He && !H.render) {
                        const E = H.template || resolveMergedOptions(v).template;
                        if (E) {
                            0;
                            const {"isCustomElement": k, "compilerOptions": R} = v.appContext.config
                              , {"delimiters": G, "compilerOptions": W} = H
                              , Z = (0,
                            U.l7)((0,
                            U.l7)({
                                "isCustomElement": k,
                                "delimiters": G
                            }, R), W);
                            H.render = He(E, Z)
                        }
                    }
                    v.render = H.render || U.dG,
                    ze && ze(v)
                }
                {
                    const E = setCurrentInstance(v);
                    (0,
                    R.Jd)();
                    try {
                        applyOptions(v)
                    } finally {
                        (0,
                        R.lk)(),
                        E()
                    }
                }
            }
            const Ge = {
                "get"(v, E) {
                    return (0,
                    R.j)(v, "get", ""),
                    v[E]
                }
            };
            function createSetupContext(v) {
                const expose = E => {
                    v.exposed = E || {}
                }
                ;
                return {
                    "attrs": new Proxy(v.attrs,Ge),
                    "slots": v.slots,
                    "emit": v.emit,
                    "expose": expose
                }
            }
            function getExposeProxy(v) {
                if (v.exposed)
                    return v.exposeProxy || (v.exposeProxy = new Proxy((0,
                    R.WL)((0,
                    R.Xl)(v.exposed)),{
                        "get"(E, k) {
                            return k in E ? E[k] : k in Se ? Se[k](v) : void 0
                        },
                        "has"(v, E) {
                            return E in v || E in Se
                        }
                    }))
            }
            function getComponentName(v, E=!0) {
                return (0,
                U.mf)(v) ? v.displayName || v.name : v.name || E && v.__name
            }
            function isClassComponent(v) {
                return (0,
                U.mf)(v) && "__vccOpts"in v
            }
            const computed = (v, E) => (0,
            R.Fl)(v, E, qe);
            function h(v, E, k) {
                const R = arguments.length;
                return 2 === R ? (0,
                U.Kn)(E) && !(0,
                U.kJ)(E) ? isVNode(E) ? $e(v, null, [E]) : $e(v, E) : $e(v, null, E) : (R > 3 ? k = Array.prototype.slice.call(arguments, 2) : 3 === R && isVNode(k) && (k = [k]),
                $e(v, E, k))
            }
            const Ve = "3.4.27"
        },
        "2610": function(v, E, k) {
            "use strict";
            k.d(E, {
                "B": function() {
                    return effectScope
                },
                "Bj": function() {
                    return EffectScope
                },
                "Fl": function() {
                    return computed
                },
                "IU": function() {
                    return toRaw
                },
                "Jd": function() {
                    return pauseTracking
                },
                "PG": function() {
                    return isReactive
                },
                "Um": function() {
                    return shallowReactive
                },
                "WL": function() {
                    return proxyRefs
                },
                "X$": function() {
                    return trigger
                },
                "X3": function() {
                    return isProxy
                },
                "Xl": function() {
                    return markRaw
                },
                "dq": function() {
                    return isRef
                },
                "iH": function() {
                    return ref
                },
                "j": function() {
                    return track
                },
                "lk": function() {
                    return resetTracking
                },
                "nZ": function() {
                    return getCurrentScope
                },
                "qj": function() {
                    return reactive
                },
                "qq": function() {
                    return ReactiveEffect
                },
                "yT": function() {
                    return isShallow
                }
            });
            var R = k(3577);
            let U, H;
            class EffectScope {
                "constructor"(v=!1) {
                    this.detached = v,
                    this._active = !0,
                    this.effects = [],
                    this.cleanups = [],
                    this.parent = U,
                    !v && U && (this.index = (U.scopes || (U.scopes = [])).push(this) - 1)
                }
                get "active"() {
                    return this._active
                }
                "run"(v) {
                    if (this._active) {
                        const E = U;
                        try {
                            return U = this,
                            v()
                        } finally {
                            U = E
                        }
                    } else
                        0
                }
                "on"() {
                    U = this
                }
                "off"() {
                    U = this.parent
                }
                "stop"(v) {
                    if (this._active) {
                        let E, k;
                        for (E = 0,
                        k = this.effects.length; E < k; E++)
                            this.effects[E].stop();
                        for (E = 0,
                        k = this.cleanups.length; E < k; E++)
                            this.cleanups[E]();
                        if (this.scopes)
                            for (E = 0,
                            k = this.scopes.length; E < k; E++)
                                this.scopes[E].stop(!0);
                        if (!this.detached && this.parent && !v) {
                            const v = this.parent.scopes.pop();
                            v && v !== this && (this.parent.scopes[this.index] = v,
                            v.index = this.index)
                        }
                        this.parent = void 0,
                        this._active = !1
                    }
                }
            }
            function effectScope(v) {
                return new EffectScope(v)
            }
            function recordEffectScope(v, E=U) {
                E && E.active && E.effects.push(v)
            }
            function getCurrentScope() {
                return U
            }
            class ReactiveEffect {
                "constructor"(v, E, k, R) {
                    this.fn = v,
                    this.trigger = E,
                    this.scheduler = k,
                    this.active = !0,
                    this.deps = [],
                    this._dirtyLevel = 4,
                    this._trackId = 0,
                    this._runnings = 0,
                    this._shouldSchedule = !1,
                    this._depsLength = 0,
                    recordEffectScope(this, R)
                }
                get "dirty"() {
                    if (2 === this._dirtyLevel || 3 === this._dirtyLevel) {
                        this._dirtyLevel = 1,
                        pauseTracking();
                        for (let v = 0; v < this._depsLength; v++) {
                            const E = this.deps[v];
                            if (E.computed && (triggerComputed(E.computed),
                            this._dirtyLevel >= 4))
                                break
                        }
                        1 === this._dirtyLevel && (this._dirtyLevel = 0),
                        resetTracking()
                    }
                    return this._dirtyLevel >= 4
                }
                set "dirty"(v) {
                    this._dirtyLevel = v ? 4 : 0
                }
                "run"() {
                    if (this._dirtyLevel = 0,
                    !this.active)
                        return this.fn();
                    let v = G
                      , E = H;
                    try {
                        return G = !0,
                        H = this,
                        this._runnings++,
                        preCleanupEffect(this),
                        this.fn()
                    } finally {
                        postCleanupEffect(this),
                        this._runnings--,
                        H = E,
                        G = v
                    }
                }
                "stop"() {
                    this.active && (preCleanupEffect(this),
                    postCleanupEffect(this),
                    this.onStop && this.onStop(),
                    this.active = !1)
                }
            }
            function triggerComputed(v) {
                return v.value
            }
            function preCleanupEffect(v) {
                v._trackId++,
                v._depsLength = 0
            }
            function postCleanupEffect(v) {
                if (v.deps.length > v._depsLength) {
                    for (let E = v._depsLength; E < v.deps.length; E++)
                        cleanupDepEffect(v.deps[E], v);
                    v.deps.length = v._depsLength
                }
            }
            function cleanupDepEffect(v, E) {
                const k = v.get(E);
                void 0 !== k && E._trackId !== k && (v.delete(E),
                0 === v.size && v.cleanup())
            }
            let G = !0
              , W = 0;
            const Z = [];
            function pauseTracking() {
                Z.push(G),
                G = !1
            }
            function resetTracking() {
                const v = Z.pop();
                G = void 0 === v || v
            }
            function pauseScheduling() {
                W++
            }
            function resetScheduling() {
                for (W--; !W && Y.length; )
                    Y.shift()()
            }
            function trackEffect(v, E, k) {
                if (E.get(v) !== v._trackId) {
                    E.set(v, v._trackId);
                    const k = v.deps[v._depsLength];
                    k !== E ? (k && cleanupDepEffect(k, v),
                    v.deps[v._depsLength++] = E) : v._depsLength++
                }
            }
            const Y = [];
            function triggerEffects(v, E, k) {
                pauseScheduling();
                for (const k of v.keys()) {
                    let R;
                    k._dirtyLevel < E && (null != R ? R : R = v.get(k) === k._trackId) && (k._shouldSchedule || (k._shouldSchedule = 0 === k._dirtyLevel),
                    k._dirtyLevel = E),
                    k._shouldSchedule && (null != R ? R : R = v.get(k) === k._trackId) && (k.trigger(),
                    k._runnings && !k.allowRecurse || 2 === k._dirtyLevel || (k._shouldSchedule = !1,
                    k.scheduler && Y.push(k.scheduler)))
                }
                resetScheduling()
            }
            const createDep = (v, E) => {
                const k = new Map;
                return k.cleanup = v,
                k.computed = E,
                k
            }
              , J = new WeakMap
              , K = Symbol("")
              , X = Symbol("");
            function track(v, E, k) {
                if (G && H) {
                    let E = J.get(v);
                    E || J.set(v, E = new Map);
                    let R = E.get(k);
                    R || E.set(k, R = createDep(( () => E.delete(k)))),
                    trackEffect(H, R)
                }
            }
            function trigger(v, E, k, U, H, G) {
                const W = J.get(v);
                if (!W)
                    return;
                let Z = [];
                if ("clear" === E)
                    Z = [...W.values()];
                else if ("length" === k && (0,
                R.kJ)(v)) {
                    const v = Number(U);
                    W.forEach(( (E, k) => {
                        ("length" === k || !(0,
                        R.yk)(k) && k >= v) && Z.push(E)
                    }
                    ))
                } else
                    switch (void 0 !== k && Z.push(W.get(k)),
                    E) {
                    case "add":
                        (0,
                        R.kJ)(v) ? (0,
                        R.S0)(k) && Z.push(W.get("length")) : (Z.push(W.get(K)),
                        (0,
                        R._N)(v) && Z.push(W.get(X)));
                        break;
                    case "delete":
                        (0,
                        R.kJ)(v) || (Z.push(W.get(K)),
                        (0,
                        R._N)(v) && Z.push(W.get(X)));
                        break;
                    case "set":
                        (0,
                        R._N)(v) && Z.push(W.get(K))
                    }
                pauseScheduling();
                for (const v of Z)
                    v && triggerEffects(v, 4);
                resetScheduling()
            }
            const Q = (0,
            R.fY)("__proto__,__v_isRef,__isVue")
              , ee = new Set(Object.getOwnPropertyNames(Symbol).filter((v => "arguments" !== v && "caller" !== v)).map((v => Symbol[v])).filter(R.yk))
              , te = createArrayInstrumentations();
            function createArrayInstrumentations() {
                const v = {};
                return ["includes", "indexOf", "lastIndexOf"].forEach((E => {
                    v[E] = function(...v) {
                        const k = toRaw(this);
                        for (let v = 0, E = this.length; v < E; v++)
                            track(k, 0, v + "");
                        const R = k[E](...v);
                        return -1 === R || !1 === R ? k[E](...v.map(toRaw)) : R
                    }
                }
                )),
                ["push", "pop", "shift", "unshift", "splice"].forEach((E => {
                    v[E] = function(...v) {
                        pauseTracking(),
                        pauseScheduling();
                        const k = toRaw(this)[E].apply(this, v);
                        return resetScheduling(),
                        resetTracking(),
                        k
                    }
                }
                )),
                v
            }
            function hasOwnProperty(v) {
                (0,
                R.yk)(v) || (v = String(v));
                const E = toRaw(this);
                return track(E, 0, v),
                E.hasOwnProperty(v)
            }
            class BaseReactiveHandler {
                "constructor"(v=!1, E=!1) {
                    this._isReadonly = v,
                    this._isShallow = E
                }
                "get"(v, E, k) {
                    const U = this._isReadonly
                      , H = this._isShallow;
                    if ("__v_isReactive" === E)
                        return !U;
                    if ("__v_isReadonly" === E)
                        return U;
                    if ("__v_isShallow" === E)
                        return H;
                    if ("__v_raw" === E)
                        return k === (U ? H ? me : he : H ? fe : pe).get(v) || Object.getPrototypeOf(v) === Object.getPrototypeOf(k) ? v : void 0;
                    const G = (0,
                    R.kJ)(v);
                    if (!U) {
                        if (G && (0,
                        R.RI)(te, E))
                            return Reflect.get(te, E, k);
                        if ("hasOwnProperty" === E)
                            return hasOwnProperty
                    }
                    const W = Reflect.get(v, E, k);
                    return ((0,
                    R.yk)(E) ? ee.has(E) : Q(E)) ? W : (U || track(v, 0, E),
                    H ? W : isRef(W) ? G && (0,
                    R.S0)(E) ? W : W.value : (0,
                    R.Kn)(W) ? U ? readonly(W) : reactive(W) : W)
                }
            }
            class MutableReactiveHandler extends BaseReactiveHandler {
                "constructor"(v=!1) {
                    super(!1, v)
                }
                "set"(v, E, k, U) {
                    let H = v[E];
                    if (!this._isShallow) {
                        const E = isReadonly(H);
                        if (isShallow(k) || isReadonly(k) || (H = toRaw(H),
                        k = toRaw(k)),
                        !(0,
                        R.kJ)(v) && isRef(H) && !isRef(k))
                            return !E && (H.value = k,
                            !0)
                    }
                    const G = (0,
                    R.kJ)(v) && (0,
                    R.S0)(E) ? Number(E) < v.length : (0,
                    R.RI)(v, E)
                      , W = Reflect.set(v, E, k, U);
                    return v === toRaw(U) && (G ? (0,
                    R.aU)(k, H) && trigger(v, "set", E, k) : trigger(v, "add", E, k)),
                    W
                }
                "deleteProperty"(v, E) {
                    const k = (0,
                    R.RI)(v, E)
                      , U = (v[E],
                    Reflect.deleteProperty(v, E));
                    return U && k && trigger(v, "delete", E, void 0),
                    U
                }
                "has"(v, E) {
                    const k = Reflect.has(v, E);
                    return (0,
                    R.yk)(E) && ee.has(E) || track(v, 0, E),
                    k
                }
                "ownKeys"(v) {
                    return track(v, 0, (0,
                    R.kJ)(v) ? "length" : K),
                    Reflect.ownKeys(v)
                }
            }
            class ReadonlyReactiveHandler extends BaseReactiveHandler {
                "constructor"(v=!1) {
                    super(!0, v)
                }
                "set"(v, E) {
                    return !0
                }
                "deleteProperty"(v, E) {
                    return !0
                }
            }
            const ne = new MutableReactiveHandler
              , re = new ReadonlyReactiveHandler
              , oe = new MutableReactiveHandler(!0)
              , toShallow = v => v
              , getProto = v => Reflect.getPrototypeOf(v);
            function get(v, E, k=!1, U=!1) {
                const H = toRaw(v = v.__v_raw)
                  , G = toRaw(E);
                k || ((0,
                R.aU)(E, G) && track(H, 0, E),
                track(H, 0, G));
                const {"has": W} = getProto(H)
                  , Z = U ? toShallow : k ? toReadonly : toReactive;
                return W.call(H, E) ? Z(v.get(E)) : W.call(H, G) ? Z(v.get(G)) : void (v !== H && v.get(E))
            }
            function has(v, E=!1) {
                const k = this.__v_raw
                  , U = toRaw(k)
                  , H = toRaw(v);
                return E || ((0,
                R.aU)(v, H) && track(U, 0, v),
                track(U, 0, H)),
                v === H ? k.has(v) : k.has(v) || k.has(H)
            }
            function size(v, E=!1) {
                return v = v.__v_raw,
                !E && track(toRaw(v), 0, K),
                Reflect.get(v, "size", v)
            }
            function add(v) {
                v = toRaw(v);
                const E = toRaw(this);
                return getProto(E).has.call(E, v) || (E.add(v),
                trigger(E, "add", v, v)),
                this
            }
            function set(v, E) {
                E = toRaw(E);
                const k = toRaw(this)
                  , {"has": U, "get": H} = getProto(k);
                let G = U.call(k, v);
                G || (v = toRaw(v),
                G = U.call(k, v));
                const W = H.call(k, v);
                return k.set(v, E),
                G ? (0,
                R.aU)(E, W) && trigger(k, "set", v, E) : trigger(k, "add", v, E),
                this
            }
            function deleteEntry(v) {
                const E = toRaw(this)
                  , {"has": k, "get": R} = getProto(E);
                let U = k.call(E, v);
                U || (v = toRaw(v),
                U = k.call(E, v));
                R && R.call(E, v);
                const H = E.delete(v);
                return U && trigger(E, "delete", v, void 0),
                H
            }
            function clear() {
                const v = toRaw(this)
                  , E = 0 !== v.size
                  , k = v.clear();
                return E && trigger(v, "clear", void 0, void 0),
                k
            }
            function createForEach(v, E) {
                return function forEach(k, R) {
                    const U = this
                      , H = U.__v_raw
                      , G = toRaw(H)
                      , W = E ? toShallow : v ? toReadonly : toReactive;
                    return !v && track(G, 0, K),
                    H.forEach(( (v, E) => k.call(R, W(v), W(E), U)))
                }
            }
            function createIterableMethod(v, E, k) {
                return function(...U) {
                    const H = this.__v_raw
                      , G = toRaw(H)
                      , W = (0,
                    R._N)(G)
                      , Z = "entries" === v || v === Symbol.iterator && W
                      , Y = "keys" === v && W
                      , J = H[v](...U)
                      , Q = k ? toShallow : E ? toReadonly : toReactive;
                    return !E && track(G, 0, Y ? X : K),
                    {
                        "next"() {
                            const {"value": v, "done": E} = J.next();
                            return E ? {
                                "value": v,
                                "done": E
                            } : {
                                "value": Z ? [Q(v[0]), Q(v[1])] : Q(v),
                                "done": E
                            }
                        },
                        [Symbol.iterator]() {
                            return this
                        }
                    }
                }
            }
            function createReadonlyMethod(v) {
                return function(...E) {
                    return "delete" !== v && ("clear" === v ? void 0 : this)
                }
            }
            function createInstrumentations() {
                const v = {
                    "get"(v) {
                        return get(this, v)
                    },
                    get "size"() {
                        return size(this)
                    },
                    "has": has,
                    "add": add,
                    "set": set,
                    "delete": deleteEntry,
                    "clear": clear,
                    "forEach": createForEach(!1, !1)
                }
                  , E = {
                    "get"(v) {
                        return get(this, v, !1, !0)
                    },
                    get "size"() {
                        return size(this)
                    },
                    "has": has,
                    "add": add,
                    "set": set,
                    "delete": deleteEntry,
                    "clear": clear,
                    "forEach": createForEach(!1, !0)
                }
                  , k = {
                    "get"(v) {
                        return get(this, v, !0)
                    },
                    get "size"() {
                        return size(this, !0)
                    },
                    "has"(v) {
                        return has.call(this, v, !0)
                    },
                    "add": createReadonlyMethod("add"),
                    "set": createReadonlyMethod("set"),
                    "delete": createReadonlyMethod("delete"),
                    "clear": createReadonlyMethod("clear"),
                    "forEach": createForEach(!0, !1)
                }
                  , R = {
                    "get"(v) {
                        return get(this, v, !0, !0)
                    },
                    get "size"() {
                        return size(this, !0)
                    },
                    "has"(v) {
                        return has.call(this, v, !0)
                    },
                    "add": createReadonlyMethod("add"),
                    "set": createReadonlyMethod("set"),
                    "delete": createReadonlyMethod("delete"),
                    "clear": createReadonlyMethod("clear"),
                    "forEach": createForEach(!0, !0)
                };
                return ["keys", "values", "entries", Symbol.iterator].forEach((U => {
                    v[U] = createIterableMethod(U, !1, !1),
                    k[U] = createIterableMethod(U, !0, !1),
                    E[U] = createIterableMethod(U, !1, !0),
                    R[U] = createIterableMethod(U, !0, !0)
                }
                )),
                [v, k, E, R]
            }
            const [ie,ae,se,ce] = createInstrumentations();
            function createInstrumentationGetter(v, E) {
                const k = E ? v ? ce : se : v ? ae : ie;
                return (E, U, H) => "__v_isReactive" === U ? !v : "__v_isReadonly" === U ? v : "__v_raw" === U ? E : Reflect.get((0,
                R.RI)(k, U) && U in E ? k : E, U, H)
            }
            const le = {
                "get": createInstrumentationGetter(!1, !1)
            }
              , ue = {
                "get": createInstrumentationGetter(!1, !0)
            }
              , de = {
                "get": createInstrumentationGetter(!0, !1)
            };
            const pe = new WeakMap
              , fe = new WeakMap
              , he = new WeakMap
              , me = new WeakMap;
            function reactive(v) {
                return isReadonly(v) ? v : createReactiveObject(v, !1, ne, le, pe)
            }
            function shallowReactive(v) {
                return createReactiveObject(v, !1, oe, ue, fe)
            }
            function readonly(v) {
                return createReactiveObject(v, !0, re, de, he)
            }
            function createReactiveObject(v, E, k, U, H) {
                if (!(0,
                R.Kn)(v))
                    return v;
                if (v.__v_raw && (!E || !v.__v_isReactive))
                    return v;
                const G = H.get(v);
                if (G)
                    return G;
                const W = function getTargetType(v) {
                    return v.__v_skip || !Object.isExtensible(v) ? 0 : function targetTypeMap(v) {
                        switch (v) {
                        case "Object":
                        case "Array":
                            return 1;
                        case "Map":
                        case "Set":
                        case "WeakMap":
                        case "WeakSet":
                            return 2;
                        default:
                            return 0
                        }
                    }((0,
                    R.W7)(v))
                }(v);
                if (0 === W)
                    return v;
                const Z = new Proxy(v,2 === W ? U : k);
                return H.set(v, Z),
                Z
            }
            function isReactive(v) {
                return isReadonly(v) ? isReactive(v.__v_raw) : !(!v || !v.__v_isReactive)
            }
            function isReadonly(v) {
                return !(!v || !v.__v_isReadonly)
            }
            function isShallow(v) {
                return !(!v || !v.__v_isShallow)
            }
            function isProxy(v) {
                return !!v && !!v.__v_raw
            }
            function toRaw(v) {
                const E = v && v.__v_raw;
                return E ? toRaw(E) : v
            }
            function markRaw(v) {
                return Object.isExtensible(v) && (0,
                R.Nj)(v, "__v_skip", !0),
                v
            }
            const toReactive = v => (0,
            R.Kn)(v) ? reactive(v) : v
              , toReadonly = v => (0,
            R.Kn)(v) ? readonly(v) : v;
            class ComputedRefImpl {
                "constructor"(v, E, k, R) {
                    this.getter = v,
                    this._setter = E,
                    this.dep = void 0,
                    this.__v_isRef = !0,
                    this.__v_isReadonly = !1,
                    this.effect = new ReactiveEffect(( () => v(this._value)),( () => triggerRefValue(this, 2 === this.effect._dirtyLevel ? 2 : 3))),
                    this.effect.computed = this,
                    this.effect.active = this._cacheable = !R,
                    this.__v_isReadonly = k
                }
                get "value"() {
                    const v = toRaw(this);
                    return v._cacheable && !v.effect.dirty || !(0,
                    R.aU)(v._value, v._value = v.effect.run()) || triggerRefValue(v, 4),
                    trackRefValue(v),
                    v.effect._dirtyLevel >= 2 && triggerRefValue(v, 2),
                    v._value
                }
                set "value"(v) {
                    this._setter(v)
                }
                get "_dirty"() {
                    return this.effect.dirty
                }
                set "_dirty"(v) {
                    this.effect.dirty = v
                }
            }
            function computed(v, E, k=!1) {
                let U, H;
                const G = (0,
                R.mf)(v);
                G ? (U = v,
                H = R.dG) : (U = v.get,
                H = v.set);
                return new ComputedRefImpl(U,H,G || !H,k)
            }
            function trackRefValue(v) {
                var E;
                G && H && (v = toRaw(v),
                trackEffect(H, null != (E = v.dep) ? E : v.dep = createDep(( () => v.dep = void 0), v instanceof ComputedRefImpl ? v : void 0)))
            }
            function triggerRefValue(v, E=4, k) {
                const R = (v = toRaw(v)).dep;
                R && triggerEffects(R, E)
            }
            function isRef(v) {
                return !(!v || !0 !== v.__v_isRef)
            }
            function ref(v) {
                return createRef(v, !1)
            }
            function createRef(v, E) {
                return isRef(v) ? v : new RefImpl(v,E)
            }
            class RefImpl {
                "constructor"(v, E) {
                    this.__v_isShallow = E,
                    this.dep = void 0,
                    this.__v_isRef = !0,
                    this._rawValue = E ? v : toRaw(v),
                    this._value = E ? v : toReactive(v)
                }
                get "value"() {
                    return trackRefValue(this),
                    this._value
                }
                set "value"(v) {
                    const E = this.__v_isShallow || isShallow(v) || isReadonly(v);
                    v = E ? v : toRaw(v),
                    (0,
                    R.aU)(v, this._rawValue) && (this._rawValue = v,
                    this._value = E ? v : toReactive(v),
                    triggerRefValue(this, 4))
                }
            }
            function unref(v) {
                return isRef(v) ? v.value : v
            }
            const ge = {
                "get": (v, E, k) => unref(Reflect.get(v, E, k)),
                "set": (v, E, k, R) => {
                    const U = v[E];
                    return isRef(U) && !isRef(k) ? (U.value = k,
                    !0) : Reflect.set(v, E, k, R)
                }
            };
            function proxyRefs(v) {
                return isReactive(v) ? v : new Proxy(v,ge)
            }
        },
        "9963": function(v, E, k) {
            "use strict";
            k.d(E, {
                "F8": function() {
                    return ne
                },
                "iM": function() {
                    return withModifiers
                },
                "ri": function() {
                    return createApp
                },
                "uT": function() {
                    return Transition
                }
            });
            var R = k(6252)
              , U = k(3577);
            k(2610);
            const H = "undefined" != typeof document ? document : null
              , G = H && H.createElement("template")
              , W = {
                "insert": (v, E, k) => {
                    E.insertBefore(v, k || null)
                }
                ,
                "remove": v => {
                    const E = v.parentNode;
                    E && E.removeChild(v)
                }
                ,
                "createElement": (v, E, k, R) => {
                    const U = "svg" === E ? H.createElementNS("http://www.w3.org/2000/svg", v) : "mathml" === E ? H.createElementNS("http://www.w3.org/1998/Math/MathML", v) : H.createElement(v, k ? {
                        "is": k
                    } : void 0);
                    return "select" === v && R && null != R.multiple && U.setAttribute("multiple", R.multiple),
                    U
                }
                ,
                "createText": v => H.createTextNode(v),
                "createComment": v => H.createComment(v),
                "setText": (v, E) => {
                    v.nodeValue = E
                }
                ,
                "setElementText": (v, E) => {
                    v.textContent = E
                }
                ,
                "parentNode": v => v.parentNode,
                "nextSibling": v => v.nextSibling,
                "querySelector": v => H.querySelector(v),
                "setScopeId"(v, E) {
                    v.setAttribute(E, "")
                },
                "insertStaticContent"(v, E, k, R, U, H) {
                    const W = k ? k.previousSibling : E.lastChild;
                    if (U && (U === H || U.nextSibling))
                        for (; E.insertBefore(U.cloneNode(!0), k),
                        U !== H && (U = U.nextSibling); )
                            ;
                    else {
                        G.innerHTML = "svg" === R ? `<svg>${v}</svg>` : "mathml" === R ? `<math>${v}</math>` : v;
                        const U = G.content;
                        if ("svg" === R || "mathml" === R) {
                            const v = U.firstChild;
                            for (; v.firstChild; )
                                U.appendChild(v.firstChild);
                            U.removeChild(v)
                        }
                        E.insertBefore(U, k)
                    }
                    return [W ? W.nextSibling : E.firstChild, k ? k.previousSibling : E.lastChild]
                }
            }
              , Z = "transition"
              , Y = "animation"
              , J = Symbol("_vtc")
              , Transition = (v, {"slots": E}) => (0,
            R.h)(R.P$, resolveTransitionProps(v), E);
            Transition.displayName = "Transition";
            const K = {
                "name": String,
                "type": String,
                "css": {
                    "type": Boolean,
                    "default": !0
                },
                "duration": [String, Number, Object],
                "enterFromClass": String,
                "enterActiveClass": String,
                "enterToClass": String,
                "appearFromClass": String,
                "appearActiveClass": String,
                "appearToClass": String,
                "leaveFromClass": String,
                "leaveActiveClass": String,
                "leaveToClass": String
            }
              , X = (Transition.props = (0,
            U.l7)({}, R.nJ, K),
            (v, E=[]) => {
                (0,
                U.kJ)(v) ? v.forEach((v => v(...E))) : v && v(...E)
            }
            )
              , hasExplicitCallback = v => !!v && ((0,
            U.kJ)(v) ? v.some((v => v.length > 1)) : v.length > 1);
            function resolveTransitionProps(v) {
                const E = {};
                for (const k in v)
                    k in K || (E[k] = v[k]);
                if (!1 === v.css)
                    return E;
                const {"name": k="v", "type": R, "duration": H, "enterFromClass": G=`${k}-enter-from`, "enterActiveClass": W=`${k}-enter-active`, "enterToClass": Z=`${k}-enter-to`, "appearFromClass": Y=G, "appearActiveClass": J=W, "appearToClass": Q=Z, "leaveFromClass": ee=`${k}-leave-from`, "leaveActiveClass": te=`${k}-leave-active`, "leaveToClass": ne=`${k}-leave-to`} = v
                  , re = function normalizeDuration(v) {
                    if (null == v)
                        return null;
                    if ((0,
                    U.Kn)(v))
                        return [NumberOf(v.enter), NumberOf(v.leave)];
                    {
                        const E = NumberOf(v);
                        return [E, E]
                    }
                }(H)
                  , oe = re && re[0]
                  , ie = re && re[1]
                  , {"onBeforeEnter": ae, "onEnter": se, "onEnterCancelled": ce, "onLeave": le, "onLeaveCancelled": ue, "onBeforeAppear": de=ae, "onAppear": pe=se, "onAppearCancelled": fe=ce} = E
                  , finishEnter = (v, E, k) => {
                    removeTransitionClass(v, E ? Q : Z),
                    removeTransitionClass(v, E ? J : W),
                    k && k()
                }
                  , finishLeave = (v, E) => {
                    v._isLeaving = !1,
                    removeTransitionClass(v, ee),
                    removeTransitionClass(v, ne),
                    removeTransitionClass(v, te),
                    E && E()
                }
                  , makeEnterHook = v => (E, k) => {
                    const U = v ? pe : se
                      , resolve = () => finishEnter(E, v, k);
                    X(U, [E, resolve]),
                    nextFrame(( () => {
                        removeTransitionClass(E, v ? Y : G),
                        addTransitionClass(E, v ? Q : Z),
                        hasExplicitCallback(U) || whenTransitionEnds(E, R, oe, resolve)
                    }
                    ))
                }
                ;
                return (0,
                U.l7)(E, {
                    "onBeforeEnter"(v) {
                        X(ae, [v]),
                        addTransitionClass(v, G),
                        addTransitionClass(v, W)
                    },
                    "onBeforeAppear"(v) {
                        X(de, [v]),
                        addTransitionClass(v, Y),
                        addTransitionClass(v, J)
                    },
                    "onEnter": makeEnterHook(!1),
                    "onAppear": makeEnterHook(!0),
                    "onLeave"(v, E) {
                        v._isLeaving = !0;
                        const resolve = () => finishLeave(v, E);
                        addTransitionClass(v, ee),
                        addTransitionClass(v, te),
                        forceReflow(),
                        nextFrame(( () => {
                            v._isLeaving && (removeTransitionClass(v, ee),
                            addTransitionClass(v, ne),
                            hasExplicitCallback(le) || whenTransitionEnds(v, R, ie, resolve))
                        }
                        )),
                        X(le, [v, resolve])
                    },
                    "onEnterCancelled"(v) {
                        finishEnter(v, !1),
                        X(ce, [v])
                    },
                    "onAppearCancelled"(v) {
                        finishEnter(v, !0),
                        X(fe, [v])
                    },
                    "onLeaveCancelled"(v) {
                        finishLeave(v),
                        X(ue, [v])
                    }
                })
            }
            function NumberOf(v) {
                return (0,
                U.He)(v)
            }
            function addTransitionClass(v, E) {
                E.split(/\s+/).forEach((E => E && v.classList.add(E))),
                (v[J] || (v[J] = new Set)).add(E)
            }
            function removeTransitionClass(v, E) {
                E.split(/\s+/).forEach((E => E && v.classList.remove(E)));
                const k = v[J];
                k && (k.delete(E),
                k.size || (v[J] = void 0))
            }
            function nextFrame(v) {
                requestAnimationFrame(( () => {
                    requestAnimationFrame(v)
                }
                ))
            }
            let Q = 0;
            function whenTransitionEnds(v, E, k, R) {
                const U = v._endId = ++Q
                  , resolveIfNotStale = () => {
                    U === v._endId && R()
                }
                ;
                if (k)
                    return setTimeout(resolveIfNotStale, k);
                const {"type": H, "timeout": G, "propCount": W} = getTransitionInfo(v, E);
                if (!H)
                    return R();
                const Z = H + "end";
                let Y = 0;
                const end = () => {
                    v.removeEventListener(Z, onEnd),
                    resolveIfNotStale()
                }
                  , onEnd = E => {
                    E.target === v && ++Y >= W && end()
                }
                ;
                setTimeout(( () => {
                    Y < W && end()
                }
                ), G + 1),
                v.addEventListener(Z, onEnd)
            }
            function getTransitionInfo(v, E) {
                const k = window.getComputedStyle(v)
                  , getStyleProperties = v => (k[v] || "").split(", ")
                  , R = getStyleProperties(`${Z}Delay`)
                  , U = getStyleProperties(`${Z}Duration`)
                  , H = getTimeout(R, U)
                  , G = getStyleProperties(`${Y}Delay`)
                  , W = getStyleProperties(`${Y}Duration`)
                  , J = getTimeout(G, W);
                let K = null
                  , X = 0
                  , Q = 0;
                E === Z ? H > 0 && (K = Z,
                X = H,
                Q = U.length) : E === Y ? J > 0 && (K = Y,
                X = J,
                Q = W.length) : (X = Math.max(H, J),
                K = X > 0 ? H > J ? Z : Y : null,
                Q = K ? K === Z ? U.length : W.length : 0);
                return {
                    "type": K,
                    "timeout": X,
                    "propCount": Q,
                    "hasTransform": K === Z && /\b(transform|all)(,|$)/.test(getStyleProperties(`${Z}Property`).toString())
                }
            }
            function getTimeout(v, E) {
                for (; v.length < E.length; )
                    v = v.concat(v);
                return Math.max(...E.map(( (E, k) => toMs(E) + toMs(v[k]))))
            }
            function toMs(v) {
                return "auto" === v ? 0 : 1e3 * Number(v.slice(0, -1).replace(",", "."))
            }
            function forceReflow() {
                return document.body.offsetHeight
            }
            const ee = Symbol("_vod")
              , te = Symbol("_vsh")
              , ne = {
                "beforeMount"(v, {"value": E}, {"transition": k}) {
                    v[ee] = "none" === v.style.display ? "" : v.style.display,
                    k && E ? k.beforeEnter(v) : setDisplay(v, E)
                },
                "mounted"(v, {"value": E}, {"transition": k}) {
                    k && E && k.enter(v)
                },
                "updated"(v, {"value": E, "oldValue": k}, {"transition": R}) {
                    !E != !k && (R ? E ? (R.beforeEnter(v),
                    setDisplay(v, !0),
                    R.enter(v)) : R.leave(v, ( () => {
                        setDisplay(v, !1)
                    }
                    )) : setDisplay(v, E))
                },
                "beforeUnmount"(v, {"value": E}) {
                    setDisplay(v, E)
                }
            };
            function setDisplay(v, E) {
                v.style.display = E ? v[ee] : "none",
                v[te] = !E
            }
            const re = Symbol("");
            const oe = /(^|;)\s*display\s*:/;
            const ie = /\s*!important$/;
            function setStyle(v, E, k) {
                if ((0,
                U.kJ)(k))
                    k.forEach((k => setStyle(v, E, k)));
                else if (null == k && (k = ""),
                E.startsWith("--"))
                    v.setProperty(E, k);
                else {
                    const R = function autoPrefix(v, E) {
                        const k = se[E];
                        if (k)
                            return k;
                        let R = (0,
                        U._A)(E);
                        if ("filter" !== R && R in v)
                            return se[E] = R;
                        R = (0,
                        U.kC)(R);
                        for (let k = 0; k < ae.length; k++) {
                            const U = ae[k] + R;
                            if (U in v)
                                return se[E] = U
                        }
                        return E
                    }(v, E);
                    ie.test(k) ? v.setProperty((0,
                    U.rs)(R), k.replace(ie, ""), "important") : v[R] = k
                }
            }
            const ae = ["Webkit", "Moz", "ms"]
              , se = {};
            const ce = "http://www.w3.org/1999/xlink";
            function addEventListener(v, E, k, R) {
                v.addEventListener(E, k, R)
            }
            const le = Symbol("_vei");
            function patchEvent(v, E, k, H, G=null) {
                const W = v[le] || (v[le] = {})
                  , Z = W[E];
                if (H && Z)
                    Z.value = H;
                else {
                    const [k,Y] = function parseName(v) {
                        let E;
                        if (ue.test(v)) {
                            let k;
                            for (E = {}; k = v.match(ue); )
                                v = v.slice(0, v.length - k[0].length),
                                E[k[0].toLowerCase()] = !0
                        }
                        const k = ":" === v[2] ? v.slice(3) : (0,
                        U.rs)(v.slice(2));
                        return [k, E]
                    }(E);
                    if (H) {
                        const Z = W[E] = function createInvoker(v, E) {
                            const invoker = v => {
                                if (v._vts) {
                                    if (v._vts <= invoker.attached)
                                        return
                                } else
                                    v._vts = Date.now();
                                (0,
                                R.$d)(function patchStopImmediatePropagation(v, E) {
                                    if ((0,
                                    U.kJ)(E)) {
                                        const k = v.stopImmediatePropagation;
                                        return v.stopImmediatePropagation = () => {
                                            k.call(v),
                                            v._stopped = !0
                                        }
                                        ,
                                        E.map((v => E => !E._stopped && v && v(E)))
                                    }
                                    return E
                                }(v, invoker.value), E, 5, [v])
                            }
                            ;
                            return invoker.value = v,
                            invoker.attached = getNow(),
                            invoker
                        }(H, G);
                        addEventListener(v, k, Z, Y)
                    } else
                        Z && (!function removeEventListener(v, E, k, R) {
                            v.removeEventListener(E, k, R)
                        }(v, k, Z, Y),
                        W[E] = void 0)
                }
            }
            const ue = /(?:Once|Passive|Capture)$/;
            let de = 0;
            const pe = Promise.resolve()
              , getNow = () => de || (pe.then(( () => de = 0)),
            de = Date.now());
            const isNativeOn = v => 111 === v.charCodeAt(0) && 110 === v.charCodeAt(1) && v.charCodeAt(2) > 96 && v.charCodeAt(2) < 123;
            "undefined" != typeof HTMLElement && HTMLElement;
            Symbol("_moveCb"),
            Symbol("_enterCb");
            Symbol("_assign");
            const fe = ["ctrl", "shift", "alt", "meta"]
              , he = {
                "stop": v => v.stopPropagation(),
                "prevent": v => v.preventDefault(),
                "self": v => v.target !== v.currentTarget,
                "ctrl": v => !v.ctrlKey,
                "shift": v => !v.shiftKey,
                "alt": v => !v.altKey,
                "meta": v => !v.metaKey,
                "left": v => "button"in v && 0 !== v.button,
                "middle": v => "button"in v && 1 !== v.button,
                "right": v => "button"in v && 2 !== v.button,
                "exact": (v, E) => fe.some((k => v[`${k}Key`] && !E.includes(k)))
            }
              , withModifiers = (v, E) => {
                const k = v._withMods || (v._withMods = {})
                  , R = E.join(".");
                return k[R] || (k[R] = (k, ...R) => {
                    for (let v = 0; v < E.length; v++) {
                        const R = he[E[v]];
                        if (R && R(k, E))
                            return
                    }
                    return v(k, ...R)
                }
                )
            }
              , me = (0,
            U.l7)({
                "patchProp": (v, E, k, R, H, G, W, Z, Y) => {
                    const K = "svg" === H;
                    "class" === E ? function patchClass(v, E, k) {
                        const R = v[J];
                        R && (E = (E ? [E, ...R] : [...R]).join(" ")),
                        null == E ? v.removeAttribute("class") : k ? v.setAttribute("class", E) : v.className = E
                    }(v, R, K) : "style" === E ? function patchStyle(v, E, k) {
                        const R = v.style
                          , H = (0,
                        U.HD)(k);
                        let G = !1;
                        if (k && !H) {
                            if (E)
                                if ((0,
                                U.HD)(E))
                                    for (const v of E.split(";")) {
                                        const E = v.slice(0, v.indexOf(":")).trim();
                                        null == k[E] && setStyle(R, E, "")
                                    }
                                else
                                    for (const v in E)
                                        null == k[v] && setStyle(R, v, "");
                            for (const v in k)
                                "display" === v && (G = !0),
                                setStyle(R, v, k[v])
                        } else if (H) {
                            if (E !== k) {
                                const v = R[re];
                                v && (k += ";" + v),
                                R.cssText = k,
                                G = oe.test(k)
                            }
                        } else
                            E && v.removeAttribute("style");
                        ee in v && (v[ee] = G ? R.display : "",
                        v[te] && (R.display = "none"))
                    }(v, k, R) : (0,
                    U.F7)(E) ? (0,
                    U.tR)(E) || patchEvent(v, E, 0, R, W) : ("." === E[0] ? (E = E.slice(1),
                    1) : "^" === E[0] ? (E = E.slice(1),
                    0) : function shouldSetAsProp(v, E, k, R) {
                        if (R)
                            return "innerHTML" === E || "textContent" === E || !!(E in v && isNativeOn(E) && (0,
                            U.mf)(k));
                        if ("spellcheck" === E || "draggable" === E || "translate" === E)
                            return !1;
                        if ("form" === E)
                            return !1;
                        if ("list" === E && "INPUT" === v.tagName)
                            return !1;
                        if ("type" === E && "TEXTAREA" === v.tagName)
                            return !1;
                        if ("width" === E || "height" === E) {
                            const E = v.tagName;
                            if ("IMG" === E || "VIDEO" === E || "CANVAS" === E || "SOURCE" === E)
                                return !1
                        }
                        if (isNativeOn(E) && (0,
                        U.HD)(k))
                            return !1;
                        return E in v
                    }(v, E, R, K)) ? function patchDOMProp(v, E, k, R, H, G, W) {
                        if ("innerHTML" === E || "textContent" === E)
                            return R && W(R, H, G),
                            void (v[E] = null == k ? "" : k);
                        const Z = v.tagName;
                        if ("value" === E && "PROGRESS" !== Z && !Z.includes("-")) {
                            const R = null == k ? "" : k;
                            return ("OPTION" === Z ? v.getAttribute("value") || "" : v.value) === R && "_value"in v || (v.value = R),
                            null == k && v.removeAttribute(E),
                            void (v._value = k)
                        }
                        let Y = !1;
                        if ("" === k || null == k) {
                            const R = typeof v[E];
                            "boolean" === R ? k = (0,
                            U.yA)(k) : null == k && "string" === R ? (k = "",
                            Y = !0) : "number" === R && (k = 0,
                            Y = !0)
                        }
                        try {
                            v[E] = k
                        } catch (v) {}
                        Y && v.removeAttribute(E)
                    }(v, E, R, G, W, Z, Y) : ("true-value" === E ? v._trueValue = R : "false-value" === E && (v._falseValue = R),
                    function patchAttr(v, E, k, R, H) {
                        if (R && E.startsWith("xlink:"))
                            null == k ? v.removeAttributeNS(ce, E.slice(6, E.length)) : v.setAttributeNS(ce, E, k);
                        else {
                            const R = (0,
                            U.Pq)(E);
                            null == k || R && !(0,
                            U.yA)(k) ? v.removeAttribute(E) : v.setAttribute(E, R ? "" : k)
                        }
                    }(v, E, R, K))
                }
            }, W);
            let ge;
            function ensureRenderer() {
                return ge || (ge = (0,
                R.Us)(me))
            }
            const createApp = (...v) => {
                const E = ensureRenderer().createApp(...v);
                const {"mount": k} = E;
                return E.mount = v => {
                    const R = normalizeContainer(v);
                    if (!R)
                        return;
                    const H = E._component;
                    (0,
                    U.mf)(H) || H.render || H.template || (H.template = R.innerHTML),
                    R.innerHTML = "";
                    const G = k(R, !1, resolveRootNamespace(R));
                    return R instanceof Element && (R.removeAttribute("v-cloak"),
                    R.setAttribute("data-v-app", "")),
                    G
                }
                ,
                E
            }
            ;
            function resolveRootNamespace(v) {
                return v instanceof SVGElement ? "svg" : "function" == typeof MathMLElement && v instanceof MathMLElement ? "mathml" : void 0
            }
            function normalizeContainer(v) {
                if ((0,
                U.HD)(v)) {
                    return document.querySelector(v)
                }
                return v
            }
        },
        "3577": function(v, E, k) {
            "use strict";
            function makeMap(v, E) {
                const k = new Set(v.split(","));
                return E ? v => k.has(v.toLowerCase()) : v => k.has(v)
            }
            k.d(E, {
                "C_": function() {
                    return normalizeClass
                },
                "DM": function() {
                    return isSet
                },
                "E9": function() {
                    return getGlobalThis
                },
                "F7": function() {
                    return isOn
                },
                "Gg": function() {
                    return Y
                },
                "HD": function() {
                    return isString
                },
                "He": function() {
                    return toNumber
                },
                "Kj": function() {
                    return isRegExp
                },
                "Kn": function() {
                    return isObject
                },
                "NO": function() {
                    return NO
                },
                "Nj": function() {
                    return def
                },
                "Od": function() {
                    return remove
                },
                "PO": function() {
                    return isPlainObject
                },
                "Pq": function() {
                    return ce
                },
                "RI": function() {
                    return hasOwn
                },
                "S0": function() {
                    return isIntegerKey
                },
                "W7": function() {
                    return toRawType
                },
                "WV": function() {
                    return looseEqual
                },
                "Z6": function() {
                    return U
                },
                "_A": function() {
                    return K
                },
                "_N": function() {
                    return isMap
                },
                "aU": function() {
                    return hasChanged
                },
                "dG": function() {
                    return NOOP
                },
                "fY": function() {
                    return makeMap
                },
                "h5": function() {
                    return looseToNumber
                },
                "hR": function() {
                    return te
                },
                "hq": function() {
                    return looseIndexOf
                },
                "ir": function() {
                    return invokeArrayFns
                },
                "j5": function() {
                    return normalizeStyle
                },
                "kC": function() {
                    return ee
                },
                "kJ": function() {
                    return W
                },
                "kT": function() {
                    return R
                },
                "l7": function() {
                    return H
                },
                "mf": function() {
                    return isFunction
                },
                "rs": function() {
                    return Q
                },
                "tI": function() {
                    return isPromise
                },
                "tR": function() {
                    return isModelListener
                },
                "yA": function() {
                    return includeBooleanAttr
                },
                "yk": function() {
                    return isSymbol
                },
                "yl": function() {
                    return re
                },
                "zw": function() {
                    return toDisplayString
                }
            });
            const R = {}
              , U = []
              , NOOP = () => {}
              , NO = () => !1
              , isOn = v => 111 === v.charCodeAt(0) && 110 === v.charCodeAt(1) && (v.charCodeAt(2) > 122 || v.charCodeAt(2) < 97)
              , isModelListener = v => v.startsWith("onUpdate:")
              , H = Object.assign
              , remove = (v, E) => {
                const k = v.indexOf(E);
                k > -1 && v.splice(k, 1)
            }
              , G = Object.prototype.hasOwnProperty
              , hasOwn = (v, E) => G.call(v, E)
              , W = Array.isArray
              , isMap = v => "[object Map]" === toTypeString(v)
              , isSet = v => "[object Set]" === toTypeString(v)
              , isDate = v => "[object Date]" === toTypeString(v)
              , isRegExp = v => "[object RegExp]" === toTypeString(v)
              , isFunction = v => "function" == typeof v
              , isString = v => "string" == typeof v
              , isSymbol = v => "symbol" == typeof v
              , isObject = v => null !== v && "object" == typeof v
              , isPromise = v => (isObject(v) || isFunction(v)) && isFunction(v.then) && isFunction(v.catch)
              , Z = Object.prototype.toString
              , toTypeString = v => Z.call(v)
              , toRawType = v => toTypeString(v).slice(8, -1)
              , isPlainObject = v => "[object Object]" === toTypeString(v)
              , isIntegerKey = v => isString(v) && "NaN" !== v && "-" !== v[0] && "" + parseInt(v, 10) === v
              , Y = makeMap(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted")
              , cacheStringFunction = v => {
                const E = Object.create(null);
                return k => E[k] || (E[k] = v(k))
            }
              , J = /-(\w)/g
              , K = cacheStringFunction((v => v.replace(J, ( (v, E) => E ? E.toUpperCase() : ""))))
              , X = /\B([A-Z])/g
              , Q = cacheStringFunction((v => v.replace(X, "-$1").toLowerCase()))
              , ee = cacheStringFunction((v => v.charAt(0).toUpperCase() + v.slice(1)))
              , te = cacheStringFunction((v => v ? `on${ee(v)}` : ""))
              , hasChanged = (v, E) => !Object.is(v, E)
              , invokeArrayFns = (v, E) => {
                for (let k = 0; k < v.length; k++)
                    v[k](E)
            }
              , def = (v, E, k, R=!1) => {
                Object.defineProperty(v, E, {
                    "configurable": !0,
                    "enumerable": !1,
                    "writable": R,
                    "value": k
                })
            }
              , looseToNumber = v => {
                const E = parseFloat(v);
                return isNaN(E) ? v : E
            }
              , toNumber = v => {
                const E = isString(v) ? Number(v) : NaN;
                return isNaN(E) ? v : E
            }
            ;
            let ne;
            const getGlobalThis = () => ne || (ne = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : void 0 !== k.g ? k.g : {});
            const re = makeMap("Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error");
            function normalizeStyle(v) {
                if (W(v)) {
                    const E = {};
                    for (let k = 0; k < v.length; k++) {
                        const R = v[k]
                          , U = isString(R) ? parseStringStyle(R) : normalizeStyle(R);
                        if (U)
                            for (const v in U)
                                E[v] = U[v]
                    }
                    return E
                }
                if (isString(v) || isObject(v))
                    return v
            }
            const oe = /;(?![^(]*\))/g
              , ie = /:([^]+)/
              , ae = /\/\*[^]*?\*\//g;
            function parseStringStyle(v) {
                const E = {};
                return v.replace(ae, "").split(oe).forEach((v => {
                    if (v) {
                        const k = v.split(ie);
                        k.length > 1 && (E[k[0].trim()] = k[1].trim())
                    }
                }
                )),
                E
            }
            function normalizeClass(v) {
                let E = "";
                if (isString(v))
                    E = v;
                else if (W(v))
                    for (let k = 0; k < v.length; k++) {
                        const R = normalizeClass(v[k]);
                        R && (E += R + " ")
                    }
                else if (isObject(v))
                    for (const k in v)
                        v[k] && (E += k + " ");
                return E.trim()
            }
            const se = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly"
              , ce = makeMap(se);
            function includeBooleanAttr(v) {
                return !!v || "" === v
            }
            function looseEqual(v, E) {
                if (v === E)
                    return !0;
                let k = isDate(v)
                  , R = isDate(E);
                if (k || R)
                    return !(!k || !R) && v.getTime() === E.getTime();
                if (k = isSymbol(v),
                R = isSymbol(E),
                k || R)
                    return v === E;
                if (k = W(v),
                R = W(E),
                k || R)
                    return !(!k || !R) && function looseCompareArrays(v, E) {
                        if (v.length !== E.length)
                            return !1;
                        let k = !0;
                        for (let R = 0; k && R < v.length; R++)
                            k = looseEqual(v[R], E[R]);
                        return k
                    }(v, E);
                if (k = isObject(v),
                R = isObject(E),
                k || R) {
                    if (!k || !R)
                        return !1;
                    if (Object.keys(v).length !== Object.keys(E).length)
                        return !1;
                    for (const k in v) {
                        const R = v.hasOwnProperty(k)
                          , U = E.hasOwnProperty(k);
                        if (R && !U || !R && U || !looseEqual(v[k], E[k]))
                            return !1
                    }
                }
                return String(v) === String(E)
            }
            function looseIndexOf(v, E) {
                return v.findIndex((v => looseEqual(v, E)))
            }
            const toDisplayString = v => isString(v) ? v : null == v ? "" : W(v) || isObject(v) && (v.toString === Z || !isFunction(v.toString)) ? JSON.stringify(v, replacer, 2) : String(v)
              , replacer = (v, E) => E && E.__v_isRef ? replacer(v, E.value) : isMap(E) ? {
                [`Map(${E.size})`]: [...E.entries()].reduce(( (v, [E,k], R) => (v[stringifySymbol(E, R) + " =>"] = k,
                v)), {})
            } : isSet(E) ? {
                [`Set(${E.size})`]: [...E.values()].map((v => stringifySymbol(v)))
            } : isSymbol(E) ? stringifySymbol(E) : !isObject(E) || W(E) || isPlainObject(E) ? E : String(E)
              , stringifySymbol = (v, E="") => {
                var k;
                return isSymbol(v) ? `Symbol(${null != (k = v.description) ? k : E})` : v
            }
        },
        "6486": function(v, E, k) {
            var R, U;
            R = function() {
                "use strict";
                function _classCallCheck(v, E) {
                    if (!(v instanceof E))
                        throw new TypeError("Cannot call a class as a function")
                }
                function _defineProperties(v, E) {
                    for (var k = 0; k < E.length; k++) {
                        var R = E[k];
                        R.enumerable = R.enumerable || !1,
                        R.configurable = !0,
                        "value"in R && (R.writable = !0),
                        Object.defineProperty(v, R.key, R)
                    }
                }
                function _createClass(v, E, k) {
                    return E && _defineProperties(v.prototype, E),
                    k && _defineProperties(v, k),
                    Object.defineProperty(v, "prototype", {
                        "writable": !1
                    }),
                    v
                }
                function _inherits(v, E) {
                    if ("function" != typeof E && null !== E)
                        throw new TypeError("Super expression must either be null or a function");
                    v.prototype = Object.create(E && E.prototype, {
                        "constructor": {
                            "value": v,
                            "writable": !0,
                            "configurable": !0
                        }
                    }),
                    Object.defineProperty(v, "prototype", {
                        "writable": !1
                    }),
                    E && _setPrototypeOf(v, E)
                }
                function _getPrototypeOf(v) {
                    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(v) {
                        return v.__proto__ || Object.getPrototypeOf(v)
                    }
                    ,
                    _getPrototypeOf(v)
                }
                function _setPrototypeOf(v, E) {
                    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(v, E) {
                        return v.__proto__ = E,
                        v
                    }
                    ,
                    _setPrototypeOf(v, E)
                }
                function _isNativeReflectConstruct() {
                    if ("undefined" == typeof Reflect || !Reflect.construct)
                        return !1;
                    if (Reflect.construct.sham)
                        return !1;
                    if ("function" == typeof Proxy)
                        return !0;
                    try {
                        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}
                        ))),
                        !0
                    } catch (v) {
                        return !1
                    }
                }
                function _assertThisInitialized(v) {
                    if (void 0 === v)
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return v
                }
                function _possibleConstructorReturn(v, E) {
                    if (E && ("object" == typeof E || "function" == typeof E))
                        return E;
                    if (void 0 !== E)
                        throw new TypeError("Derived constructors may only return object or undefined");
                    return _assertThisInitialized(v)
                }
                function _createSuper(v) {
                    var E = _isNativeReflectConstruct();
                    return function _createSuperInternal() {
                        var k, R = _getPrototypeOf(v);
                        if (E) {
                            var U = _getPrototypeOf(this).constructor;
                            k = Reflect.construct(R, arguments, U)
                        } else
                            k = R.apply(this, arguments);
                        return _possibleConstructorReturn(this, k)
                    }
                }
                function _superPropBase(v, E) {
                    for (; !Object.prototype.hasOwnProperty.call(v, E) && null !== (v = _getPrototypeOf(v)); )
                        ;
                    return v
                }
                function _get() {
                    return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function _get(v, E, k) {
                        var R = _superPropBase(v, E);
                        if (R) {
                            var U = Object.getOwnPropertyDescriptor(R, E);
                            return U.get ? U.get.call(arguments.length < 3 ? v : k) : U.value
                        }
                    }
                    ,
                    _get.apply(this, arguments)
                }
                var v = function() {
                    function Emitter() {
                        _classCallCheck(this, Emitter),
                        Object.defineProperty(this, "listeners", {
                            "value": {},
                            "writable": !0,
                            "configurable": !0
                        })
                    }
                    return _createClass(Emitter, [{
                        "key": "addEventListener",
                        "value": function addEventListener(v, E, k) {
                            v in this.listeners || (this.listeners[v] = []),
                            this.listeners[v].push({
                                "callback": E,
                                "options": k
                            })
                        }
                    }, {
                        "key": "removeEventListener",
                        "value": function removeEventListener(v, E) {
                            if (v in this.listeners)
                                for (var k = this.listeners[v], R = 0, U = k.length; R < U; R++)
                                    if (k[R].callback === E)
                                        return void k.splice(R, 1)
                        }
                    }, {
                        "key": "dispatchEvent",
                        "value": function dispatchEvent(v) {
                            if (v.type in this.listeners) {
                                for (var E = this.listeners[v.type].slice(), k = 0, R = E.length; k < R; k++) {
                                    var U = E[k];
                                    try {
                                        U.callback.call(this, v)
                                    } catch (v) {
                                        Promise.resolve().then((function() {
                                            throw v
                                        }
                                        ))
                                    }
                                    U.options && U.options.once && this.removeEventListener(v.type, U.callback)
                                }
                                return !v.defaultPrevented
                            }
                        }
                    }]),
                    Emitter
                }()
                  , E = function(E) {
                    _inherits(AbortSignal, E);
                    var k = _createSuper(AbortSignal);
                    function AbortSignal() {
                        var E;
                        return _classCallCheck(this, AbortSignal),
                        (E = k.call(this)).listeners || v.call(_assertThisInitialized(E)),
                        Object.defineProperty(_assertThisInitialized(E), "aborted", {
                            "value": !1,
                            "writable": !0,
                            "configurable": !0
                        }),
                        Object.defineProperty(_assertThisInitialized(E), "onabort", {
                            "value": null,
                            "writable": !0,
                            "configurable": !0
                        }),
                        Object.defineProperty(_assertThisInitialized(E), "reason", {
                            "value": void 0,
                            "writable": !0,
                            "configurable": !0
                        }),
                        E
                    }
                    return _createClass(AbortSignal, [{
                        "key": "toString",
                        "value": function toString() {
                            return "[object AbortSignal]"
                        }
                    }, {
                        "key": "dispatchEvent",
                        "value": function dispatchEvent(v) {
                            "abort" === v.type && (this.aborted = !0,
                            "function" == typeof this.onabort && this.onabort.call(this, v)),
                            _get(_getPrototypeOf(AbortSignal.prototype), "dispatchEvent", this).call(this, v)
                        }
                    }]),
                    AbortSignal
                }(v)
                  , R = function() {
                    function AbortController() {
                        _classCallCheck(this, AbortController),
                        Object.defineProperty(this, "signal", {
                            "value": new E,
                            "writable": !0,
                            "configurable": !0
                        })
                    }
                    return _createClass(AbortController, [{
                        "key": "abort",
                        "value": function abort(v) {
                            var E;
                            try {
                                E = new Event("abort")
                            } catch (v) {
                                "undefined" != typeof document ? document.createEvent ? (E = document.createEvent("Event")).initEvent("abort", !1, !1) : (E = document.createEventObject()).type = "abort" : E = {
                                    "type": "abort",
                                    "bubbles": !1,
                                    "cancelable": !1
                                }
                            }
                            var k = v;
                            if (void 0 === k)
                                if ("undefined" == typeof document)
                                    (k = new Error("This operation was aborted")).name = "AbortError";
                                else
                                    try {
                                        k = new DOMException("signal is aborted without reason")
                                    } catch (v) {
                                        (k = new Error("This operation was aborted")).name = "AbortError"
                                    }
                            this.signal.reason = k,
                            this.signal.dispatchEvent(E)
                        }
                    }, {
                        "key": "toString",
                        "value": function toString() {
                            return "[object AbortController]"
                        }
                    }]),
                    AbortController
                }();
                function polyfillNeeded(v) {
                    return v.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL ? (console.log("__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL=true is set, will force install polyfill"),
                    !0) : "function" == typeof v.Request && !v.Request.prototype.hasOwnProperty("signal") || !v.AbortController
                }
                "undefined" != typeof Symbol && Symbol.toStringTag && (R.prototype[Symbol.toStringTag] = "AbortController",
                E.prototype[Symbol.toStringTag] = "AbortSignal"),
                function(v) {
                    polyfillNeeded(v) && (v.AbortController = R,
                    v.AbortSignal = E)
                }("undefined" != typeof self ? self : k.g)
            }
            ,
            void 0 === (U = "function" == typeof R ? R.call(E, k, E, v) : R) || (v.exports = U)
        },
        "5276": function(v, E, k) {
            "use strict";
            var R = {};
            k.r(R),
            k.d(R, {
                "BrowserClient": function() {
                    return BrowserClient
                },
                "SDK_VERSION": function() {
                    return ce
                },
                "SEMANTIC_ATTRIBUTE_SENTRY_OP": function() {
                    return Ue
                },
                "SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN": function() {
                    return He
                },
                "SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE": function() {
                    return Be
                },
                "SEMANTIC_ATTRIBUTE_SENTRY_SOURCE": function() {
                    return je
                },
                "Scope": function() {
                    return Ee
                },
                "WINDOW": function() {
                    return Et
                },
                "addBreadcrumb": function() {
                    return addBreadcrumb
                },
                "addEventProcessor": function() {
                    return addEventProcessor
                },
                "addIntegration": function() {
                    return addIntegration
                },
                "addTracingExtensions": function() {
                    return addTracingExtensions
                },
                "attachErrorHandler": function() {
                    return attachErrorHandler
                },
                "breadcrumbsIntegration": function() {
                    return breadcrumbsIntegration
                },
                "browserApiErrorsIntegration": function() {
                    return browserApiErrorsIntegration
                },
                "browserProfilingIntegration": function() {
                    return browserProfilingIntegration
                },
                "browserTracingIntegration": function() {
                    return browserTracingIntegration_browserTracingIntegration
                },
                "captureConsoleIntegration": function() {
                    return captureConsoleIntegration
                },
                "captureEvent": function() {
                    return captureEvent
                },
                "captureException": function() {
                    return captureException
                },
                "captureFeedback": function() {
                    return captureFeedback
                },
                "captureMessage": function() {
                    return captureMessage
                },
                "captureSession": function() {
                    return captureSession
                },
                "captureUserFeedback": function() {
                    return captureUserFeedback
                },
                "chromeStackLineParser": function() {
                    return Gt
                },
                "close": function() {
                    return exports_close
                },
                "contextLinesIntegration": function() {
                    return contextLinesIntegration
                },
                "continueTrace": function() {
                    return continueTrace
                },
                "createTracingMixins": function() {
                    return createTracingMixins
                },
                "createTransport": function() {
                    return createTransport
                },
                "createUserFeedbackEnvelope": function() {
                    return createUserFeedbackEnvelope
                },
                "debugIntegration": function() {
                    return debugIntegration
                },
                "dedupeIntegration": function() {
                    return dedupeIntegration
                },
                "defaultRequestInstrumentationOptions": function() {
                    return Ta
                },
                "defaultStackLineParsers": function() {
                    return tn
                },
                "defaultStackParser": function() {
                    return nn
                },
                "endSession": function() {
                    return endSession
                },
                "eventFromException": function() {
                    return eventFromException
                },
                "eventFromMessage": function() {
                    return eventFromMessage
                },
                "exceptionFromError": function() {
                    return exceptionFromError
                },
                "extraErrorDataIntegration": function() {
                    return extraErrorDataIntegration
                },
                "feedbackAsyncIntegration": function() {
                    return fa
                },
                "feedbackIntegration": function() {
                    return ha
                },
                "feedbackSyncIntegration": function() {
                    return ha
                },
                "flush": function() {
                    return flush
                },
                "forceLoad": function() {
                    return forceLoad
                },
                "functionToStringIntegration": function() {
                    return functionToStringIntegration
                },
                "geckoStackLineParser": function() {
                    return Zt
                },
                "getActiveSpan": function() {
                    return getActiveSpan
                },
                "getClient": function() {
                    return currentScopes_getClient
                },
                "getCurrentHub": function() {
                    return Mn
                },
                "getCurrentScope": function() {
                    return currentScopes_getCurrentScope
                },
                "getDefaultIntegrations": function() {
                    return getDefaultIntegrations
                },
                "getFeedback": function() {
                    return getFeedback
                },
                "getGlobalScope": function() {
                    return currentScopes_getGlobalScope
                },
                "getIsolationScope": function() {
                    return currentScopes_getIsolationScope
                },
                "getReplay": function() {
                    return getReplay
                },
                "getRootSpan": function() {
                    return getRootSpan
                },
                "getSpanDescendants": function() {
                    return getSpanDescendants
                },
                "getSpanStatusFromHttpCode": function() {
                    return getSpanStatusFromHttpCode
                },
                "globalHandlersIntegration": function() {
                    return globalHandlersIntegration
                },
                "httpClientIntegration": function() {
                    return httpClientIntegration
                },
                "httpContextIntegration": function() {
                    return httpContextIntegration
                },
                "inboundFiltersIntegration": function() {
                    return inboundFiltersIntegration
                },
                "init": function() {
                    return sdk_init
                },
                "instrumentOutgoingRequests": function() {
                    return instrumentOutgoingRequests
                },
                "isInitialized": function() {
                    return isInitialized
                },
                "lastEventId": function() {
                    return lastEventId
                },
                "lazyLoadIntegration": function() {
                    return lazyLoadIntegration
                },
                "linkedErrorsIntegration": function() {
                    return linkedErrorsIntegration
                },
                "makeBrowserOfflineTransport": function() {
                    return makeBrowserOfflineTransport
                },
                "makeFetchTransport": function() {
                    return makeFetchTransport
                },
                "makeMultiplexedTransport": function() {
                    return makeMultiplexedTransport
                },
                "metrics": function() {
                    return wa
                },
                "moduleMetadataIntegration": function() {
                    return moduleMetadataIntegration
                },
                "onLoad": function() {
                    return onLoad
                },
                "opera10StackLineParser": function() {
                    return Xt
                },
                "opera11StackLineParser": function() {
                    return en
                },
                "parameterize": function() {
                    return parameterize
                },
                "registerSpanErrorInstrumentation": function() {
                    return registerSpanErrorInstrumentation
                },
                "replayCanvasIntegration": function() {
                    return replayCanvasIntegration
                },
                "replayIntegration": function() {
                    return replayIntegration
                },
                "reportingObserverIntegration": function() {
                    return reportingObserverIntegration
                },
                "rewriteFramesIntegration": function() {
                    return rewriteFramesIntegration
                },
                "sendFeedback": function() {
                    return sendFeedback
                },
                "sessionTimingIntegration": function() {
                    return sessionTimingIntegration
                },
                "setContext": function() {
                    return setContext
                },
                "setCurrentClient": function() {
                    return setCurrentClient
                },
                "setExtra": function() {
                    return setExtra
                },
                "setExtras": function() {
                    return setExtras
                },
                "setHttpStatus": function() {
                    return setHttpStatus
                },
                "setMeasurement": function() {
                    return setMeasurement
                },
                "setTag": function() {
                    return setTag
                },
                "setTags": function() {
                    return setTags
                },
                "setUser": function() {
                    return setUser
                },
                "showReportDialog": function() {
                    return showReportDialog
                },
                "spanToBaggageHeader": function() {
                    return spanToBaggageHeader
                },
                "spanToJSON": function() {
                    return spanUtils_spanToJSON
                },
                "spanToTraceHeader": function() {
                    return spanToTraceHeader
                },
                "startBrowserTracingNavigationSpan": function() {
                    return startBrowserTracingNavigationSpan
                },
                "startBrowserTracingPageLoadSpan": function() {
                    return startBrowserTracingPageLoadSpan
                },
                "startInactiveSpan": function() {
                    return startInactiveSpan
                },
                "startNewTrace": function() {
                    return startNewTrace
                },
                "startSession": function() {
                    return startSession
                },
                "startSpan": function() {
                    return startSpan
                },
                "startSpanManual": function() {
                    return startSpanManual
                },
                "thirdPartyErrorFilterIntegration": function() {
                    return thirdPartyErrorFilterIntegration
                },
                "vueIntegration": function() {
                    return vueIntegration
                },
                "winjsStackLineParser": function() {
                    return Jt
                },
                "withActiveSpan": function() {
                    return withActiveSpan
                },
                "withIsolationScope": function() {
                    return currentScopes_withIsolationScope
                },
                "withScope": function() {
                    return currentScopes_withScope
                },
                "zodErrorsIntegration": function() {
                    return zodErrorsIntegration
                }
            });
            k(1298),
            k(1772);
            var U = k(7945)
              , H = k(1682)
              , G = k(6582)
              , W = k(2782)
              , Z = k(1413)
              , Y = k(9963)
              , J = k(1490)
              , K = k(2153)
              , X = k(5225)
              , Q = k(354)
              , ee = k(989)
              , te = k(5547)
              , ne = k(5210)
              , re = k(5980)
              , oe = k(2229)
              , ie = k(8360)
              , ae = k(3570)
              , se = k(230);
            const ce = "8.30.0"
              , le = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__
              , ue = globalThis;
            function worldwide_getGlobalSingleton(v, E, k) {
                const R = k || ue
                  , U = R.__SENTRY__ = R.__SENTRY__ || {}
                  , H = U[ce] = U[ce] || {};
                return H[v] || (H[v] = E())
            }
            const de = ["debug", "info", "warn", "error", "log", "assert", "trace"]
              , pe = {};
            function logger_consoleSandbox(v) {
                if (!("console"in ue))
                    return v();
                const E = ue.console
                  , k = {}
                  , R = Object.keys(pe);
                R.forEach((v => {
                    const R = pe[v];
                    k[v] = E[v],
                    E[v] = R
                }
                ));
                try {
                    return v()
                } finally {
                    R.forEach((v => {
                        E[v] = k[v]
                    }
                    ))
                }
            }
            const fe = worldwide_getGlobalSingleton("logger", (function makeLogger() {
                let v = !1;
                const E = {
                    "enable": () => {
                        v = !0
                    }
                    ,
                    "disable": () => {
                        v = !1
                    }
                    ,
                    "isEnabled": () => v
                };
                return le ? de.forEach((k => {
                    E[k] = (...E) => {
                        v && logger_consoleSandbox(( () => {
                            ue.console[k](`Sentry Logger [${k}]:`, ...E)
                        }
                        ))
                    }
                }
                )) : de.forEach((v => {
                    E[v] = () => {}
                }
                )),
                E
            }
            ))
              , he = Object.prototype.toString;
            function is_isError(v) {
                switch (he.call(v)) {
                case "[object Error]":
                case "[object Exception]":
                case "[object DOMException]":
                    return !0;
                default:
                    return is_isInstanceOf(v, Error)
                }
            }
            function isBuiltin(v, E) {
                return he.call(v) === `[object ${E}]`
            }
            function isErrorEvent(v) {
                return isBuiltin(v, "ErrorEvent")
            }
            function isDOMError(v) {
                return isBuiltin(v, "DOMError")
            }
            function is_isString(v) {
                return isBuiltin(v, "String")
            }
            function isParameterizedString(v) {
                return "object" == typeof v && null !== v && "__sentry_template_string__"in v && "__sentry_template_values__"in v
            }
            function is_isPrimitive(v) {
                return null === v || isParameterizedString(v) || "object" != typeof v && "function" != typeof v
            }
            function isPlainObject(v) {
                return isBuiltin(v, "Object")
            }
            function is_isEvent(v) {
                return "undefined" != typeof Event && is_isInstanceOf(v, Event)
            }
            function is_isThenable(v) {
                return Boolean(v && v.then && "function" == typeof v.then)
            }
            function is_isInstanceOf(v, E) {
                try {
                    return v instanceof E
                } catch (v) {
                    return !1
                }
            }
            function is_isVueViewModel(v) {
                return !("object" != typeof v || null === v || !v.__isVue && !v._isVue)
            }
            const me = ue
              , ge = 80;
            function browser_htmlTreeAsString(v, E={}) {
                if (!v)
                    return "<unknown>";
                try {
                    let k = v;
                    const R = 5
                      , U = [];
                    let H = 0
                      , G = 0;
                    const W = " > "
                      , Z = W.length;
                    let Y;
                    const J = Array.isArray(E) ? E : E.keyAttrs
                      , K = !Array.isArray(E) && E.maxStringLength || ge;
                    for (; k && H++ < R && (Y = _htmlElementAsString(k, J),
                    !("html" === Y || H > 1 && G + U.length * Z + Y.length >= K)); )
                        U.push(Y),
                        G += Y.length,
                        k = k.parentNode;
                    return U.reverse().join(W)
                } catch (v) {
                    return "<unknown>"
                }
            }
            function _htmlElementAsString(v, E) {
                const k = v
                  , R = [];
                if (!k || !k.tagName)
                    return "";
                if (me.HTMLElement && k instanceof HTMLElement && k.dataset) {
                    if (k.dataset.sentryComponent)
                        return k.dataset.sentryComponent;
                    if (k.dataset.sentryElement)
                        return k.dataset.sentryElement
                }
                R.push(k.tagName.toLowerCase());
                const U = E && E.length ? E.filter((v => k.getAttribute(v))).map((v => [v, k.getAttribute(v)])) : null;
                if (U && U.length)
                    U.forEach((v => {
                        R.push(`[${v[0]}="${v[1]}"]`)
                    }
                    ));
                else {
                    k.id && R.push(`#${k.id}`);
                    const v = k.className;
                    if (v && is_isString(v)) {
                        const E = v.split(/\s+/);
                        for (const v of E)
                            R.push(`.${v}`)
                    }
                }
                const H = ["aria-label", "type", "name", "title", "alt"];
                for (const v of H) {
                    const E = k.getAttribute(v);
                    E && R.push(`[${v}="${E}"]`)
                }
                return R.join("")
            }
            function string_truncate(v, E=0) {
                return "string" != typeof v || 0 === E || v.length <= E ? v : `${v.slice(0, E)}...`
            }
            function string_snipLine(v, E) {
                let k = v;
                const R = k.length;
                if (R <= 150)
                    return k;
                E > R && (E = R);
                let U = Math.max(E - 60, 0);
                U < 5 && (U = 0);
                let H = Math.min(U + 140, R);
                return H > R - 5 && (H = R),
                H === R && (U = Math.max(H - 140, 0)),
                k = k.slice(U, H),
                U > 0 && (k = `'{snip} ${k}`),
                H < R && (k += " {snip}"),
                k
            }
            function safeJoin(v, E) {
                if (!Array.isArray(v))
                    return "";
                const k = [];
                for (let E = 0; E < v.length; E++) {
                    const R = v[E];
                    try {
                        is_isVueViewModel(R) ? k.push("[VueViewModel]") : k.push(String(R))
                    } catch (v) {
                        k.push("[value cannot be serialized]")
                    }
                }
                return k.join(E)
            }
            function isMatchingPattern(v, E, k=!1) {
                return !!is_isString(v) && (function isRegExp(v) {
                    return isBuiltin(v, "RegExp")
                }(E) ? E.test(v) : !!is_isString(E) && (k ? v === E : v.includes(E)))
            }
            function stringMatchesSomePattern(v, E=[], k=!1) {
                return E.some((E => isMatchingPattern(v, E, k)))
            }
            function fill(v, E, k) {
                if (!(E in v))
                    return;
                const R = v[E]
                  , U = k(R);
                "function" == typeof U && markFunctionWrapped(U, R),
                v[E] = U
            }
            function object_addNonEnumerableProperty(v, E, k) {
                try {
                    Object.defineProperty(v, E, {
                        "value": k,
                        "writable": !0,
                        "configurable": !0
                    })
                } catch (k) {
                    le && fe.log(`Failed to add non-enumerable property "${E}" to object`, v)
                }
            }
            function markFunctionWrapped(v, E) {
                try {
                    const k = E.prototype || {};
                    v.prototype = E.prototype = k,
                    object_addNonEnumerableProperty(v, "__sentry_original__", E)
                } catch (v) {}
            }
            function getOriginalFunction(v) {
                return v.__sentry_original__
            }
            function convertToPlainObject(v) {
                if (is_isError(v))
                    return {
                        "message": v.message,
                        "name": v.name,
                        "stack": v.stack,
                        ...getOwnProperties(v)
                    };
                if (is_isEvent(v)) {
                    const E = {
                        "type": v.type,
                        "target": serializeEventTarget(v.target),
                        "currentTarget": serializeEventTarget(v.currentTarget),
                        ...getOwnProperties(v)
                    };
                    return "undefined" != typeof CustomEvent && is_isInstanceOf(v, CustomEvent) && (E.detail = v.detail),
                    E
                }
                return v
            }
            function serializeEventTarget(v) {
                try {
                    return function is_isElement(v) {
                        return "undefined" != typeof Element && is_isInstanceOf(v, Element)
                    }(v) ? browser_htmlTreeAsString(v) : Object.prototype.toString.call(v)
                } catch (v) {
                    return "<unknown>"
                }
            }
            function getOwnProperties(v) {
                if ("object" == typeof v && null !== v) {
                    const E = {};
                    for (const k in v)
                        Object.prototype.hasOwnProperty.call(v, k) && (E[k] = v[k]);
                    return E
                }
                return {}
            }
            function object_dropUndefinedKeys(v) {
                return _dropUndefinedKeys(v, new Map)
            }
            function _dropUndefinedKeys(v, E) {
                if (function isPojo(v) {
                    if (!isPlainObject(v))
                        return !1;
                    try {
                        const E = Object.getPrototypeOf(v).constructor.name;
                        return !E || "Object" === E
                    } catch (v) {
                        return !0
                    }
                }(v)) {
                    const k = E.get(v);
                    if (void 0 !== k)
                        return k;
                    const R = {};
                    E.set(v, R);
                    for (const k of Object.keys(v))
                        void 0 !== v[k] && (R[k] = _dropUndefinedKeys(v[k], E));
                    return R
                }
                if (Array.isArray(v)) {
                    const k = E.get(v);
                    if (void 0 !== k)
                        return k;
                    const R = [];
                    return E.set(v, R),
                    v.forEach((v => {
                        R.push(_dropUndefinedKeys(v, E))
                    }
                    )),
                    R
                }
                return v
            }
            function misc_uuid4() {
                const v = ue
                  , E = v.crypto || v.msCrypto;
                let getRandomByte = () => 16 * Math.random();
                try {
                    if (E && E.randomUUID)
                        return E.randomUUID().replace(/-/g, "");
                    E && E.getRandomValues && (getRandomByte = () => {
                        const v = new Uint8Array(1);
                        return E.getRandomValues(v),
                        v[0]
                    }
                    )
                } catch (v) {}
                return ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, (v => (v ^ (15 & getRandomByte()) >> v / 4).toString(16)))
            }
            function getFirstException(v) {
                return v.exception && v.exception.values ? v.exception.values[0] : void 0
            }
            function getEventDescription(v) {
                const {"message": E, "event_id": k} = v;
                if (E)
                    return E;
                const R = getFirstException(v);
                return R ? R.type && R.value ? `${R.type}: ${R.value}` : R.type || R.value || k || "<unknown>" : k || "<unknown>"
            }
            function addExceptionTypeValue(v, E, k) {
                const R = v.exception = v.exception || {}
                  , U = R.values = R.values || []
                  , H = U[0] = U[0] || {};
                H.value || (H.value = E || ""),
                H.type || (H.type = k || "Error")
            }
            function misc_addExceptionMechanism(v, E) {
                const k = getFirstException(v);
                if (!k)
                    return;
                const R = k.mechanism;
                if (k.mechanism = {
                    "type": "generic",
                    "handled": !0,
                    ...R,
                    ...E
                },
                E && "data"in E) {
                    const v = {
                        ...R && R.data,
                        ...E.data
                    };
                    k.mechanism.data = v
                }
            }
            function checkOrSetAlreadyCaught(v) {
                if (v && v.__sentry_captured__)
                    return !0;
                try {
                    object_addNonEnumerableProperty(v, "__sentry_captured__", !0)
                } catch (v) {}
                return !1
            }
            function misc_arrayify(v) {
                return Array.isArray(v) ? v : [v]
            }
            const _e = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__;
            function carrier_getMainCarrier() {
                return carrier_getSentryCarrier(ue),
                ue
            }
            function carrier_getSentryCarrier(v) {
                const E = v.__SENTRY__ = v.__SENTRY__ || {};
                return E.version = E.version || ce,
                E[ce] = E[ce] || {}
            }
            function propagationContext_generatePropagationContext() {
                return {
                    "traceId": misc_uuid4(),
                    "spanId": misc_uuid4().substring(16)
                }
            }
            const ve = 1e3;
            function time_dateTimestampInSeconds() {
                return Date.now() / ve
            }
            const ye = function createUnixTimestampInSecondsFunc() {
                const {"performance": v} = ue;
                if (!v || !v.now)
                    return time_dateTimestampInSeconds;
                const E = Date.now() - v.now()
                  , k = null == v.timeOrigin ? E : v.timeOrigin;
                return () => (k + v.now()) / ve
            }();
            let be;
            const Se = ( () => {
                const {"performance": v} = ue;
                if (!v || !v.now)
                    return void (be = "none");
                const E = 36e5
                  , k = v.now()
                  , R = Date.now()
                  , U = v.timeOrigin ? Math.abs(v.timeOrigin + k - R) : E
                  , H = U < E
                  , G = v.timing && v.timing.navigationStart
                  , W = "number" == typeof G ? Math.abs(G + k - R) : E;
                return H || W < E ? U <= W ? (be = "timeOrigin",
                v.timeOrigin) : (be = "navigationStart",
                G) : (be = "dateNow",
                R)
            }
            )();
            function session_makeSession(v) {
                const E = ye()
                  , k = {
                    "sid": misc_uuid4(),
                    "init": !0,
                    "timestamp": E,
                    "started": E,
                    "duration": 0,
                    "status": "ok",
                    "errors": 0,
                    "ignoreDuration": !1,
                    "toJSON": () => function sessionToJSON(v) {
                        return object_dropUndefinedKeys({
                            "sid": `${v.sid}`,
                            "init": v.init,
                            "started": new Date(1e3 * v.started).toISOString(),
                            "timestamp": new Date(1e3 * v.timestamp).toISOString(),
                            "status": v.status,
                            "errors": v.errors,
                            "did": "number" == typeof v.did || "string" == typeof v.did ? `${v.did}` : void 0,
                            "duration": v.duration,
                            "abnormal_mechanism": v.abnormal_mechanism,
                            "attrs": {
                                "release": v.release,
                                "environment": v.environment,
                                "ip_address": v.ipAddress,
                                "user_agent": v.userAgent
                            }
                        })
                    }(k)
                };
                return v && session_updateSession(k, v),
                k
            }
            function session_updateSession(v, E={}) {
                if (E.user && (!v.ipAddress && E.user.ip_address && (v.ipAddress = E.user.ip_address),
                v.did || E.did || (v.did = E.user.id || E.user.email || E.user.username)),
                v.timestamp = E.timestamp || ye(),
                E.abnormal_mechanism && (v.abnormal_mechanism = E.abnormal_mechanism),
                E.ignoreDuration && (v.ignoreDuration = E.ignoreDuration),
                E.sid && (v.sid = 32 === E.sid.length ? E.sid : misc_uuid4()),
                void 0 !== E.init && (v.init = E.init),
                !v.did && E.did && (v.did = `${E.did}`),
                "number" == typeof E.started && (v.started = E.started),
                v.ignoreDuration)
                    v.duration = void 0;
                else if ("number" == typeof E.duration)
                    v.duration = E.duration;
                else {
                    const E = v.timestamp - v.started;
                    v.duration = E >= 0 ? E : 0
                }
                E.release && (v.release = E.release),
                E.environment && (v.environment = E.environment),
                !v.ipAddress && E.ipAddress && (v.ipAddress = E.ipAddress),
                !v.userAgent && E.userAgent && (v.userAgent = E.userAgent),
                "number" == typeof E.errors && (v.errors = E.errors),
                E.status && (v.status = E.status)
            }
            const we = "_sentrySpan";
            function spanOnScope_setSpanForScope(v, E) {
                E ? object_addNonEnumerableProperty(v, we, E) : delete v[we]
            }
            function _getSpanForScope(v) {
                return v[we]
            }
            class ScopeClass {
                "constructor"() {
                    this._notifyingListeners = !1,
                    this._scopeListeners = [],
                    this._eventProcessors = [],
                    this._breadcrumbs = [],
                    this._attachments = [],
                    this._user = {},
                    this._tags = {},
                    this._extra = {},
                    this._contexts = {},
                    this._sdkProcessingMetadata = {},
                    this._propagationContext = propagationContext_generatePropagationContext()
                }
                "clone"() {
                    const v = new ScopeClass;
                    return v._breadcrumbs = [...this._breadcrumbs],
                    v._tags = {
                        ...this._tags
                    },
                    v._extra = {
                        ...this._extra
                    },
                    v._contexts = {
                        ...this._contexts
                    },
                    v._user = this._user,
                    v._level = this._level,
                    v._session = this._session,
                    v._transactionName = this._transactionName,
                    v._fingerprint = this._fingerprint,
                    v._eventProcessors = [...this._eventProcessors],
                    v._requestSession = this._requestSession,
                    v._attachments = [...this._attachments],
                    v._sdkProcessingMetadata = {
                        ...this._sdkProcessingMetadata
                    },
                    v._propagationContext = {
                        ...this._propagationContext
                    },
                    v._client = this._client,
                    v._lastEventId = this._lastEventId,
                    spanOnScope_setSpanForScope(v, _getSpanForScope(this)),
                    v
                }
                "setClient"(v) {
                    this._client = v
                }
                "setLastEventId"(v) {
                    this._lastEventId = v
                }
                "getClient"() {
                    return this._client
                }
                "lastEventId"() {
                    return this._lastEventId
                }
                "addScopeListener"(v) {
                    this._scopeListeners.push(v)
                }
                "addEventProcessor"(v) {
                    return this._eventProcessors.push(v),
                    this
                }
                "setUser"(v) {
                    return this._user = v || {
                        "email": void 0,
                        "id": void 0,
                        "ip_address": void 0,
                        "username": void 0
                    },
                    this._session && session_updateSession(this._session, {
                        "user": v
                    }),
                    this._notifyScopeListeners(),
                    this
                }
                "getUser"() {
                    return this._user
                }
                "getRequestSession"() {
                    return this._requestSession
                }
                "setRequestSession"(v) {
                    return this._requestSession = v,
                    this
                }
                "setTags"(v) {
                    return this._tags = {
                        ...this._tags,
                        ...v
                    },
                    this._notifyScopeListeners(),
                    this
                }
                "setTag"(v, E) {
                    return this._tags = {
                        ...this._tags,
                        [v]: E
                    },
                    this._notifyScopeListeners(),
                    this
                }
                "setExtras"(v) {
                    return this._extra = {
                        ...this._extra,
                        ...v
                    },
                    this._notifyScopeListeners(),
                    this
                }
                "setExtra"(v, E) {
                    return this._extra = {
                        ...this._extra,
                        [v]: E
                    },
                    this._notifyScopeListeners(),
                    this
                }
                "setFingerprint"(v) {
                    return this._fingerprint = v,
                    this._notifyScopeListeners(),
                    this
                }
                "setLevel"(v) {
                    return this._level = v,
                    this._notifyScopeListeners(),
                    this
                }
                "setTransactionName"(v) {
                    return this._transactionName = v,
                    this._notifyScopeListeners(),
                    this
                }
                "setContext"(v, E) {
                    return null === E ? delete this._contexts[v] : this._contexts[v] = E,
                    this._notifyScopeListeners(),
                    this
                }
                "setSession"(v) {
                    return v ? this._session = v : delete this._session,
                    this._notifyScopeListeners(),
                    this
                }
                "getSession"() {
                    return this._session
                }
                "update"(v) {
                    if (!v)
                        return this;
                    const E = "function" == typeof v ? v(this) : v
                      , [k,R] = E instanceof Ee ? [E.getScopeData(), E.getRequestSession()] : isPlainObject(E) ? [v, v.requestSession] : []
                      , {"tags": U, "extra": H, "user": G, "contexts": W, "level": Z, "fingerprint": Y=[], "propagationContext": J} = k || {};
                    return this._tags = {
                        ...this._tags,
                        ...U
                    },
                    this._extra = {
                        ...this._extra,
                        ...H
                    },
                    this._contexts = {
                        ...this._contexts,
                        ...W
                    },
                    G && Object.keys(G).length && (this._user = G),
                    Z && (this._level = Z),
                    Y.length && (this._fingerprint = Y),
                    J && (this._propagationContext = J),
                    R && (this._requestSession = R),
                    this
                }
                "clear"() {
                    return this._breadcrumbs = [],
                    this._tags = {},
                    this._extra = {},
                    this._user = {},
                    this._contexts = {},
                    this._level = void 0,
                    this._transactionName = void 0,
                    this._fingerprint = void 0,
                    this._requestSession = void 0,
                    this._session = void 0,
                    spanOnScope_setSpanForScope(this, void 0),
                    this._attachments = [],
                    this._propagationContext = propagationContext_generatePropagationContext(),
                    this._notifyScopeListeners(),
                    this
                }
                "addBreadcrumb"(v, E) {
                    const k = "number" == typeof E ? E : 100;
                    if (k <= 0)
                        return this;
                    const R = {
                        "timestamp": time_dateTimestampInSeconds(),
                        ...v
                    }
                      , U = this._breadcrumbs;
                    return U.push(R),
                    this._breadcrumbs = U.length > k ? U.slice(-k) : U,
                    this._notifyScopeListeners(),
                    this
                }
                "getLastBreadcrumb"() {
                    return this._breadcrumbs[this._breadcrumbs.length - 1]
                }
                "clearBreadcrumbs"() {
                    return this._breadcrumbs = [],
                    this._notifyScopeListeners(),
                    this
                }
                "addAttachment"(v) {
                    return this._attachments.push(v),
                    this
                }
                "clearAttachments"() {
                    return this._attachments = [],
                    this
                }
                "getScopeData"() {
                    return {
                        "breadcrumbs": this._breadcrumbs,
                        "attachments": this._attachments,
                        "contexts": this._contexts,
                        "tags": this._tags,
                        "extra": this._extra,
                        "user": this._user,
                        "level": this._level,
                        "fingerprint": this._fingerprint || [],
                        "eventProcessors": this._eventProcessors,
                        "propagationContext": this._propagationContext,
                        "sdkProcessingMetadata": this._sdkProcessingMetadata,
                        "transactionName": this._transactionName,
                        "span": _getSpanForScope(this)
                    }
                }
                "setSDKProcessingMetadata"(v) {
                    return this._sdkProcessingMetadata = {
                        ...this._sdkProcessingMetadata,
                        ...v
                    },
                    this
                }
                "setPropagationContext"(v) {
                    return this._propagationContext = v,
                    this
                }
                "getPropagationContext"() {
                    return this._propagationContext
                }
                "captureException"(v, E) {
                    const k = E && E.event_id ? E.event_id : misc_uuid4();
                    if (!this._client)
                        return fe.warn("No client configured on scope - will not capture exception!"),
                        k;
                    const R = new Error("Sentry syntheticException");
                    return this._client.captureException(v, {
                        "originalException": v,
                        "syntheticException": R,
                        ...E,
                        "event_id": k
                    }, this),
                    k
                }
                "captureMessage"(v, E, k) {
                    const R = k && k.event_id ? k.event_id : misc_uuid4();
                    if (!this._client)
                        return fe.warn("No client configured on scope - will not capture message!"),
                        R;
                    const U = new Error(v);
                    return this._client.captureMessage(v, E, {
                        "originalException": v,
                        "syntheticException": U,
                        ...k,
                        "event_id": R
                    }, this),
                    R
                }
                "captureEvent"(v, E) {
                    const k = E && E.event_id ? E.event_id : misc_uuid4();
                    return this._client ? (this._client.captureEvent(v, {
                        ...E,
                        "event_id": k
                    }, this),
                    k) : (fe.warn("No client configured on scope - will not capture event!"),
                    k)
                }
                "_notifyScopeListeners"() {
                    this._notifyingListeners || (this._notifyingListeners = !0,
                    this._scopeListeners.forEach((v => {
                        v(this)
                    }
                    )),
                    this._notifyingListeners = !1)
                }
            }
            const Ee = ScopeClass;
            class AsyncContextStack {
                "constructor"(v, E) {
                    let k, R;
                    k = v || new Ee,
                    R = E || new Ee,
                    this._stack = [{
                        "scope": k
                    }],
                    this._isolationScope = R
                }
                "withScope"(v) {
                    const E = this._pushScope();
                    let k;
                    try {
                        k = v(E)
                    } catch (v) {
                        throw this._popScope(),
                        v
                    }
                    return is_isThenable(k) ? k.then((v => (this._popScope(),
                    v)), (v => {
                        throw this._popScope(),
                        v
                    }
                    )) : (this._popScope(),
                    k)
                }
                "getClient"() {
                    return this.getStackTop().client
                }
                "getScope"() {
                    return this.getStackTop().scope
                }
                "getIsolationScope"() {
                    return this._isolationScope
                }
                "getStackTop"() {
                    return this._stack[this._stack.length - 1]
                }
                "_pushScope"() {
                    const v = this.getScope().clone();
                    return this._stack.push({
                        "client": this.getClient(),
                        "scope": v
                    }),
                    v
                }
                "_popScope"() {
                    return !(this._stack.length <= 1) && !!this._stack.pop()
                }
            }
            function getAsyncContextStack() {
                const v = carrier_getSentryCarrier(carrier_getMainCarrier());
                return v.stack = v.stack || new AsyncContextStack(function getDefaultCurrentScope() {
                    return worldwide_getGlobalSingleton("defaultCurrentScope", ( () => new Ee))
                }(),function getDefaultIsolationScope() {
                    return worldwide_getGlobalSingleton("defaultIsolationScope", ( () => new Ee))
                }())
            }
            function stackStrategy_withScope(v) {
                return getAsyncContextStack().withScope(v)
            }
            function withSetScope(v, E) {
                const k = getAsyncContextStack();
                return k.withScope(( () => (k.getStackTop().scope = v,
                E(v))))
            }
            function stackStrategy_withIsolationScope(v) {
                return getAsyncContextStack().withScope(( () => v(getAsyncContextStack().getIsolationScope())))
            }
            function asyncContext_getAsyncContextStrategy(v) {
                const E = carrier_getSentryCarrier(v);
                return E.acs ? E.acs : function getStackAsyncContextStrategy() {
                    return {
                        "withIsolationScope": stackStrategy_withIsolationScope,
                        "withScope": stackStrategy_withScope,
                        "withSetScope": withSetScope,
                        "withSetIsolationScope": (v, E) => stackStrategy_withIsolationScope(E),
                        "getCurrentScope": () => getAsyncContextStack().getScope(),
                        "getIsolationScope": () => getAsyncContextStack().getIsolationScope()
                    }
                }()
            }
            function currentScopes_getCurrentScope() {
                return asyncContext_getAsyncContextStrategy(carrier_getMainCarrier()).getCurrentScope()
            }
            function currentScopes_getIsolationScope() {
                return asyncContext_getAsyncContextStrategy(carrier_getMainCarrier()).getIsolationScope()
            }
            function currentScopes_getGlobalScope() {
                return worldwide_getGlobalSingleton("globalScope", ( () => new Ee))
            }
            function currentScopes_withScope(...v) {
                const E = asyncContext_getAsyncContextStrategy(carrier_getMainCarrier());
                if (2 === v.length) {
                    const [k,R] = v;
                    return k ? E.withSetScope(k, R) : E.withScope(R)
                }
                return E.withScope(v[0])
            }
            function currentScopes_withIsolationScope(...v) {
                const E = asyncContext_getAsyncContextStrategy(carrier_getMainCarrier());
                if (2 === v.length) {
                    const [k,R] = v;
                    return k ? E.withSetIsolationScope(k, R) : E.withIsolationScope(R)
                }
                return E.withIsolationScope(v[0])
            }
            function currentScopes_getClient() {
                return currentScopes_getCurrentScope().getClient()
            }
            const Ce = [];
            function getIntegrationsToSetup(v) {
                const E = v.defaultIntegrations || []
                  , k = v.integrations;
                let R;
                E.forEach((v => {
                    v.isDefaultInstance = !0
                }
                )),
                R = Array.isArray(k) ? [...E, ...k] : "function" == typeof k ? misc_arrayify(k(E)) : E;
                const U = function filterDuplicates(v) {
                    const E = {};
                    return v.forEach((v => {
                        const {"name": k} = v
                          , R = E[k];
                        R && !R.isDefaultInstance && v.isDefaultInstance || (E[k] = v)
                    }
                    )),
                    Object.values(E)
                }(R)
                  , H = U.findIndex((v => "Debug" === v.name));
                if (H > -1) {
                    const [v] = U.splice(H, 1);
                    U.push(v)
                }
                return U
            }
            function afterSetupIntegrations(v, E) {
                for (const k of E)
                    k && k.afterAllSetup && k.afterAllSetup(v)
            }
            function setupIntegration(v, E, k) {
                if (k[E.name])
                    _e && fe.log(`Integration skipped because it was already installed: ${E.name}`);
                else {
                    if (k[E.name] = E,
                    -1 === Ce.indexOf(E.name) && "function" == typeof E.setupOnce && (E.setupOnce(),
                    Ce.push(E.name)),
                    E.setup && "function" == typeof E.setup && E.setup(v),
                    "function" == typeof E.preprocessEvent) {
                        const k = E.preprocessEvent.bind(E);
                        v.on("preprocessEvent", ( (E, R) => k(E, R, v)))
                    }
                    if ("function" == typeof E.processEvent) {
                        const k = E.processEvent.bind(E)
                          , R = Object.assign(( (E, R) => k(E, R, v)), {
                            "id": E.name
                        });
                        v.addEventProcessor(R)
                    }
                    _e && fe.log(`Integration installed: ${E.name}`)
                }
            }
            function addIntegration(v) {
                const E = currentScopes_getClient();
                E ? E.addIntegration(v) : _e && fe.warn(`Cannot add integration "${v.name}" because no SDK Client is available.`)
            }
            const Te = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/, /^ResizeObserver loop completed with undelivered notifications.$/, /^Cannot redefine property: googletag$/, "undefined is not an object (evaluating 'a.L')", 'can\'t redefine non-configurable property "solana"', "vv().getRestrictions is not a function. (In 'vv().getRestrictions(1,a)', 'vv().getRestrictions' is undefined)", "Can't find variable: _AutofillCallbackHandler"]
              , inboundFiltersIntegration = (v={}) => ({
                "name": "InboundFilters",
                "processEvent"(E, k, R) {
                    const U = R.getOptions()
                      , H = function _mergeOptions(v={}, E={}) {
                        return {
                            "allowUrls": [...v.allowUrls || [], ...E.allowUrls || []],
                            "denyUrls": [...v.denyUrls || [], ...E.denyUrls || []],
                            "ignoreErrors": [...v.ignoreErrors || [], ...E.ignoreErrors || [], ...v.disableErrorDefaults ? [] : Te],
                            "ignoreTransactions": [...v.ignoreTransactions || [], ...E.ignoreTransactions || []],
                            "ignoreInternal": void 0 === v.ignoreInternal || v.ignoreInternal
                        }
                    }(v, U);
                    return function _shouldDropEvent(v, E) {
                        if (E.ignoreInternal && function _isSentryError(v) {
                            try {
                                return "SentryError" === v.exception.values[0].type
                            } catch (v) {}
                            return !1
                        }(v))
                            return _e && fe.warn(`Event dropped due to being internal Sentry Error.\nEvent: ${getEventDescription(v)}`),
                            !0;
                        if (function _isIgnoredError(v, E) {
                            if (v.type || !E || !E.length)
                                return !1;
                            return function _getPossibleEventMessages(v) {
                                const E = [];
                                v.message && E.push(v.message);
                                let k;
                                try {
                                    k = v.exception.values[v.exception.values.length - 1]
                                } catch (v) {}
                                k && k.value && (E.push(k.value),
                                k.type && E.push(`${k.type}: ${k.value}`));
                                return E
                            }(v).some((v => stringMatchesSomePattern(v, E)))
                        }(v, E.ignoreErrors))
                            return _e && fe.warn(`Event dropped due to being matched by \`ignoreErrors\` option.\nEvent: ${getEventDescription(v)}`),
                            !0;
                        if (function _isUselessError(v) {
                            if (v.type)
                                return !1;
                            if (!v.exception || !v.exception.values || 0 === v.exception.values.length)
                                return !1;
                            return !v.message && !v.exception.values.some((v => v.stacktrace || v.type && "Error" !== v.type || v.value))
                        }(v))
                            return _e && fe.warn(`Event dropped due to not having an error message, error type or stacktrace.\nEvent: ${getEventDescription(v)}`),
                            !0;
                        if (function _isIgnoredTransaction(v, E) {
                            if ("transaction" !== v.type || !E || !E.length)
                                return !1;
                            const k = v.transaction;
                            return !!k && stringMatchesSomePattern(k, E)
                        }(v, E.ignoreTransactions))
                            return _e && fe.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.\nEvent: ${getEventDescription(v)}`),
                            !0;
                        if (function _isDeniedUrl(v, E) {
                            if (!E || !E.length)
                                return !1;
                            const k = _getEventFilterUrl(v);
                            return !!k && stringMatchesSomePattern(k, E)
                        }(v, E.denyUrls))
                            return _e && fe.warn(`Event dropped due to being matched by \`denyUrls\` option.\nEvent: ${getEventDescription(v)}.\nUrl: ${_getEventFilterUrl(v)}`),
                            !0;
                        if (!function _isAllowedUrl(v, E) {
                            if (!E || !E.length)
                                return !0;
                            const k = _getEventFilterUrl(v);
                            return !k || stringMatchesSomePattern(k, E)
                        }(v, E.allowUrls))
                            return _e && fe.warn(`Event dropped due to not being matched by \`allowUrls\` option.\nEvent: ${getEventDescription(v)}.\nUrl: ${_getEventFilterUrl(v)}`),
                            !0;
                        return !1
                    }(E, H) ? null : E
                }
            });
            function _getEventFilterUrl(v) {
                try {
                    let E;
                    try {
                        E = v.exception.values[0].stacktrace.frames
                    } catch (v) {}
                    return E ? function _getLastValidUrl(v=[]) {
                        for (let E = v.length - 1; E >= 0; E--) {
                            const k = v[E];
                            if (k && "<anonymous>" !== k.filename && "[native code]" !== k.filename)
                                return k.filename || null
                        }
                        return null
                    }(E) : null
                } catch (E) {
                    return _e && fe.error(`Cannot extract url for event ${getEventDescription(v)}`),
                    null
                }
            }
            let xe;
            const Ae = new WeakMap
              , functionToStringIntegration = () => ({
                "name": "FunctionToString",
                "setupOnce"() {
                    xe = Function.prototype.toString;
                    try {
                        Function.prototype.toString = function(...v) {
                            const E = getOriginalFunction(this)
                              , k = Ae.has(currentScopes_getClient()) && void 0 !== E ? E : this;
                            return xe.apply(k, v)
                        }
                    } catch (v) {}
                },
                "setup"(v) {
                    Ae.set(v, !0)
                }
            })
              , Ie = 50
              , ke = "?"
              , Oe = /\(error: (.*)\)/
              , Pe = /captureMessage|captureException/;
            function createStackParser(...v) {
                const E = v.sort(( (v, E) => v[0] - E[0])).map((v => v[1]));
                return (v, k=0, R=0) => {
                    const U = []
                      , H = v.split("\n");
                    for (let v = k; v < H.length; v++) {
                        const k = H[v];
                        if (k.length > 1024)
                            continue;
                        const G = Oe.test(k) ? k.replace(Oe, "$1") : k;
                        if (!G.match(/\S*Error: /)) {
                            for (const v of E) {
                                const E = v(G);
                                if (E) {
                                    U.push(E);
                                    break
                                }
                            }
                            if (U.length >= Ie + R)
                                break
                        }
                    }
                    return function stripSentryFramesAndReverse(v) {
                        if (!v.length)
                            return [];
                        const E = Array.from(v);
                        /sentryWrapped/.test(getLastStackFrame(E).function || "") && E.pop();
                        E.reverse(),
                        Pe.test(getLastStackFrame(E).function || "") && (E.pop(),
                        Pe.test(getLastStackFrame(E).function || "") && E.pop());
                        return E.slice(0, Ie).map((v => ({
                            ...v,
                            "filename": v.filename || getLastStackFrame(E).filename,
                            "function": v.function || ke
                        })))
                    }(U.slice(R))
                }
            }
            function getLastStackFrame(v) {
                return v[v.length - 1] || {}
            }
            const Re = "<anonymous>";
            function getFunctionName(v) {
                try {
                    return v && "function" == typeof v && v.name || Re
                } catch (v) {
                    return Re
                }
            }
            function getFramesFromEvent(v) {
                const E = v.exception;
                if (E) {
                    const v = [];
                    try {
                        return E.values.forEach((E => {
                            E.stacktrace.frames && v.push(...E.stacktrace.frames)
                        }
                        )),
                        v
                    } catch (v) {
                        return
                    }
                }
            }
            const dedupeIntegration = () => {
                let v;
                return {
                    "name": "Dedupe",
                    "processEvent"(E) {
                        if (E.type)
                            return E;
                        try {
                            if (function dedupe_shouldDropEvent(v, E) {
                                if (!E)
                                    return !1;
                                if (function _isSameMessageEvent(v, E) {
                                    const k = v.message
                                      , R = E.message;
                                    if (!k && !R)
                                        return !1;
                                    if (k && !R || !k && R)
                                        return !1;
                                    if (k !== R)
                                        return !1;
                                    if (!_isSameFingerprint(v, E))
                                        return !1;
                                    if (!_isSameStacktrace(v, E))
                                        return !1;
                                    return !0
                                }(v, E))
                                    return !0;
                                if (function _isSameExceptionEvent(v, E) {
                                    const k = _getExceptionFromEvent(E)
                                      , R = _getExceptionFromEvent(v);
                                    if (!k || !R)
                                        return !1;
                                    if (k.type !== R.type || k.value !== R.value)
                                        return !1;
                                    if (!_isSameFingerprint(v, E))
                                        return !1;
                                    if (!_isSameStacktrace(v, E))
                                        return !1;
                                    return !0
                                }(v, E))
                                    return !0;
                                return !1
                            }(E, v))
                                return _e && fe.warn("Event dropped due to being a duplicate of previously captured event."),
                                null
                        } catch (v) {}
                        return v = E
                    }
                }
            }
            ;
            function _isSameStacktrace(v, E) {
                let k = getFramesFromEvent(v)
                  , R = getFramesFromEvent(E);
                if (!k && !R)
                    return !0;
                if (k && !R || !k && R)
                    return !1;
                if (R.length !== k.length)
                    return !1;
                for (let v = 0; v < R.length; v++) {
                    const E = R[v]
                      , U = k[v];
                    if (E.filename !== U.filename || E.lineno !== U.lineno || E.colno !== U.colno || E.function !== U.function)
                        return !1
                }
                return !0
            }
            function _isSameFingerprint(v, E) {
                let k = v.fingerprint
                  , R = E.fingerprint;
                if (!k && !R)
                    return !0;
                if (k && !R || !k && R)
                    return !1;
                try {
                    return !(k.join("") !== R.join(""))
                } catch (v) {
                    return !1
                }
            }
            function _getExceptionFromEvent(v) {
                return v.exception && v.exception.values && v.exception.values[0]
            }
            function setCurrentClient(v) {
                currentScopes_getCurrentScope().setClient(v)
            }
            const Me = "production";
            function normalize_normalize(v, E=100, k=1 / 0) {
                try {
                    return visit("", v, E, k)
                } catch (v) {
                    return {
                        "ERROR": `**non-serializable** (${v})`
                    }
                }
            }
            function normalizeToSize(v, E=3, k=102400) {
                const R = normalize_normalize(v, E);
                return function jsonSize(v) {
                    return function utf8Length(v) {
                        return ~-encodeURI(v).split(/%..|./).length
                    }(JSON.stringify(v))
                }(R) > k ? normalizeToSize(v, E - 1, k) : R
            }
            function visit(v, E, k=1 / 0, R=1 / 0, U=function memoBuilder() {
                const v = "function" == typeof WeakSet
                  , E = v ? new WeakSet : [];
                return [function memoize(k) {
                    if (v)
                        return !!E.has(k) || (E.add(k),
                        !1);
                    for (let v = 0; v < E.length; v++)
                        if (E[v] === k)
                            return !0;
                    return E.push(k),
                    !1
                }
                , function unmemoize(k) {
                    if (v)
                        E.delete(k);
                    else
                        for (let v = 0; v < E.length; v++)
                            if (E[v] === k) {
                                E.splice(v, 1);
                                break
                            }
                }
                ]
            }()) {
                const [H,G] = U;
                if (null == E || ["number", "boolean", "string"].includes(typeof E) && !Number.isNaN(E))
                    return E;
                const W = function stringifyValue(v, E) {
                    try {
                        if ("domain" === v && E && "object" == typeof E && E._events)
                            return "[Domain]";
                        if ("domainEmitter" === v)
                            return "[DomainEmitter]";
                        if ("undefined" != typeof global && E === global)
                            return "[Global]";
                        if ("undefined" != typeof window && E === window)
                            return "[Window]";
                        if ("undefined" != typeof document && E === document)
                            return "[Document]";
                        if (is_isVueViewModel(E))
                            return "[VueViewModel]";
                        if (function isSyntheticEvent(v) {
                            return isPlainObject(v) && "nativeEvent"in v && "preventDefault"in v && "stopPropagation"in v
                        }(E))
                            return "[SyntheticEvent]";
                        if ("number" == typeof E && E != E)
                            return "[NaN]";
                        if ("function" == typeof E)
                            return `[Function: ${getFunctionName(E)}]`;
                        if ("symbol" == typeof E)
                            return `[${String(E)}]`;
                        if ("bigint" == typeof E)
                            return `[BigInt: ${String(E)}]`;
                        const k = function getConstructorName(v) {
                            const E = Object.getPrototypeOf(v);
                            return E ? E.constructor.name : "null prototype"
                        }(E);
                        return /^HTML(\w*)Element$/.test(k) ? `[HTMLElement: ${k}]` : `[object ${k}]`
                    } catch (v) {
                        return `**non-serializable** (${v})`
                    }
                }(v, E);
                if (!W.startsWith("[object "))
                    return W;
                if (E.__sentry_skip_normalization__)
                    return E;
                const Z = "number" == typeof E.__sentry_override_normalization_depth__ ? E.__sentry_override_normalization_depth__ : k;
                if (0 === Z)
                    return W.replace("object ", "");
                if (H(E))
                    return "[Circular ~]";
                const Y = E;
                if (Y && "function" == typeof Y.toJSON)
                    try {
                        return visit("", Y.toJSON(), Z - 1, R, U)
                    } catch (v) {}
                const J = Array.isArray(E) ? [] : {};
                let K = 0;
                const X = convertToPlainObject(E);
                for (const v in X) {
                    if (!Object.prototype.hasOwnProperty.call(X, v))
                        continue;
                    if (K >= R) {
                        J[v] = "[MaxProperties ~]";
                        break
                    }
                    const E = X[v];
                    J[v] = visit(v, E, Z - 1, R, U),
                    K++
                }
                return G(E),
                J
            }
            var Ne;
            function resolvedSyncPromise(v) {
                return new SyncPromise((E => {
                    E(v)
                }
                ))
            }
            function rejectedSyncPromise(v) {
                return new SyncPromise(( (E, k) => {
                    k(v)
                }
                ))
            }
            !function(v) {
                v[v.PENDING = 0] = "PENDING";
                v[v.RESOLVED = 1] = "RESOLVED";
                v[v.REJECTED = 2] = "REJECTED"
            }(Ne || (Ne = {}));
            class SyncPromise {
                "constructor"(v) {
                    SyncPromise.prototype.__init.call(this),
                    SyncPromise.prototype.__init2.call(this),
                    SyncPromise.prototype.__init3.call(this),
                    SyncPromise.prototype.__init4.call(this),
                    this._state = Ne.PENDING,
                    this._handlers = [];
                    try {
                        v(this._resolve, this._reject)
                    } catch (v) {
                        this._reject(v)
                    }
                }
                "then"(v, E) {
                    return new SyncPromise(( (k, R) => {
                        this._handlers.push([!1, E => {
                            if (v)
                                try {
                                    k(v(E))
                                } catch (v) {
                                    R(v)
                                }
                            else
                                k(E)
                        }
                        , v => {
                            if (E)
                                try {
                                    k(E(v))
                                } catch (v) {
                                    R(v)
                                }
                            else
                                R(v)
                        }
                        ]),
                        this._executeHandlers()
                    }
                    ))
                }
                "catch"(v) {
                    return this.then((v => v), v)
                }
                "finally"(v) {
                    return new SyncPromise(( (E, k) => {
                        let R, U;
                        return this.then((E => {
                            U = !1,
                            R = E,
                            v && v()
                        }
                        ), (E => {
                            U = !0,
                            R = E,
                            v && v()
                        }
                        )).then(( () => {
                            U ? k(R) : E(R)
                        }
                        ))
                    }
                    ))
                }
                "__init"() {
                    this._resolve = v => {
                        this._setResult(Ne.RESOLVED, v)
                    }
                }
                "__init2"() {
                    this._reject = v => {
                        this._setResult(Ne.REJECTED, v)
                    }
                }
                "__init3"() {
                    this._setResult = (v, E) => {
                        this._state === Ne.PENDING && (is_isThenable(E) ? E.then(this._resolve, this._reject) : (this._state = v,
                        this._value = E,
                        this._executeHandlers()))
                    }
                }
                "__init4"() {
                    this._executeHandlers = () => {
                        if (this._state === Ne.PENDING)
                            return;
                        const v = this._handlers.slice();
                        this._handlers = [],
                        v.forEach((v => {
                            v[0] || (this._state === Ne.RESOLVED && v[1](this._value),
                            this._state === Ne.REJECTED && v[2](this._value),
                            v[0] = !0)
                        }
                        ))
                    }
                }
            }
            function eventProcessors_notifyEventProcessors(v, E, k, R=0) {
                return new SyncPromise(( (U, H) => {
                    const G = v[R];
                    if (null === E || "function" != typeof G)
                        U(E);
                    else {
                        const W = G({
                            ...E
                        }, k);
                        _e && G.id && null === W && fe.log(`Event processor "${G.id}" dropped event`),
                        is_isThenable(W) ? W.then((E => eventProcessors_notifyEventProcessors(v, E, k, R + 1).then(U))).then(null, H) : eventProcessors_notifyEventProcessors(v, W, k, R + 1).then(U).then(null, H)
                    }
                }
                ))
            }
            const De = "baggage"
              , $e = "sentry-"
              , Le = /^sentry-/
              , Fe = 8192;
            function baggageHeaderToDynamicSamplingContext(v) {
                const E = function parseBaggageHeader(v) {
                    if (!v || !is_isString(v) && !Array.isArray(v))
                        return;
                    if (Array.isArray(v))
                        return v.reduce(( (v, E) => {
                            const k = baggageHeaderToObject(E);
                            return Object.entries(k).forEach(( ([E,k]) => {
                                v[E] = k
                            }
                            )),
                            v
                        }
                        ), {});
                    return baggageHeaderToObject(v)
                }(v);
                if (!E)
                    return;
                const k = Object.entries(E).reduce(( (v, [E,k]) => {
                    if (E.match(Le)) {
                        v[E.slice($e.length)] = k
                    }
                    return v
                }
                ), {});
                return Object.keys(k).length > 0 ? k : void 0
            }
            function baggage_dynamicSamplingContextToSentryBaggageHeader(v) {
                if (!v)
                    return;
                return function objectToBaggageHeader(v) {
                    if (0 === Object.keys(v).length)
                        return;
                    return Object.entries(v).reduce(( (v, [E,k], R) => {
                        const U = `${encodeURIComponent(E)}=${encodeURIComponent(k)}`
                          , H = 0 === R ? U : `${v},${U}`;
                        return H.length > Fe ? (le && fe.warn(`Not adding key: ${E} with val: ${k} to baggage header due to exceeding baggage size limits.`),
                        v) : H
                    }
                    ), "")
                }(Object.entries(v).reduce(( (v, [E,k]) => (k && (v[`${$e}${E}`] = k),
                v)), {}))
            }
            function baggageHeaderToObject(v) {
                return v.split(",").map((v => v.split("=").map((v => decodeURIComponent(v.trim()))))).reduce(( (v, [E,k]) => (E && k && (v[E] = k),
                v)), {})
            }
            const je = "sentry.source"
              , Be = "sentry.sample_rate"
              , Ue = "sentry.op"
              , He = "sentry.origin"
              , ze = "sentry.idle_span_finish_reason"
              , qe = "sentry.measurement_unit"
              , Ge = "sentry.measurement_value"
              , Ve = new RegExp("^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$");
            function tracing_propagationContextFromHeaders(v, E) {
                const k = function extractTraceparentData(v) {
                    if (!v)
                        return;
                    const E = v.match(Ve);
                    if (!E)
                        return;
                    let k;
                    return "1" === E[3] ? k = !0 : "0" === E[3] && (k = !1),
                    {
                        "traceId": E[1],
                        "parentSampled": k,
                        "parentSpanId": E[2]
                    }
                }(v)
                  , R = baggageHeaderToDynamicSamplingContext(E)
                  , {"traceId": U, "parentSpanId": H, "parentSampled": G} = k || {};
                return k ? {
                    "traceId": U || misc_uuid4(),
                    "parentSpanId": H || misc_uuid4().substring(16),
                    "spanId": misc_uuid4().substring(16),
                    "sampled": G,
                    "dsc": R || {}
                } : {
                    "traceId": U || misc_uuid4(),
                    "spanId": misc_uuid4().substring(16)
                }
            }
            function tracing_generateSentryTraceHeader(v=misc_uuid4(), E=misc_uuid4().substring(16), k) {
                let R = "";
                return void 0 !== k && (R = k ? "-1" : "-0"),
                `${v}-${E}${R}`
            }
            const We = "_sentryMetrics";
            function getMetricSummaryJsonForSpan(v) {
                const E = v[We];
                if (!E)
                    return;
                const k = {};
                for (const [,[v,R]] of E) {
                    (k[v] || (k[v] = [])).push(object_dropUndefinedKeys(R))
                }
                return k
            }
            const Ze = 0
              , Ye = 1
              , Je = 2;
            function getSpanStatusFromHttpCode(v) {
                if (v < 400 && v >= 100)
                    return {
                        "code": Ye
                    };
                if (v >= 400 && v < 500)
                    switch (v) {
                    case 401:
                        return {
                            "code": Je,
                            "message": "unauthenticated"
                        };
                    case 403:
                        return {
                            "code": Je,
                            "message": "permission_denied"
                        };
                    case 404:
                        return {
                            "code": Je,
                            "message": "not_found"
                        };
                    case 409:
                        return {
                            "code": Je,
                            "message": "already_exists"
                        };
                    case 413:
                        return {
                            "code": Je,
                            "message": "failed_precondition"
                        };
                    case 429:
                        return {
                            "code": Je,
                            "message": "resource_exhausted"
                        };
                    case 499:
                        return {
                            "code": Je,
                            "message": "cancelled"
                        };
                    default:
                        return {
                            "code": Je,
                            "message": "invalid_argument"
                        }
                    }
                if (v >= 500 && v < 600)
                    switch (v) {
                    case 501:
                        return {
                            "code": Je,
                            "message": "unimplemented"
                        };
                    case 503:
                        return {
                            "code": Je,
                            "message": "unavailable"
                        };
                    case 504:
                        return {
                            "code": Je,
                            "message": "deadline_exceeded"
                        };
                    default:
                        return {
                            "code": Je,
                            "message": "internal_error"
                        }
                    }
                return {
                    "code": Je,
                    "message": "unknown_error"
                }
            }
            function setHttpStatus(v, E) {
                v.setAttribute("http.response.status_code", E);
                const k = getSpanStatusFromHttpCode(E);
                "unknown_error" !== k.message && v.setStatus(k)
            }
            const Ke = 1;
            function spanToTransactionTraceContext(v) {
                const {"spanId": E, "traceId": k} = v.spanContext()
                  , {"data": R, "op": U, "parent_span_id": H, "status": G, "origin": W} = spanUtils_spanToJSON(v);
                return object_dropUndefinedKeys({
                    "parent_span_id": H,
                    "span_id": E,
                    "trace_id": k,
                    "data": R,
                    "op": U,
                    "status": G,
                    "origin": W
                })
            }
            function spanToTraceContext(v) {
                const {"spanId": E, "traceId": k} = v.spanContext()
                  , {"parent_span_id": R} = spanUtils_spanToJSON(v);
                return object_dropUndefinedKeys({
                    "parent_span_id": R,
                    "span_id": E,
                    "trace_id": k
                })
            }
            function spanToTraceHeader(v) {
                const {"traceId": E, "spanId": k} = v.spanContext();
                return tracing_generateSentryTraceHeader(E, k, spanIsSampled(v))
            }
            function spanTimeInputToSeconds(v) {
                return "number" == typeof v ? ensureTimestampInSeconds(v) : Array.isArray(v) ? v[0] + v[1] / 1e9 : v instanceof Date ? ensureTimestampInSeconds(v.getTime()) : ye()
            }
            function ensureTimestampInSeconds(v) {
                return v > 9999999999 ? v / 1e3 : v
            }
            function spanUtils_spanToJSON(v) {
                if (function spanIsSentrySpan(v) {
                    return "function" == typeof v.getSpanJSON
                }(v))
                    return v.getSpanJSON();
                try {
                    const {"spanId": E, "traceId": k} = v.spanContext();
                    if (function spanIsOpenTelemetrySdkTraceBaseSpan(v) {
                        const E = v;
                        return !!(E.attributes && E.startTime && E.name && E.endTime && E.status)
                    }(v)) {
                        const {"attributes": R, "startTime": U, "name": H, "endTime": G, "parentSpanId": W, "status": Z} = v;
                        return object_dropUndefinedKeys({
                            "span_id": E,
                            "trace_id": k,
                            "data": R,
                            "description": H,
                            "parent_span_id": W,
                            "start_timestamp": spanTimeInputToSeconds(U),
                            "timestamp": spanTimeInputToSeconds(G) || void 0,
                            "status": getStatusMessage(Z),
                            "op": R[Ue],
                            "origin": R[He],
                            "_metrics_summary": getMetricSummaryJsonForSpan(v)
                        })
                    }
                    return {
                        "span_id": E,
                        "trace_id": k
                    }
                } catch (v) {
                    return {}
                }
            }
            function spanIsSampled(v) {
                const {"traceFlags": E} = v.spanContext();
                return E === Ke
            }
            function getStatusMessage(v) {
                if (v && v.code !== Ze)
                    return v.code === Ye ? "ok" : v.message || "unknown_error"
            }
            const Xe = "_sentryChildSpans"
              , Qe = "_sentryRootSpan";
            function addChildSpanToSpan(v, E) {
                const k = v[Qe] || v;
                object_addNonEnumerableProperty(E, Qe, k),
                v[Xe] ? v[Xe].add(E) : object_addNonEnumerableProperty(v, Xe, new Set([E]))
            }
            function getSpanDescendants(v) {
                const E = new Set;
                return function addSpanChildren(v) {
                    if (!E.has(v) && spanIsSampled(v)) {
                        E.add(v);
                        const k = v[Xe] ? Array.from(v[Xe]) : [];
                        for (const v of k)
                            addSpanChildren(v)
                    }
                }(v),
                Array.from(E)
            }
            function getRootSpan(v) {
                return v[Qe] || v
            }
            function getActiveSpan() {
                const v = asyncContext_getAsyncContextStrategy(carrier_getMainCarrier());
                return v.getActiveSpan ? v.getActiveSpan() : _getSpanForScope(currentScopes_getCurrentScope())
            }
            function updateMetricSummaryOnActiveSpan(v, E, k, R, U, H) {
                const G = getActiveSpan();
                G && function metric_summary_updateMetricSummaryOnSpan(v, E, k, R, U, H, G) {
                    const W = v[We] || (v[We] = new Map)
                      , Z = `${E}:${k}@${U}`
                      , Y = W.get(G);
                    if (Y) {
                        const [,v] = Y;
                        W.set(G, [Z, {
                            "min": Math.min(v.min, R),
                            "max": Math.max(v.max, R),
                            "count": v.count += 1,
                            "sum": v.sum += R,
                            "tags": v.tags
                        }])
                    } else
                        W.set(G, [Z, {
                            "min": R,
                            "max": R,
                            "count": 1,
                            "sum": R,
                            "tags": H
                        }])
                }(G, v, E, k, R, U, H)
            }
            const et = "_frozenDsc";
            function freezeDscOnSpan(v, E) {
                object_addNonEnumerableProperty(v, et, E)
            }
            function getDynamicSamplingContextFromClient(v, E) {
                const k = E.getOptions()
                  , {"publicKey": R} = E.getDsn() || {}
                  , U = object_dropUndefinedKeys({
                    "environment": k.environment || Me,
                    "release": k.release,
                    "public_key": R,
                    "trace_id": v
                });
                return E.emit("createDsc", U),
                U
            }
            function getDynamicSamplingContextFromSpan(v) {
                const E = currentScopes_getClient();
                if (!E)
                    return {};
                const k = getDynamicSamplingContextFromClient(spanUtils_spanToJSON(v).trace_id || "", E)
                  , R = getRootSpan(v)
                  , U = R[et];
                if (U)
                    return U;
                const H = R.spanContext().traceState
                  , G = H && H.get("sentry.dsc")
                  , W = G && baggageHeaderToDynamicSamplingContext(G);
                if (W)
                    return W;
                const Z = spanUtils_spanToJSON(R)
                  , Y = Z.data || {}
                  , J = Y[Be];
                null != J && (k.sample_rate = `${J}`);
                const K = Y[je]
                  , X = Z.description;
                return "url" !== K && X && (k.transaction = X),
                k.sampled = String(spanIsSampled(R)),
                E.emit("createDsc", k, R),
                k
            }
            function spanToBaggageHeader(v) {
                return baggage_dynamicSamplingContextToSentryBaggageHeader(getDynamicSamplingContextFromSpan(v))
            }
            function applyScopeDataToEvent_applyScopeDataToEvent(v, E) {
                const {"fingerprint": k, "span": R, "breadcrumbs": U, "sdkProcessingMetadata": H} = E;
                !function applyDataToEvent(v, E) {
                    const {"extra": k, "tags": R, "user": U, "contexts": H, "level": G, "transactionName": W} = E
                      , Z = object_dropUndefinedKeys(k);
                    Z && Object.keys(Z).length && (v.extra = {
                        ...Z,
                        ...v.extra
                    });
                    const Y = object_dropUndefinedKeys(R);
                    Y && Object.keys(Y).length && (v.tags = {
                        ...Y,
                        ...v.tags
                    });
                    const J = object_dropUndefinedKeys(U);
                    J && Object.keys(J).length && (v.user = {
                        ...J,
                        ...v.user
                    });
                    const K = object_dropUndefinedKeys(H);
                    K && Object.keys(K).length && (v.contexts = {
                        ...K,
                        ...v.contexts
                    });
                    G && (v.level = G);
                    W && "transaction" !== v.type && (v.transaction = W)
                }(v, E),
                R && function applySpanToEvent(v, E) {
                    v.contexts = {
                        "trace": spanToTraceContext(E),
                        ...v.contexts
                    },
                    v.sdkProcessingMetadata = {
                        "dynamicSamplingContext": getDynamicSamplingContextFromSpan(E),
                        ...v.sdkProcessingMetadata
                    };
                    const k = getRootSpan(E)
                      , R = spanUtils_spanToJSON(k).description;
                    R && !v.transaction && "transaction" === v.type && (v.transaction = R)
                }(v, R),
                function applyFingerprintToEvent(v, E) {
                    v.fingerprint = v.fingerprint ? misc_arrayify(v.fingerprint) : [],
                    E && (v.fingerprint = v.fingerprint.concat(E));
                    v.fingerprint && !v.fingerprint.length && delete v.fingerprint
                }(v, k),
                function applyBreadcrumbsToEvent(v, E) {
                    const k = [...v.breadcrumbs || [], ...E];
                    v.breadcrumbs = k.length ? k : void 0
                }(v, U),
                function applySdkMetadataToEvent(v, E) {
                    v.sdkProcessingMetadata = {
                        ...v.sdkProcessingMetadata,
                        ...E
                    }
                }(v, H)
            }
            function applyScopeDataToEvent_mergeScopeData(v, E) {
                const {"extra": k, "tags": R, "user": U, "contexts": H, "level": G, "sdkProcessingMetadata": W, "breadcrumbs": Z, "fingerprint": Y, "eventProcessors": J, "attachments": K, "propagationContext": X, "transactionName": Q, "span": ee} = E;
                mergeAndOverwriteScopeData(v, "extra", k),
                mergeAndOverwriteScopeData(v, "tags", R),
                mergeAndOverwriteScopeData(v, "user", U),
                mergeAndOverwriteScopeData(v, "contexts", H),
                mergeAndOverwriteScopeData(v, "sdkProcessingMetadata", W),
                G && (v.level = G),
                Q && (v.transactionName = Q),
                ee && (v.span = ee),
                Z.length && (v.breadcrumbs = [...v.breadcrumbs, ...Z]),
                Y.length && (v.fingerprint = [...v.fingerprint, ...Y]),
                J.length && (v.eventProcessors = [...v.eventProcessors, ...J]),
                K.length && (v.attachments = [...v.attachments, ...K]),
                v.propagationContext = {
                    ...v.propagationContext,
                    ...X
                }
            }
            function mergeAndOverwriteScopeData(v, E, k) {
                if (k && Object.keys(k).length) {
                    v[E] = {
                        ...v[E]
                    };
                    for (const R in k)
                        Object.prototype.hasOwnProperty.call(k, R) && (v[E][R] = k[R])
                }
            }
            function prepareEvent(v, E, k, R, U, H) {
                const {"normalizeDepth": G=3, "normalizeMaxBreadth": W=1e3} = v
                  , Z = {
                    ...E,
                    "event_id": E.event_id || k.event_id || misc_uuid4(),
                    "timestamp": E.timestamp || time_dateTimestampInSeconds()
                }
                  , Y = k.integrations || v.integrations.map((v => v.name));
                !function applyClientOptions(v, E) {
                    const {"environment": k, "release": R, "dist": U, "maxValueLength": H=250} = E;
                    "environment"in v || (v.environment = "environment"in E ? k : Me);
                    void 0 === v.release && void 0 !== R && (v.release = R);
                    void 0 === v.dist && void 0 !== U && (v.dist = U);
                    v.message && (v.message = string_truncate(v.message, H));
                    const G = v.exception && v.exception.values && v.exception.values[0];
                    G && G.value && (G.value = string_truncate(G.value, H));
                    const W = v.request;
                    W && W.url && (W.url = string_truncate(W.url, H))
                }(Z, v),
                function applyIntegrationsMetadata(v, E) {
                    E.length > 0 && (v.sdk = v.sdk || {},
                    v.sdk.integrations = [...v.sdk.integrations || [], ...E])
                }(Z, Y),
                U && U.emit("applyFrameMetadata", E),
                void 0 === E.type && function applyDebugIds(v, E) {
                    const k = ue._sentryDebugIds;
                    if (!k)
                        return;
                    let R;
                    const U = tt.get(E);
                    U ? R = U : (R = new Map,
                    tt.set(E, R));
                    const H = Object.entries(k).reduce(( (v, [k,U]) => {
                        let H;
                        const G = R.get(k);
                        G ? H = G : (H = E(k),
                        R.set(k, H));
                        for (let E = H.length - 1; E >= 0; E--) {
                            const k = H[E];
                            if (k.filename) {
                                v[k.filename] = U;
                                break
                            }
                        }
                        return v
                    }
                    ), {});
                    try {
                        v.exception.values.forEach((v => {
                            v.stacktrace.frames.forEach((v => {
                                v.filename && (v.debug_id = H[v.filename])
                            }
                            ))
                        }
                        ))
                    } catch (v) {}
                }(Z, v.stackParser);
                const J = function getFinalScope(v, E) {
                    if (!E)
                        return v;
                    const k = v ? v.clone() : new Ee;
                    return k.update(E),
                    k
                }(R, k.captureContext);
                k.mechanism && misc_addExceptionMechanism(Z, k.mechanism);
                const K = U ? U.getEventProcessors() : []
                  , X = currentScopes_getGlobalScope().getScopeData();
                if (H) {
                    applyScopeDataToEvent_mergeScopeData(X, H.getScopeData())
                }
                if (J) {
                    applyScopeDataToEvent_mergeScopeData(X, J.getScopeData())
                }
                const Q = [...k.attachments || [], ...X.attachments];
                Q.length && (k.attachments = Q),
                applyScopeDataToEvent_applyScopeDataToEvent(Z, X);
                return eventProcessors_notifyEventProcessors([...K, ...X.eventProcessors], Z, k).then((v => (v && function applyDebugMeta(v) {
                    const E = {};
                    try {
                        v.exception.values.forEach((v => {
                            v.stacktrace.frames.forEach((v => {
                                v.debug_id && (v.abs_path ? E[v.abs_path] = v.debug_id : v.filename && (E[v.filename] = v.debug_id),
                                delete v.debug_id)
                            }
                            ))
                        }
                        ))
                    } catch (v) {}
                    if (0 === Object.keys(E).length)
                        return;
                    v.debug_meta = v.debug_meta || {},
                    v.debug_meta.images = v.debug_meta.images || [];
                    const k = v.debug_meta.images;
                    Object.entries(E).forEach(( ([v,E]) => {
                        k.push({
                            "type": "sourcemap",
                            "code_file": v,
                            "debug_id": E
                        })
                    }
                    ))
                }(v),
                "number" == typeof G && G > 0 ? function normalizeEvent(v, E, k) {
                    if (!v)
                        return null;
                    const R = {
                        ...v,
                        ...v.breadcrumbs && {
                            "breadcrumbs": v.breadcrumbs.map((v => ({
                                ...v,
                                ...v.data && {
                                    "data": normalize_normalize(v.data, E, k)
                                }
                            })))
                        },
                        ...v.user && {
                            "user": normalize_normalize(v.user, E, k)
                        },
                        ...v.contexts && {
                            "contexts": normalize_normalize(v.contexts, E, k)
                        },
                        ...v.extra && {
                            "extra": normalize_normalize(v.extra, E, k)
                        }
                    };
                    v.contexts && v.contexts.trace && R.contexts && (R.contexts.trace = v.contexts.trace,
                    v.contexts.trace.data && (R.contexts.trace.data = normalize_normalize(v.contexts.trace.data, E, k)));
                    v.spans && (R.spans = v.spans.map((v => ({
                        ...v,
                        ...v.data && {
                            "data": normalize_normalize(v.data, E, k)
                        }
                    }))));
                    return R
                }(v, G, W) : v)))
            }
            const tt = new WeakMap;
            function parseEventHintOrCaptureContext(v) {
                if (v)
                    return function hintIsScopeOrFunction(v) {
                        return v instanceof Ee || "function" == typeof v
                    }(v) || function hintIsScopeContext(v) {
                        return Object.keys(v).some((v => nt.includes(v)))
                    }(v) ? {
                        "captureContext": v
                    } : v
            }
            const nt = ["user", "level", "extra", "contexts", "tags", "fingerprint", "requestSession", "propagationContext"];
            function captureException(v, E) {
                return currentScopes_getCurrentScope().captureException(v, parseEventHintOrCaptureContext(E))
            }
            function captureMessage(v, E) {
                const k = "string" == typeof E ? E : void 0
                  , R = "string" != typeof E ? {
                    "captureContext": E
                } : void 0;
                return currentScopes_getCurrentScope().captureMessage(v, k, R)
            }
            function captureEvent(v, E) {
                return currentScopes_getCurrentScope().captureEvent(v, E)
            }
            function setContext(v, E) {
                currentScopes_getIsolationScope().setContext(v, E)
            }
            function setExtras(v) {
                currentScopes_getIsolationScope().setExtras(v)
            }
            function setExtra(v, E) {
                currentScopes_getIsolationScope().setExtra(v, E)
            }
            function setTags(v) {
                currentScopes_getIsolationScope().setTags(v)
            }
            function setTag(v, E) {
                currentScopes_getIsolationScope().setTag(v, E)
            }
            function setUser(v) {
                currentScopes_getIsolationScope().setUser(v)
            }
            function lastEventId() {
                return currentScopes_getIsolationScope().lastEventId()
            }
            async function flush(v) {
                const E = currentScopes_getClient();
                return E ? E.flush(v) : (_e && fe.warn("Cannot flush events. No client defined."),
                Promise.resolve(!1))
            }
            async function exports_close(v) {
                const E = currentScopes_getClient();
                return E ? E.close(v) : (_e && fe.warn("Cannot flush events and disable SDK. No client defined."),
                Promise.resolve(!1))
            }
            function isInitialized() {
                return !!currentScopes_getClient()
            }
            function addEventProcessor(v) {
                currentScopes_getIsolationScope().addEventProcessor(v)
            }
            function startSession(v) {
                const E = currentScopes_getClient()
                  , k = currentScopes_getIsolationScope()
                  , R = currentScopes_getCurrentScope()
                  , {"release": U, "environment": H=Me} = E && E.getOptions() || {}
                  , {"userAgent": G} = ue.navigator || {}
                  , W = session_makeSession({
                    "release": U,
                    "environment": H,
                    "user": R.getUser() || k.getUser(),
                    ...G && {
                        "userAgent": G
                    },
                    ...v
                })
                  , Z = k.getSession();
                return Z && "ok" === Z.status && session_updateSession(Z, {
                    "status": "exited"
                }),
                endSession(),
                k.setSession(W),
                R.setSession(W),
                W
            }
            function endSession() {
                const v = currentScopes_getIsolationScope()
                  , E = currentScopes_getCurrentScope()
                  , k = E.getSession() || v.getSession();
                k && function session_closeSession(v, E) {
                    let k = {};
                    E ? k = {
                        "status": E
                    } : "ok" === v.status && (k = {
                        "status": "exited"
                    }),
                    session_updateSession(v, k)
                }(k),
                _sendSessionUpdate(),
                v.setSession(),
                E.setSession()
            }
            function _sendSessionUpdate() {
                const v = currentScopes_getIsolationScope()
                  , E = currentScopes_getCurrentScope()
                  , k = currentScopes_getClient()
                  , R = E.getSession() || v.getSession();
                R && k && k.captureSession(R)
            }
            function captureSession(v=!1) {
                v ? endSession() : _sendSessionUpdate()
            }
            const rt = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
            function dsn_dsnToString(v, E=!1) {
                const {"host": k, "path": R, "pass": U, "port": H, "projectId": G, "protocol": W, "publicKey": Z} = v;
                return `${W}://${Z}${E && U ? `:${U}` : ""}@${k}${H ? `:${H}` : ""}/${R ? `${R}/` : R}${G}`
            }
            function dsnFromString(v) {
                const E = rt.exec(v);
                if (!E)
                    return void logger_consoleSandbox(( () => {
                        console.error(`Invalid Sentry Dsn: ${v}`)
                    }
                    ));
                const [k,R,U="",H="",G="",W=""] = E.slice(1);
                let Z = ""
                  , Y = W;
                const J = Y.split("/");
                if (J.length > 1 && (Z = J.slice(0, -1).join("/"),
                Y = J.pop()),
                Y) {
                    const v = Y.match(/^\d+/);
                    v && (Y = v[0])
                }
                return dsnFromComponents({
                    "host": H,
                    "pass": U,
                    "path": Z,
                    "projectId": Y,
                    "port": G,
                    "protocol": k,
                    "publicKey": R
                })
            }
            function dsnFromComponents(v) {
                return {
                    "protocol": v.protocol,
                    "publicKey": v.publicKey || "",
                    "pass": v.pass || "",
                    "host": v.host,
                    "port": v.port || "",
                    "path": v.path || "",
                    "projectId": v.projectId
                }
            }
            function makeDsn(v) {
                const E = "string" == typeof v ? dsnFromString(v) : dsnFromComponents(v);
                if (E && function validateDsn(v) {
                    if (!le)
                        return !0;
                    const {"port": E, "projectId": k, "protocol": R} = v;
                    return !(["protocol", "publicKey", "host", "projectId"].find((E => !v[E] && (fe.error(`Invalid Sentry Dsn: ${E} missing`),
                    !0))) || (k.match(/^\d+$/) ? function isValidProtocol(v) {
                        return "http" === v || "https" === v
                    }(R) ? E && isNaN(parseInt(E, 10)) && (fe.error(`Invalid Sentry Dsn: Invalid port ${E}`),
                    1) : (fe.error(`Invalid Sentry Dsn: Invalid protocol ${R}`),
                    1) : (fe.error(`Invalid Sentry Dsn: Invalid projectId ${k}`),
                    1)))
                }(E))
                    return E
            }
            const ot = "7";
            function getBaseApiEndpoint(v) {
                const E = v.protocol ? `${v.protocol}:` : ""
                  , k = v.port ? `:${v.port}` : "";
                return `${E}//${v.host}${k}${v.path ? `/${v.path}` : ""}/api/`
            }
            function _encodedAuth(v, E) {
                return function urlEncode(v) {
                    return Object.keys(v).map((E => `${encodeURIComponent(E)}=${encodeURIComponent(v[E])}`)).join("&")
                }({
                    "sentry_key": v.publicKey,
                    "sentry_version": ot,
                    ...E && {
                        "sentry_client": `${E.name}/${E.version}`
                    }
                })
            }
            function getEnvelopeEndpointWithUrlEncodedAuth(v, E, k) {
                return E || `${function _getIngestEndpoint(v) {
                    return `${getBaseApiEndpoint(v)}${v.projectId}/envelope/`
                }(v)}?${_encodedAuth(v, k)}`
            }
            const it = ue;
            function supportsFetch() {
                if (!("fetch"in it))
                    return !1;
                try {
                    return new Headers,
                    new Request("http://www.example.com"),
                    new Response,
                    !0
                } catch (v) {
                    return !1
                }
            }
            function isNativeFunction(v) {
                return v && /^function\s+\w+\(\)\s+\{\s+\[native code\]\s+\}$/.test(v.toString())
            }
            function supportsNativeFetch() {
                if ("string" == typeof EdgeRuntime)
                    return !0;
                if (!supportsFetch())
                    return !1;
                if (isNativeFunction(it.fetch))
                    return !0;
                let v = !1;
                const E = it.document;
                if (E && "function" == typeof E.createElement)
                    try {
                        const k = E.createElement("iframe");
                        k.hidden = !0,
                        E.head.appendChild(k),
                        k.contentWindow && k.contentWindow.fetch && (v = isNativeFunction(k.contentWindow.fetch)),
                        E.head.removeChild(k)
                    } catch (v) {
                        le && fe.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", v)
                    }
                return v
            }
            const at = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__
              , st = "8.30.0"
              , ct = globalThis;
            function esm_worldwide_getGlobalSingleton(v, E, k) {
                const R = k || ct
                  , U = R.__SENTRY__ = R.__SENTRY__ || {}
                  , H = U[st] = U[st] || {};
                return H[v] || (H[v] = E())
            }
            const lt = ["debug", "info", "warn", "error", "log", "assert", "trace"]
              , ut = {};
            const dt = esm_worldwide_getGlobalSingleton("logger", (function logger_makeLogger() {
                let v = !1;
                const E = {
                    "enable": () => {
                        v = !0
                    }
                    ,
                    "disable": () => {
                        v = !1
                    }
                    ,
                    "isEnabled": () => v
                };
                return at ? lt.forEach((k => {
                    E[k] = (...E) => {
                        v && function esm_logger_consoleSandbox(v) {
                            if (!("console"in ct))
                                return v();
                            const E = ct.console
                              , k = {}
                              , R = Object.keys(ut);
                            R.forEach((v => {
                                const R = ut[v];
                                k[v] = E[v],
                                E[v] = R
                            }
                            ));
                            try {
                                return v()
                            } finally {
                                R.forEach((v => {
                                    E[v] = k[v]
                                }
                                ))
                            }
                        }(( () => {
                            ct.console[k](`Sentry Logger [${k}]:`, ...E)
                        }
                        ))
                    }
                }
                )) : lt.forEach((v => {
                    E[v] = () => {}
                }
                )),
                E
            }
            ));
            const pt = "<anonymous>";
            function stacktrace_getFunctionName(v) {
                try {
                    return v && "function" == typeof v && v.name || pt
                } catch (v) {
                    return pt
                }
            }
            const ft = {}
              , ht = {};
            function addHandler(v, E) {
                ft[v] = ft[v] || [],
                ft[v].push(E)
            }
            function maybeInstrument(v, E) {
                ht[v] || (E(),
                ht[v] = !0)
            }
            function triggerHandlers(v, E) {
                const k = v && ft[v];
                if (k)
                    for (const R of k)
                        try {
                            R(E)
                        } catch (E) {
                            at && dt.error(`Error while triggering instrumentation handler.\nType: ${v}\nName: ${stacktrace_getFunctionName(R)}\nError:`, E)
                        }
            }
            const mt = ct;
            const gt = Object.prototype.toString;
            function is_isBuiltin(v, E) {
                return gt.call(v) === `[object ${E}]`
            }
            function esm_is_isString(v) {
                return is_isBuiltin(v, "String")
            }
            function is_isPlainObject(v) {
                return is_isBuiltin(v, "Object")
            }
            function object_fill(v, E, k) {
                if (!(E in v))
                    return;
                const R = v[E]
                  , U = k(R);
                "function" == typeof U && function object_markFunctionWrapped(v, E) {
                    try {
                        const k = E.prototype || {};
                        v.prototype = E.prototype = k,
                        esm_object_addNonEnumerableProperty(v, "__sentry_original__", E)
                    } catch (v) {}
                }(U, R),
                v[E] = U
            }
            function esm_object_addNonEnumerableProperty(v, E, k) {
                try {
                    Object.defineProperty(v, E, {
                        "value": k,
                        "writable": !0,
                        "configurable": !0
                    })
                } catch (k) {
                    at && dt.log(`Failed to add non-enumerable property "${E}" to object`, v)
                }
            }
            function esm_object_dropUndefinedKeys(v) {
                return build_esm_object_dropUndefinedKeys(v, new Map)
            }
            function build_esm_object_dropUndefinedKeys(v, E) {
                if (function object_isPojo(v) {
                    if (!is_isPlainObject(v))
                        return !1;
                    try {
                        const E = Object.getPrototypeOf(v).constructor.name;
                        return !E || "Object" === E
                    } catch (v) {
                        return !0
                    }
                }(v)) {
                    const k = E.get(v);
                    if (void 0 !== k)
                        return k;
                    const R = {};
                    E.set(v, R);
                    for (const k of Object.keys(v))
                        void 0 !== v[k] && (R[k] = build_esm_object_dropUndefinedKeys(v[k], E));
                    return R
                }
                if (Array.isArray(v)) {
                    const k = E.get(v);
                    if (void 0 !== k)
                        return k;
                    const R = [];
                    return E.set(v, R),
                    v.forEach((v => {
                        R.push(build_esm_object_dropUndefinedKeys(v, E))
                    }
                    )),
                    R
                }
                return v
            }
            const _t = ct;
            let vt;
            function addHistoryInstrumentationHandler(v) {
                const E = "history";
                addHandler(E, v),
                maybeInstrument(E, instrumentHistory)
            }
            function instrumentHistory() {
                if (!function supportsHistory() {
                    const v = mt.chrome
                      , E = v && v.app && v.app.runtime
                      , k = "history"in mt && !!mt.history.pushState && !!mt.history.replaceState;
                    return !E && k
                }())
                    return;
                const v = _t.onpopstate;
                function historyReplacementFunction(v) {
                    return function(...E) {
                        const k = E.length > 2 ? E[2] : void 0;
                        if (k) {
                            const v = vt
                              , E = String(k);
                            vt = E;
                            triggerHandlers("history", {
                                "from": v,
                                "to": E
                            })
                        }
                        return v.apply(this, E)
                    }
                }
                _t.onpopstate = function(...E) {
                    const k = _t.location.href
                      , R = vt;
                    vt = k;
                    if (triggerHandlers("history", {
                        "from": R,
                        "to": k
                    }),
                    v)
                        try {
                            return v.apply(this, E)
                        } catch (v) {}
                }
                ,
                object_fill(_t.history, "pushState", historyReplacementFunction),
                object_fill(_t.history, "replaceState", historyReplacementFunction)
            }
            function envelope_createEnvelope(v, E=[]) {
                return [v, E]
            }
            function addItemToEnvelope(v, E) {
                const [k,R] = v;
                return [k, [...R, E]]
            }
            function forEachEnvelopeItem(v, E) {
                const k = v[1];
                for (const v of k) {
                    if (E(v, v[0].type))
                        return !0
                }
                return !1
            }
            function envelopeContainsItemType(v, E) {
                return forEachEnvelopeItem(v, ( (v, k) => E.includes(k)))
            }
            function encodeUTF8(v) {
                return ue.__SENTRY__ && ue.__SENTRY__.encodePolyfill ? ue.__SENTRY__.encodePolyfill(v) : (new TextEncoder).encode(v)
            }
            function serializeEnvelope(v) {
                const [E,k] = v;
                let R = JSON.stringify(E);
                function append(v) {
                    "string" == typeof R ? R = "string" == typeof v ? R + v : [encodeUTF8(R), v] : R.push("string" == typeof v ? encodeUTF8(v) : v)
                }
                for (const v of k) {
                    const [E,k] = v;
                    if (append(`\n${JSON.stringify(E)}\n`),
                    "string" == typeof k || k instanceof Uint8Array)
                        append(k);
                    else {
                        let v;
                        try {
                            v = JSON.stringify(k)
                        } catch (E) {
                            v = JSON.stringify(normalize_normalize(k))
                        }
                        append(v)
                    }
                }
                return "string" == typeof R ? R : function concatBuffers(v) {
                    const E = v.reduce(( (v, E) => v + E.length), 0)
                      , k = new Uint8Array(E);
                    let R = 0;
                    for (const E of v)
                        k.set(E, R),
                        R += E.length;
                    return k
                }(R)
            }
            function parseEnvelope(v) {
                let E = "string" == typeof v ? encodeUTF8(v) : v;
                function readBinary(v) {
                    const k = E.subarray(0, v);
                    return E = E.subarray(v + 1),
                    k
                }
                function readJson() {
                    let v = E.indexOf(10);
                    return v < 0 && (v = E.length),
                    JSON.parse(function decodeUTF8(v) {
                        return ue.__SENTRY__ && ue.__SENTRY__.decodePolyfill ? ue.__SENTRY__.decodePolyfill(v) : (new TextDecoder).decode(v)
                    }(readBinary(v)))
                }
                const k = readJson()
                  , R = [];
                for (; E.length; ) {
                    const v = readJson()
                      , E = "number" == typeof v.length ? v.length : void 0;
                    R.push([v, E ? readBinary(E) : readJson()])
                }
                return [k, R]
            }
            function createSpanEnvelopeItem(v) {
                return [{
                    "type": "span"
                }, v]
            }
            function createAttachmentEnvelopeItem(v) {
                const E = "string" == typeof v.data ? encodeUTF8(v.data) : v.data;
                return [object_dropUndefinedKeys({
                    "type": "attachment",
                    "length": E.length,
                    "filename": v.filename,
                    "content_type": v.contentType,
                    "attachment_type": v.attachmentType
                }), E]
            }
            const yt = {
                "session": "session",
                "sessions": "session",
                "attachment": "attachment",
                "transaction": "transaction",
                "event": "error",
                "client_report": "internal",
                "user_report": "default",
                "profile": "profile",
                "profile_chunk": "profile",
                "replay_event": "replay",
                "replay_recording": "replay",
                "check_in": "monitor",
                "feedback": "feedback",
                "span": "span",
                "statsd": "metric_bucket"
            };
            function envelopeItemTypeToDataCategory(v) {
                return yt[v]
            }
            function envelope_getSdkMetadataForEnvelopeHeader(v) {
                if (!v || !v.sdk)
                    return;
                const {"name": E, "version": k} = v.sdk;
                return {
                    "name": E,
                    "version": k
                }
            }
            class SentryError extends Error {
                "constructor"(v, E="warn") {
                    super(v),
                    this.message = v,
                    this.name = new.target.prototype.constructor.name,
                    Object.setPrototypeOf(this, new.target.prototype),
                    this.logLevel = E
                }
            }
            function createEventEnvelope(v, E, k, R) {
                const U = envelope_getSdkMetadataForEnvelopeHeader(k)
                  , H = v.type && "replay_event" !== v.type ? v.type : "event";
                !function enhanceEventWithSdkInfo(v, E) {
                    return E ? (v.sdk = v.sdk || {},
                    v.sdk.name = v.sdk.name || E.name,
                    v.sdk.version = v.sdk.version || E.version,
                    v.sdk.integrations = [...v.sdk.integrations || [], ...E.integrations || []],
                    v.sdk.packages = [...v.sdk.packages || [], ...E.packages || []],
                    v) : v
                }(v, k && k.sdk);
                const G = function envelope_createEventEnvelopeHeaders(v, E, k, R) {
                    const U = v.sdkProcessingMetadata && v.sdkProcessingMetadata.dynamicSamplingContext;
                    return {
                        "event_id": v.event_id,
                        "sent_at": (new Date).toISOString(),
                        ...E && {
                            "sdk": E
                        },
                        ...!!k && R && {
                            "dsn": dsn_dsnToString(R)
                        },
                        ...U && {
                            "trace": object_dropUndefinedKeys({
                                ...U
                            })
                        }
                    }
                }(v, U, R, E);
                delete v.sdkProcessingMetadata;
                return envelope_createEnvelope(G, [[{
                    "type": H
                }, v]])
            }
            function parseSampleRate(v) {
                if ("boolean" == typeof v)
                    return Number(v);
                const E = "string" == typeof v ? parseFloat(v) : v;
                if (!("number" != typeof E || isNaN(E) || E < 0 || E > 1))
                    return E;
                _e && fe.warn(`[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(v)} of type ${JSON.stringify(typeof v)}.`)
            }
            const bt = "Not capturing exception because it's already been captured.";
            class BaseClient {
                "constructor"(v) {
                    if (this._options = v,
                    this._integrations = {},
                    this._numProcessing = 0,
                    this._outcomes = {},
                    this._hooks = {},
                    this._eventProcessors = [],
                    v.dsn ? this._dsn = makeDsn(v.dsn) : _e && fe.warn("No DSN provided, client will not send events."),
                    this._dsn) {
                        const E = getEnvelopeEndpointWithUrlEncodedAuth(this._dsn, v.tunnel, v._metadata ? v._metadata.sdk : void 0);
                        this._transport = v.transport({
                            "tunnel": this._options.tunnel,
                            "recordDroppedEvent": this.recordDroppedEvent.bind(this),
                            ...v.transportOptions,
                            "url": E
                        })
                    }
                }
                "captureException"(v, E, k) {
                    const R = misc_uuid4();
                    if (checkOrSetAlreadyCaught(v))
                        return _e && fe.log(bt),
                        R;
                    const U = {
                        "event_id": R,
                        ...E
                    };
                    return this._process(this.eventFromException(v, U).then((v => this._captureEvent(v, U, k)))),
                    U.event_id
                }
                "captureMessage"(v, E, k, R) {
                    const U = {
                        "event_id": misc_uuid4(),
                        ...k
                    }
                      , H = isParameterizedString(v) ? v : String(v)
                      , G = is_isPrimitive(v) ? this.eventFromMessage(H, E, U) : this.eventFromException(v, U);
                    return this._process(G.then((v => this._captureEvent(v, U, R)))),
                    U.event_id
                }
                "captureEvent"(v, E, k) {
                    const R = misc_uuid4();
                    if (E && E.originalException && checkOrSetAlreadyCaught(E.originalException))
                        return _e && fe.log(bt),
                        R;
                    const U = {
                        "event_id": R,
                        ...E
                    }
                      , H = (v.sdkProcessingMetadata || {}).capturedSpanScope;
                    return this._process(this._captureEvent(v, U, H || k)),
                    U.event_id
                }
                "captureSession"(v) {
                    "string" != typeof v.release ? _e && fe.warn("Discarded session because of missing or non-string release") : (this.sendSession(v),
                    session_updateSession(v, {
                        "init": !1
                    }))
                }
                "getDsn"() {
                    return this._dsn
                }
                "getOptions"() {
                    return this._options
                }
                "getSdkMetadata"() {
                    return this._options._metadata
                }
                "getTransport"() {
                    return this._transport
                }
                "flush"(v) {
                    const E = this._transport;
                    return E ? (this.emit("flush"),
                    this._isClientDoneProcessing(v).then((k => E.flush(v).then((v => k && v))))) : resolvedSyncPromise(!0)
                }
                "close"(v) {
                    return this.flush(v).then((v => (this.getOptions().enabled = !1,
                    this.emit("close"),
                    v)))
                }
                "getEventProcessors"() {
                    return this._eventProcessors
                }
                "addEventProcessor"(v) {
                    this._eventProcessors.push(v)
                }
                "init"() {
                    (this._isEnabled() || this._options.integrations.some(( ({"name": v}) => v.startsWith("Spotlight")))) && this._setupIntegrations()
                }
                "getIntegrationByName"(v) {
                    return this._integrations[v]
                }
                "addIntegration"(v) {
                    const E = this._integrations[v.name];
                    setupIntegration(this, v, this._integrations),
                    E || afterSetupIntegrations(this, [v])
                }
                "sendEvent"(v, E={}) {
                    this.emit("beforeSendEvent", v, E);
                    let k = createEventEnvelope(v, this._dsn, this._options._metadata, this._options.tunnel);
                    for (const v of E.attachments || [])
                        k = addItemToEnvelope(k, createAttachmentEnvelopeItem(v));
                    const R = this.sendEnvelope(k);
                    R && R.then((E => this.emit("afterSendEvent", v, E)), null)
                }
                "sendSession"(v) {
                    const E = function createSessionEnvelope(v, E, k, R) {
                        const U = envelope_getSdkMetadataForEnvelopeHeader(k);
                        return envelope_createEnvelope({
                            "sent_at": (new Date).toISOString(),
                            ...U && {
                                "sdk": U
                            },
                            ...!!R && E && {
                                "dsn": dsn_dsnToString(E)
                            }
                        }, ["aggregates"in v ? [{
                            "type": "sessions"
                        }, v] : [{
                            "type": "session"
                        }, v.toJSON()]])
                    }(v, this._dsn, this._options._metadata, this._options.tunnel);
                    this.sendEnvelope(E)
                }
                "recordDroppedEvent"(v, E, k) {
                    if (this._options.sendClientReports) {
                        const R = "number" == typeof k ? k : 1
                          , U = `${v}:${E}`;
                        _e && fe.log(`Recording outcome: "${U}"${R > 1 ? ` (${R} times)` : ""}`),
                        this._outcomes[U] = (this._outcomes[U] || 0) + R
                    }
                }
                "on"(v, E) {
                    const k = this._hooks[v] = this._hooks[v] || [];
                    return k.push(E),
                    () => {
                        const v = k.indexOf(E);
                        v > -1 && k.splice(v, 1)
                    }
                }
                "emit"(v, ...E) {
                    const k = this._hooks[v];
                    k && k.forEach((v => v(...E)))
                }
                "sendEnvelope"(v) {
                    return this.emit("beforeEnvelope", v),
                    this._isEnabled() && this._transport ? this._transport.send(v).then(null, (v => (_e && fe.error("Error while sending event:", v),
                    v))) : (_e && fe.error("Transport disabled"),
                    resolvedSyncPromise({}))
                }
                "_setupIntegrations"() {
                    const {"integrations": v} = this._options;
                    this._integrations = function setupIntegrations(v, E) {
                        const k = {};
                        return E.forEach((E => {
                            E && setupIntegration(v, E, k)
                        }
                        )),
                        k
                    }(this, v),
                    afterSetupIntegrations(this, v)
                }
                "_updateSessionFromEvent"(v, E) {
                    let k = !1
                      , R = !1;
                    const U = E.exception && E.exception.values;
                    if (U) {
                        R = !0;
                        for (const v of U) {
                            const E = v.mechanism;
                            if (E && !1 === E.handled) {
                                k = !0;
                                break
                            }
                        }
                    }
                    const H = "ok" === v.status;
                    (H && 0 === v.errors || H && k) && (session_updateSession(v, {
                        ...k && {
                            "status": "crashed"
                        },
                        "errors": v.errors || Number(R || k)
                    }),
                    this.captureSession(v))
                }
                "_isClientDoneProcessing"(v) {
                    return new SyncPromise((E => {
                        let k = 0;
                        const R = setInterval(( () => {
                            0 == this._numProcessing ? (clearInterval(R),
                            E(!0)) : (k += 1,
                            v && k >= v && (clearInterval(R),
                            E(!1)))
                        }
                        ), 1)
                    }
                    ))
                }
                "_isEnabled"() {
                    return !1 !== this.getOptions().enabled && void 0 !== this._transport
                }
                "_prepareEvent"(v, E, k, R=currentScopes_getIsolationScope()) {
                    const U = this.getOptions()
                      , H = Object.keys(this._integrations);
                    return !E.integrations && H.length > 0 && (E.integrations = H),
                    this.emit("preprocessEvent", v, E),
                    v.type || R.setLastEventId(v.event_id || E.event_id),
                    prepareEvent(U, v, E, k, this, R).then((v => {
                        if (null === v)
                            return v;
                        const E = {
                            ...R.getPropagationContext(),
                            ...k ? k.getPropagationContext() : void 0
                        };
                        if (!(v.contexts && v.contexts.trace) && E) {
                            const {"traceId": k, "spanId": R, "parentSpanId": U, "dsc": H} = E;
                            v.contexts = {
                                "trace": object_dropUndefinedKeys({
                                    "trace_id": k,
                                    "span_id": R,
                                    "parent_span_id": U
                                }),
                                ...v.contexts
                            };
                            const G = H || getDynamicSamplingContextFromClient(k, this);
                            v.sdkProcessingMetadata = {
                                "dynamicSamplingContext": G,
                                ...v.sdkProcessingMetadata
                            }
                        }
                        return v
                    }
                    ))
                }
                "_captureEvent"(v, E={}, k) {
                    return this._processEvent(v, E, k).then((v => v.event_id), (v => {
                        if (_e) {
                            const E = v;
                            "log" === E.logLevel ? fe.log(E.message) : fe.warn(E)
                        }
                    }
                    ))
                }
                "_processEvent"(v, E, k) {
                    const R = this.getOptions()
                      , {"sampleRate": U} = R
                      , H = isTransactionEvent(v)
                      , G = baseclient_isErrorEvent(v)
                      , W = v.type || "error"
                      , Z = `before send for type \`${W}\``
                      , Y = void 0 === U ? void 0 : parseSampleRate(U);
                    if (G && "number" == typeof Y && Math.random() > Y)
                        return this.recordDroppedEvent("sample_rate", "error", v),
                        rejectedSyncPromise(new SentryError(`Discarding event because it's not included in the random sample (sampling rate = ${U})`,"log"));
                    const J = "replay_event" === W ? "replay" : W
                      , K = (v.sdkProcessingMetadata || {}).capturedSpanIsolationScope;
                    return this._prepareEvent(v, E, k, K).then((k => {
                        if (null === k)
                            throw this.recordDroppedEvent("event_processor", J, v),
                            new SentryError("An event processor returned `null`, will not send event.","log");
                        if (E.data && !0 === E.data.__sentry__)
                            return k;
                        const U = function processBeforeSend(v, E, k, R) {
                            const {"beforeSend": U, "beforeSendTransaction": H, "beforeSendSpan": G} = E;
                            if (baseclient_isErrorEvent(k) && U)
                                return U(k, R);
                            if (isTransactionEvent(k)) {
                                if (k.spans && G) {
                                    const E = [];
                                    for (const R of k.spans) {
                                        const k = G(R);
                                        k ? E.push(k) : v.recordDroppedEvent("before_send", "span")
                                    }
                                    k.spans = E
                                }
                                if (H) {
                                    if (k.spans) {
                                        const v = k.spans.length;
                                        k.sdkProcessingMetadata = {
                                            ...k.sdkProcessingMetadata,
                                            "spanCountBeforeProcessing": v
                                        }
                                    }
                                    return H(k, R)
                                }
                            }
                            return k
                        }(this, R, k, E);
                        return function _validateBeforeSendResult(v, E) {
                            const k = `${E} must return \`null\` or a valid event.`;
                            if (is_isThenable(v))
                                return v.then((v => {
                                    if (!isPlainObject(v) && null !== v)
                                        throw new SentryError(k);
                                    return v
                                }
                                ), (v => {
                                    throw new SentryError(`${E} rejected with ${v}`)
                                }
                                ));
                            if (!isPlainObject(v) && null !== v)
                                throw new SentryError(k);
                            return v
                        }(U, Z)
                    }
                    )).then((R => {
                        if (null === R) {
                            if (this.recordDroppedEvent("before_send", J, v),
                            H) {
                                const E = 1 + (v.spans || []).length;
                                this.recordDroppedEvent("before_send", "span", E)
                            }
                            throw new SentryError(`${Z} returned \`null\`, will not send event.`,"log")
                        }
                        const U = k && k.getSession();
                        if (!H && U && this._updateSessionFromEvent(U, R),
                        H) {
                            const v = (R.sdkProcessingMetadata && R.sdkProcessingMetadata.spanCountBeforeProcessing || 0) - (R.spans ? R.spans.length : 0);
                            v > 0 && this.recordDroppedEvent("before_send", "span", v)
                        }
                        const G = R.transaction_info;
                        if (H && G && R.transaction !== v.transaction) {
                            const v = "custom";
                            R.transaction_info = {
                                ...G,
                                "source": v
                            }
                        }
                        return this.sendEvent(R, E),
                        R
                    }
                    )).then(null, (v => {
                        if (v instanceof SentryError)
                            throw v;
                        throw this.captureException(v, {
                            "data": {
                                "__sentry__": !0
                            },
                            "originalException": v
                        }),
                        new SentryError(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\nReason: ${v}`)
                    }
                    ))
                }
                "_process"(v) {
                    this._numProcessing++,
                    v.then((v => (this._numProcessing--,
                    v)), (v => (this._numProcessing--,
                    v)))
                }
                "_clearOutcomes"() {
                    const v = this._outcomes;
                    return this._outcomes = {},
                    Object.entries(v).map(( ([v,E]) => {
                        const [k,R] = v.split(":");
                        return {
                            "reason": k,
                            "category": R,
                            "quantity": E
                        }
                    }
                    ))
                }
                "_flushOutcomes"() {
                    _e && fe.log("Flushing outcomes...");
                    const v = this._clearOutcomes();
                    if (0 === v.length)
                        return void (_e && fe.log("No outcomes to send"));
                    if (!this._dsn)
                        return void (_e && fe.log("No dsn provided, will not send outcomes"));
                    _e && fe.log("Sending outcomes:", v);
                    const E = function createClientReportEnvelope(v, E, k) {
                        return envelope_createEnvelope(E ? {
                            "dsn": E
                        } : {}, [[{
                            "type": "client_report"
                        }, {
                            "timestamp": k || time_dateTimestampInSeconds(),
                            "discarded_events": v
                        }]])
                    }(v, this._options.tunnel && dsn_dsnToString(this._dsn));
                    this.sendEnvelope(E)
                }
            }
            function baseclient_isErrorEvent(v) {
                return void 0 === v.type
            }
            function isTransactionEvent(v) {
                return "transaction" === v.type
            }
            const St = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__;
            function exceptionFromError(v, E) {
                const k = parseStackFrames(v, E)
                  , R = {
                    "type": E && E.name,
                    "value": extractMessage(E)
                };
                return k.length && (R.stacktrace = {
                    "frames": k
                }),
                void 0 === R.type && "" === R.value && (R.value = "Unrecoverable error caught"),
                R
            }
            function eventFromPlainObject(v, E, k, R) {
                const U = currentScopes_getClient()
                  , H = U && U.getOptions().normalizeDepth
                  , G = function getErrorPropertyFromObject(v) {
                    for (const E in v)
                        if (Object.prototype.hasOwnProperty.call(v, E)) {
                            const k = v[E];
                            if (k instanceof Error)
                                return k
                        }
                    return
                }(E)
                  , W = {
                    "__serialized__": normalizeToSize(E, H)
                };
                if (G)
                    return {
                        "exception": {
                            "values": [exceptionFromError(v, G)]
                        },
                        "extra": W
                    };
                const Z = {
                    "exception": {
                        "values": [{
                            "type": is_isEvent(E) ? E.constructor.name : R ? "UnhandledRejection" : "Error",
                            "value": getNonErrorObjectExceptionValue(E, {
                                "isUnhandledRejection": R
                            })
                        }]
                    },
                    "extra": W
                };
                if (k) {
                    const E = parseStackFrames(v, k);
                    E.length && (Z.exception.values[0].stacktrace = {
                        "frames": E
                    })
                }
                return Z
            }
            function eventFromError(v, E) {
                return {
                    "exception": {
                        "values": [exceptionFromError(v, E)]
                    }
                }
            }
            function parseStackFrames(v, E) {
                const k = E.stacktrace || E.stack || ""
                  , R = function getSkipFirstStackStringLines(v) {
                    if (v && wt.test(v.message))
                        return 1;
                    return 0
                }(E)
                  , U = function getPopFirstTopFrames(v) {
                    if ("number" == typeof v.framesToPop)
                        return v.framesToPop;
                    return 0
                }(E);
                try {
                    return v(k, R, U)
                } catch (v) {}
                return []
            }
            const wt = /Minified React error #\d+;/i;
            function extractMessage(v) {
                const E = v && v.message;
                return E ? E.error && "string" == typeof E.error.message ? E.error.message : E : "No error message"
            }
            function eventFromException(v, E, k, R) {
                const U = eventFromUnknownInput(v, E, k && k.syntheticException || void 0, R);
                return misc_addExceptionMechanism(U),
                U.level = "error",
                k && k.event_id && (U.event_id = k.event_id),
                resolvedSyncPromise(U)
            }
            function eventFromMessage(v, E, k="info", R, U) {
                const H = eventFromString(v, E, R && R.syntheticException || void 0, U);
                return H.level = k,
                R && R.event_id && (H.event_id = R.event_id),
                resolvedSyncPromise(H)
            }
            function eventFromUnknownInput(v, E, k, R, U) {
                let H;
                if (isErrorEvent(E) && E.error) {
                    return eventFromError(v, E.error)
                }
                if (isDOMError(E) || function isDOMException(v) {
                    return isBuiltin(v, "DOMException")
                }(E)) {
                    const U = E;
                    if ("stack"in E)
                        H = eventFromError(v, E);
                    else {
                        const E = U.name || (isDOMError(U) ? "DOMError" : "DOMException")
                          , G = U.message ? `${E}: ${U.message}` : E;
                        H = eventFromString(v, G, k, R),
                        addExceptionTypeValue(H, G)
                    }
                    return "code"in U && (H.tags = {
                        ...H.tags,
                        "DOMException.code": `${U.code}`
                    }),
                    H
                }
                if (is_isError(E))
                    return eventFromError(v, E);
                if (isPlainObject(E) || is_isEvent(E)) {
                    return H = eventFromPlainObject(v, E, k, U),
                    misc_addExceptionMechanism(H, {
                        "synthetic": !0
                    }),
                    H
                }
                return H = eventFromString(v, E, k, R),
                addExceptionTypeValue(H, `${E}`, void 0),
                misc_addExceptionMechanism(H, {
                    "synthetic": !0
                }),
                H
            }
            function eventFromString(v, E, k, R) {
                const U = {};
                if (R && k) {
                    const R = parseStackFrames(v, k);
                    R.length && (U.exception = {
                        "values": [{
                            "value": E,
                            "stacktrace": {
                                "frames": R
                            }
                        }]
                    })
                }
                if (isParameterizedString(E)) {
                    const {"__sentry_template_string__": v, "__sentry_template_values__": k} = E;
                    return U.logentry = {
                        "message": v,
                        "params": k
                    },
                    U
                }
                return U.message = E,
                U
            }
            function getNonErrorObjectExceptionValue(v, {"isUnhandledRejection": E}) {
                const k = function extractExceptionKeysForMessage(v, E=40) {
                    const k = Object.keys(convertToPlainObject(v));
                    k.sort();
                    const R = k[0];
                    if (!R)
                        return "[object has no keys]";
                    if (R.length >= E)
                        return string_truncate(R, E);
                    for (let v = k.length; v > 0; v--) {
                        const R = k.slice(0, v).join(", ");
                        if (!(R.length > E))
                            return v === k.length ? R : string_truncate(R, E)
                    }
                    return ""
                }(v)
                  , R = E ? "promise rejection" : "exception";
                if (isErrorEvent(v))
                    return `Event \`ErrorEvent\` captured as ${R} with message \`${v.message}\``;
                if (is_isEvent(v)) {
                    return `Event \`${function getObjectClassName(v) {
                        try {
                            const E = Object.getPrototypeOf(v);
                            return E ? E.constructor.name : void 0
                        } catch (v) {}
                    }(v)}\` (type=${v.type}) captured as ${R}`
                }
                return `Object captured as ${R} with keys: ${k}`
            }
            const Et = ue;
            let Ct = 0;
            function shouldIgnoreOnError() {
                return Ct > 0
            }
            function wrap(v, E={}, k) {
                if ("function" != typeof v)
                    return v;
                try {
                    const E = v.__sentry_wrapped__;
                    if (E)
                        return E;
                    if (getOriginalFunction(v))
                        return v
                } catch (E) {
                    return v
                }
                const sentryWrapped = function() {
                    const R = Array.prototype.slice.call(arguments);
                    try {
                        k && "function" == typeof k && k.apply(this, arguments);
                        const U = R.map((v => wrap(v, E)));
                        return v.apply(this, U)
                    } catch (v) {
                        throw function ignoreNextOnError() {
                            Ct++,
                            setTimeout(( () => {
                                Ct--
                            }
                            ))
                        }(),
                        currentScopes_withScope((k => {
                            k.addEventProcessor((v => (E.mechanism && (addExceptionTypeValue(v, void 0, void 0),
                            misc_addExceptionMechanism(v, E.mechanism)),
                            v.extra = {
                                ...v.extra,
                                "arguments": R
                            },
                            v))),
                            captureException(v)
                        }
                        )),
                        v
                    }
                };
                try {
                    for (const E in v)
                        Object.prototype.hasOwnProperty.call(v, E) && (sentryWrapped[E] = v[E])
                } catch (v) {}
                markFunctionWrapped(sentryWrapped, v),
                object_addNonEnumerableProperty(v, "__sentry_wrapped__", sentryWrapped);
                try {
                    Object.getOwnPropertyDescriptor(sentryWrapped, "name").configurable && Object.defineProperty(sentryWrapped, "name", {
                        "get"() {
                            return v.name
                        }
                    })
                } catch (v) {}
                return sentryWrapped
            }
            function createUserFeedbackEnvelope(v, {"metadata": E, "tunnel": k, "dsn": R}) {
                const U = {
                    "event_id": v.event_id,
                    "sent_at": (new Date).toISOString(),
                    ...E && E.sdk && {
                        "sdk": {
                            "name": E.sdk.name,
                            "version": E.sdk.version
                        }
                    },
                    ...!!k && !!R && {
                        "dsn": dsn_dsnToString(R)
                    }
                }
                  , H = function createUserFeedbackEnvelopeItem(v) {
                    return [{
                        "type": "user_report"
                    }, v]
                }(v);
                return envelope_createEnvelope(U, [H])
            }
            class BrowserClient extends BaseClient {
                "constructor"(v) {
                    const E = {
                        "parentSpanIsAlwaysRootSpan": !0,
                        ...v
                    };
                    !function applySdkMetadata(v, E, k=[E], R="npm") {
                        const U = v._metadata || {};
                        U.sdk || (U.sdk = {
                            "name": `sentry.javascript.${E}`,
                            "packages": k.map((v => ({
                                "name": `${R}:@sentry/${v}`,
                                "version": ce
                            }))),
                            "version": ce
                        }),
                        v._metadata = U
                    }(E, "browser", ["browser"], Et.SENTRY_SDK_SOURCE || "npm"),
                    super(E),
                    E.sendClientReports && Et.document && Et.document.addEventListener("visibilitychange", ( () => {
                        "hidden" === Et.document.visibilityState && this._flushOutcomes()
                    }
                    ))
                }
                "eventFromException"(v, E) {
                    return eventFromException(this._options.stackParser, v, E, this._options.attachStacktrace)
                }
                "eventFromMessage"(v, E="info", k) {
                    return eventFromMessage(this._options.stackParser, v, E, k, this._options.attachStacktrace)
                }
                "captureUserFeedback"(v) {
                    if (!this._isEnabled())
                        return void (St && fe.warn("SDK not enabled, will not capture user feedback."));
                    const E = createUserFeedbackEnvelope(v, {
                        "metadata": this.getSdkMetadata(),
                        "dsn": this.getDsn(),
                        "tunnel": this.getOptions().tunnel
                    });
                    this.sendEnvelope(E)
                }
                "_prepareEvent"(v, E, k) {
                    return v.platform = v.platform || "javascript",
                    super._prepareEvent(v, E, k)
                }
            }
            function esm_misc_uuid4() {
                const v = ct
                  , E = v.crypto || v.msCrypto;
                let getRandomByte = () => 16 * Math.random();
                try {
                    if (E && E.randomUUID)
                        return E.randomUUID().replace(/-/g, "");
                    E && E.getRandomValues && (getRandomByte = () => {
                        const v = new Uint8Array(1);
                        return E.getRandomValues(v),
                        v[0]
                    }
                    )
                } catch (v) {}
                return ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, (v => (v ^ (15 & getRandomByte()) >> v / 4).toString(16)))
            }
            const Tt = 1e3;
            let xt, At, It;
            function addClickKeypressInstrumentationHandler(v) {
                addHandler("dom", v),
                maybeInstrument("dom", instrumentDOM)
            }
            function instrumentDOM() {
                if (!_t.document)
                    return;
                const v = triggerHandlers.bind(null, "dom")
                  , E = makeDOMEventHandler(v, !0);
                _t.document.addEventListener("click", E, !1),
                _t.document.addEventListener("keypress", E, !1),
                ["EventTarget", "Node"].forEach((E => {
                    const k = _t[E] && _t[E].prototype;
                    k && k.hasOwnProperty && k.hasOwnProperty("addEventListener") && (object_fill(k, "addEventListener", (function(E) {
                        return function(k, R, U) {
                            if ("click" === k || "keypress" == k)
                                try {
                                    const R = this
                                      , H = R.__sentry_instrumentation_handlers__ = R.__sentry_instrumentation_handlers__ || {}
                                      , G = H[k] = H[k] || {
                                        "refCount": 0
                                    };
                                    if (!G.handler) {
                                        const R = makeDOMEventHandler(v);
                                        G.handler = R,
                                        E.call(this, k, R, U)
                                    }
                                    G.refCount++
                                } catch (v) {}
                            return E.call(this, k, R, U)
                        }
                    }
                    )),
                    object_fill(k, "removeEventListener", (function(v) {
                        return function(E, k, R) {
                            if ("click" === E || "keypress" == E)
                                try {
                                    const k = this
                                      , U = k.__sentry_instrumentation_handlers__ || {}
                                      , H = U[E];
                                    H && (H.refCount--,
                                    H.refCount <= 0 && (v.call(this, E, H.handler, R),
                                    H.handler = void 0,
                                    delete U[E]),
                                    0 === Object.keys(U).length && delete k.__sentry_instrumentation_handlers__)
                                } catch (v) {}
                            return v.call(this, E, k, R)
                        }
                    }
                    )))
                }
                ))
            }
            function makeDOMEventHandler(v, E=!1) {
                return k => {
                    if (!k || k._sentryCaptured)
                        return;
                    const R = function getEventTarget(v) {
                        try {
                            return v.target
                        } catch (v) {
                            return null
                        }
                    }(k);
                    if (function shouldSkipDOMEvent(v, E) {
                        return "keypress" === v && (!E || !E.tagName || "INPUT" !== E.tagName && "TEXTAREA" !== E.tagName && !E.isContentEditable)
                    }(k.type, R))
                        return;
                    esm_object_addNonEnumerableProperty(k, "_sentryCaptured", !0),
                    R && !R._sentryId && esm_object_addNonEnumerableProperty(R, "_sentryId", esm_misc_uuid4());
                    const U = "keypress" === k.type ? "input" : k.type;
                    if (!function isSimilarToLastCapturedEvent(v) {
                        if (v.type !== At)
                            return !1;
                        try {
                            if (!v.target || v.target._sentryId !== It)
                                return !1
                        } catch (v) {}
                        return !0
                    }(k)) {
                        v({
                            "event": k,
                            "name": U,
                            "global": E
                        }),
                        At = k.type,
                        It = R ? R._sentryId : void 0
                    }
                    clearTimeout(xt),
                    xt = _t.setTimeout(( () => {
                        It = void 0,
                        At = void 0
                    }
                    ), Tt)
                }
            }
            const kt = 1e3;
            function esm_time_dateTimestampInSeconds() {
                return Date.now() / kt
            }
            const Ot = function time_createUnixTimestampInSecondsFunc() {
                const {"performance": v} = ct;
                if (!v || !v.now)
                    return esm_time_dateTimestampInSeconds;
                const E = Date.now() - v.now()
                  , k = null == v.timeOrigin ? E : v.timeOrigin;
                return () => (k + v.now()) / kt
            }();
            let Pt;
            const Rt = ( () => {
                const {"performance": v} = ct;
                if (!v || !v.now)
                    return void (Pt = "none");
                const E = 36e5
                  , k = v.now()
                  , R = Date.now()
                  , U = v.timeOrigin ? Math.abs(v.timeOrigin + k - R) : E
                  , H = U < E
                  , G = v.timing && v.timing.navigationStart
                  , W = "number" == typeof G ? Math.abs(G + k - R) : E;
                return H || W < E ? U <= W ? (Pt = "timeOrigin",
                v.timeOrigin) : (Pt = "navigationStart",
                G) : (Pt = "dateNow",
                R)
            }
            )()
              , Mt = "__sentry_xhr_v3__";
            function addXhrInstrumentationHandler(v) {
                addHandler("xhr", v),
                maybeInstrument("xhr", instrumentXHR)
            }
            function instrumentXHR() {
                if (!_t.XMLHttpRequest)
                    return;
                const v = XMLHttpRequest.prototype;
                v.open = new Proxy(v.open,{
                    "apply"(v, E, k) {
                        const R = 1e3 * Ot()
                          , U = esm_is_isString(k[0]) ? k[0].toUpperCase() : void 0
                          , H = function parseUrl(v) {
                            if (esm_is_isString(v))
                                return v;
                            try {
                                return v.toString()
                            } catch (v) {}
                            return
                        }(k[1]);
                        if (!U || !H)
                            return v.apply(E, k);
                        E[Mt] = {
                            "method": U,
                            "url": H,
                            "request_headers": {}
                        },
                        "POST" === U && H.match(/sentry_key/) && (E.__sentry_own_request__ = !0);
                        const onreadystatechangeHandler = () => {
                            const v = E[Mt];
                            if (v && 4 === E.readyState) {
                                try {
                                    v.status_code = E.status
                                } catch (v) {}
                                triggerHandlers("xhr", {
                                    "endTimestamp": 1e3 * Ot(),
                                    "startTimestamp": R,
                                    "xhr": E
                                })
                            }
                        }
                        ;
                        return "onreadystatechange"in E && "function" == typeof E.onreadystatechange ? E.onreadystatechange = new Proxy(E.onreadystatechange,{
                            "apply"(v, E, k) {
                                return onreadystatechangeHandler(),
                                v.apply(E, k)
                            }
                        }) : E.addEventListener("readystatechange", onreadystatechangeHandler),
                        E.setRequestHeader = new Proxy(E.setRequestHeader,{
                            "apply"(v, E, k) {
                                const [R,U] = k
                                  , H = E[Mt];
                                return H && esm_is_isString(R) && esm_is_isString(U) && (H.request_headers[R.toLowerCase()] = U),
                                v.apply(E, k)
                            }
                        }),
                        v.apply(E, k)
                    }
                }),
                v.send = new Proxy(v.send,{
                    "apply"(v, E, k) {
                        const R = E[Mt];
                        if (!R)
                            return v.apply(E, k);
                        void 0 !== k[0] && (R.body = k[0]);
                        return triggerHandlers("xhr", {
                            "startTimestamp": 1e3 * Ot(),
                            "xhr": E
                        }),
                        v.apply(E, k)
                    }
                })
            }
            const Nt = 100;
            function addBreadcrumb(v, E) {
                const k = currentScopes_getClient()
                  , R = currentScopes_getIsolationScope();
                if (!k)
                    return;
                const {"beforeBreadcrumb": U=null, "maxBreadcrumbs": H=Nt} = k.getOptions();
                if (H <= 0)
                    return;
                const G = {
                    "timestamp": time_dateTimestampInSeconds(),
                    ...v
                }
                  , W = U ? logger_consoleSandbox(( () => U(G, E))) : G;
                null !== W && (k.emit && k.emit("beforeAddBreadcrumb", W, E),
                R.addBreadcrumb(W, H))
            }
            const Dt = {}
              , $t = {};
            function handlers_addHandler(v, E) {
                Dt[v] = Dt[v] || [],
                Dt[v].push(E)
            }
            function handlers_maybeInstrument(v, E) {
                $t[v] || (E(),
                $t[v] = !0)
            }
            function handlers_triggerHandlers(v, E) {
                const k = v && Dt[v];
                if (k)
                    for (const R of k)
                        try {
                            R(E)
                        } catch (E) {
                            le && fe.error(`Error while triggering instrumentation handler.\nType: ${v}\nName: ${getFunctionName(R)}\nError:`, E)
                        }
            }
            function addConsoleInstrumentationHandler(v) {
                const E = "console";
                handlers_addHandler(E, v),
                handlers_maybeInstrument(E, instrumentConsole)
            }
            function instrumentConsole() {
                "console"in ue && de.forEach((function(v) {
                    v in ue.console && fill(ue.console, v, (function(E) {
                        return pe[v] = E,
                        function(...E) {
                            handlers_triggerHandlers("console", {
                                "args": E,
                                "level": v
                            });
                            const k = pe[v];
                            k && k.apply(ue.console, E)
                        }
                    }
                    ))
                }
                ))
            }
            function addFetchInstrumentationHandler(v, E) {
                const k = "fetch";
                handlers_addHandler(k, v),
                handlers_maybeInstrument(k, ( () => instrumentFetch(void 0, E)))
            }
            function instrumentFetch(v, E=!1) {
                E && !supportsNativeFetch() || fill(ue, "fetch", (function(E) {
                    return function(...k) {
                        const {"method": R, "url": U} = function parseFetchArgs(v) {
                            if (0 === v.length)
                                return {
                                    "method": "GET",
                                    "url": ""
                                };
                            if (2 === v.length) {
                                const [E,k] = v;
                                return {
                                    "url": getUrlFromResource(E),
                                    "method": hasProp(k, "method") ? String(k.method).toUpperCase() : "GET"
                                }
                            }
                            const E = v[0];
                            return {
                                "url": getUrlFromResource(E),
                                "method": hasProp(E, "method") ? String(E.method).toUpperCase() : "GET"
                            }
                        }(k)
                          , H = {
                            "args": k,
                            "fetchData": {
                                "method": R,
                                "url": U
                            },
                            "startTimestamp": 1e3 * ye()
                        };
                        v || handlers_triggerHandlers("fetch", {
                            ...H
                        });
                        const G = (new Error).stack;
                        return E.apply(ue, k).then((async E => (v ? v(E) : handlers_triggerHandlers("fetch", {
                            ...H,
                            "endTimestamp": 1e3 * ye(),
                            "response": E
                        }),
                        E)), (v => {
                            throw handlers_triggerHandlers("fetch", {
                                ...H,
                                "endTimestamp": 1e3 * ye(),
                                "error": v
                            }),
                            is_isError(v) && void 0 === v.stack && (v.stack = G,
                            object_addNonEnumerableProperty(v, "framesToPop", 1)),
                            v
                        }
                        ))
                    }
                }
                ))
            }
            async function streamHandler(v) {
                let E;
                try {
                    E = v.clone()
                } catch (v) {
                    return
                }
                await async function resolveResponse(v, E) {
                    if (v && v.body && v.body.getReader) {
                        const k = v.body.getReader();
                        async function consumeChunks({"done": v}) {
                            if (v)
                                return Promise.resolve();
                            try {
                                const v = await Promise.race([k.read(), new Promise((v => {
                                    setTimeout(( () => {
                                        v({
                                            "done": !0
                                        })
                                    }
                                    ), 5e3)
                                }
                                ))]);
                                await consumeChunks(v)
                            } catch (v) {}
                        }
                        return k.read().then(consumeChunks).then(E).catch(( () => {}
                        ))
                    }
                }(E, ( () => {
                    handlers_triggerHandlers("fetch-body-resolved", {
                        "endTimestamp": 1e3 * ye(),
                        "response": v
                    })
                }
                ))
            }
            function hasProp(v, E) {
                return !!v && "object" == typeof v && !!v[E]
            }
            function getUrlFromResource(v) {
                return "string" == typeof v ? v : v ? hasProp(v, "url") ? v.url : v.toString ? v.toString() : "" : ""
            }
            const Lt = ["fatal", "error", "warning", "log", "info", "debug"];
            function severityLevelFromString(v) {
                return "warn" === v ? "warning" : Lt.includes(v) ? v : "log"
            }
            function url_parseUrl(v) {
                if (!v)
                    return {};
                const E = v.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
                if (!E)
                    return {};
                const k = E[6] || ""
                  , R = E[8] || "";
                return {
                    "host": E[4],
                    "path": E[5],
                    "protocol": E[2],
                    "search": k,
                    "hash": R,
                    "relative": E[5] + k + R
                }
            }
            const Ft = 1024
              , breadcrumbsIntegration = (v={}) => {
                const E = {
                    "console": !0,
                    "dom": !0,
                    "fetch": !0,
                    "history": !0,
                    "sentry": !0,
                    "xhr": !0,
                    ...v
                };
                return {
                    "name": "Breadcrumbs",
                    "setup"(v) {
                        E.console && addConsoleInstrumentationHandler(function _getConsoleBreadcrumbHandler(v) {
                            return function _consoleBreadcrumb(E) {
                                if (currentScopes_getClient() !== v)
                                    return;
                                const k = {
                                    "category": "console",
                                    "data": {
                                        "arguments": E.args,
                                        "logger": "console"
                                    },
                                    "level": severityLevelFromString(E.level),
                                    "message": safeJoin(E.args, " ")
                                };
                                if ("assert" === E.level) {
                                    if (!1 !== E.args[0])
                                        return;
                                    k.message = `Assertion failed: ${safeJoin(E.args.slice(1), " ") || "console.assert"}`,
                                    k.data.arguments = E.args.slice(1)
                                }
                                addBreadcrumb(k, {
                                    "input": E.args,
                                    "level": E.level
                                })
                            }
                        }(v)),
                        E.dom && addClickKeypressInstrumentationHandler(function _getDomBreadcrumbHandler(v, E) {
                            return function _innerDomBreadcrumb(k) {
                                if (currentScopes_getClient() !== v)
                                    return;
                                let R, U, H = "object" == typeof E ? E.serializeAttribute : void 0, G = "object" == typeof E && "number" == typeof E.maxStringLength ? E.maxStringLength : void 0;
                                G && G > Ft && (St && fe.warn(`\`dom.maxStringLength\` cannot exceed 1024, but a value of ${G} was configured. Sentry will use 1024 instead.`),
                                G = Ft),
                                "string" == typeof H && (H = [H]);
                                try {
                                    const v = k.event
                                      , E = function _isEvent(v) {
                                        return !!v && !!v.target
                                    }(v) ? v.target : v;
                                    R = browser_htmlTreeAsString(E, {
                                        "keyAttrs": H,
                                        "maxStringLength": G
                                    }),
                                    U = function getComponentName(v) {
                                        if (!me.HTMLElement)
                                            return null;
                                        let E = v;
                                        for (let v = 0; v < 5; v++) {
                                            if (!E)
                                                return null;
                                            if (E instanceof HTMLElement) {
                                                if (E.dataset.sentryComponent)
                                                    return E.dataset.sentryComponent;
                                                if (E.dataset.sentryElement)
                                                    return E.dataset.sentryElement
                                            }
                                            E = E.parentNode
                                        }
                                        return null
                                    }(E)
                                } catch (v) {
                                    R = "<unknown>"
                                }
                                if (0 === R.length)
                                    return;
                                const W = {
                                    "category": `ui.${k.name}`,
                                    "message": R
                                };
                                U && (W.data = {
                                    "ui.component_name": U
                                }),
                                addBreadcrumb(W, {
                                    "event": k.event,
                                    "name": k.name,
                                    "global": k.global
                                })
                            }
                        }(v, E.dom)),
                        E.xhr && addXhrInstrumentationHandler(function _getXhrBreadcrumbHandler(v) {
                            return function _xhrBreadcrumb(E) {
                                if (currentScopes_getClient() !== v)
                                    return;
                                const {"startTimestamp": k, "endTimestamp": R} = E
                                  , U = E.xhr[Mt];
                                if (!k || !R || !U)
                                    return;
                                const {"method": H, "url": G, "status_code": W, "body": Z} = U;
                                addBreadcrumb({
                                    "category": "xhr",
                                    "data": {
                                        "method": H,
                                        "url": G,
                                        "status_code": W
                                    },
                                    "type": "http"
                                }, {
                                    "xhr": E.xhr,
                                    "input": Z,
                                    "startTimestamp": k,
                                    "endTimestamp": R
                                })
                            }
                        }(v)),
                        E.fetch && addFetchInstrumentationHandler(function _getFetchBreadcrumbHandler(v) {
                            return function _fetchBreadcrumb(E) {
                                if (currentScopes_getClient() !== v)
                                    return;
                                const {"startTimestamp": k, "endTimestamp": R} = E;
                                if (R && (!E.fetchData.url.match(/sentry_key/) || "POST" !== E.fetchData.method))
                                    if (E.error) {
                                        addBreadcrumb({
                                            "category": "fetch",
                                            "data": E.fetchData,
                                            "level": "error",
                                            "type": "http"
                                        }, {
                                            "data": E.error,
                                            "input": E.args,
                                            "startTimestamp": k,
                                            "endTimestamp": R
                                        })
                                    } else {
                                        const v = E.response;
                                        addBreadcrumb({
                                            "category": "fetch",
                                            "data": {
                                                ...E.fetchData,
                                                "status_code": v && v.status
                                            },
                                            "type": "http"
                                        }, {
                                            "input": E.args,
                                            "response": v,
                                            "startTimestamp": k,
                                            "endTimestamp": R
                                        })
                                    }
                            }
                        }(v)),
                        E.history && addHistoryInstrumentationHandler(function _getHistoryBreadcrumbHandler(v) {
                            return function _historyBreadcrumb(E) {
                                if (currentScopes_getClient() !== v)
                                    return;
                                let k = E.from
                                  , R = E.to;
                                const U = url_parseUrl(Et.location.href);
                                let H = k ? url_parseUrl(k) : void 0;
                                const G = url_parseUrl(R);
                                H && H.path || (H = U),
                                U.protocol === G.protocol && U.host === G.host && (R = G.relative),
                                U.protocol === H.protocol && U.host === H.host && (k = H.relative),
                                addBreadcrumb({
                                    "category": "navigation",
                                    "data": {
                                        "from": k,
                                        "to": R
                                    }
                                })
                            }
                        }(v)),
                        E.sentry && v.on("beforeSendEvent", function _getSentryBreadcrumbHandler(v) {
                            return function addSentryBreadcrumb(E) {
                                currentScopes_getClient() === v && addBreadcrumb({
                                    "category": "sentry." + ("transaction" === E.type ? "transaction" : "event"),
                                    "event_id": E.event_id,
                                    "level": E.level,
                                    "message": getEventDescription(E)
                                }, {
                                    "event": E
                                })
                            }
                        }(v))
                    }
                }
            }
            ;
            const jt = ["EventTarget", "Window", "Node", "ApplicationCache", "AudioTrackList", "BroadcastChannel", "ChannelMergerNode", "CryptoOperation", "EventSource", "FileReader", "HTMLUnknownElement", "IDBDatabase", "IDBRequest", "IDBTransaction", "KeyOperation", "MediaController", "MessagePort", "ModalWindow", "Notification", "SVGElementInstance", "Screen", "SharedWorker", "TextTrack", "TextTrackCue", "TextTrackList", "WebSocket", "WebSocketWorker", "Worker", "XMLHttpRequest", "XMLHttpRequestEventTarget", "XMLHttpRequestUpload"]
              , browserApiErrorsIntegration = (v={}) => {
                const E = {
                    "XMLHttpRequest": !0,
                    "eventTarget": !0,
                    "requestAnimationFrame": !0,
                    "setInterval": !0,
                    "setTimeout": !0,
                    ...v
                };
                return {
                    "name": "BrowserApiErrors",
                    "setupOnce"() {
                        E.setTimeout && fill(Et, "setTimeout", _wrapTimeFunction),
                        E.setInterval && fill(Et, "setInterval", _wrapTimeFunction),
                        E.requestAnimationFrame && fill(Et, "requestAnimationFrame", _wrapRAF),
                        E.XMLHttpRequest && "XMLHttpRequest"in Et && fill(XMLHttpRequest.prototype, "send", _wrapXHR);
                        const v = E.eventTarget;
                        if (v) {
                            (Array.isArray(v) ? v : jt).forEach(_wrapEventTarget)
                        }
                    }
                }
            }
            ;
            function _wrapTimeFunction(v) {
                return function(...E) {
                    const k = E[0];
                    return E[0] = wrap(k, {
                        "mechanism": {
                            "data": {
                                "function": getFunctionName(v)
                            },
                            "handled": !1,
                            "type": "instrument"
                        }
                    }),
                    v.apply(this, E)
                }
            }
            function _wrapRAF(v) {
                return function(E) {
                    return v.apply(this, [wrap(E, {
                        "mechanism": {
                            "data": {
                                "function": "requestAnimationFrame",
                                "handler": getFunctionName(v)
                            },
                            "handled": !1,
                            "type": "instrument"
                        }
                    })])
                }
            }
            function _wrapXHR(v) {
                return function(...E) {
                    const k = this;
                    return ["onload", "onerror", "onprogress", "onreadystatechange"].forEach((v => {
                        v in k && "function" == typeof k[v] && fill(k, v, (function(E) {
                            const k = {
                                "mechanism": {
                                    "data": {
                                        "function": v,
                                        "handler": getFunctionName(E)
                                    },
                                    "handled": !1,
                                    "type": "instrument"
                                }
                            }
                              , R = getOriginalFunction(E);
                            return R && (k.mechanism.data.handler = getFunctionName(R)),
                            wrap(E, k)
                        }
                        ))
                    }
                    )),
                    v.apply(this, E)
                }
            }
            function _wrapEventTarget(v) {
                const E = Et
                  , k = E[v] && E[v].prototype;
                k && k.hasOwnProperty && k.hasOwnProperty("addEventListener") && (fill(k, "addEventListener", (function(E) {
                    return function(k, R, U) {
                        try {
                            "function" == typeof R.handleEvent && (R.handleEvent = wrap(R.handleEvent, {
                                "mechanism": {
                                    "data": {
                                        "function": "handleEvent",
                                        "handler": getFunctionName(R),
                                        "target": v
                                    },
                                    "handled": !1,
                                    "type": "instrument"
                                }
                            }))
                        } catch (v) {}
                        return E.apply(this, [k, wrap(R, {
                            "mechanism": {
                                "data": {
                                    "function": "addEventListener",
                                    "handler": getFunctionName(R),
                                    "target": v
                                },
                                "handled": !1,
                                "type": "instrument"
                            }
                        }), U])
                    }
                }
                )),
                fill(k, "removeEventListener", (function(v) {
                    return function(E, k, R) {
                        const U = k;
                        try {
                            const k = U && U.__sentry_wrapped__;
                            k && v.call(this, E, k, R)
                        } catch (v) {}
                        return v.call(this, E, U, R)
                    }
                }
                )))
            }
            let Bt = null;
            function addGlobalErrorInstrumentationHandler(v) {
                const E = "error";
                handlers_addHandler(E, v),
                handlers_maybeInstrument(E, instrumentError)
            }
            function instrumentError() {
                Bt = ue.onerror,
                ue.onerror = function(v, E, k, R, U) {
                    return handlers_triggerHandlers("error", {
                        "column": R,
                        "error": U,
                        "line": k,
                        "msg": v,
                        "url": E
                    }),
                    !(!Bt || Bt.__SENTRY_LOADER__) && Bt.apply(this, arguments)
                }
                ,
                ue.onerror.__SENTRY_INSTRUMENTED__ = !0
            }
            let Ut = null;
            function addGlobalUnhandledRejectionInstrumentationHandler(v) {
                const E = "unhandledrejection";
                handlers_addHandler(E, v),
                handlers_maybeInstrument(E, instrumentUnhandledRejection)
            }
            function instrumentUnhandledRejection() {
                Ut = ue.onunhandledrejection,
                ue.onunhandledrejection = function(v) {
                    return handlers_triggerHandlers("unhandledrejection", v),
                    !(Ut && !Ut.__SENTRY_LOADER__) || Ut.apply(this, arguments)
                }
                ,
                ue.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0
            }
            const globalHandlersIntegration = (v={}) => {
                const E = {
                    "onerror": !0,
                    "onunhandledrejection": !0,
                    ...v
                };
                return {
                    "name": "GlobalHandlers",
                    "setupOnce"() {
                        Error.stackTraceLimit = 50
                    },
                    "setup"(v) {
                        E.onerror && (!function _installGlobalOnErrorHandler(v) {
                            addGlobalErrorInstrumentationHandler((E => {
                                const {"stackParser": k, "attachStacktrace": R} = getOptions();
                                if (currentScopes_getClient() !== v || shouldIgnoreOnError())
                                    return;
                                const {"msg": U, "url": H, "line": G, "column": W, "error": Z} = E
                                  , Y = function _enhanceEventWithInitialFrame(v, E, k, R) {
                                    const U = v.exception = v.exception || {}
                                      , H = U.values = U.values || []
                                      , G = H[0] = H[0] || {}
                                      , W = G.stacktrace = G.stacktrace || {}
                                      , Z = W.frames = W.frames || []
                                      , Y = isNaN(parseInt(R, 10)) ? void 0 : R
                                      , J = isNaN(parseInt(k, 10)) ? void 0 : k
                                      , K = is_isString(E) && E.length > 0 ? E : function getLocationHref() {
                                        try {
                                            return me.document.location.href
                                        } catch (v) {
                                            return ""
                                        }
                                    }();
                                    0 === Z.length && Z.push({
                                        "colno": Y,
                                        "filename": K,
                                        "function": ke,
                                        "in_app": !0,
                                        "lineno": J
                                    });
                                    return v
                                }(eventFromUnknownInput(k, Z || U, void 0, R, !1), H, G, W);
                                Y.level = "error",
                                captureEvent(Y, {
                                    "originalException": Z,
                                    "mechanism": {
                                        "handled": !1,
                                        "type": "onerror"
                                    }
                                })
                            }
                            ))
                        }(v),
                        globalHandlerLog("onerror")),
                        E.onunhandledrejection && (!function _installGlobalOnUnhandledRejectionHandler(v) {
                            addGlobalUnhandledRejectionInstrumentationHandler((E => {
                                const {"stackParser": k, "attachStacktrace": R} = getOptions();
                                if (currentScopes_getClient() !== v || shouldIgnoreOnError())
                                    return;
                                const U = function _getUnhandledRejectionError(v) {
                                    if (is_isPrimitive(v))
                                        return v;
                                    try {
                                        if ("reason"in v)
                                            return v.reason;
                                        if ("detail"in v && "reason"in v.detail)
                                            return v.detail.reason
                                    } catch (v) {}
                                    return v
                                }(E)
                                  , H = is_isPrimitive(U) ? function _eventFromRejectionWithPrimitive(v) {
                                    return {
                                        "exception": {
                                            "values": [{
                                                "type": "UnhandledRejection",
                                                "value": `Non-Error promise rejection captured with value: ${String(v)}`
                                            }]
                                        }
                                    }
                                }(U) : eventFromUnknownInput(k, U, void 0, R, !0);
                                H.level = "error",
                                captureEvent(H, {
                                    "originalException": U,
                                    "mechanism": {
                                        "handled": !1,
                                        "type": "onunhandledrejection"
                                    }
                                })
                            }
                            ))
                        }(v),
                        globalHandlerLog("onunhandledrejection"))
                    }
                }
            }
            ;
            function globalHandlerLog(v) {
                St && fe.log(`Global Handler attached: ${v}`)
            }
            function getOptions() {
                const v = currentScopes_getClient();
                return v && v.getOptions() || {
                    "stackParser": () => [],
                    "attachStacktrace": !1
                }
            }
            const httpContextIntegration = () => ({
                "name": "HttpContext",
                "preprocessEvent"(v) {
                    if (!Et.navigator && !Et.location && !Et.document)
                        return;
                    const E = v.request && v.request.url || Et.location && Et.location.href
                      , {"referrer": k} = Et.document || {}
                      , {"userAgent": R} = Et.navigator || {}
                      , U = {
                        ...v.request && v.request.headers,
                        ...k && {
                            "Referer": k
                        },
                        ...R && {
                            "User-Agent": R
                        }
                    }
                      , H = {
                        ...v.request,
                        ...E && {
                            "url": E
                        },
                        "headers": U
                    };
                    v.request = H
                }
            });
            function applyAggregateErrorsToEvent(v, E, k=250, R, U, H, G) {
                if (!(H.exception && H.exception.values && G && is_isInstanceOf(G.originalException, Error)))
                    return;
                const W = H.exception.values.length > 0 ? H.exception.values[H.exception.values.length - 1] : void 0;
                W && (H.exception.values = function truncateAggregateExceptions(v, E) {
                    return v.map((v => (v.value && (v.value = string_truncate(v.value, E)),
                    v)))
                }(aggregateExceptionsFromError(v, E, U, G.originalException, R, H.exception.values, W, 0), k))
            }
            function aggregateExceptionsFromError(v, E, k, R, U, H, G, W) {
                if (H.length >= k + 1)
                    return H;
                let Z = [...H];
                if (is_isInstanceOf(R[U], Error)) {
                    applyExceptionGroupFieldsForParentException(G, W);
                    const H = v(E, R[U])
                      , Y = Z.length;
                    applyExceptionGroupFieldsForChildException(H, U, Y, W),
                    Z = aggregateExceptionsFromError(v, E, k, R[U], U, [H, ...Z], H, Y)
                }
                return Array.isArray(R.errors) && R.errors.forEach(( (R, H) => {
                    if (is_isInstanceOf(R, Error)) {
                        applyExceptionGroupFieldsForParentException(G, W);
                        const Y = v(E, R)
                          , J = Z.length;
                        applyExceptionGroupFieldsForChildException(Y, `errors[${H}]`, J, W),
                        Z = aggregateExceptionsFromError(v, E, k, R, U, [Y, ...Z], Y, J)
                    }
                }
                )),
                Z
            }
            function applyExceptionGroupFieldsForParentException(v, E) {
                v.mechanism = v.mechanism || {
                    "type": "generic",
                    "handled": !0
                },
                v.mechanism = {
                    ...v.mechanism,
                    ..."AggregateError" === v.type && {
                        "is_exception_group": !0
                    },
                    "exception_id": E
                }
            }
            function applyExceptionGroupFieldsForChildException(v, E, k, R) {
                v.mechanism = v.mechanism || {
                    "type": "generic",
                    "handled": !0
                },
                v.mechanism = {
                    ...v.mechanism,
                    "type": "chained",
                    "source": E,
                    "exception_id": k,
                    "parent_id": R
                }
            }
            const linkedErrorsIntegration = (v={}) => {
                const E = v.limit || 5
                  , k = v.key || "cause";
                return {
                    "name": "LinkedErrors",
                    "preprocessEvent"(v, R, U) {
                        const H = U.getOptions();
                        applyAggregateErrorsToEvent(exceptionFromError, H.stackParser, H.maxValueLength, k, E, v, R)
                    }
                }
            }
            ;
            function createFrame(v, E, k, R) {
                const U = {
                    "filename": v,
                    "function": "<anonymous>" === E ? ke : E,
                    "in_app": !0
                };
                return void 0 !== k && (U.lineno = k),
                void 0 !== R && (U.colno = R),
                U
            }
            const Ht = /^\s*at (\S+?)(?::(\d+))(?::(\d+))\s*$/i
              , zt = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i
              , qt = /\((\S*)(?::(\d+))(?::(\d+))\)/
              , Gt = [30, v => {
                const E = Ht.exec(v);
                if (E) {
                    const [,v,k,R] = E;
                    return createFrame(v, ke, +k, +R)
                }
                const k = zt.exec(v);
                if (k) {
                    if (k[2] && 0 === k[2].indexOf("eval")) {
                        const v = qt.exec(k[2]);
                        v && (k[2] = v[1],
                        k[3] = v[2],
                        k[4] = v[3])
                    }
                    const [v,E] = extractSafariExtensionDetails(k[1] || ke, k[2]);
                    return createFrame(E, v, k[3] ? +k[3] : void 0, k[4] ? +k[4] : void 0)
                }
            }
            ]
              , Vt = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i
              , Wt = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i
              , Zt = [50, v => {
                const E = Vt.exec(v);
                if (E) {
                    if (E[3] && E[3].indexOf(" > eval") > -1) {
                        const v = Wt.exec(E[3]);
                        v && (E[1] = E[1] || "eval",
                        E[3] = v[1],
                        E[4] = v[2],
                        E[5] = "")
                    }
                    let v = E[3]
                      , k = E[1] || ke;
                    return [k,v] = extractSafariExtensionDetails(k, v),
                    createFrame(v, k, E[4] ? +E[4] : void 0, E[5] ? +E[5] : void 0)
                }
            }
            ]
              , Yt = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:[-a-z]+):.*?):(\d+)(?::(\d+))?\)?\s*$/i
              , Jt = [40, v => {
                const E = Yt.exec(v);
                return E ? createFrame(E[2], E[1] || ke, +E[3], E[4] ? +E[4] : void 0) : void 0
            }
            ]
              , Kt = / line (\d+).*script (?:in )?(\S+)(?:: in function (\S+))?$/i
              , Xt = [10, v => {
                const E = Kt.exec(v);
                return E ? createFrame(E[2], E[3] || ke, +E[1]) : void 0
            }
            ]
              , Qt = / line (\d+), column (\d+)\s*(?:in (?:<anonymous function: ([^>]+)>|([^)]+))\(.*\))? in (.*):\s*$/i
              , en = [20, v => {
                const E = Qt.exec(v);
                return E ? createFrame(E[5], E[3] || E[4] || ke, +E[1], +E[2]) : void 0
            }
            ]
              , tn = [Gt, Zt]
              , nn = createStackParser(...tn)
              , extractSafariExtensionDetails = (v, E) => {
                const k = -1 !== v.indexOf("safari-extension")
                  , R = -1 !== v.indexOf("safari-web-extension");
                return k || R ? [-1 !== v.indexOf("@") ? v.split("@")[0] : ke, k ? `safari-extension:${E}` : `safari-web-extension:${E}`] : [v, E]
            }
            ;
            function supports_isNativeFunction(v) {
                return v && /^function\s+\w+\(\)\s+\{\s+\[native code\]\s+\}$/.test(v.toString())
            }
            const rn = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__
              , an = {};
            function getNativeImplementation(v) {
                const E = an[v];
                if (E)
                    return E;
                let k = _t[v];
                if (supports_isNativeFunction(k))
                    return an[v] = k.bind(_t);
                const R = _t.document;
                if (R && "function" == typeof R.createElement)
                    try {
                        const E = R.createElement("iframe");
                        E.hidden = !0,
                        R.head.appendChild(E);
                        const U = E.contentWindow;
                        U && U[v] && (k = U[v]),
                        R.head.removeChild(E)
                    } catch (E) {
                        rn && dt.warn(`Could not create sandbox iframe for ${v} check, bailing to window.${v}: `, E)
                    }
                return k ? an[v] = k.bind(_t) : k
            }
            function clearCachedImplementation(v) {
                an[v] = void 0
            }
            function getNativeImplementation_setTimeout(...v) {
                return getNativeImplementation("setTimeout")(...v)
            }
            function makePromiseBuffer(v) {
                const E = [];
                function remove(v) {
                    return E.splice(E.indexOf(v), 1)[0] || Promise.resolve(void 0)
                }
                return {
                    "$": E,
                    "add": function add(k) {
                        if (!function isReady() {
                            return void 0 === v || E.length < v
                        }())
                            return rejectedSyncPromise(new SentryError("Not adding Promise because buffer limit was reached."));
                        const R = k();
                        return -1 === E.indexOf(R) && E.push(R),
                        R.then(( () => remove(R))).then(null, ( () => remove(R).then(null, ( () => {}
                        )))),
                        R
                    },
                    "drain": function drain(v) {
                        return new SyncPromise(( (k, R) => {
                            let U = E.length;
                            if (!U)
                                return k(!0);
                            const H = setTimeout(( () => {
                                v && v > 0 && k(!1)
                            }
                            ), v);
                            E.forEach((v => {
                                resolvedSyncPromise(v).then(( () => {
                                    --U || (clearTimeout(H),
                                    k(!0))
                                }
                                ), R)
                            }
                            ))
                        }
                        ))
                    }
                }
            }
            const sn = 6e4;
            function parseRetryAfterHeader(v, E=Date.now()) {
                const k = parseInt(`${v}`, 10);
                if (!isNaN(k))
                    return 1e3 * k;
                const R = Date.parse(`${v}`);
                return isNaN(R) ? sn : R - E
            }
            const cn = 64;
            function createTransport(v, E, k=makePromiseBuffer(v.bufferSize || cn)) {
                let R = {};
                return {
                    "send": function send(U) {
                        const H = [];
                        if (forEachEnvelopeItem(U, ( (E, k) => {
                            const U = envelopeItemTypeToDataCategory(k);
                            if (function isRateLimited(v, E, k=Date.now()) {
                                return function disabledUntil(v, E) {
                                    return v[E] || v.all || 0
                                }(v, E) > k
                            }(R, U)) {
                                const R = getEventForEnvelopeItem(E, k);
                                v.recordDroppedEvent("ratelimit_backoff", U, R)
                            } else
                                H.push(E)
                        }
                        )),
                        0 === H.length)
                            return resolvedSyncPromise({});
                        const G = envelope_createEnvelope(U[0], H)
                          , recordEnvelopeLoss = E => {
                            forEachEnvelopeItem(G, ( (k, R) => {
                                const U = getEventForEnvelopeItem(k, R);
                                v.recordDroppedEvent(E, envelopeItemTypeToDataCategory(R), U)
                            }
                            ))
                        }
                        ;
                        return k.add(( () => E({
                            "body": serializeEnvelope(G)
                        }).then((v => (void 0 !== v.statusCode && (v.statusCode < 200 || v.statusCode >= 300) && _e && fe.warn(`Sentry responded with status code ${v.statusCode} to sent event.`),
                        R = function updateRateLimits(v, {"statusCode": E, "headers": k}, R=Date.now()) {
                            const U = {
                                ...v
                            }
                              , H = k && k["x-sentry-rate-limits"]
                              , G = k && k["retry-after"];
                            if (H)
                                for (const v of H.trim().split(",")) {
                                    const [E,k,,,H] = v.split(":", 5)
                                      , G = parseInt(E, 10)
                                      , W = 1e3 * (isNaN(G) ? 60 : G);
                                    if (k)
                                        for (const v of k.split(";"))
                                            "metric_bucket" === v && H && !H.split(";").includes("custom") || (U[v] = R + W);
                                    else
                                        U.all = R + W
                                }
                            else
                                G ? U.all = R + parseRetryAfterHeader(G, R) : 429 === E && (U.all = R + 6e4);
                            return U
                        }(R, v),
                        v)), (v => {
                            throw recordEnvelopeLoss("network_error"),
                            v
                        }
                        )))).then((v => v), (v => {
                            if (v instanceof SentryError)
                                return _e && fe.error("Skipped sending event because buffer is full."),
                                recordEnvelopeLoss("queue_overflow"),
                                resolvedSyncPromise({});
                            throw v
                        }
                        ))
                    },
                    "flush": v => k.drain(v)
                }
            }
            function getEventForEnvelopeItem(v, E) {
                if ("event" === E || "transaction" === E)
                    return Array.isArray(v) ? v[1] : void 0
            }
            function makeFetchTransport(v, E=getNativeImplementation("fetch")) {
                let k = 0
                  , R = 0;
                return createTransport(v, (function makeRequest(U) {
                    const H = U.body.length;
                    k += H,
                    R++;
                    const G = {
                        "body": U.body,
                        "method": "POST",
                        "referrerPolicy": "origin",
                        "headers": v.headers,
                        "keepalive": k <= 6e4 && R < 15,
                        ...v.fetchOptions
                    };
                    if (!E)
                        return clearCachedImplementation("fetch"),
                        rejectedSyncPromise("No fetch implementation available");
                    try {
                        return E(v.url, G).then((v => (k -= H,
                        R--,
                        {
                            "statusCode": v.status,
                            "headers": {
                                "x-sentry-rate-limits": v.headers.get("X-Sentry-Rate-Limits"),
                                "retry-after": v.headers.get("Retry-After")
                            }
                        })))
                    } catch (v) {
                        return clearCachedImplementation("fetch"),
                        k -= H,
                        R--,
                        rejectedSyncPromise(v)
                    }
                }
                ))
            }
            function getDefaultIntegrations(v) {
                return [inboundFiltersIntegration(), functionToStringIntegration(), browserApiErrorsIntegration(), breadcrumbsIntegration(), globalHandlersIntegration(), linkedErrorsIntegration(), dedupeIntegration(), httpContextIntegration()]
            }
            function init(v={}) {
                const E = function applyDefaultOptions(v={}) {
                    const E = {
                        "defaultIntegrations": getDefaultIntegrations(),
                        "release": "string" == typeof __SENTRY_RELEASE__ ? __SENTRY_RELEASE__ : Et.SENTRY_RELEASE && Et.SENTRY_RELEASE.id ? Et.SENTRY_RELEASE.id : void 0,
                        "autoSessionTracking": !0,
                        "sendClientReports": !0
                    };
                    return null == v.defaultIntegrations && delete v.defaultIntegrations,
                    {
                        ...E,
                        ...v
                    }
                }(v);
                if (function shouldShowBrowserExtensionError() {
                    const v = void 0 !== Et.window && Et;
                    if (!v)
                        return !1;
                    const E = v[v.chrome ? "chrome" : "browser"]
                      , k = E && E.runtime && E.runtime.id
                      , R = Et.location && Et.location.href || ""
                      , U = !!k && Et === Et.top && ["chrome-extension:", "moz-extension:", "ms-browser-extension:", "safari-web-extension:"].some((v => R.startsWith(`${v}//`)))
                      , H = void 0 !== v.nw;
                    return !!k && !U && !H
                }())
                    return void logger_consoleSandbox(( () => {
                        console.error("[Sentry] You cannot run Sentry this way in a browser extension, check: https://docs.sentry.io/platforms/javascript/best-practices/browser-extensions/")
                    }
                    ));
                St && (supportsFetch() || fe.warn("No Fetch API detected. The Sentry SDK requires a Fetch API compatible environment to send events. Please add a Fetch API polyfill."));
                const k = {
                    ...E,
                    "stackParser": (R = E.stackParser || nn,
                    Array.isArray(R) ? createStackParser(...R) : R),
                    "integrations": getIntegrationsToSetup(E),
                    "transport": E.transport || makeFetchTransport
                };
                var R;
                const U = function initAndBind(v, E) {
                    !0 === E.debug && (_e ? fe.enable() : logger_consoleSandbox(( () => {
                        console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.")
                    }
                    ))),
                    currentScopes_getCurrentScope().update(E.initialScope);
                    const k = new v(E);
                    return setCurrentClient(k),
                    k.init(),
                    k
                }(BrowserClient, k);
                return E.autoSessionTracking && function startSessionTracking() {
                    if (void 0 === Et.document)
                        return void (St && fe.warn("Session tracking in non-browser environment with @sentry/browser is not supported."));
                    startSession({
                        "ignoreDuration": !0
                    }),
                    captureSession(),
                    addHistoryInstrumentationHandler(( ({"from": v, "to": E}) => {
                        void 0 !== v && v !== E && (startSession({
                            "ignoreDuration": !0
                        }),
                        captureSession())
                    }
                    ))
                }(),
                U
            }
            function showReportDialog(v={}) {
                if (!Et.document)
                    return void (St && fe.error("Global document not defined in showReportDialog call"));
                const E = currentScopes_getCurrentScope()
                  , k = E.getClient()
                  , R = k && k.getDsn();
                if (!R)
                    return void (St && fe.error("DSN not configured for showReportDialog call"));
                if (E && (v.user = {
                    ...E.getUser(),
                    ...v.user
                }),
                !v.eventId) {
                    const E = lastEventId();
                    E && (v.eventId = E)
                }
                const U = Et.document.createElement("script");
                U.async = !0,
                U.crossOrigin = "anonymous",
                U.src = function getReportDialogEndpoint(v, E) {
                    const k = makeDsn(v);
                    if (!k)
                        return "";
                    const R = `${getBaseApiEndpoint(k)}embed/error-page/`;
                    let U = `dsn=${dsn_dsnToString(k)}`;
                    for (const v in E)
                        if ("dsn" !== v && "onClose" !== v)
                            if ("user" === v) {
                                const v = E.user;
                                if (!v)
                                    continue;
                                v.name && (U += `&name=${encodeURIComponent(v.name)}`),
                                v.email && (U += `&email=${encodeURIComponent(v.email)}`)
                            } else
                                U += `&${encodeURIComponent(v)}=${encodeURIComponent(E[v])}`;
                    return `${R}?${U}`
                }(R, v),
                v.onLoad && (U.onload = v.onLoad);
                const {"onClose": H} = v;
                if (H) {
                    const reportDialogClosedMessageHandler = v => {
                        if ("__sentry_reportdialog_closed__" === v.data)
                            try {
                                H()
                            } finally {
                                Et.removeEventListener("message", reportDialogClosedMessageHandler)
                            }
                    }
                    ;
                    Et.addEventListener("message", reportDialogClosedMessageHandler)
                }
                const G = Et.document.head || Et.document.body;
                G ? G.appendChild(U) : St && fe.error("Not injecting report dialog. No injection point found in HTML")
            }
            function forceLoad() {}
            function onLoad(v) {
                v()
            }
            function captureUserFeedback(v) {
                const E = currentScopes_getClient();
                E && E.captureUserFeedback(v)
            }
            const ln = "8.30.0"
              , un = globalThis;
            function build_esm_worldwide_getGlobalSingleton(v, E, k) {
                const R = k || un
                  , U = R.__SENTRY__ = R.__SENTRY__ || {}
                  , H = U[ln] = U[ln] || {};
                return H[v] || (H[v] = E())
            }
            function esm_carrier_getMainCarrier() {
                return esm_carrier_getSentryCarrier(un),
                un
            }
            function esm_carrier_getSentryCarrier(v) {
                const E = v.__SENTRY__ = v.__SENTRY__ || {};
                return E.version = E.version || ln,
                E[ln] = E[ln] || {}
            }
            const dn = Object.prototype.toString;
            function esm_is_isBuiltin(v, E) {
                return dn.call(v) === `[object ${E}]`
            }
            function esm_is_isPlainObject(v) {
                return esm_is_isBuiltin(v, "Object")
            }
            function build_esm_misc_uuid4() {
                const v = un
                  , E = v.crypto || v.msCrypto;
                let getRandomByte = () => 16 * Math.random();
                try {
                    if (E && E.randomUUID)
                        return E.randomUUID().replace(/-/g, "");
                    E && E.getRandomValues && (getRandomByte = () => {
                        const v = new Uint8Array(1);
                        return E.getRandomValues(v),
                        v[0]
                    }
                    )
                } catch (v) {}
                return ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, (v => (v ^ (15 & getRandomByte()) >> v / 4).toString(16)))
            }
            function esm_propagationContext_generatePropagationContext() {
                return {
                    "traceId": build_esm_misc_uuid4(),
                    "spanId": build_esm_misc_uuid4().substring(16)
                }
            }
            const pn = 1e3;
            function build_esm_time_dateTimestampInSeconds() {
                return Date.now() / pn
            }
            const fn = function esm_time_createUnixTimestampInSecondsFunc() {
                const {"performance": v} = un;
                if (!v || !v.now)
                    return build_esm_time_dateTimestampInSeconds;
                const E = Date.now() - v.now()
                  , k = null == v.timeOrigin ? E : v.timeOrigin;
                return () => (k + v.now()) / pn
            }();
            let hn;
            ( () => {
                const {"performance": v} = un;
                if (!v || !v.now)
                    return void (hn = "none");
                const E = 36e5
                  , k = v.now()
                  , R = Date.now()
                  , U = v.timeOrigin ? Math.abs(v.timeOrigin + k - R) : E
                  , H = U < E
                  , G = v.timing && v.timing.navigationStart
                  , W = "number" == typeof G ? Math.abs(G + k - R) : E;
                H || W < E ? U <= W ? (hn = "timeOrigin",
                v.timeOrigin) : hn = "navigationStart" : hn = "dateNow"
            }
            )();
            const mn = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__
              , gn = ["debug", "info", "warn", "error", "log", "assert", "trace"]
              , _n = {};
            function build_esm_logger_consoleSandbox(v) {
                if (!("console"in un))
                    return v();
                const E = un.console
                  , k = {}
                  , R = Object.keys(_n);
                R.forEach((v => {
                    const R = _n[v];
                    k[v] = E[v],
                    E[v] = R
                }
                ));
                try {
                    return v()
                } finally {
                    R.forEach((v => {
                        E[v] = k[v]
                    }
                    ))
                }
            }
            const vn = build_esm_worldwide_getGlobalSingleton("logger", (function esm_logger_makeLogger() {
                let v = !1;
                const E = {
                    "enable": () => {
                        v = !0
                    }
                    ,
                    "disable": () => {
                        v = !1
                    }
                    ,
                    "isEnabled": () => v
                };
                return mn ? gn.forEach((k => {
                    E[k] = (...E) => {
                        v && build_esm_logger_consoleSandbox(( () => {
                            un.console[k](`Sentry Logger [${k}]:`, ...E)
                        }
                        ))
                    }
                }
                )) : gn.forEach((v => {
                    E[v] = () => {}
                }
                )),
                E
            }
            ));
            function esm_session_updateSession(v, E={}) {
                if (E.user && (!v.ipAddress && E.user.ip_address && (v.ipAddress = E.user.ip_address),
                v.did || E.did || (v.did = E.user.id || E.user.email || E.user.username)),
                v.timestamp = E.timestamp || fn(),
                E.abnormal_mechanism && (v.abnormal_mechanism = E.abnormal_mechanism),
                E.ignoreDuration && (v.ignoreDuration = E.ignoreDuration),
                E.sid && (v.sid = 32 === E.sid.length ? E.sid : build_esm_misc_uuid4()),
                void 0 !== E.init && (v.init = E.init),
                !v.did && E.did && (v.did = `${E.did}`),
                "number" == typeof E.started && (v.started = E.started),
                v.ignoreDuration)
                    v.duration = void 0;
                else if ("number" == typeof E.duration)
                    v.duration = E.duration;
                else {
                    const E = v.timestamp - v.started;
                    v.duration = E >= 0 ? E : 0
                }
                E.release && (v.release = E.release),
                E.environment && (v.environment = E.environment),
                !v.ipAddress && E.ipAddress && (v.ipAddress = E.ipAddress),
                !v.userAgent && E.userAgent && (v.userAgent = E.userAgent),
                "number" == typeof E.errors && (v.errors = E.errors),
                E.status && (v.status = E.status)
            }
            function build_esm_object_addNonEnumerableProperty(v, E, k) {
                try {
                    Object.defineProperty(v, E, {
                        "value": k,
                        "writable": !0,
                        "configurable": !0
                    })
                } catch (k) {
                    mn && vn.log(`Failed to add non-enumerable property "${E}" to object`, v)
                }
            }
            function utils_build_esm_object_dropUndefinedKeys(v) {
                return _sentry_utils_build_esm_object_dropUndefinedKeys(v, new Map)
            }
            function _sentry_utils_build_esm_object_dropUndefinedKeys(v, E) {
                if (function esm_object_isPojo(v) {
                    if (!esm_is_isPlainObject(v))
                        return !1;
                    try {
                        const E = Object.getPrototypeOf(v).constructor.name;
                        return !E || "Object" === E
                    } catch (v) {
                        return !0
                    }
                }(v)) {
                    const k = E.get(v);
                    if (void 0 !== k)
                        return k;
                    const R = {};
                    E.set(v, R);
                    for (const k of Object.keys(v))
                        void 0 !== v[k] && (R[k] = _sentry_utils_build_esm_object_dropUndefinedKeys(v[k], E));
                    return R
                }
                if (Array.isArray(v)) {
                    const k = E.get(v);
                    if (void 0 !== k)
                        return k;
                    const R = [];
                    return E.set(v, R),
                    v.forEach((v => {
                        R.push(_sentry_utils_build_esm_object_dropUndefinedKeys(v, E))
                    }
                    )),
                    R
                }
                return v
            }
            const yn = "_sentrySpan";
            function utils_spanOnScope_setSpanForScope(v, E) {
                E ? build_esm_object_addNonEnumerableProperty(v, yn, E) : delete v[yn]
            }
            function spanOnScope_getSpanForScope(v) {
                return v[yn]
            }
            class scope_ScopeClass {
                "constructor"() {
                    this._notifyingListeners = !1,
                    this._scopeListeners = [],
                    this._eventProcessors = [],
                    this._breadcrumbs = [],
                    this._attachments = [],
                    this._user = {},
                    this._tags = {},
                    this._extra = {},
                    this._contexts = {},
                    this._sdkProcessingMetadata = {},
                    this._propagationContext = esm_propagationContext_generatePropagationContext()
                }
                "clone"() {
                    const v = new scope_ScopeClass;
                    return v._breadcrumbs = [...this._breadcrumbs],
                    v._tags = {
                        ...this._tags
                    },
                    v._extra = {
                        ...this._extra
                    },
                    v._contexts = {
                        ...this._contexts
                    },
                    v._user = this._user,
                    v._level = this._level,
                    v._session = this._session,
                    v._transactionName = this._transactionName,
                    v._fingerprint = this._fingerprint,
                    v._eventProcessors = [...this._eventProcessors],
                    v._requestSession = this._requestSession,
                    v._attachments = [...this._attachments],
                    v._sdkProcessingMetadata = {
                        ...this._sdkProcessingMetadata
                    },
                    v._propagationContext = {
                        ...this._propagationContext
                    },
                    v._client = this._client,
                    v._lastEventId = this._lastEventId,
                    utils_spanOnScope_setSpanForScope(v, spanOnScope_getSpanForScope(this)),
                    v
                }
                "setClient"(v) {
                    this._client = v
                }
                "setLastEventId"(v) {
                    this._lastEventId = v
                }
                "getClient"() {
                    return this._client
                }
                "lastEventId"() {
                    return this._lastEventId
                }
                "addScopeListener"(v) {
                    this._scopeListeners.push(v)
                }
                "addEventProcessor"(v) {
                    return this._eventProcessors.push(v),
                    this
                }
                "setUser"(v) {
                    return this._user = v || {
                        "email": void 0,
                        "id": void 0,
                        "ip_address": void 0,
                        "username": void 0
                    },
                    this._session && esm_session_updateSession(this._session, {
                        "user": v
                    }),
                    this._notifyScopeListeners(),
                    this
                }
                "getUser"() {
                    return this._user
                }
                "getRequestSession"() {
                    return this._requestSession
                }
                "setRequestSession"(v) {
                    return this._requestSession = v,
                    this
                }
                "setTags"(v) {
                    return this._tags = {
                        ...this._tags,
                        ...v
                    },
                    this._notifyScopeListeners(),
                    this
                }
                "setTag"(v, E) {
                    return this._tags = {
                        ...this._tags,
                        [v]: E
                    },
                    this._notifyScopeListeners(),
                    this
                }
                "setExtras"(v) {
                    return this._extra = {
                        ...this._extra,
                        ...v
                    },
                    this._notifyScopeListeners(),
                    this
                }
                "setExtra"(v, E) {
                    return this._extra = {
                        ...this._extra,
                        [v]: E
                    },
                    this._notifyScopeListeners(),
                    this
                }
                "setFingerprint"(v) {
                    return this._fingerprint = v,
                    this._notifyScopeListeners(),
                    this
                }
                "setLevel"(v) {
                    return this._level = v,
                    this._notifyScopeListeners(),
                    this
                }
                "setTransactionName"(v) {
                    return this._transactionName = v,
                    this._notifyScopeListeners(),
                    this
                }
                "setContext"(v, E) {
                    return null === E ? delete this._contexts[v] : this._contexts[v] = E,
                    this._notifyScopeListeners(),
                    this
                }
                "setSession"(v) {
                    return v ? this._session = v : delete this._session,
                    this._notifyScopeListeners(),
                    this
                }
                "getSession"() {
                    return this._session
                }
                "update"(v) {
                    if (!v)
                        return this;
                    const E = "function" == typeof v ? v(this) : v
                      , [k,R] = E instanceof bn ? [E.getScopeData(), E.getRequestSession()] : esm_is_isPlainObject(E) ? [v, v.requestSession] : []
                      , {"tags": U, "extra": H, "user": G, "contexts": W, "level": Z, "fingerprint": Y=[], "propagationContext": J} = k || {};
                    return this._tags = {
                        ...this._tags,
                        ...U
                    },
                    this._extra = {
                        ...this._extra,
                        ...H
                    },
                    this._contexts = {
                        ...this._contexts,
                        ...W
                    },
                    G && Object.keys(G).length && (this._user = G),
                    Z && (this._level = Z),
                    Y.length && (this._fingerprint = Y),
                    J && (this._propagationContext = J),
                    R && (this._requestSession = R),
                    this
                }
                "clear"() {
                    return this._breadcrumbs = [],
                    this._tags = {},
                    this._extra = {},
                    this._user = {},
                    this._contexts = {},
                    this._level = void 0,
                    this._transactionName = void 0,
                    this._fingerprint = void 0,
                    this._requestSession = void 0,
                    this._session = void 0,
                    utils_spanOnScope_setSpanForScope(this, void 0),
                    this._attachments = [],
                    this._propagationContext = esm_propagationContext_generatePropagationContext(),
                    this._notifyScopeListeners(),
                    this
                }
                "addBreadcrumb"(v, E) {
                    const k = "number" == typeof E ? E : 100;
                    if (k <= 0)
                        return this;
                    const R = {
                        "timestamp": build_esm_time_dateTimestampInSeconds(),
                        ...v
                    }
                      , U = this._breadcrumbs;
                    return U.push(R),
                    this._breadcrumbs = U.length > k ? U.slice(-k) : U,
                    this._notifyScopeListeners(),
                    this
                }
                "getLastBreadcrumb"() {
                    return this._breadcrumbs[this._breadcrumbs.length - 1]
                }
                "clearBreadcrumbs"() {
                    return this._breadcrumbs = [],
                    this._notifyScopeListeners(),
                    this
                }
                "addAttachment"(v) {
                    return this._attachments.push(v),
                    this
                }
                "clearAttachments"() {
                    return this._attachments = [],
                    this
                }
                "getScopeData"() {
                    return {
                        "breadcrumbs": this._breadcrumbs,
                        "attachments": this._attachments,
                        "contexts": this._contexts,
                        "tags": this._tags,
                        "extra": this._extra,
                        "user": this._user,
                        "level": this._level,
                        "fingerprint": this._fingerprint || [],
                        "eventProcessors": this._eventProcessors,
                        "propagationContext": this._propagationContext,
                        "sdkProcessingMetadata": this._sdkProcessingMetadata,
                        "transactionName": this._transactionName,
                        "span": spanOnScope_getSpanForScope(this)
                    }
                }
                "setSDKProcessingMetadata"(v) {
                    return this._sdkProcessingMetadata = {
                        ...this._sdkProcessingMetadata,
                        ...v
                    },
                    this
                }
                "setPropagationContext"(v) {
                    return this._propagationContext = v,
                    this
                }
                "getPropagationContext"() {
                    return this._propagationContext
                }
                "captureException"(v, E) {
                    const k = E && E.event_id ? E.event_id : build_esm_misc_uuid4();
                    if (!this._client)
                        return vn.warn("No client configured on scope - will not capture exception!"),
                        k;
                    const R = new Error("Sentry syntheticException");
                    return this._client.captureException(v, {
                        "originalException": v,
                        "syntheticException": R,
                        ...E,
                        "event_id": k
                    }, this),
                    k
                }
                "captureMessage"(v, E, k) {
                    const R = k && k.event_id ? k.event_id : build_esm_misc_uuid4();
                    if (!this._client)
                        return vn.warn("No client configured on scope - will not capture message!"),
                        R;
                    const U = new Error(v);
                    return this._client.captureMessage(v, E, {
                        "originalException": v,
                        "syntheticException": U,
                        ...k,
                        "event_id": R
                    }, this),
                    R
                }
                "captureEvent"(v, E) {
                    const k = E && E.event_id ? E.event_id : build_esm_misc_uuid4();
                    return this._client ? (this._client.captureEvent(v, {
                        ...E,
                        "event_id": k
                    }, this),
                    k) : (vn.warn("No client configured on scope - will not capture event!"),
                    k)
                }
                "_notifyScopeListeners"() {
                    this._notifyingListeners || (this._notifyingListeners = !0,
                    this._scopeListeners.forEach((v => {
                        v(this)
                    }
                    )),
                    this._notifyingListeners = !1)
                }
            }
            const bn = scope_ScopeClass;
            class stackStrategy_AsyncContextStack {
                "constructor"(v, E) {
                    let k, R;
                    k = v || new bn,
                    R = E || new bn,
                    this._stack = [{
                        "scope": k
                    }],
                    this._isolationScope = R
                }
                "withScope"(v) {
                    const E = this._pushScope();
                    let k;
                    try {
                        k = v(E)
                    } catch (v) {
                        throw this._popScope(),
                        v
                    }
                    return function build_esm_is_isThenable(v) {
                        return Boolean(v && v.then && "function" == typeof v.then)
                    }(k) ? k.then((v => (this._popScope(),
                    v)), (v => {
                        throw this._popScope(),
                        v
                    }
                    )) : (this._popScope(),
                    k)
                }
                "getClient"() {
                    return this.getStackTop().client
                }
                "getScope"() {
                    return this.getStackTop().scope
                }
                "getIsolationScope"() {
                    return this._isolationScope
                }
                "getStackTop"() {
                    return this._stack[this._stack.length - 1]
                }
                "_pushScope"() {
                    const v = this.getScope().clone();
                    return this._stack.push({
                        "client": this.getClient(),
                        "scope": v
                    }),
                    v
                }
                "_popScope"() {
                    return !(this._stack.length <= 1) && !!this._stack.pop()
                }
            }
            function stackStrategy_getAsyncContextStack() {
                const v = esm_carrier_getSentryCarrier(esm_carrier_getMainCarrier());
                return v.stack = v.stack || new stackStrategy_AsyncContextStack(function defaultScopes_getDefaultCurrentScope() {
                    return build_esm_worldwide_getGlobalSingleton("defaultCurrentScope", ( () => new bn))
                }(),function defaultScopes_getDefaultIsolationScope() {
                    return build_esm_worldwide_getGlobalSingleton("defaultIsolationScope", ( () => new bn))
                }())
            }
            function asyncContext_stackStrategy_withScope(v) {
                return stackStrategy_getAsyncContextStack().withScope(v)
            }
            function stackStrategy_withSetScope(v, E) {
                const k = stackStrategy_getAsyncContextStack();
                return k.withScope(( () => (k.getStackTop().scope = v,
                E(v))))
            }
            function asyncContext_stackStrategy_withIsolationScope(v) {
                return stackStrategy_getAsyncContextStack().withScope(( () => v(stackStrategy_getAsyncContextStack().getIsolationScope())))
            }
            function esm_asyncContext_getAsyncContextStrategy(v) {
                const E = esm_carrier_getSentryCarrier(v);
                return E.acs ? E.acs : function stackStrategy_getStackAsyncContextStrategy() {
                    return {
                        "withIsolationScope": asyncContext_stackStrategy_withIsolationScope,
                        "withScope": asyncContext_stackStrategy_withScope,
                        "withSetScope": stackStrategy_withSetScope,
                        "withSetIsolationScope": (v, E) => asyncContext_stackStrategy_withIsolationScope(E),
                        "getCurrentScope": () => stackStrategy_getAsyncContextStack().getScope(),
                        "getIsolationScope": () => stackStrategy_getAsyncContextStack().getIsolationScope()
                    }
                }()
            }
            function esm_currentScopes_getCurrentScope() {
                return esm_asyncContext_getAsyncContextStrategy(esm_carrier_getMainCarrier()).getCurrentScope()
            }
            function hasTracingEnabled(v) {
                if ("boolean" == typeof __SENTRY_TRACING__ && !__SENTRY_TRACING__)
                    return !1;
                const E = function esm_currentScopes_getClient() {
                    return esm_currentScopes_getCurrentScope().getClient()
                }()
                  , k = v || E && E.getOptions();
                return !!k && (k.enableTracing || "tracesSampleRate"in k || "tracesSampler"in k)
            }
            const Sn = ["activate", "mount", "update"]
              , wn = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__;
            new WeakMap;
            function prepareEvent_parseEventHintOrCaptureContext(v) {
                if (v)
                    return function prepareEvent_hintIsScopeOrFunction(v) {
                        return v instanceof bn || "function" == typeof v
                    }(v) || function prepareEvent_hintIsScopeContext(v) {
                        return Object.keys(v).some((v => En.includes(v)))
                    }(v) ? {
                        "captureContext": v
                    } : v
            }
            const En = ["user", "level", "extra", "contexts", "tags", "fingerprint", "requestSession", "propagationContext"];
            const Cn = /(?:^|[-_])(\w)/g
              , Tn = "<Anonymous>"
              , formatComponentName = (v, E) => {
                if (!v)
                    return Tn;
                if (v.$root === v)
                    return "<Root>";
                if (!v.$options)
                    return Tn;
                const k = v.$options;
                let R = k.name || k._componentTag || k.__name;
                const U = k.__file;
                if (!R && U) {
                    const v = U.match(/([^/\\]+)\.vue$/);
                    v && (R = v[1])
                }
                return (R ? `<${H = R,
                H.replace(Cn, (v => v.toUpperCase())).replace(/[-_]/g, "")}>` : Tn) + (U && !1 !== E ? ` at ${U}` : "");
                var H
            }
              , attachErrorHandler = (v, E) => {
                const {"errorHandler": k, "warnHandler": R, "silent": U} = v.config;
                v.config.errorHandler = (H, G, W) => {
                    const Z = formatComponentName(G, !1)
                      , Y = G ? (v => {
                        if (v && (v._isVue || v.__isVue) && v.$parent) {
                            const E = [];
                            let k = 0;
                            for (; v; ) {
                                if (E.length > 0) {
                                    const R = E[E.length - 1];
                                    if (R.constructor === v.constructor) {
                                        k++,
                                        v = v.$parent;
                                        continue
                                    }
                                    k > 0 && (E[E.length - 1] = [R, k],
                                    k = 0)
                                }
                                E.push(v),
                                v = v.$parent
                            }
                            const R = E.map(( (v, E) => `${(0 === E ? "---\x3e " : ( (v, E) => " ".repeat(E))(0, 5 + 2 * E)) + (Array.isArray(v) ? `${formatComponentName(v[0])}... (${v[1]} recursive calls)` : formatComponentName(v))}`)).join("\n");
                            return `\n\nfound in\n\n${R}`
                        }
                        return `\n\n(found in ${formatComponentName(v)})`
                    }
                    )(G) : ""
                      , J = {
                        "componentName": Z,
                        "lifecycleHook": W,
                        "trace": Y
                    };
                    if (E.attachProps && G && (G.$options && G.$options.propsData ? J.propsData = G.$options.propsData : G.$props && (J.propsData = G.$props)),
                    setTimeout(( () => {
                        !function exports_captureException(v, E) {
                            return esm_currentScopes_getCurrentScope().captureException(v, prepareEvent_parseEventHintOrCaptureContext(E))
                        }(H, {
                            "captureContext": {
                                "contexts": {
                                    "vue": J
                                }
                            },
                            "mechanism": {
                                "handled": !1
                            }
                        })
                    }
                    )),
                    "function" == typeof k && k.call(v, H, G, W),
                    E.logErrors) {
                        const v = "undefined" != typeof console
                          , E = `Error in ${W}: "${H && H.toString()}"`;
                        R ? R.call(null, E, G, Y) : v && !U && build_esm_logger_consoleSandbox(( () => {
                            console.error(`[Vue warn]: ${E}${Y}`)
                        }
                        ))
                    }
                }
            }
            ;
            function handleCallbackErrors_handleCallbackErrors(v, E, k=( () => {}
            )) {
                let R;
                try {
                    R = v()
                } catch (v) {
                    throw E(v),
                    k(),
                    v
                }
                return function maybeHandlePromiseRejection(v, E, k) {
                    if (is_isThenable(v))
                        return v.then((v => (k(),
                        v)), (v => {
                            throw E(v),
                            k(),
                            v
                        }
                        ));
                    return k(),
                    v
                }(R, E, k)
            }
            function hasTracingEnabled_hasTracingEnabled(v) {
                if ("boolean" == typeof __SENTRY_TRACING__ && !__SENTRY_TRACING__)
                    return !1;
                const E = currentScopes_getClient()
                  , k = v || E && E.getOptions();
                return !!k && (k.enableTracing || "tracesSampleRate"in k || "tracesSampler"in k)
            }
            class sentryNonRecordingSpan_SentryNonRecordingSpan {
                "constructor"(v={}) {
                    this._traceId = v.traceId || misc_uuid4(),
                    this._spanId = v.spanId || misc_uuid4().substring(16)
                }
                "spanContext"() {
                    return {
                        "spanId": this._spanId,
                        "traceId": this._traceId,
                        "traceFlags": 0
                    }
                }
                "end"(v) {}
                "setAttribute"(v, E) {
                    return this
                }
                "setAttributes"(v) {
                    return this
                }
                "setStatus"(v) {
                    return this
                }
                "updateName"(v) {
                    return this
                }
                "isRecording"() {
                    return !1
                }
                "addEvent"(v, E, k) {
                    return this
                }
                "addLink"(v) {
                    return this
                }
                "addLinks"(v) {
                    return this
                }
                "recordException"(v, E) {}
            }
            function setMeasurement(v, E, k, R=getActiveSpan()) {
                const U = R && getRootSpan(R);
                U && U.addEvent(v, {
                    [Ge]: E,
                    [qe]: k
                })
            }
            function timedEventsToMeasurements(v) {
                if (!v || 0 === v.length)
                    return;
                const E = {};
                return v.forEach((v => {
                    const k = v.attributes || {}
                      , R = k[qe]
                      , U = k[Ge];
                    "string" == typeof R && "number" == typeof U && (E[v.name] = {
                        "value": U,
                        "unit": R
                    })
                }
                )),
                E
            }
            const xn = "_sentryScope"
              , An = "_sentryIsolationScope";
            function getCapturedScopesOnSpan(v) {
                return {
                    "scope": v[xn],
                    "isolationScope": v[An]
                }
            }
            class SentrySpan {
                "constructor"(v={}) {
                    this._traceId = v.traceId || misc_uuid4(),
                    this._spanId = v.spanId || misc_uuid4().substring(16),
                    this._startTime = v.startTimestamp || ye(),
                    this._attributes = {},
                    this.setAttributes({
                        [He]: "manual",
                        [Ue]: v.op,
                        ...v.attributes
                    }),
                    this._name = v.name,
                    v.parentSpanId && (this._parentSpanId = v.parentSpanId),
                    "sampled"in v && (this._sampled = v.sampled),
                    v.endTimestamp && (this._endTime = v.endTimestamp),
                    this._events = [],
                    this._isStandaloneSpan = v.isStandalone,
                    this._endTime && this._onSpanEnded()
                }
                "addLink"(v) {
                    return this
                }
                "addLinks"(v) {
                    return this
                }
                "recordException"(v, E) {}
                "spanContext"() {
                    const {"_spanId": v, "_traceId": E, "_sampled": k} = this;
                    return {
                        "spanId": v,
                        "traceId": E,
                        "traceFlags": k ? Ke : 0
                    }
                }
                "setAttribute"(v, E) {
                    return void 0 === E ? delete this._attributes[v] : this._attributes[v] = E,
                    this
                }
                "setAttributes"(v) {
                    return Object.keys(v).forEach((E => this.setAttribute(E, v[E]))),
                    this
                }
                "updateStartTime"(v) {
                    this._startTime = spanTimeInputToSeconds(v)
                }
                "setStatus"(v) {
                    return this._status = v,
                    this
                }
                "updateName"(v) {
                    return this._name = v,
                    this
                }
                "end"(v) {
                    this._endTime || (this._endTime = spanTimeInputToSeconds(v),
                    function logSpanEnd(v) {
                        if (!_e)
                            return;
                        const {"description": E="< unknown name >", "op": k="< unknown op >"} = spanUtils_spanToJSON(v)
                          , {"spanId": R} = v.spanContext()
                          , U = `[Tracing] Finishing "${k}" ${getRootSpan(v) === v ? "root " : ""}span "${E}" with ID ${R}`;
                        fe.log(U)
                    }(this),
                    this._onSpanEnded())
                }
                "getSpanJSON"() {
                    return object_dropUndefinedKeys({
                        "data": this._attributes,
                        "description": this._name,
                        "op": this._attributes[Ue],
                        "parent_span_id": this._parentSpanId,
                        "span_id": this._spanId,
                        "start_timestamp": this._startTime,
                        "status": getStatusMessage(this._status),
                        "timestamp": this._endTime,
                        "trace_id": this._traceId,
                        "origin": this._attributes[He],
                        "_metrics_summary": getMetricSummaryJsonForSpan(this),
                        "profile_id": this._attributes["sentry.profile_id"],
                        "exclusive_time": this._attributes["sentry.exclusive_time"],
                        "measurements": timedEventsToMeasurements(this._events),
                        "is_segment": this._isStandaloneSpan && getRootSpan(this) === this || void 0,
                        "segment_id": this._isStandaloneSpan ? getRootSpan(this).spanContext().spanId : void 0
                    })
                }
                "isRecording"() {
                    return !this._endTime && !!this._sampled
                }
                "addEvent"(v, E, k) {
                    _e && fe.log("[Tracing] Adding an event to span:", v);
                    const R = isSpanTimeInput(E) ? E : k || ye()
                      , U = isSpanTimeInput(E) ? {} : E || {}
                      , H = {
                        "name": v,
                        "time": spanTimeInputToSeconds(R),
                        "attributes": U
                    };
                    return this._events.push(H),
                    this
                }
                "isStandaloneSpan"() {
                    return !!this._isStandaloneSpan
                }
                "_onSpanEnded"() {
                    const v = currentScopes_getClient();
                    v && v.emit("spanEnd", this);
                    if (!(this._isStandaloneSpan || this === getRootSpan(this)))
                        return;
                    if (this._isStandaloneSpan)
                        return void (this._sampled ? function sendSpanEnvelope(v) {
                            const E = currentScopes_getClient();
                            if (!E)
                                return;
                            const k = v[1];
                            if (!k || 0 === k.length)
                                return void E.recordDroppedEvent("before_send", "span");
                            const R = E.getTransport();
                            R && R.send(v).then(null, (v => {
                                _e && fe.error("Error while sending span:", v)
                            }
                            ))
                        }(function createSpanEnvelope(v, E) {
                            const k = getDynamicSamplingContextFromSpan(v[0])
                              , R = E && E.getDsn()
                              , U = E && E.getOptions().tunnel
                              , H = {
                                "sent_at": (new Date).toISOString(),
                                ...function dscHasRequiredProps(v) {
                                    return !!v.trace_id && !!v.public_key
                                }(k) && {
                                    "trace": k
                                },
                                ...!!U && R && {
                                    "dsn": dsn_dsnToString(R)
                                }
                            }
                              , G = E && E.getOptions().beforeSendSpan
                              , W = G ? v => G(spanUtils_spanToJSON(v)) : v => spanUtils_spanToJSON(v)
                              , Z = [];
                            for (const E of v) {
                                const v = W(E);
                                v && Z.push(createSpanEnvelopeItem(v))
                            }
                            return envelope_createEnvelope(H, Z)
                        }([this], v)) : (_e && fe.log("[Tracing] Discarding standalone span because its trace was not chosen to be sampled."),
                        v && v.recordDroppedEvent("sample_rate", "span")));
                    const E = this._convertSpanToTransaction();
                    if (E) {
                        (getCapturedScopesOnSpan(this).scope || currentScopes_getCurrentScope()).captureEvent(E)
                    }
                }
                "_convertSpanToTransaction"() {
                    if (!isFullFinishedSpan(spanUtils_spanToJSON(this)))
                        return;
                    this._name || (_e && fe.warn("Transaction has no name, falling back to `<unlabeled transaction>`."),
                    this._name = "<unlabeled transaction>");
                    const {"scope": v, "isolationScope": E} = getCapturedScopesOnSpan(this)
                      , k = (v || currentScopes_getCurrentScope()).getClient() || currentScopes_getClient();
                    if (!0 !== this._sampled)
                        return _e && fe.log("[Tracing] Discarding transaction because its trace was not chosen to be sampled."),
                        void (k && k.recordDroppedEvent("sample_rate", "transaction"));
                    const R = getSpanDescendants(this).filter((v => v !== this && !function isStandaloneSpan(v) {
                        return v instanceof SentrySpan && v.isStandaloneSpan()
                    }(v))).map((v => spanUtils_spanToJSON(v))).filter(isFullFinishedSpan)
                      , U = this._attributes[je]
                      , H = {
                        "contexts": {
                            "trace": spanToTransactionTraceContext(this)
                        },
                        "spans": R.length > 1e3 ? R.sort(( (v, E) => v.start_timestamp - E.start_timestamp)).slice(0, 1e3) : R,
                        "start_timestamp": this._startTime,
                        "timestamp": this._endTime,
                        "transaction": this._name,
                        "type": "transaction",
                        "sdkProcessingMetadata": {
                            "capturedSpanScope": v,
                            "capturedSpanIsolationScope": E,
                            ...object_dropUndefinedKeys({
                                "dynamicSamplingContext": getDynamicSamplingContextFromSpan(this)
                            })
                        },
                        "_metrics_summary": getMetricSummaryJsonForSpan(this),
                        ...U && {
                            "transaction_info": {
                                "source": U
                            }
                        }
                    }
                      , G = timedEventsToMeasurements(this._events);
                    return G && Object.keys(G).length && (_e && fe.log("[Measurements] Adding measurements to transaction event", JSON.stringify(G, void 0, 2)),
                    H.measurements = G),
                    H
                }
            }
            function isSpanTimeInput(v) {
                return v && "number" == typeof v || v instanceof Date || Array.isArray(v)
            }
            function isFullFinishedSpan(v) {
                return !!(v.start_timestamp && v.timestamp && v.span_id && v.trace_id)
            }
            const In = "__SENTRY_SUPPRESS_TRACING__";
            function startSpan(v, E) {
                const k = getAcs();
                if (k.startSpan)
                    return k.startSpan(v, E);
                const R = parseSentrySpanArguments(v)
                  , {"forceTransaction": U, "parentSpan": H} = v;
                return currentScopes_withScope(v.scope, ( () => getActiveSpanWrapper(H)(( () => {
                    const k = currentScopes_getCurrentScope()
                      , H = getParentSpan(k)
                      , G = v.onlyIfParent && !H ? new sentryNonRecordingSpan_SentryNonRecordingSpan : createChildOrRootSpan({
                        "parentSpan": H,
                        "spanArguments": R,
                        "forceTransaction": U,
                        "scope": k
                    });
                    return spanOnScope_setSpanForScope(k, G),
                    handleCallbackErrors_handleCallbackErrors(( () => E(G)), ( () => {
                        const {"status": v} = spanUtils_spanToJSON(G);
                        !G.isRecording() || v && "ok" !== v || G.setStatus({
                            "code": Je,
                            "message": "internal_error"
                        })
                    }
                    ), ( () => G.end()))
                }
                ))))
            }
            function startSpanManual(v, E) {
                const k = getAcs();
                if (k.startSpanManual)
                    return k.startSpanManual(v, E);
                const R = parseSentrySpanArguments(v)
                  , {"forceTransaction": U, "parentSpan": H} = v;
                return currentScopes_withScope(v.scope, ( () => getActiveSpanWrapper(H)(( () => {
                    const k = currentScopes_getCurrentScope()
                      , H = getParentSpan(k)
                      , G = v.onlyIfParent && !H ? new sentryNonRecordingSpan_SentryNonRecordingSpan : createChildOrRootSpan({
                        "parentSpan": H,
                        "spanArguments": R,
                        "forceTransaction": U,
                        "scope": k
                    });
                    function finishAndSetSpan() {
                        G.end()
                    }
                    return spanOnScope_setSpanForScope(k, G),
                    handleCallbackErrors_handleCallbackErrors(( () => E(G, finishAndSetSpan)), ( () => {
                        const {"status": v} = spanUtils_spanToJSON(G);
                        !G.isRecording() || v && "ok" !== v || G.setStatus({
                            "code": Je,
                            "message": "internal_error"
                        })
                    }
                    ))
                }
                ))))
            }
            function startInactiveSpan(v) {
                const E = getAcs();
                if (E.startInactiveSpan)
                    return E.startInactiveSpan(v);
                const k = parseSentrySpanArguments(v)
                  , {"forceTransaction": R, "parentSpan": U} = v;
                return (v.scope ? E => currentScopes_withScope(v.scope, E) : void 0 !== U ? v => withActiveSpan(U, v) : v => v())(( () => {
                    const E = currentScopes_getCurrentScope()
                      , U = getParentSpan(E);
                    return v.onlyIfParent && !U ? new sentryNonRecordingSpan_SentryNonRecordingSpan : createChildOrRootSpan({
                        "parentSpan": U,
                        "spanArguments": k,
                        "forceTransaction": R,
                        "scope": E
                    })
                }
                ))
            }
            const continueTrace = ({"sentryTrace": v, "baggage": E}, k) => currentScopes_withScope((R => {
                const U = tracing_propagationContextFromHeaders(v, E);
                return R.setPropagationContext(U),
                k()
            }
            ));
            function withActiveSpan(v, E) {
                const k = getAcs();
                return k.withActiveSpan ? k.withActiveSpan(v, E) : currentScopes_withScope((k => (spanOnScope_setSpanForScope(k, v || void 0),
                E(k))))
            }
            function startNewTrace(v) {
                return currentScopes_withScope((E => (E.setPropagationContext(propagationContext_generatePropagationContext()),
                _e && fe.info(`Starting a new trace with id ${E.getPropagationContext().traceId}`),
                withActiveSpan(null, v))))
            }
            function createChildOrRootSpan({"parentSpan": v, "spanArguments": E, "forceTransaction": k, "scope": R}) {
                if (!hasTracingEnabled_hasTracingEnabled())
                    return new sentryNonRecordingSpan_SentryNonRecordingSpan;
                const U = currentScopes_getIsolationScope();
                let H;
                if (v && !k)
                    H = function _startChildSpan(v, E, k) {
                        const {"spanId": R, "traceId": U} = v.spanContext()
                          , H = !E.getScopeData().sdkProcessingMetadata[In] && spanIsSampled(v)
                          , G = H ? new SentrySpan({
                            ...k,
                            "parentSpanId": R,
                            "traceId": U,
                            "sampled": H
                        }) : new sentryNonRecordingSpan_SentryNonRecordingSpan({
                            "traceId": U
                        });
                        addChildSpanToSpan(v, G);
                        const W = currentScopes_getClient();
                        W && (W.emit("spanStart", G),
                        k.endTimestamp && W.emit("spanEnd", G));
                        return G
                    }(v, R, E),
                    addChildSpanToSpan(v, H);
                else if (v) {
                    const k = getDynamicSamplingContextFromSpan(v)
                      , {"traceId": U, "spanId": G} = v.spanContext()
                      , W = spanIsSampled(v);
                    H = _startRootSpan({
                        "traceId": U,
                        "parentSpanId": G,
                        ...E
                    }, R, W),
                    freezeDscOnSpan(H, k)
                } else {
                    const {"traceId": v, "dsc": k, "parentSpanId": G, "sampled": W} = {
                        ...U.getPropagationContext(),
                        ...R.getPropagationContext()
                    };
                    H = _startRootSpan({
                        "traceId": v,
                        "parentSpanId": G,
                        ...E
                    }, R, W),
                    k && freezeDscOnSpan(H, k)
                }
                return function logSpanStart(v) {
                    if (!_e)
                        return;
                    const {"description": E="< unknown name >", "op": k="< unknown op >", "parent_span_id": R} = spanUtils_spanToJSON(v)
                      , {"spanId": U} = v.spanContext()
                      , H = spanIsSampled(v)
                      , G = getRootSpan(v)
                      , W = G === v
                      , Z = `[Tracing] Starting ${H ? "sampled" : "unsampled"} ${W ? "root " : ""}span`
                      , Y = [`op: ${k}`, `name: ${E}`, `ID: ${U}`];
                    if (R && Y.push(`parent ID: ${R}`),
                    !W) {
                        const {"op": v, "description": E} = spanUtils_spanToJSON(G);
                        Y.push(`root ID: ${G.spanContext().spanId}`),
                        v && Y.push(`root op: ${v}`),
                        E && Y.push(`root description: ${E}`)
                    }
                    fe.log(`${Z}\n  ${Y.join("\n  ")}`)
                }(H),
                function setCapturedScopesOnSpan(v, E, k) {
                    v && (object_addNonEnumerableProperty(v, An, k),
                    object_addNonEnumerableProperty(v, xn, E))
                }(H, R, U),
                H
            }
            function parseSentrySpanArguments(v) {
                const E = {
                    "isStandalone": (v.experimental || {}).standalone,
                    ...v
                };
                if (v.startTime) {
                    const k = {
                        ...E
                    };
                    return k.startTimestamp = spanTimeInputToSeconds(v.startTime),
                    delete k.startTime,
                    k
                }
                return E
            }
            function getAcs() {
                return asyncContext_getAsyncContextStrategy(carrier_getMainCarrier())
            }
            function _startRootSpan(v, E, k) {
                const R = currentScopes_getClient()
                  , U = R && R.getOptions() || {}
                  , {"name": H="", "attributes": G} = v
                  , [W,Z] = E.getScopeData().sdkProcessingMetadata[In] ? [!1] : function sampleSpan(v, E) {
                    if (!hasTracingEnabled_hasTracingEnabled(v))
                        return [!1];
                    let k;
                    k = "function" == typeof v.tracesSampler ? v.tracesSampler(E) : void 0 !== E.parentSampled ? E.parentSampled : void 0 !== v.tracesSampleRate ? v.tracesSampleRate : 1;
                    const R = parseSampleRate(k);
                    return void 0 === R ? (_e && fe.warn("[Tracing] Discarding transaction because of invalid sample rate."),
                    [!1]) : R ? Math.random() < R ? [!0, R] : (_e && fe.log(`[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(k)})`),
                    [!1, R]) : (_e && fe.log("[Tracing] Discarding transaction because " + ("function" == typeof v.tracesSampler ? "tracesSampler returned 0 or false" : "a negative sampling decision was inherited or tracesSampleRate is set to 0")),
                    [!1, R])
                }(U, {
                    "name": H,
                    "parentSampled": k,
                    "attributes": G,
                    "transactionContext": {
                        "name": H,
                        "parentSampled": k
                    }
                })
                  , Y = new SentrySpan({
                    ...v,
                    "attributes": {
                        [je]: "custom",
                        ...v.attributes
                    },
                    "sampled": W
                });
                return void 0 !== Z && Y.setAttribute(Be, Z),
                R && R.emit("spanStart", Y),
                Y
            }
            function getParentSpan(v) {
                const E = _getSpanForScope(v);
                if (!E)
                    return;
                const k = currentScopes_getClient();
                return (k ? k.getOptions() : {}).parentSpanIsAlwaysRootSpan ? getRootSpan(E) : E
            }
            function getActiveSpanWrapper(v) {
                return void 0 !== v ? E => withActiveSpan(v, E) : v => v()
            }
            const kn = "ui.vue"
              , On = {
                "activate": ["activated", "deactivated"],
                "create": ["beforeCreate", "created"],
                "unmount": ["beforeUnmount", "unmounted"],
                "destroy": ["beforeDestroy", "destroyed"],
                "mount": ["beforeMount", "mounted"],
                "update": ["beforeUpdate", "updated"]
            };
            function findTrackComponent(v, E) {
                function extractComponentName(v) {
                    return v.replace(/^<([^\s]*)>(?: at [^\s]*)?$/, "$1")
                }
                return v.some((v => extractComponentName(E) === extractComponentName(v)))
            }
            const createTracingMixins = v => {
                const E = (v.hooks || []).concat(Sn).filter(( (v, E, k) => k.indexOf(v) === E))
                  , k = {};
                for (const R of E) {
                    const E = On[R];
                    if (E)
                        for (const U of E)
                            k[U] = function() {
                                const k = this.$root === this;
                                if (k) {
                                    getActiveSpan() && (this.$_sentryRootSpan = this.$_sentryRootSpan || startInactiveSpan({
                                        "name": "Application Render",
                                        "op": `${kn}.render`,
                                        "attributes": {
                                            [He]: "auto.ui.vue"
                                        }
                                    }))
                                }
                                const H = formatComponentName(this, !1)
                                  , G = Array.isArray(v.trackComponents) ? findTrackComponent(v.trackComponents, H) : v.trackComponents;
                                var W, Z, Y;
                                if (k || G)
                                    if (this.$_sentrySpans = this.$_sentrySpans || {},
                                    U == E[0]) {
                                        if (this.$root && this.$root.$_sentryRootSpan || getActiveSpan()) {
                                            const v = this.$_sentrySpans[R];
                                            v && v.end(),
                                            this.$_sentrySpans[R] = startInactiveSpan({
                                                "name": `Vue ${H}`,
                                                "op": `${kn}.${R}`,
                                                "attributes": {
                                                    [He]: "auto.ui.vue"
                                                },
                                                "onlyIfParent": !0
                                            })
                                        }
                                    } else {
                                        const E = this.$_sentrySpans[R];
                                        if (!E)
                                            return;
                                        E.end(),
                                        W = this,
                                        Z = fn(),
                                        Y = v.timeout,
                                        W.$_sentryRootSpanTimer && clearTimeout(W.$_sentryRootSpanTimer),
                                        W.$_sentryRootSpanTimer = setTimeout(( () => {
                                            W.$root && W.$root.$_sentryRootSpan && (W.$root.$_sentryRootSpan.end(Z),
                                            W.$root.$_sentryRootSpan = void 0)
                                        }
                                        ), Y)
                                    }
                            }
                            ;
                    else
                        wn && vn.warn(`Unknown hook: ${R}`)
                }
                return k
            }
              , Pn = {
                "Vue": un.Vue,
                "attachProps": !0,
                "logErrors": !0,
                "hooks": Sn,
                "timeout": 2e3,
                "trackComponents": !1
            }
              , vueIntegration = (v={}) => ({
                "name": "Vue",
                "setup"(E) {
                    !function _setupIntegration(v, E) {
                        const k = {
                            ...Pn,
                            ...v.getOptions(),
                            ...E
                        };
                        if (!k.Vue && !k.app)
                            return void build_esm_logger_consoleSandbox(( () => {
                                console.warn("[@sentry/vue]: Misconfigured SDK. Vue specific errors will not be captured.\nUpdate your `Sentry.init` call with an appropriate config option:\n`app` (Application Instance - Vue 3) or `Vue` (Vue Constructor - Vue 2).")
                            }
                            ));
                        if (k.app) {
                            (function build_esm_misc_arrayify(v) {
                                return Array.isArray(v) ? v : [v]
                            }
                            )(k.app).forEach((v => vueInit(v, k)))
                        } else
                            k.Vue && vueInit(k.Vue, k)
                    }(E, v)
                }
            });
            const vueInit = (v, E) => {
                if (wn) {
                    const E = v;
                    !0 === (E._instance && E._instance.isMounted) && build_esm_logger_consoleSandbox(( () => {
                        console.warn("[@sentry/vue]: Misconfigured SDK. Vue app is already mounted. Make sure to call `app.mount()` after `Sentry.init()`.")
                    }
                    ))
                }
                attachErrorHandler(v, E),
                hasTracingEnabled(E) && v.mixin(createTracingMixins({
                    ...E,
                    ...E.tracingOptions
                }))
            }
            ;
            function sdk_init(v={}) {
                return init({
                    "_metadata": {
                        "sdk": {
                            "name": "sentry.javascript.vue",
                            "packages": [{
                                "name": "npm:@sentry/vue",
                                "version": ce
                            }],
                            "version": ce
                        }
                    },
                    "defaultIntegrations": [...getDefaultIntegrations(), vueIntegration()],
                    ...v
                })
            }
            let Rn = !1;
            function registerSpanErrorInstrumentation() {
                Rn || (Rn = !0,
                addGlobalErrorInstrumentationHandler(errorCallback),
                addGlobalUnhandledRejectionInstrumentationHandler(errorCallback))
            }
            function errorCallback() {
                const v = getActiveSpan()
                  , E = v && getRootSpan(v);
                if (E) {
                    const v = "internal_error";
                    _e && fe.log(`[Tracing] Root span: ${v} -> Global error occured`),
                    E.setStatus({
                        "code": Je,
                        "message": v
                    })
                }
            }
            function addTracingExtensions() {
                registerSpanErrorInstrumentation()
            }
            errorCallback.tag = "sentry_tracingErrorCallback";
            const captureConsoleIntegration = (v={}) => {
                const E = v.levels || de;
                return {
                    "name": "CaptureConsole",
                    "setup"(v) {
                        "console"in ue && addConsoleInstrumentationHandler(( ({"args": k, "level": R}) => {
                            currentScopes_getClient() === v && E.includes(R) && function consoleHandler(v, E) {
                                const k = {
                                    "level": severityLevelFromString(E),
                                    "extra": {
                                        "arguments": v
                                    }
                                };
                                currentScopes_withScope((R => {
                                    if (R.addEventProcessor((v => (v.logger = "console",
                                    misc_addExceptionMechanism(v, {
                                        "handled": !1,
                                        "type": "console"
                                    }),
                                    v))),
                                    "assert" === E) {
                                        if (!v[0]) {
                                            const E = `Assertion failed: ${safeJoin(v.slice(1), " ") || "console.assert"}`;
                                            R.setExtra("arguments", v.slice(1)),
                                            captureMessage(E, k)
                                        }
                                        return
                                    }
                                    const U = v.find((v => v instanceof Error));
                                    if (U)
                                        return void captureException(U, k);
                                    captureMessage(safeJoin(v, " "), k)
                                }
                                ))
                            }(k, R)
                        }
                        ))
                    }
                }
            }
            ;
            function captureFeedback(v, E={}, k=currentScopes_getCurrentScope()) {
                const {"message": R, "name": U, "email": H, "url": G, "source": W, "associatedEventId": Z, "tags": Y} = v
                  , J = {
                    "contexts": {
                        "feedback": object_dropUndefinedKeys({
                            "contact_email": H,
                            "name": U,
                            "message": R,
                            "url": G,
                            "source": W,
                            "associated_event_id": Z
                        })
                    },
                    "type": "feedback",
                    "level": "info",
                    "tags": Y
                }
                  , K = k && k.getClient() || currentScopes_getClient();
                K && K.emit("beforeSendFeedback", J, E);
                return k.captureEvent(J, E)
            }
            const debugIntegration = (v={}) => {
                const E = {
                    "debugger": !1,
                    "stringify": !1,
                    ...v
                };
                return {
                    "name": "Debug",
                    "setup"(v) {
                        v.on("beforeSendEvent", ( (v, k) => {
                            E.debugger,
                            logger_consoleSandbox(( () => {
                                E.stringify ? (console.log(JSON.stringify(v, null, 2)),
                                k && Object.keys(k).length && console.log(JSON.stringify(k, null, 2))) : (console.log(v),
                                k && Object.keys(k).length && console.log(k))
                            }
                            ))
                        }
                        ))
                    }
                }
            }
              , extraErrorDataIntegration = (v={}) => {
                const {"depth": E=3, "captureErrorCause": k=!0} = v;
                return {
                    "name": "ExtraErrorData",
                    "processEvent"(v, R, U) {
                        const {"maxValueLength": H=250} = U.getOptions();
                        return function _enhanceEventWithErrorData(v, E={}, k, R, U) {
                            if (!E.originalException || !is_isError(E.originalException))
                                return v;
                            const H = E.originalException.name || E.originalException.constructor.name
                              , G = function _extractErrorData(v, E, k) {
                                try {
                                    const R = ["name", "message", "stack", "line", "column", "fileName", "lineNumber", "columnNumber", "toJSON"]
                                      , U = {};
                                    for (const E of Object.keys(v)) {
                                        if (-1 !== R.indexOf(E))
                                            continue;
                                        const H = v[E];
                                        U[E] = is_isError(H) || "string" == typeof H ? string_truncate(`${H}`, k) : H
                                    }
                                    if (E && void 0 !== v.cause && (U.cause = is_isError(v.cause) ? v.cause.toString() : v.cause),
                                    "function" == typeof v.toJSON) {
                                        const E = v.toJSON();
                                        for (const v of Object.keys(E)) {
                                            const k = E[v];
                                            U[v] = is_isError(k) ? k.toString() : k
                                        }
                                    }
                                    return U
                                } catch (v) {
                                    _e && fe.error("Unable to extract extra data from the Error object:", v)
                                }
                                return null
                            }(E.originalException, R, U);
                            if (G) {
                                const E = {
                                    ...v.contexts
                                }
                                  , R = normalize_normalize(G, k);
                                return isPlainObject(R) && (object_addNonEnumerableProperty(R, "__sentry_skip_normalization__", !0),
                                E[H] = R),
                                {
                                    ...v,
                                    "contexts": E
                                }
                            }
                            return v
                        }(v, R, E, k, H)
                    }
                }
            }
            ;
            const Mn = function getCurrentHubShim() {
                return {
                    "bindClient"(v) {
                        currentScopes_getCurrentScope().setClient(v)
                    },
                    "withScope": currentScopes_withScope,
                    "getClient": () => currentScopes_getClient(),
                    "getScope": currentScopes_getCurrentScope,
                    "getIsolationScope": currentScopes_getIsolationScope,
                    "captureException": (v, E) => currentScopes_getCurrentScope().captureException(v, E),
                    "captureMessage": (v, E, k) => currentScopes_getCurrentScope().captureMessage(v, E, k),
                    "captureEvent": captureEvent,
                    "addBreadcrumb": addBreadcrumb,
                    "setUser": setUser,
                    "setTags": setTags,
                    "setTag": setTag,
                    "setExtra": setExtra,
                    "setExtras": setExtras,
                    "setContext": setContext,
                    "getIntegration"(v) {
                        const E = currentScopes_getClient();
                        return E && E.getIntegrationByName(v.id) || null
                    },
                    "startSession": startSession,
                    "endSession": endSession,
                    "captureSession"(v) {
                        if (v)
                            return endSession();
                        !function getCurrentHubShim_sendSessionUpdate() {
                            const v = currentScopes_getCurrentScope()
                              , E = currentScopes_getClient()
                              , k = v.getSession();
                            E && k && E.captureSession(k)
                        }()
                    }
                }
            };
            function eventFromEnvelope(v, E) {
                let k;
                return forEachEnvelopeItem(v, ( (v, R) => (E.includes(R) && (k = Array.isArray(v) ? v[1] : void 0),
                !!k))),
                k
            }
            function makeMultiplexedTransport(v, E) {
                return k => {
                    const R = v(k)
                      , U = new Map;
                    function getTransport(E, R) {
                        const H = R ? `${E}:${R}` : E;
                        let G = U.get(H);
                        if (!G) {
                            const W = dsnFromString(E);
                            if (!W)
                                return;
                            const Z = getEnvelopeEndpointWithUrlEncodedAuth(W, k.tunnel);
                            G = R ? function makeOverrideReleaseTransport(v, E) {
                                return k => {
                                    const R = v(k);
                                    return {
                                        ...R,
                                        "send": async v => {
                                            const k = eventFromEnvelope(v, ["event", "transaction", "profile", "replay_event"]);
                                            return k && (k.release = E),
                                            R.send(v)
                                        }
                                    }
                                }
                            }(v, R)({
                                ...k,
                                "url": Z
                            }) : v({
                                ...k,
                                "url": Z
                            }),
                            U.set(H, G)
                        }
                        return [E, G]
                    }
                    return {
                        "send": async function send(v) {
                            const k = E({
                                "envelope": v,
                                "getEvent": function getEvent(E) {
                                    const k = E && E.length ? E : ["event"];
                                    return eventFromEnvelope(v, k)
                                }
                            }).map((v => "string" == typeof v ? getTransport(v, void 0) : getTransport(v.dsn, v.release))).filter((v => !!v))
                              , U = k.length ? k : [["", R]];
                            return (await Promise.all(U.map(( ([E,k]) => k.send(function overrideDsn(v, E) {
                                return envelope_createEnvelope(E ? {
                                    ...v[0],
                                    "dsn": E
                                } : v[0], v[1])
                            }(v, E))))))[0]
                        },
                        "flush": async function flush(v) {
                            const E = [...U.values(), R];
                            return (await Promise.all(E.map((E => E.flush(v))))).every((v => v))
                        }
                    }
                }
            }
            const Nn = new Map
              , Dn = new Set;
            function getMetadataForUrl(v, E) {
                return function ensureMetadataStacksAreParsed(v) {
                    if (ue._sentryModuleMetadata)
                        for (const E of Object.keys(ue._sentryModuleMetadata)) {
                            const k = ue._sentryModuleMetadata[E];
                            if (Dn.has(E))
                                continue;
                            Dn.add(E);
                            const R = v(E);
                            for (const v of R.reverse())
                                if (v.filename) {
                                    Nn.set(v.filename, k);
                                    break
                                }
                        }
                }(v),
                Nn.get(E)
            }
            function addMetadataToStackFrames(v, E) {
                try {
                    E.exception.values.forEach((E => {
                        if (E.stacktrace)
                            for (const k of E.stacktrace.frames || []) {
                                if (!k.filename || k.module_metadata)
                                    continue;
                                const E = getMetadataForUrl(v, k.filename);
                                E && (k.module_metadata = E)
                            }
                    }
                    ))
                } catch (v) {}
            }
            function stripMetadataFromStackFrames(v) {
                try {
                    v.exception.values.forEach((v => {
                        if (v.stacktrace)
                            for (const E of v.stacktrace.frames || [])
                                delete E.module_metadata
                    }
                    ))
                } catch (v) {}
            }
            const moduleMetadataIntegration = () => ({
                "name": "ModuleMetadata",
                "setup"(v) {
                    v.on("beforeEnvelope", (v => {
                        forEachEnvelopeItem(v, ( (v, E) => {
                            if ("event" === E) {
                                const E = Array.isArray(v) ? v[1] : void 0;
                                E && (stripMetadataFromStackFrames(E),
                                v[1] = E)
                            }
                        }
                        ))
                    }
                    )),
                    v.on("applyFrameMetadata", (E => {
                        if (E.type)
                            return;
                        addMetadataToStackFrames(v.getOptions().stackParser, E)
                    }
                    ))
                }
            });
            function parameterize(v, ...E) {
                const k = new String(String.raw(v, ...E));
                return k.__sentry_template_string__ = v.join("\0").replace(/%/g, "%%").replace(/\0/g, "%s"),
                k.__sentry_template_values__ = E,
                k
            }
            function normalizeArray(v, E) {
                let k = 0;
                for (let E = v.length - 1; E >= 0; E--) {
                    const R = v[E];
                    "." === R ? v.splice(E, 1) : ".." === R ? (v.splice(E, 1),
                    k++) : k && (v.splice(E, 1),
                    k--)
                }
                if (E)
                    for (; k--; k)
                        v.unshift("..");
                return v
            }
            const $n = /^(\S+:\\|\/?)([\s\S]*?)((?:\.{1,2}|[^/\\]+?|)(\.[^./\\]*|))(?:[/\\]*)$/;
            function splitPath(v) {
                const E = v.length > 1024 ? `<truncated>${v.slice(-1024)}` : v
                  , k = $n.exec(E);
                return k ? k.slice(1) : []
            }
            function resolve(...v) {
                let E = ""
                  , k = !1;
                for (let R = v.length - 1; R >= -1 && !k; R--) {
                    const U = R >= 0 ? v[R] : "/";
                    U && (E = `${U}/${E}`,
                    k = "/" === U.charAt(0))
                }
                return E = normalizeArray(E.split("/").filter((v => !!v)), !k).join("/"),
                (k ? "/" : "") + E || "."
            }
            function trim(v) {
                let E = 0;
                for (; E < v.length && "" === v[E]; E++)
                    ;
                let k = v.length - 1;
                for (; k >= 0 && "" === v[k]; k--)
                    ;
                return E > k ? [] : v.slice(E, k - E + 1)
            }
            const rewriteFramesIntegration = (v={}) => {
                const E = v.root
                  , k = v.prefix || "app:///"
                  , R = "window"in ue && void 0 !== ue.window
                  , U = v.iteratee || function generateIteratee({"isBrowser": v, "root": E, "prefix": k}) {
                    return R => {
                        if (!R.filename)
                            return R;
                        const U = /^[a-zA-Z]:\\/.test(R.filename) || R.filename.includes("\\") && !R.filename.includes("/")
                          , H = /^\//.test(R.filename);
                        if (v) {
                            if (E) {
                                const v = R.filename;
                                0 === v.indexOf(E) && (R.filename = v.replace(E, k))
                            }
                        } else if (U || H) {
                            const v = U ? R.filename.replace(/^[a-zA-Z]:/, "").replace(/\\/g, "/") : R.filename
                              , H = E ? function relative(v, E) {
                                v = resolve(v).slice(1),
                                E = resolve(E).slice(1);
                                const k = trim(v.split("/"))
                                  , R = trim(E.split("/"))
                                  , U = Math.min(k.length, R.length);
                                let H = U;
                                for (let v = 0; v < U; v++)
                                    if (k[v] !== R[v]) {
                                        H = v;
                                        break
                                    }
                                let G = [];
                                for (let v = H; v < k.length; v++)
                                    G.push("..");
                                return G = G.concat(R.slice(H)),
                                G.join("/")
                            }(E, v) : function basename(v, E) {
                                let k = splitPath(v)[2] || "";
                                return E && k.slice(-1 * E.length) === E && (k = k.slice(0, k.length - E.length)),
                                k
                            }(v);
                            R.filename = `${k}${H}`
                        }
                        return R
                    }
                }({
                    "isBrowser": R,
                    "root": E,
                    "prefix": k
                });
                return {
                    "name": "RewriteFrames",
                    "processEvent"(v) {
                        let E = v;
                        return v.exception && Array.isArray(v.exception.values) && (E = function _processExceptionsEvent(v) {
                            try {
                                return {
                                    ...v,
                                    "exception": {
                                        ...v.exception,
                                        "values": v.exception.values.map((v => {
                                            return {
                                                ...v,
                                                ...v.stacktrace && {
                                                    "stacktrace": (E = v.stacktrace,
                                                    {
                                                        ...E,
                                                        "frames": E && E.frames && E.frames.map((v => U(v)))
                                                    })
                                                }
                                            };
                                            var E
                                        }
                                        ))
                                    }
                                }
                            } catch (E) {
                                return v
                            }
                        }(E)),
                        E
                    }
                }
            }
            ;
            const sessionTimingIntegration = () => {
                const v = 1e3 * ye();
                return {
                    "name": "SessionTiming",
                    "processEvent"(E) {
                        const k = 1e3 * ye();
                        return {
                            ...E,
                            "extra": {
                                ...E.extra,
                                "session:start": v,
                                "session:duration": k - v,
                                "session:end": k
                            }
                        }
                    }
                }
            }
              , thirdPartyErrorFilterIntegration = v => ({
                "name": "ThirdPartyErrorsFilter",
                "setup"(v) {
                    v.on("beforeEnvelope", (v => {
                        forEachEnvelopeItem(v, ( (v, E) => {
                            if ("event" === E) {
                                const E = Array.isArray(v) ? v[1] : void 0;
                                E && (stripMetadataFromStackFrames(E),
                                v[1] = E)
                            }
                        }
                        ))
                    }
                    )),
                    v.on("applyFrameMetadata", (E => {
                        if (E.type)
                            return;
                        addMetadataToStackFrames(v.getOptions().stackParser, E)
                    }
                    ))
                },
                "processEvent"(E) {
                    const k = function getBundleKeysForAllFramesWithFilenames(v) {
                        const E = getFramesFromEvent(v);
                        if (!E)
                            return;
                        return E.filter((v => !!v.filename)).map((v => v.module_metadata ? Object.keys(v.module_metadata).filter((v => v.startsWith(Ln))).map((v => v.slice(Ln.length))) : []))
                    }(E);
                    if (k) {
                        const R = k["drop-error-if-contains-third-party-frames" === v.behaviour || "apply-tag-if-contains-third-party-frames" === v.behaviour ? "some" : "every"]((E => !E.some((E => v.filterKeys.includes(E)))));
                        if (R) {
                            if ("drop-error-if-contains-third-party-frames" === v.behaviour || "drop-error-if-exclusively-contains-third-party-frames" === v.behaviour)
                                return null;
                            E.tags = {
                                ...E.tags,
                                "third_party_code": !0
                            }
                        }
                    }
                    return E
                }
            });
            const Ln = "_sentryBundlerPluginAppKey:";
            function formatIssueTitle(v) {
                return {
                    ...v,
                    "path": "path"in v && Array.isArray(v.path) ? v.path.join(".") : void 0,
                    "keys": "keys"in v ? JSON.stringify(v.keys) : void 0,
                    "unionErrors": "unionErrors"in v ? JSON.stringify(v.unionErrors) : void 0
                }
            }
            function formatIssueMessage(v) {
                const E = new Set;
                for (const k of v.issues)
                    k.path && k.path[0] && E.add(k.path[0]);
                return `Failed to validate keys: ${string_truncate(Array.from(E).join(", "), 100)}`
            }
            function applyZodErrorsToEvent(v, E, k) {
                return E.exception && E.exception.values && k && k.originalException && function originalExceptionIsZodError(v) {
                    return is_isError(v) && "ZodError" === v.name && Array.isArray(v.errors)
                }(k.originalException) && 0 !== k.originalException.issues.length ? {
                    ...E,
                    "exception": {
                        ...E.exception,
                        "values": [{
                            ...E.exception.values[0],
                            "value": formatIssueMessage(k.originalException)
                        }, ...E.exception.values.slice(1)]
                    },
                    "extra": {
                        ...E.extra,
                        "zoderror.issues": k.originalException.errors.slice(0, v).map(formatIssueTitle)
                    }
                } : E
            }
            const zodErrorsIntegration = (v={}) => {
                const E = v.limit || 10;
                return {
                    "name": "ZodErrors",
                    "processEvent"(v, k) {
                        return applyZodErrorsToEvent(E, v, k)
                    }
                }
            }
              , Fn = {
                "replayIntegration": "replay",
                "replayCanvasIntegration": "replay-canvas",
                "feedbackIntegration": "feedback",
                "feedbackModalIntegration": "feedback-modal",
                "feedbackScreenshotIntegration": "feedback-screenshot",
                "captureConsoleIntegration": "captureconsole",
                "contextLinesIntegration": "contextlines",
                "linkedErrorsIntegration": "linkederrors",
                "debugIntegration": "debug",
                "dedupeIntegration": "dedupe",
                "extraErrorDataIntegration": "extraerrordata",
                "httpClientIntegration": "httpclient",
                "reportingObserverIntegration": "reportingobserver",
                "rewriteFramesIntegration": "rewriteframes",
                "sessionTimingIntegration": "sessiontiming",
                "browserProfilingIntegration": "browserprofiling"
            }
              , jn = Et;
            async function lazyLoadIntegration(v, E) {
                const k = Fn[v]
                  , R = jn.Sentry = jn.Sentry || {};
                if (!k)
                    throw new Error(`Cannot lazy load integration: ${v}`);
                const U = R[v];
                if ("function" == typeof U && !("_isShim"in U))
                    return U;
                const H = function getScriptURL(v) {
                    const E = currentScopes_getClient()
                      , k = E && E.getOptions()
                      , R = k && k.cdnBaseUrl || "https://browser.sentry-cdn.com";
                    return new URL(`/${ce}/${v}.min.js`,R).toString()
                }(k)
                  , G = Et.document.createElement("script");
                G.src = H,
                G.crossOrigin = "anonymous",
                G.referrerPolicy = "origin",
                E && G.setAttribute("nonce", E);
                const W = new Promise(( (v, E) => {
                    G.addEventListener("load", ( () => v())),
                    G.addEventListener("error", E)
                }
                ));
                Et.document.body.appendChild(G);
                try {
                    await W
                } catch (E) {
                    throw new Error(`Error when loading integration: ${v}`)
                }
                const Z = R[v];
                if ("function" != typeof Z)
                    throw new Error(`Could not load integration: ${v}`);
                return Z
            }
            const Bn = ue
              , Un = new WeakMap
              , reportingObserverIntegration = (v={}) => {
                const E = v.types || ["crash", "deprecation", "intervention"];
                function handler(v) {
                    if (Un.has(currentScopes_getClient()))
                        for (const E of v)
                            currentScopes_withScope((v => {
                                v.setExtra("url", E.url);
                                const k = `ReportingObserver [${E.type}]`;
                                let R = "No details available";
                                if (E.body) {
                                    const k = {};
                                    for (const v in E.body)
                                        k[v] = E.body[v];
                                    if (v.setExtra("body", k),
                                    "crash" === E.type) {
                                        const v = E.body;
                                        R = [v.crashId || "", v.reason || ""].join(" ").trim() || R
                                    } else {
                                        R = E.body.message || R
                                    }
                                }
                                captureMessage(`${k}: ${R}`)
                            }
                            ))
                }
                return {
                    "name": "ReportingObserver",
                    "setupOnce"() {
                        if (!function supportsReportingObserver() {
                            return "ReportingObserver"in it
                        }())
                            return;
                        new Bn.ReportingObserver(handler,{
                            "buffered": !0,
                            "types": E
                        }).observe()
                    },
                    "setup"(v) {
                        Un.set(v, !0)
                    }
                }
            }
            ;
            function isSentryRequestUrl(v, E) {
                const k = E && E.getDsn()
                  , R = E && E.getOptions().tunnel;
                return function checkDsn(v, E) {
                    return !!E && v.includes(E.host)
                }(v, k) || function checkTunnel(v, E) {
                    if (!E)
                        return !1;
                    return removeTrailingSlash(v) === removeTrailingSlash(E)
                }(v, R)
            }
            function removeTrailingSlash(v) {
                return "/" === v[v.length - 1] ? v.slice(0, -1) : v
            }
            const httpClientIntegration = (v={}) => {
                const E = {
                    "failedRequestStatusCodes": [[500, 599]],
                    "failedRequestTargets": [/.*/],
                    ...v
                };
                return {
                    "name": "HttpClient",
                    "setup"(v) {
                        !function _wrapFetch(v, E) {
                            if (!supportsNativeFetch())
                                return;
                            addFetchInstrumentationHandler((k => {
                                if (currentScopes_getClient() !== v)
                                    return;
                                const {"response": R, "args": U} = k
                                  , [H,G] = U;
                                R && function _fetchResponseHandler(v, E, k, R) {
                                    if (_shouldCaptureResponse(v, k.status, k.url)) {
                                        const v = function _getRequest(v, E) {
                                            if (!E && v instanceof Request)
                                                return v;
                                            if (v instanceof Request && v.bodyUsed)
                                                return v;
                                            return new Request(v,E)
                                        }(E, R);
                                        let U, H, G, W;
                                        _shouldSendDefaultPii() && ([U,G] = _parseCookieHeaders("Cookie", v),
                                        [H,W] = _parseCookieHeaders("Set-Cookie", k));
                                        captureEvent(_createEvent({
                                            "url": v.url,
                                            "method": v.method,
                                            "status": k.status,
                                            "requestHeaders": U,
                                            "responseHeaders": H,
                                            "requestCookies": G,
                                            "responseCookies": W
                                        }))
                                    }
                                }(E, H, R, G)
                            }
                            ))
                        }(v, E),
                        function httpclient_wrapXHR(v, E) {
                            if (!("XMLHttpRequest"in ue))
                                return;
                            addXhrInstrumentationHandler((k => {
                                if (currentScopes_getClient() !== v)
                                    return;
                                const R = k.xhr
                                  , U = R[Mt];
                                if (!U)
                                    return;
                                const {"method": H, "request_headers": G} = U;
                                try {
                                    !function _xhrResponseHandler(v, E, k, R) {
                                        if (_shouldCaptureResponse(v, E.status, E.responseURL)) {
                                            let v, U, H;
                                            if (_shouldSendDefaultPii()) {
                                                try {
                                                    const v = E.getResponseHeader("Set-Cookie") || E.getResponseHeader("set-cookie") || void 0;
                                                    v && (U = _parseCookieString(v))
                                                } catch (v) {
                                                    St && fe.log("Could not extract cookies from response headers")
                                                }
                                                try {
                                                    H = function _getXHRResponseHeaders(v) {
                                                        const E = v.getAllResponseHeaders();
                                                        if (!E)
                                                            return {};
                                                        return E.split("\r\n").reduce(( (v, E) => {
                                                            const [k,R] = E.split(": ");
                                                            return k && R && (v[k] = R),
                                                            v
                                                        }
                                                        ), {})
                                                    }(E)
                                                } catch (v) {
                                                    St && fe.log("Could not extract headers from response")
                                                }
                                                v = R
                                            }
                                            captureEvent(_createEvent({
                                                "url": E.responseURL,
                                                "method": k,
                                                "status": E.status,
                                                "requestHeaders": v,
                                                "responseHeaders": H,
                                                "responseCookies": U
                                            }))
                                        }
                                    }(E, R, H, G)
                                } catch (v) {
                                    St && fe.warn("Error while extracting response event form XHR response", v)
                                }
                            }
                            ))
                        }(v, E)
                    }
                }
            }
            ;
            function _parseCookieHeaders(v, E) {
                const k = function _extractFetchHeaders(v) {
                    const E = {};
                    return v.forEach(( (v, k) => {
                        E[k] = v
                    }
                    )),
                    E
                }(E.headers);
                let R;
                try {
                    const E = k[v] || k[v.toLowerCase()] || void 0;
                    E && (R = _parseCookieString(E))
                } catch (E) {
                    St && fe.log(`Could not extract cookies from header ${v}`)
                }
                return [k, R]
            }
            function _getResponseSizeFromHeaders(v) {
                if (v) {
                    const E = v["Content-Length"] || v["content-length"];
                    if (E)
                        return parseInt(E, 10)
                }
            }
            function _parseCookieString(v) {
                return v.split("; ").reduce(( (v, E) => {
                    const [k,R] = E.split("=");
                    return k && R && (v[k] = R),
                    v
                }
                ), {})
            }
            function _shouldCaptureResponse(v, E, k) {
                return function _isInGivenStatusRanges(v, E) {
                    return v.some((v => "number" == typeof v ? v === E : E >= v[0] && E <= v[1]))
                }(v.failedRequestStatusCodes, E) && function _isInGivenRequestTargets(v, E) {
                    return v.some((v => "string" == typeof v ? E.includes(v) : v.test(E)))
                }(v.failedRequestTargets, k) && !isSentryRequestUrl(k, currentScopes_getClient())
            }
            function _createEvent(v) {
                const E = `HTTP Client Error with status code: ${v.status}`
                  , k = {
                    "message": E,
                    "exception": {
                        "values": [{
                            "type": "Error",
                            "value": E
                        }]
                    },
                    "request": {
                        "url": v.url,
                        "method": v.method,
                        "headers": v.requestHeaders,
                        "cookies": v.requestCookies
                    },
                    "contexts": {
                        "response": {
                            "status_code": v.status,
                            "headers": v.responseHeaders,
                            "cookies": v.responseCookies,
                            "body_size": _getResponseSizeFromHeaders(v.responseHeaders)
                        }
                    }
                };
                return misc_addExceptionMechanism(k, {
                    "type": "http.client",
                    "handled": !1
                }),
                k
            }
            function _shouldSendDefaultPii() {
                const v = currentScopes_getClient();
                return !!v && Boolean(v.getOptions().sendDefaultPii)
            }
            const Hn = ue
              , contextLinesIntegration = (v={}) => {
                const E = null != v.frameContextLines ? v.frameContextLines : 7;
                return {
                    "name": "ContextLines",
                    "processEvent"(v) {
                        return function addSourceContext(v, E) {
                            const k = Hn.document
                              , R = Hn.location && function stripUrlQueryAndFragment(v) {
                                return v.split(/[?#]/, 1)[0]
                            }(Hn.location.href);
                            if (!k || !R)
                                return v;
                            const U = v.exception && v.exception.values;
                            if (!U || !U.length)
                                return v;
                            const H = k.documentElement.innerHTML;
                            if (!H)
                                return v;
                            const G = ["<!DOCTYPE html>", "<html>", ...H.split("\n"), "</html>"];
                            return U.forEach((v => {
                                const k = v.stacktrace;
                                k && k.frames && (k.frames = k.frames.map((v => function applySourceContextToFrame(v, E, k, R) {
                                    if (v.filename !== k || !v.lineno || !E.length)
                                        return v;
                                    return function addContextToFrame(v, E, k=5) {
                                        if (void 0 === E.lineno)
                                            return;
                                        const R = v.length
                                          , U = Math.max(Math.min(R - 1, E.lineno - 1), 0);
                                        E.pre_context = v.slice(Math.max(0, U - k), U).map((v => string_snipLine(v, 0)));
                                        const H = Math.min(R - 1, U);
                                        E.context_line = string_snipLine(v[H], E.colno || 0),
                                        E.post_context = v.slice(Math.min(U + 1, R), U + 1 + k).map((v => string_snipLine(v, 0)))
                                    }(E, v, R),
                                    v
                                }(v, G, R, E))))
                            }
                            )),
                            v
                        }(v, E)
                    }
                }
            }
            ;
            function _optionalChain(v) {
                let E, k = v[0], R = 1;
                for (; R < v.length; ) {
                    const U = v[R]
                      , H = v[R + 1];
                    if (R += 2,
                    ("optionalAccess" === U || "optionalCall" === U) && null == k)
                        return;
                    "access" === U || "optionalAccess" === U ? (E = k,
                    k = H(k)) : "call" !== U && "optionalCall" !== U || (k = H(( (...v) => k.call(E, ...v))),
                    E = void 0)
                }
                return k
            }
            const zn = "8.30.0"
              , qn = globalThis;
            function utils_build_esm_worldwide_getGlobalSingleton(v, E, k) {
                const R = k || qn
                  , U = R.__SENTRY__ = R.__SENTRY__ || {}
                  , H = U[zn] = U[zn] || {};
                return H[v] || (H[v] = E())
            }
            const Gn = 1e3;
            function utils_build_esm_time_dateTimestampInSeconds() {
                return Date.now() / Gn
            }
            const Vn = function build_esm_time_createUnixTimestampInSecondsFunc() {
                const {"performance": v} = qn;
                if (!v || !v.now)
                    return utils_build_esm_time_dateTimestampInSeconds;
                const E = Date.now() - v.now()
                  , k = null == v.timeOrigin ? E : v.timeOrigin;
                return () => (k + v.now()) / Gn
            }();
            let Wn;
            const Zn = ( () => {
                const {"performance": v} = qn;
                if (!v || !v.now)
                    return void (Wn = "none");
                const E = 36e5
                  , k = v.now()
                  , R = Date.now()
                  , U = v.timeOrigin ? Math.abs(v.timeOrigin + k - R) : E
                  , H = U < E
                  , G = v.timing && v.timing.navigationStart
                  , W = "number" == typeof G ? Math.abs(G + k - R) : E;
                return H || W < E ? U <= W ? (Wn = "timeOrigin",
                v.timeOrigin) : (Wn = "navigationStart",
                G) : (Wn = "dateNow",
                R)
            }
            )()
              , Yn = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__
              , Jn = ["debug", "info", "warn", "error", "log", "assert", "trace"]
              , Kn = {};
            function utils_build_esm_logger_consoleSandbox(v) {
                if (!("console"in qn))
                    return v();
                const E = qn.console
                  , k = {}
                  , R = Object.keys(Kn);
                R.forEach((v => {
                    const R = Kn[v];
                    k[v] = E[v],
                    E[v] = R
                }
                ));
                try {
                    return v()
                } finally {
                    R.forEach((v => {
                        E[v] = k[v]
                    }
                    ))
                }
            }
            const Xn = utils_build_esm_worldwide_getGlobalSingleton("logger", (function build_esm_logger_makeLogger() {
                let v = !1;
                const E = {
                    "enable": () => {
                        v = !0
                    }
                    ,
                    "disable": () => {
                        v = !1
                    }
                    ,
                    "isEnabled": () => v
                };
                return Yn ? Jn.forEach((k => {
                    E[k] = (...E) => {
                        v && utils_build_esm_logger_consoleSandbox(( () => {
                            qn.console[k](`Sentry Logger [${k}]:`, ...E)
                        }
                        ))
                    }
                }
                )) : Jn.forEach((v => {
                    E[v] = () => {}
                }
                )),
                E
            }
            ));
            function build_esm_carrier_getMainCarrier() {
                return build_esm_carrier_getSentryCarrier(qn),
                qn
            }
            function build_esm_carrier_getSentryCarrier(v) {
                const E = v.__SENTRY__ = v.__SENTRY__ || {};
                return E.version = E.version || zn,
                E[zn] = E[zn] || {}
            }
            const Qn = Object.prototype.toString;
            function build_esm_is_isBuiltin(v, E) {
                return Qn.call(v) === `[object ${E}]`
            }
            function utils_build_esm_is_isString(v) {
                return build_esm_is_isBuiltin(v, "String")
            }
            function build_esm_is_isPlainObject(v) {
                return build_esm_is_isBuiltin(v, "Object")
            }
            function utils_build_esm_is_isThenable(v) {
                return Boolean(v && v.then && "function" == typeof v.then)
            }
            function utils_build_esm_is_isInstanceOf(v, E) {
                try {
                    return v instanceof E
                } catch (v) {
                    return !1
                }
            }
            function utils_build_esm_misc_uuid4() {
                const v = qn
                  , E = v.crypto || v.msCrypto;
                let getRandomByte = () => 16 * Math.random();
                try {
                    if (E && E.randomUUID)
                        return E.randomUUID().replace(/-/g, "");
                    E && E.getRandomValues && (getRandomByte = () => {
                        const v = new Uint8Array(1);
                        return E.getRandomValues(v),
                        v[0]
                    }
                    )
                } catch (v) {}
                return ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, (v => (v ^ (15 & getRandomByte()) >> v / 4).toString(16)))
            }
            function build_esm_misc_getFirstException(v) {
                return v.exception && v.exception.values ? v.exception.values[0] : void 0
            }
            function build_esm_propagationContext_generatePropagationContext() {
                return {
                    "traceId": utils_build_esm_misc_uuid4(),
                    "spanId": utils_build_esm_misc_uuid4().substring(16)
                }
            }
            function build_esm_session_updateSession(v, E={}) {
                if (E.user && (!v.ipAddress && E.user.ip_address && (v.ipAddress = E.user.ip_address),
                v.did || E.did || (v.did = E.user.id || E.user.email || E.user.username)),
                v.timestamp = E.timestamp || Vn(),
                E.abnormal_mechanism && (v.abnormal_mechanism = E.abnormal_mechanism),
                E.ignoreDuration && (v.ignoreDuration = E.ignoreDuration),
                E.sid && (v.sid = 32 === E.sid.length ? E.sid : utils_build_esm_misc_uuid4()),
                void 0 !== E.init && (v.init = E.init),
                !v.did && E.did && (v.did = `${E.did}`),
                "number" == typeof E.started && (v.started = E.started),
                v.ignoreDuration)
                    v.duration = void 0;
                else if ("number" == typeof E.duration)
                    v.duration = E.duration;
                else {
                    const E = v.timestamp - v.started;
                    v.duration = E >= 0 ? E : 0
                }
                E.release && (v.release = E.release),
                E.environment && (v.environment = E.environment),
                !v.ipAddress && E.ipAddress && (v.ipAddress = E.ipAddress),
                !v.userAgent && E.userAgent && (v.userAgent = E.userAgent),
                "number" == typeof E.errors && (v.errors = E.errors),
                E.status && (v.status = E.status)
            }
            const er = qn
              , tr = 80;
            function esm_browser_htmlTreeAsString(v, E={}) {
                if (!v)
                    return "<unknown>";
                try {
                    let k = v;
                    const R = 5
                      , U = [];
                    let H = 0
                      , G = 0;
                    const W = " > "
                      , Z = W.length;
                    let Y;
                    const J = Array.isArray(E) ? E : E.keyAttrs
                      , K = !Array.isArray(E) && E.maxStringLength || tr;
                    for (; k && H++ < R && (Y = browser_htmlElementAsString(k, J),
                    !("html" === Y || H > 1 && G + U.length * Z + Y.length >= K)); )
                        U.push(Y),
                        G += Y.length,
                        k = k.parentNode;
                    return U.reverse().join(W)
                } catch (v) {
                    return "<unknown>"
                }
            }
            function browser_htmlElementAsString(v, E) {
                const k = v
                  , R = [];
                if (!k || !k.tagName)
                    return "";
                if (er.HTMLElement && k instanceof HTMLElement && k.dataset) {
                    if (k.dataset.sentryComponent)
                        return k.dataset.sentryComponent;
                    if (k.dataset.sentryElement)
                        return k.dataset.sentryElement
                }
                R.push(k.tagName.toLowerCase());
                const U = E && E.length ? E.filter((v => k.getAttribute(v))).map((v => [v, k.getAttribute(v)])) : null;
                if (U && U.length)
                    U.forEach((v => {
                        R.push(`[${v[0]}="${v[1]}"]`)
                    }
                    ));
                else {
                    k.id && R.push(`#${k.id}`);
                    const v = k.className;
                    if (v && utils_build_esm_is_isString(v)) {
                        const E = v.split(/\s+/);
                        for (const v of E)
                            R.push(`.${v}`)
                    }
                }
                const H = ["aria-label", "type", "name", "title", "alt"];
                for (const v of H) {
                    const E = k.getAttribute(v);
                    E && R.push(`[${v}="${E}"]`)
                }
                return R.join("")
            }
            function browser_getLocationHref() {
                try {
                    return er.document.location.href
                } catch (v) {
                    return ""
                }
            }
            function build_esm_object_fill(v, E, k) {
                if (!(E in v))
                    return;
                const R = v[E]
                  , U = k(R);
                "function" == typeof U && function build_esm_object_markFunctionWrapped(v, E) {
                    try {
                        const k = E.prototype || {};
                        v.prototype = E.prototype = k,
                        utils_build_esm_object_addNonEnumerableProperty(v, "__sentry_original__", E)
                    } catch (v) {}
                }(U, R),
                v[E] = U
            }
            function utils_build_esm_object_addNonEnumerableProperty(v, E, k) {
                try {
                    Object.defineProperty(v, E, {
                        "value": k,
                        "writable": !0,
                        "configurable": !0
                    })
                } catch (k) {
                    Yn && Xn.log(`Failed to add non-enumerable property "${E}" to object`, v)
                }
            }
            function build_esm_object_convertToPlainObject(v) {
                if (function utils_build_esm_is_isError(v) {
                    switch (Qn.call(v)) {
                    case "[object Error]":
                    case "[object Exception]":
                    case "[object DOMException]":
                        return !0;
                    default:
                        return utils_build_esm_is_isInstanceOf(v, Error)
                    }
                }(v))
                    return {
                        "message": v.message,
                        "name": v.name,
                        "stack": v.stack,
                        ...build_esm_object_getOwnProperties(v)
                    };
                if (function utils_build_esm_is_isEvent(v) {
                    return "undefined" != typeof Event && utils_build_esm_is_isInstanceOf(v, Event)
                }(v)) {
                    const E = {
                        "type": v.type,
                        "target": build_esm_object_serializeEventTarget(v.target),
                        "currentTarget": build_esm_object_serializeEventTarget(v.currentTarget),
                        ...build_esm_object_getOwnProperties(v)
                    };
                    return "undefined" != typeof CustomEvent && utils_build_esm_is_isInstanceOf(v, CustomEvent) && (E.detail = v.detail),
                    E
                }
                return v
            }
            function build_esm_object_serializeEventTarget(v) {
                try {
                    return function utils_build_esm_is_isElement(v) {
                        return "undefined" != typeof Element && utils_build_esm_is_isInstanceOf(v, Element)
                    }(v) ? esm_browser_htmlTreeAsString(v) : Object.prototype.toString.call(v)
                } catch (v) {
                    return "<unknown>"
                }
            }
            function build_esm_object_getOwnProperties(v) {
                if ("object" == typeof v && null !== v) {
                    const E = {};
                    for (const k in v)
                        Object.prototype.hasOwnProperty.call(v, k) && (E[k] = v[k]);
                    return E
                }
                return {}
            }
            function node_modules_sentry_utils_build_esm_object_dropUndefinedKeys(v) {
                return replay_node_modules_sentry_utils_build_esm_object_dropUndefinedKeys(v, new Map)
            }
            function replay_node_modules_sentry_utils_build_esm_object_dropUndefinedKeys(v, E) {
                if (function build_esm_object_isPojo(v) {
                    if (!build_esm_is_isPlainObject(v))
                        return !1;
                    try {
                        const E = Object.getPrototypeOf(v).constructor.name;
                        return !E || "Object" === E
                    } catch (v) {
                        return !0
                    }
                }(v)) {
                    const k = E.get(v);
                    if (void 0 !== k)
                        return k;
                    const R = {};
                    E.set(v, R);
                    for (const k of Object.keys(v))
                        void 0 !== v[k] && (R[k] = replay_node_modules_sentry_utils_build_esm_object_dropUndefinedKeys(v[k], E));
                    return R
                }
                if (Array.isArray(v)) {
                    const k = E.get(v);
                    if (void 0 !== k)
                        return k;
                    const R = [];
                    return E.set(v, R),
                    v.forEach((v => {
                        R.push(replay_node_modules_sentry_utils_build_esm_object_dropUndefinedKeys(v, E))
                    }
                    )),
                    R
                }
                return v
            }
            const nr = "_sentrySpan";
            function esm_utils_spanOnScope_setSpanForScope(v, E) {
                E ? utils_build_esm_object_addNonEnumerableProperty(v, nr, E) : delete v[nr]
            }
            function utils_spanOnScope_getSpanForScope(v) {
                return v[nr]
            }
            class esm_scope_ScopeClass {
                "constructor"() {
                    this._notifyingListeners = !1,
                    this._scopeListeners = [],
                    this._eventProcessors = [],
                    this._breadcrumbs = [],
                    this._attachments = [],
                    this._user = {},
                    this._tags = {},
                    this._extra = {},
                    this._contexts = {},
                    this._sdkProcessingMetadata = {},
                    this._propagationContext = build_esm_propagationContext_generatePropagationContext()
                }
                "clone"() {
                    const v = new esm_scope_ScopeClass;
                    return v._breadcrumbs = [...this._breadcrumbs],
                    v._tags = {
                        ...this._tags
                    },
                    v._extra = {
                        ...this._extra
                    },
                    v._contexts = {
                        ...this._contexts
                    },
                    v._user = this._user,
                    v._level = this._level,
                    v._session = this._session,
                    v._transactionName = this._transactionName,
                    v._fingerprint = this._fingerprint,
                    v._eventProcessors = [...this._eventProcessors],
                    v._requestSession = this._requestSession,
                    v._attachments = [...this._attachments],
                    v._sdkProcessingMetadata = {
                        ...this._sdkProcessingMetadata
                    },
                    v._propagationContext = {
                        ...this._propagationContext
                    },
                    v._client = this._client,
                    v._lastEventId = this._lastEventId,
                    esm_utils_spanOnScope_setSpanForScope(v, utils_spanOnScope_getSpanForScope(this)),
                    v
                }
                "setClient"(v) {
                    this._client = v
                }
                "setLastEventId"(v) {
                    this._lastEventId = v
                }
                "getClient"() {
                    return this._client
                }
                "lastEventId"() {
                    return this._lastEventId
                }
                "addScopeListener"(v) {
                    this._scopeListeners.push(v)
                }
                "addEventProcessor"(v) {
                    return this._eventProcessors.push(v),
                    this
                }
                "setUser"(v) {
                    return this._user = v || {
                        "email": void 0,
                        "id": void 0,
                        "ip_address": void 0,
                        "username": void 0
                    },
                    this._session && build_esm_session_updateSession(this._session, {
                        "user": v
                    }),
                    this._notifyScopeListeners(),
                    this
                }
                "getUser"() {
                    return this._user
                }
                "getRequestSession"() {
                    return this._requestSession
                }
                "setRequestSession"(v) {
                    return this._requestSession = v,
                    this
                }
                "setTags"(v) {
                    return this._tags = {
                        ...this._tags,
                        ...v
                    },
                    this._notifyScopeListeners(),
                    this
                }
                "setTag"(v, E) {
                    return this._tags = {
                        ...this._tags,
                        [v]: E
                    },
                    this._notifyScopeListeners(),
                    this
                }
                "setExtras"(v) {
                    return this._extra = {
                        ...this._extra,
                        ...v
                    },
                    this._notifyScopeListeners(),
                    this
                }
                "setExtra"(v, E) {
                    return this._extra = {
                        ...this._extra,
                        [v]: E
                    },
                    this._notifyScopeListeners(),
                    this
                }
                "setFingerprint"(v) {
                    return this._fingerprint = v,
                    this._notifyScopeListeners(),
                    this
                }
                "setLevel"(v) {
                    return this._level = v,
                    this._notifyScopeListeners(),
                    this
                }
                "setTransactionName"(v) {
                    return this._transactionName = v,
                    this._notifyScopeListeners(),
                    this
                }
                "setContext"(v, E) {
                    return null === E ? delete this._contexts[v] : this._contexts[v] = E,
                    this._notifyScopeListeners(),
                    this
                }
                "setSession"(v) {
                    return v ? this._session = v : delete this._session,
                    this._notifyScopeListeners(),
                    this
                }
                "getSession"() {
                    return this._session
                }
                "update"(v) {
                    if (!v)
                        return this;
                    const E = "function" == typeof v ? v(this) : v
                      , [k,R] = E instanceof rr ? [E.getScopeData(), E.getRequestSession()] : build_esm_is_isPlainObject(E) ? [v, v.requestSession] : []
                      , {"tags": U, "extra": H, "user": G, "contexts": W, "level": Z, "fingerprint": Y=[], "propagationContext": J} = k || {};
                    return this._tags = {
                        ...this._tags,
                        ...U
                    },
                    this._extra = {
                        ...this._extra,
                        ...H
                    },
                    this._contexts = {
                        ...this._contexts,
                        ...W
                    },
                    G && Object.keys(G).length && (this._user = G),
                    Z && (this._level = Z),
                    Y.length && (this._fingerprint = Y),
                    J && (this._propagationContext = J),
                    R && (this._requestSession = R),
                    this
                }
                "clear"() {
                    return this._breadcrumbs = [],
                    this._tags = {},
                    this._extra = {},
                    this._user = {},
                    this._contexts = {},
                    this._level = void 0,
                    this._transactionName = void 0,
                    this._fingerprint = void 0,
                    this._requestSession = void 0,
                    this._session = void 0,
                    esm_utils_spanOnScope_setSpanForScope(this, void 0),
                    this._attachments = [],
                    this._propagationContext = build_esm_propagationContext_generatePropagationContext(),
                    this._notifyScopeListeners(),
                    this
                }
                "addBreadcrumb"(v, E) {
                    const k = "number" == typeof E ? E : 100;
                    if (k <= 0)
                        return this;
                    const R = {
                        "timestamp": utils_build_esm_time_dateTimestampInSeconds(),
                        ...v
                    }
                      , U = this._breadcrumbs;
                    return U.push(R),
                    this._breadcrumbs = U.length > k ? U.slice(-k) : U,
                    this._notifyScopeListeners(),
                    this
                }
                "getLastBreadcrumb"() {
                    return this._breadcrumbs[this._breadcrumbs.length - 1]
                }
                "clearBreadcrumbs"() {
                    return this._breadcrumbs = [],
                    this._notifyScopeListeners(),
                    this
                }
                "addAttachment"(v) {
                    return this._attachments.push(v),
                    this
                }
                "clearAttachments"() {
                    return this._attachments = [],
                    this
                }
                "getScopeData"() {
                    return {
                        "breadcrumbs": this._breadcrumbs,
                        "attachments": this._attachments,
                        "contexts": this._contexts,
                        "tags": this._tags,
                        "extra": this._extra,
                        "user": this._user,
                        "level": this._level,
                        "fingerprint": this._fingerprint || [],
                        "eventProcessors": this._eventProcessors,
                        "propagationContext": this._propagationContext,
                        "sdkProcessingMetadata": this._sdkProcessingMetadata,
                        "transactionName": this._transactionName,
                        "span": utils_spanOnScope_getSpanForScope(this)
                    }
                }
                "setSDKProcessingMetadata"(v) {
                    return this._sdkProcessingMetadata = {
                        ...this._sdkProcessingMetadata,
                        ...v
                    },
                    this
                }
                "setPropagationContext"(v) {
                    return this._propagationContext = v,
                    this
                }
                "getPropagationContext"() {
                    return this._propagationContext
                }
                "captureException"(v, E) {
                    const k = E && E.event_id ? E.event_id : utils_build_esm_misc_uuid4();
                    if (!this._client)
                        return Xn.warn("No client configured on scope - will not capture exception!"),
                        k;
                    const R = new Error("Sentry syntheticException");
                    return this._client.captureException(v, {
                        "originalException": v,
                        "syntheticException": R,
                        ...E,
                        "event_id": k
                    }, this),
                    k
                }
                "captureMessage"(v, E, k) {
                    const R = k && k.event_id ? k.event_id : utils_build_esm_misc_uuid4();
                    if (!this._client)
                        return Xn.warn("No client configured on scope - will not capture message!"),
                        R;
                    const U = new Error(v);
                    return this._client.captureMessage(v, E, {
                        "originalException": v,
                        "syntheticException": U,
                        ...k,
                        "event_id": R
                    }, this),
                    R
                }
                "captureEvent"(v, E) {
                    const k = E && E.event_id ? E.event_id : utils_build_esm_misc_uuid4();
                    return this._client ? (this._client.captureEvent(v, {
                        ...E,
                        "event_id": k
                    }, this),
                    k) : (Xn.warn("No client configured on scope - will not capture event!"),
                    k)
                }
                "_notifyScopeListeners"() {
                    this._notifyingListeners || (this._notifyingListeners = !0,
                    this._scopeListeners.forEach((v => {
                        v(this)
                    }
                    )),
                    this._notifyingListeners = !1)
                }
            }
            const rr = esm_scope_ScopeClass;
            class asyncContext_stackStrategy_AsyncContextStack {
                "constructor"(v, E) {
                    let k, R;
                    k = v || new rr,
                    R = E || new rr,
                    this._stack = [{
                        "scope": k
                    }],
                    this._isolationScope = R
                }
                "withScope"(v) {
                    const E = this._pushScope();
                    let k;
                    try {
                        k = v(E)
                    } catch (v) {
                        throw this._popScope(),
                        v
                    }
                    return utils_build_esm_is_isThenable(k) ? k.then((v => (this._popScope(),
                    v)), (v => {
                        throw this._popScope(),
                        v
                    }
                    )) : (this._popScope(),
                    k)
                }
                "getClient"() {
                    return this.getStackTop().client
                }
                "getScope"() {
                    return this.getStackTop().scope
                }
                "getIsolationScope"() {
                    return this._isolationScope
                }
                "getStackTop"() {
                    return this._stack[this._stack.length - 1]
                }
                "_pushScope"() {
                    const v = this.getScope().clone();
                    return this._stack.push({
                        "client": this.getClient(),
                        "scope": v
                    }),
                    v
                }
                "_popScope"() {
                    return !(this._stack.length <= 1) && !!this._stack.pop()
                }
            }
            function asyncContext_stackStrategy_getAsyncContextStack() {
                const v = build_esm_carrier_getSentryCarrier(build_esm_carrier_getMainCarrier());
                return v.stack = v.stack || new asyncContext_stackStrategy_AsyncContextStack(function esm_defaultScopes_getDefaultCurrentScope() {
                    return utils_build_esm_worldwide_getGlobalSingleton("defaultCurrentScope", ( () => new rr))
                }(),function esm_defaultScopes_getDefaultIsolationScope() {
                    return utils_build_esm_worldwide_getGlobalSingleton("defaultIsolationScope", ( () => new rr))
                }())
            }
            function esm_asyncContext_stackStrategy_withScope(v) {
                return asyncContext_stackStrategy_getAsyncContextStack().withScope(v)
            }
            function asyncContext_stackStrategy_withSetScope(v, E) {
                const k = asyncContext_stackStrategy_getAsyncContextStack();
                return k.withScope(( () => (k.getStackTop().scope = v,
                E(v))))
            }
            function esm_asyncContext_stackStrategy_withIsolationScope(v) {
                return asyncContext_stackStrategy_getAsyncContextStack().withScope(( () => v(asyncContext_stackStrategy_getAsyncContextStack().getIsolationScope())))
            }
            function build_esm_asyncContext_getAsyncContextStrategy(v) {
                const E = build_esm_carrier_getSentryCarrier(v);
                return E.acs ? E.acs : function asyncContext_stackStrategy_getStackAsyncContextStrategy() {
                    return {
                        "withIsolationScope": esm_asyncContext_stackStrategy_withIsolationScope,
                        "withScope": esm_asyncContext_stackStrategy_withScope,
                        "withSetScope": asyncContext_stackStrategy_withSetScope,
                        "withSetIsolationScope": (v, E) => esm_asyncContext_stackStrategy_withIsolationScope(E),
                        "getCurrentScope": () => asyncContext_stackStrategy_getAsyncContextStack().getScope(),
                        "getIsolationScope": () => asyncContext_stackStrategy_getAsyncContextStack().getIsolationScope()
                    }
                }()
            }
            function build_esm_currentScopes_getCurrentScope() {
                return build_esm_asyncContext_getAsyncContextStrategy(build_esm_carrier_getMainCarrier()).getCurrentScope()
            }
            function build_esm_currentScopes_getIsolationScope() {
                return build_esm_asyncContext_getAsyncContextStrategy(build_esm_carrier_getMainCarrier()).getIsolationScope()
            }
            function build_esm_currentScopes_getClient() {
                return build_esm_currentScopes_getCurrentScope().getClient()
            }
            const or = 100;
            function esm_string_truncate(v, E=0) {
                return "string" != typeof v || 0 === E || v.length <= E ? v : `${v.slice(0, E)}...`
            }
            function string_isMatchingPattern(v, E, k=!1) {
                return !!utils_build_esm_is_isString(v) && (function build_esm_is_isRegExp(v) {
                    return build_esm_is_isBuiltin(v, "RegExp")
                }(E) ? E.test(v) : !!utils_build_esm_is_isString(E) && (k ? v === E : v.includes(E)))
            }
            const ir = "<anonymous>";
            function esm_normalize_normalize(v, E=100, k=1 / 0) {
                try {
                    return normalize_visit("", v, E, k)
                } catch (v) {
                    return {
                        "ERROR": `**non-serializable** (${v})`
                    }
                }
            }
            function normalize_visit(v, E, k=1 / 0, R=1 / 0, U=function memo_memoBuilder() {
                const v = "function" == typeof WeakSet
                  , E = v ? new WeakSet : [];
                return [function memoize(k) {
                    if (v)
                        return !!E.has(k) || (E.add(k),
                        !1);
                    for (let v = 0; v < E.length; v++)
                        if (E[v] === k)
                            return !0;
                    return E.push(k),
                    !1
                }
                , function unmemoize(k) {
                    if (v)
                        E.delete(k);
                    else
                        for (let v = 0; v < E.length; v++)
                            if (E[v] === k) {
                                E.splice(v, 1);
                                break
                            }
                }
                ]
            }()) {
                const [H,G] = U;
                if (null == E || ["number", "boolean", "string"].includes(typeof E) && !Number.isNaN(E))
                    return E;
                const W = function normalize_stringifyValue(v, E) {
                    try {
                        if ("domain" === v && E && "object" == typeof E && E._events)
                            return "[Domain]";
                        if ("domainEmitter" === v)
                            return "[DomainEmitter]";
                        if ("undefined" != typeof global && E === global)
                            return "[Global]";
                        if ("undefined" != typeof window && E === window)
                            return "[Window]";
                        if ("undefined" != typeof document && E === document)
                            return "[Document]";
                        if (function utils_build_esm_is_isVueViewModel(v) {
                            return !("object" != typeof v || null === v || !v.__isVue && !v._isVue)
                        }(E))
                            return "[VueViewModel]";
                        if (function build_esm_is_isSyntheticEvent(v) {
                            return build_esm_is_isPlainObject(v) && "nativeEvent"in v && "preventDefault"in v && "stopPropagation"in v
                        }(E))
                            return "[SyntheticEvent]";
                        if ("number" == typeof E && E != E)
                            return "[NaN]";
                        if ("function" == typeof E)
                            return `[Function: ${function esm_stacktrace_getFunctionName(v) {
                                try {
                                    return v && "function" == typeof v && v.name || ir
                                } catch (v) {
                                    return ir
                                }
                            }(E)}]`;
                        if ("symbol" == typeof E)
                            return `[${String(E)}]`;
                        if ("bigint" == typeof E)
                            return `[BigInt: ${String(E)}]`;
                        const k = function normalize_getConstructorName(v) {
                            const E = Object.getPrototypeOf(v);
                            return E ? E.constructor.name : "null prototype"
                        }(E);
                        return /^HTML(\w*)Element$/.test(k) ? `[HTMLElement: ${k}]` : `[object ${k}]`
                    } catch (v) {
                        return `**non-serializable** (${v})`
                    }
                }(v, E);
                if (!W.startsWith("[object "))
                    return W;
                if (E.__sentry_skip_normalization__)
                    return E;
                const Z = "number" == typeof E.__sentry_override_normalization_depth__ ? E.__sentry_override_normalization_depth__ : k;
                if (0 === Z)
                    return W.replace("object ", "");
                if (H(E))
                    return "[Circular ~]";
                const Y = E;
                if (Y && "function" == typeof Y.toJSON)
                    try {
                        return normalize_visit("", Y.toJSON(), Z - 1, R, U)
                    } catch (v) {}
                const J = Array.isArray(E) ? [] : {};
                let K = 0;
                const X = build_esm_object_convertToPlainObject(E);
                for (const v in X) {
                    if (!Object.prototype.hasOwnProperty.call(X, v))
                        continue;
                    if (K >= R) {
                        J[v] = "[MaxProperties ~]";
                        break
                    }
                    const E = X[v];
                    J[v] = normalize_visit(v, E, Z - 1, R, U),
                    K++
                }
                return G(E),
                J
            }
            const ar = "production";
            var sr;
            function syncpromise_resolvedSyncPromise(v) {
                return new syncpromise_SyncPromise((E => {
                    E(v)
                }
                ))
            }
            !function(v) {
                v[v.PENDING = 0] = "PENDING";
                v[v.RESOLVED = 1] = "RESOLVED";
                v[v.REJECTED = 2] = "REJECTED"
            }(sr || (sr = {}));
            class syncpromise_SyncPromise {
                "constructor"(v) {
                    syncpromise_SyncPromise.prototype.__init.call(this),
                    syncpromise_SyncPromise.prototype.__init2.call(this),
                    syncpromise_SyncPromise.prototype.__init3.call(this),
                    syncpromise_SyncPromise.prototype.__init4.call(this),
                    this._state = sr.PENDING,
                    this._handlers = [];
                    try {
                        v(this._resolve, this._reject)
                    } catch (v) {
                        this._reject(v)
                    }
                }
                "then"(v, E) {
                    return new syncpromise_SyncPromise(( (k, R) => {
                        this._handlers.push([!1, E => {
                            if (v)
                                try {
                                    k(v(E))
                                } catch (v) {
                                    R(v)
                                }
                            else
                                k(E)
                        }
                        , v => {
                            if (E)
                                try {
                                    k(E(v))
                                } catch (v) {
                                    R(v)
                                }
                            else
                                R(v)
                        }
                        ]),
                        this._executeHandlers()
                    }
                    ))
                }
                "catch"(v) {
                    return this.then((v => v), v)
                }
                "finally"(v) {
                    return new syncpromise_SyncPromise(( (E, k) => {
                        let R, U;
                        return this.then((E => {
                            U = !1,
                            R = E,
                            v && v()
                        }
                        ), (E => {
                            U = !0,
                            R = E,
                            v && v()
                        }
                        )).then(( () => {
                            U ? k(R) : E(R)
                        }
                        ))
                    }
                    ))
                }
                "__init"() {
                    this._resolve = v => {
                        this._setResult(sr.RESOLVED, v)
                    }
                }
                "__init2"() {
                    this._reject = v => {
                        this._setResult(sr.REJECTED, v)
                    }
                }
                "__init3"() {
                    this._setResult = (v, E) => {
                        this._state === sr.PENDING && (utils_build_esm_is_isThenable(E) ? E.then(this._resolve, this._reject) : (this._state = v,
                        this._value = E,
                        this._executeHandlers()))
                    }
                }
                "__init4"() {
                    this._executeHandlers = () => {
                        if (this._state === sr.PENDING)
                            return;
                        const v = this._handlers.slice();
                        this._handlers = [],
                        v.forEach((v => {
                            v[0] || (this._state === sr.RESOLVED && v[1](this._value),
                            this._state === sr.REJECTED && v[2](this._value),
                            v[0] = !0)
                        }
                        ))
                    }
                }
            }
            const cr = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__;
            function esm_eventProcessors_notifyEventProcessors(v, E, k, R=0) {
                return new syncpromise_SyncPromise(( (U, H) => {
                    const G = v[R];
                    if (null === E || "function" != typeof G)
                        U(E);
                    else {
                        const W = G({
                            ...E
                        }, k);
                        cr && G.id && null === W && Xn.log(`Event processor "${G.id}" dropped event`),
                        utils_build_esm_is_isThenable(W) ? W.then((E => esm_eventProcessors_notifyEventProcessors(v, E, k, R + 1).then(U))).then(null, H) : esm_eventProcessors_notifyEventProcessors(v, W, k, R + 1).then(U).then(null, H)
                    }
                }
                ))
            }
            const lr = "sentry-"
              , ur = /^sentry-/;
            function baggage_baggageHeaderToDynamicSamplingContext(v) {
                const E = function baggage_parseBaggageHeader(v) {
                    if (!v || !utils_build_esm_is_isString(v) && !Array.isArray(v))
                        return;
                    if (Array.isArray(v))
                        return v.reduce(( (v, E) => {
                            const k = baggage_baggageHeaderToObject(E);
                            return Object.entries(k).forEach(( ([E,k]) => {
                                v[E] = k
                            }
                            )),
                            v
                        }
                        ), {});
                    return baggage_baggageHeaderToObject(v)
                }(v);
                if (!E)
                    return;
                const k = Object.entries(E).reduce(( (v, [E,k]) => {
                    if (E.match(ur)) {
                        v[E.slice(lr.length)] = k
                    }
                    return v
                }
                ), {});
                return Object.keys(k).length > 0 ? k : void 0
            }
            function baggage_baggageHeaderToObject(v) {
                return v.split(",").map((v => v.split("=").map((v => decodeURIComponent(v.trim()))))).reduce(( (v, [E,k]) => (E && k && (v[E] = k),
                v)), {})
            }
            const dr = "sentry.source"
              , pr = "sentry.sample_rate"
              , fr = "sentry.op"
              , hr = "sentry.origin"
              , mr = "_sentryMetrics";
            function metric_summary_getMetricSummaryJsonForSpan(v) {
                const E = v[mr];
                if (!E)
                    return;
                const k = {};
                for (const [,[v,R]] of E) {
                    (k[v] || (k[v] = [])).push(node_modules_sentry_utils_build_esm_object_dropUndefinedKeys(R))
                }
                return k
            }
            const gr = 0
              , _r = 1;
            const vr = 1;
            function spanUtils_spanToTraceContext(v) {
                const {"spanId": E, "traceId": k} = v.spanContext()
                  , {"parent_span_id": R} = utils_spanUtils_spanToJSON(v);
                return node_modules_sentry_utils_build_esm_object_dropUndefinedKeys({
                    "parent_span_id": R,
                    "span_id": E,
                    "trace_id": k
                })
            }
            function spanUtils_spanTimeInputToSeconds(v) {
                return "number" == typeof v ? spanUtils_ensureTimestampInSeconds(v) : Array.isArray(v) ? v[0] + v[1] / 1e9 : v instanceof Date ? spanUtils_ensureTimestampInSeconds(v.getTime()) : Vn()
            }
            function spanUtils_ensureTimestampInSeconds(v) {
                return v > 9999999999 ? v / 1e3 : v
            }
            function utils_spanUtils_spanToJSON(v) {
                if (function spanUtils_spanIsSentrySpan(v) {
                    return "function" == typeof v.getSpanJSON
                }(v))
                    return v.getSpanJSON();
                try {
                    const {"spanId": E, "traceId": k} = v.spanContext();
                    if (function spanUtils_spanIsOpenTelemetrySdkTraceBaseSpan(v) {
                        const E = v;
                        return !!(E.attributes && E.startTime && E.name && E.endTime && E.status)
                    }(v)) {
                        const {"attributes": R, "startTime": U, "name": H, "endTime": G, "parentSpanId": W, "status": Z} = v;
                        return node_modules_sentry_utils_build_esm_object_dropUndefinedKeys({
                            "span_id": E,
                            "trace_id": k,
                            "data": R,
                            "description": H,
                            "parent_span_id": W,
                            "start_timestamp": spanUtils_spanTimeInputToSeconds(U),
                            "timestamp": spanUtils_spanTimeInputToSeconds(G) || void 0,
                            "status": spanUtils_getStatusMessage(Z),
                            "op": R[fr],
                            "origin": R[hr],
                            "_metrics_summary": metric_summary_getMetricSummaryJsonForSpan(v)
                        })
                    }
                    return {
                        "span_id": E,
                        "trace_id": k
                    }
                } catch (v) {
                    return {}
                }
            }
            function spanUtils_spanIsSampled(v) {
                const {"traceFlags": E} = v.spanContext();
                return E === vr
            }
            function spanUtils_getStatusMessage(v) {
                if (v && v.code !== gr)
                    return v.code === _r ? "ok" : v.message || "unknown_error"
            }
            const yr = "_sentryRootSpan";
            function spanUtils_getRootSpan(v) {
                return v[yr] || v
            }
            function spanUtils_getActiveSpan() {
                const v = build_esm_asyncContext_getAsyncContextStrategy(build_esm_carrier_getMainCarrier());
                return v.getActiveSpan ? v.getActiveSpan() : utils_spanOnScope_getSpanForScope(build_esm_currentScopes_getCurrentScope())
            }
            const br = "_frozenDsc";
            function dynamicSamplingContext_getDynamicSamplingContextFromSpan(v) {
                const E = build_esm_currentScopes_getClient();
                if (!E)
                    return {};
                const k = function dynamicSamplingContext_getDynamicSamplingContextFromClient(v, E) {
                    const k = E.getOptions()
                      , {"publicKey": R} = E.getDsn() || {}
                      , U = node_modules_sentry_utils_build_esm_object_dropUndefinedKeys({
                        "environment": k.environment || ar,
                        "release": k.release,
                        "public_key": R,
                        "trace_id": v
                    });
                    return E.emit("createDsc", U),
                    U
                }(utils_spanUtils_spanToJSON(v).trace_id || "", E)
                  , R = spanUtils_getRootSpan(v)
                  , U = R[br];
                if (U)
                    return U;
                const H = R.spanContext().traceState
                  , G = H && H.get("sentry.dsc")
                  , W = G && baggage_baggageHeaderToDynamicSamplingContext(G);
                if (W)
                    return W;
                const Z = utils_spanUtils_spanToJSON(R)
                  , Y = Z.data || {}
                  , J = Y[pr];
                null != J && (k.sample_rate = `${J}`);
                const K = Y[dr]
                  , X = Z.description;
                return "url" !== K && X && (k.transaction = X),
                k.sampled = String(spanUtils_spanIsSampled(R)),
                E.emit("createDsc", k, R),
                k
            }
            function utils_applyScopeDataToEvent_applyScopeDataToEvent(v, E) {
                const {"fingerprint": k, "span": R, "breadcrumbs": U, "sdkProcessingMetadata": H} = E;
                !function applyScopeDataToEvent_applyDataToEvent(v, E) {
                    const {"extra": k, "tags": R, "user": U, "contexts": H, "level": G, "transactionName": W} = E
                      , Z = node_modules_sentry_utils_build_esm_object_dropUndefinedKeys(k);
                    Z && Object.keys(Z).length && (v.extra = {
                        ...Z,
                        ...v.extra
                    });
                    const Y = node_modules_sentry_utils_build_esm_object_dropUndefinedKeys(R);
                    Y && Object.keys(Y).length && (v.tags = {
                        ...Y,
                        ...v.tags
                    });
                    const J = node_modules_sentry_utils_build_esm_object_dropUndefinedKeys(U);
                    J && Object.keys(J).length && (v.user = {
                        ...J,
                        ...v.user
                    });
                    const K = node_modules_sentry_utils_build_esm_object_dropUndefinedKeys(H);
                    K && Object.keys(K).length && (v.contexts = {
                        ...K,
                        ...v.contexts
                    });
                    G && (v.level = G);
                    W && "transaction" !== v.type && (v.transaction = W)
                }(v, E),
                R && function applyScopeDataToEvent_applySpanToEvent(v, E) {
                    v.contexts = {
                        "trace": spanUtils_spanToTraceContext(E),
                        ...v.contexts
                    },
                    v.sdkProcessingMetadata = {
                        "dynamicSamplingContext": dynamicSamplingContext_getDynamicSamplingContextFromSpan(E),
                        ...v.sdkProcessingMetadata
                    };
                    const k = spanUtils_getRootSpan(E)
                      , R = utils_spanUtils_spanToJSON(k).description;
                    R && !v.transaction && "transaction" === v.type && (v.transaction = R)
                }(v, R),
                function applyScopeDataToEvent_applyFingerprintToEvent(v, E) {
                    v.fingerprint = v.fingerprint ? function utils_build_esm_misc_arrayify(v) {
                        return Array.isArray(v) ? v : [v]
                    }(v.fingerprint) : [],
                    E && (v.fingerprint = v.fingerprint.concat(E));
                    v.fingerprint && !v.fingerprint.length && delete v.fingerprint
                }(v, k),
                function applyScopeDataToEvent_applyBreadcrumbsToEvent(v, E) {
                    const k = [...v.breadcrumbs || [], ...E];
                    v.breadcrumbs = k.length ? k : void 0
                }(v, U),
                function applyScopeDataToEvent_applySdkMetadataToEvent(v, E) {
                    v.sdkProcessingMetadata = {
                        ...v.sdkProcessingMetadata,
                        ...E
                    }
                }(v, H)
            }
            function utils_applyScopeDataToEvent_mergeScopeData(v, E) {
                const {"extra": k, "tags": R, "user": U, "contexts": H, "level": G, "sdkProcessingMetadata": W, "breadcrumbs": Z, "fingerprint": Y, "eventProcessors": J, "attachments": K, "propagationContext": X, "transactionName": Q, "span": ee} = E;
                applyScopeDataToEvent_mergeAndOverwriteScopeData(v, "extra", k),
                applyScopeDataToEvent_mergeAndOverwriteScopeData(v, "tags", R),
                applyScopeDataToEvent_mergeAndOverwriteScopeData(v, "user", U),
                applyScopeDataToEvent_mergeAndOverwriteScopeData(v, "contexts", H),
                applyScopeDataToEvent_mergeAndOverwriteScopeData(v, "sdkProcessingMetadata", W),
                G && (v.level = G),
                Q && (v.transactionName = Q),
                ee && (v.span = ee),
                Z.length && (v.breadcrumbs = [...v.breadcrumbs, ...Z]),
                Y.length && (v.fingerprint = [...v.fingerprint, ...Y]),
                J.length && (v.eventProcessors = [...v.eventProcessors, ...J]),
                K.length && (v.attachments = [...v.attachments, ...K]),
                v.propagationContext = {
                    ...v.propagationContext,
                    ...X
                }
            }
            function applyScopeDataToEvent_mergeAndOverwriteScopeData(v, E, k) {
                if (k && Object.keys(k).length) {
                    v[E] = {
                        ...v[E]
                    };
                    for (const R in k)
                        Object.prototype.hasOwnProperty.call(k, R) && (v[E][R] = k[R])
                }
            }
            function utils_prepareEvent_prepareEvent(v, E, k, R, U, H) {
                const {"normalizeDepth": G=3, "normalizeMaxBreadth": W=1e3} = v
                  , Z = {
                    ...E,
                    "event_id": E.event_id || k.event_id || utils_build_esm_misc_uuid4(),
                    "timestamp": E.timestamp || utils_build_esm_time_dateTimestampInSeconds()
                }
                  , Y = k.integrations || v.integrations.map((v => v.name));
                !function utils_prepareEvent_applyClientOptions(v, E) {
                    const {"environment": k, "release": R, "dist": U, "maxValueLength": H=250} = E;
                    "environment"in v || (v.environment = "environment"in E ? k : ar);
                    void 0 === v.release && void 0 !== R && (v.release = R);
                    void 0 === v.dist && void 0 !== U && (v.dist = U);
                    v.message && (v.message = esm_string_truncate(v.message, H));
                    const G = v.exception && v.exception.values && v.exception.values[0];
                    G && G.value && (G.value = esm_string_truncate(G.value, H));
                    const W = v.request;
                    W && W.url && (W.url = esm_string_truncate(W.url, H))
                }(Z, v),
                function utils_prepareEvent_applyIntegrationsMetadata(v, E) {
                    E.length > 0 && (v.sdk = v.sdk || {},
                    v.sdk.integrations = [...v.sdk.integrations || [], ...E])
                }(Z, Y),
                U && U.emit("applyFrameMetadata", E),
                void 0 === E.type && function utils_prepareEvent_applyDebugIds(v, E) {
                    const k = qn._sentryDebugIds;
                    if (!k)
                        return;
                    let R;
                    const U = Sr.get(E);
                    U ? R = U : (R = new Map,
                    Sr.set(E, R));
                    const H = Object.entries(k).reduce(( (v, [k,U]) => {
                        let H;
                        const G = R.get(k);
                        G ? H = G : (H = E(k),
                        R.set(k, H));
                        for (let E = H.length - 1; E >= 0; E--) {
                            const k = H[E];
                            if (k.filename) {
                                v[k.filename] = U;
                                break
                            }
                        }
                        return v
                    }
                    ), {});
                    try {
                        v.exception.values.forEach((v => {
                            v.stacktrace.frames.forEach((v => {
                                v.filename && (v.debug_id = H[v.filename])
                            }
                            ))
                        }
                        ))
                    } catch (v) {}
                }(Z, v.stackParser);
                const J = function utils_prepareEvent_getFinalScope(v, E) {
                    if (!E)
                        return v;
                    const k = v ? v.clone() : new rr;
                    return k.update(E),
                    k
                }(R, k.captureContext);
                k.mechanism && function utils_build_esm_misc_addExceptionMechanism(v, E) {
                    const k = build_esm_misc_getFirstException(v);
                    if (!k)
                        return;
                    const R = k.mechanism;
                    if (k.mechanism = {
                        "type": "generic",
                        "handled": !0,
                        ...R,
                        ...E
                    },
                    E && "data"in E) {
                        const v = {
                            ...R && R.data,
                            ...E.data
                        };
                        k.mechanism.data = v
                    }
                }(Z, k.mechanism);
                const K = U ? U.getEventProcessors() : []
                  , X = function build_esm_currentScopes_getGlobalScope() {
                    return utils_build_esm_worldwide_getGlobalSingleton("globalScope", ( () => new rr))
                }().getScopeData();
                if (H) {
                    utils_applyScopeDataToEvent_mergeScopeData(X, H.getScopeData())
                }
                if (J) {
                    utils_applyScopeDataToEvent_mergeScopeData(X, J.getScopeData())
                }
                const Q = [...k.attachments || [], ...X.attachments];
                Q.length && (k.attachments = Q),
                utils_applyScopeDataToEvent_applyScopeDataToEvent(Z, X);
                return esm_eventProcessors_notifyEventProcessors([...K, ...X.eventProcessors], Z, k).then((v => (v && function utils_prepareEvent_applyDebugMeta(v) {
                    const E = {};
                    try {
                        v.exception.values.forEach((v => {
                            v.stacktrace.frames.forEach((v => {
                                v.debug_id && (v.abs_path ? E[v.abs_path] = v.debug_id : v.filename && (E[v.filename] = v.debug_id),
                                delete v.debug_id)
                            }
                            ))
                        }
                        ))
                    } catch (v) {}
                    if (0 === Object.keys(E).length)
                        return;
                    v.debug_meta = v.debug_meta || {},
                    v.debug_meta.images = v.debug_meta.images || [];
                    const k = v.debug_meta.images;
                    Object.entries(E).forEach(( ([v,E]) => {
                        k.push({
                            "type": "sourcemap",
                            "code_file": v,
                            "debug_id": E
                        })
                    }
                    ))
                }(v),
                "number" == typeof G && G > 0 ? function utils_prepareEvent_normalizeEvent(v, E, k) {
                    if (!v)
                        return null;
                    const R = {
                        ...v,
                        ...v.breadcrumbs && {
                            "breadcrumbs": v.breadcrumbs.map((v => ({
                                ...v,
                                ...v.data && {
                                    "data": esm_normalize_normalize(v.data, E, k)
                                }
                            })))
                        },
                        ...v.user && {
                            "user": esm_normalize_normalize(v.user, E, k)
                        },
                        ...v.contexts && {
                            "contexts": esm_normalize_normalize(v.contexts, E, k)
                        },
                        ...v.extra && {
                            "extra": esm_normalize_normalize(v.extra, E, k)
                        }
                    };
                    v.contexts && v.contexts.trace && R.contexts && (R.contexts.trace = v.contexts.trace,
                    v.contexts.trace.data && (R.contexts.trace.data = esm_normalize_normalize(v.contexts.trace.data, E, k)));
                    v.spans && (R.spans = v.spans.map((v => ({
                        ...v,
                        ...v.data && {
                            "data": esm_normalize_normalize(v.data, E, k)
                        }
                    }))));
                    return R
                }(v, G, W) : v)))
            }
            const Sr = new WeakMap;
            function utils_prepareEvent_parseEventHintOrCaptureContext(v) {
                if (v)
                    return function utils_prepareEvent_hintIsScopeOrFunction(v) {
                        return v instanceof rr || "function" == typeof v
                    }(v) || function utils_prepareEvent_hintIsScopeContext(v) {
                        return Object.keys(v).some((v => wr.includes(v)))
                    }(v) ? {
                        "captureContext": v
                    } : v
            }
            const wr = ["user", "level", "extra", "contexts", "tags", "fingerprint", "requestSession", "propagationContext"];
            function esm_exports_captureException(v, E) {
                return build_esm_currentScopes_getCurrentScope().captureException(v, utils_prepareEvent_parseEventHintOrCaptureContext(E))
            }
            function isSentryRequestUrl_isSentryRequestUrl(v, E) {
                const k = E && E.getDsn()
                  , R = E && E.getOptions().tunnel;
                return function isSentryRequestUrl_checkDsn(v, E) {
                    return !!E && v.includes(E.host)
                }(v, k) || function isSentryRequestUrl_checkTunnel(v, E) {
                    if (!E)
                        return !1;
                    return isSentryRequestUrl_removeTrailingSlash(v) === isSentryRequestUrl_removeTrailingSlash(E)
                }(v, R)
            }
            function isSentryRequestUrl_removeTrailingSlash(v) {
                return "/" === v[v.length - 1] ? v.slice(0, -1) : v
            }
            function parseSampleRate_parseSampleRate(v) {
                if ("boolean" == typeof v)
                    return Number(v);
                const E = "string" == typeof v ? parseFloat(v) : v;
                if (!("number" != typeof E || isNaN(E) || E < 0 || E > 1))
                    return E;
                cr && Xn.warn(`[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(v)} of type ${JSON.stringify(typeof v)}.`)
            }
            function esm_dsn_dsnToString(v, E=!1) {
                const {"host": k, "path": R, "pass": U, "port": H, "projectId": G, "protocol": W, "publicKey": Z} = v;
                return `${W}://${Z}${E && U ? `:${U}` : ""}@${k}${H ? `:${H}` : ""}/${R ? `${R}/` : R}${G}`
            }
            const Er = 6e4;
            function ratelimit_updateRateLimits(v, {"statusCode": E, "headers": k}, R=Date.now()) {
                const U = {
                    ...v
                }
                  , H = k && k["x-sentry-rate-limits"]
                  , G = k && k["retry-after"];
                if (H)
                    for (const v of H.trim().split(",")) {
                        const [E,k,,,H] = v.split(":", 5)
                          , G = parseInt(E, 10)
                          , W = 1e3 * (isNaN(G) ? 60 : G);
                        if (k)
                            for (const v of k.split(";"))
                                "metric_bucket" === v && H && !H.split(";").includes("custom") || (U[v] = R + W);
                        else
                            U.all = R + W
                    }
                else
                    G ? U.all = R + function ratelimit_parseRetryAfterHeader(v, E=Date.now()) {
                        const k = parseInt(`${v}`, 10);
                        if (!isNaN(k))
                            return 1e3 * k;
                        const R = Date.parse(`${v}`);
                        return isNaN(R) ? Er : R - E
                    }(G, R) : 429 === E && (U.all = R + 6e4);
                return U
            }
            function isNodeEnv() {
                return !function env_isBrowserBundle() {
                    return "undefined" != typeof __SENTRY_BROWSER_BUNDLE__ && !!__SENTRY_BROWSER_BUNDLE__
                }() && "[object process]" === Object.prototype.toString.call("undefined" != typeof process ? process : 0)
            }
            function isBrowser() {
                return "undefined" != typeof window && (!isNodeEnv() || function isElectronNodeRenderer() {
                    return void 0 !== qn.process && "renderer" === qn.process.type
                }())
            }
            const bindReporter = (v, E, k, R) => {
                let U, H;
                return G => {
                    E.value >= 0 && (G || R) && (H = E.value - (U || 0),
                    (H || void 0 === U) && (U = E.value,
                    E.delta = H,
                    E.rating = ( (v, E) => v > E[1] ? "poor" : v > E[0] ? "needs-improvement" : "good")(E.value, k),
                    v(E)))
                }
            }
              , getNavigationEntry = () => _t.performance && performance.getEntriesByType && performance.getEntriesByType("navigation")[0]
              , getActivationStart = () => {
                const v = getNavigationEntry();
                return v && v.activationStart || 0
            }
              , initMetric = (v, E) => {
                const k = getNavigationEntry();
                let R = "navigate";
                k && (_t.document && _t.document.prerendering || getActivationStart() > 0 ? R = "prerender" : _t.document && _t.document.wasDiscarded ? R = "restore" : k.type && (R = k.type.replace(/_/g, "-")));
                return {
                    "name": v,
                    "value": void 0 === E ? -1 : E,
                    "rating": "good",
                    "delta": 0,
                    "entries": [],
                    "id": `v3-${Date.now()}-${Math.floor(8999999999999 * Math.random()) + 1e12}`,
                    "navigationType": R
                }
            }
              , observe = (v, E, k) => {
                try {
                    if (PerformanceObserver.supportedEntryTypes.includes(v)) {
                        const R = new PerformanceObserver((v => {
                            Promise.resolve().then(( () => {
                                E(v.getEntries())
                            }
                            ))
                        }
                        ));
                        return R.observe(Object.assign({
                            "type": v,
                            "buffered": !0
                        }, k || {})),
                        R
                    }
                } catch (v) {}
            }
              , onHidden = v => {
                const onHiddenOrPageHide = E => {
                    ("pagehide" === E.type || _t.document && "hidden" === _t.document.visibilityState) && v(E)
                }
                ;
                _t.document && (addEventListener("visibilitychange", onHiddenOrPageHide, !0),
                addEventListener("pagehide", onHiddenOrPageHide, !0))
            }
              , runOnce = v => {
                let E = !1;
                return k => {
                    E || (v(k),
                    E = !0)
                }
            }
            ;
            let Cr = -1;
            const onVisibilityUpdate = v => {
                "hidden" === _t.document.visibilityState && Cr > -1 && (Cr = "visibilitychange" === v.type ? v.timeStamp : 0,
                removeEventListener("visibilitychange", onVisibilityUpdate, !0),
                removeEventListener("prerenderingchange", onVisibilityUpdate, !0))
            }
              , getVisibilityWatcher = () => (_t.document && Cr < 0 && (Cr = "hidden" !== _t.document.visibilityState || _t.document.prerendering ? 1 / 0 : 0,
            addEventListener("visibilitychange", onVisibilityUpdate, !0),
            addEventListener("prerenderingchange", onVisibilityUpdate, !0)),
            {
                get "firstHiddenTime"() {
                    return Cr
                }
            })
              , whenActivated = v => {
                _t.document && _t.document.prerendering ? addEventListener("prerenderingchange", ( () => v()), !0) : v()
            }
              , Tr = [1800, 3e3]
              , xr = [.1, .25]
              , onCLS = (v, E={}) => {
                ( (v, E={}) => {
                    whenActivated(( () => {
                        const k = getVisibilityWatcher()
                          , R = initMetric("FCP");
                        let U;
                        const H = observe("paint", (v => {
                            v.forEach((v => {
                                "first-contentful-paint" === v.name && (H.disconnect(),
                                v.startTime < k.firstHiddenTime && (R.value = Math.max(v.startTime - getActivationStart(), 0),
                                R.entries.push(v),
                                U(!0)))
                            }
                            ))
                        }
                        ));
                        H && (U = bindReporter(v, R, Tr, E.reportAllChanges))
                    }
                    ))
                }
                )(runOnce(( () => {
                    const k = initMetric("CLS", 0);
                    let R, U = 0, H = [];
                    const handleEntries = v => {
                        v.forEach((v => {
                            if (!v.hadRecentInput) {
                                const E = H[0]
                                  , k = H[H.length - 1];
                                U && E && k && v.startTime - k.startTime < 1e3 && v.startTime - E.startTime < 5e3 ? (U += v.value,
                                H.push(v)) : (U = v.value,
                                H = [v])
                            }
                        }
                        )),
                        U > k.value && (k.value = U,
                        k.entries = H,
                        R())
                    }
                      , G = observe("layout-shift", handleEntries);
                    G && (R = bindReporter(v, k, xr, E.reportAllChanges),
                    onHidden(( () => {
                        handleEntries(G.takeRecords()),
                        R(!0)
                    }
                    )),
                    setTimeout(R, 0))
                }
                )))
            }
              , Ar = [100, 300]
              , onFID = (v, E={}) => {
                whenActivated(( () => {
                    const k = getVisibilityWatcher()
                      , R = initMetric("FID");
                    let U;
                    const handleEntry = v => {
                        v.startTime < k.firstHiddenTime && (R.value = v.processingStart - v.startTime,
                        R.entries.push(v),
                        U(!0))
                    }
                      , handleEntries = v => {
                        v.forEach(handleEntry)
                    }
                      , H = observe("first-input", handleEntries);
                    U = bindReporter(v, R, Ar, E.reportAllChanges),
                    H && onHidden(runOnce(( () => {
                        handleEntries(H.takeRecords()),
                        H.disconnect()
                    }
                    )))
                }
                ))
            }
            ;
            let Ir = 0
              , kr = 1 / 0
              , Or = 0;
            const updateEstimate = v => {
                v.forEach((v => {
                    v.interactionId && (kr = Math.min(kr, v.interactionId),
                    Or = Math.max(Or, v.interactionId),
                    Ir = Or ? (Or - kr) / 7 + 1 : 0)
                }
                ))
            }
            ;
            let Pr;
            const initInteractionCountPolyfill = () => {
                "interactionCount"in performance || Pr || (Pr = observe("event", updateEstimate, {
                    "type": "event",
                    "buffered": !0,
                    "durationThreshold": 0
                }))
            }
              , Rr = [200, 500]
              , getInteractionCountForNavigation = () => (Pr ? Ir : performance.interactionCount || 0) - 0
              , Mr = []
              , Nr = {}
              , processEntry = v => {
                const E = Mr[Mr.length - 1]
                  , k = Nr[v.interactionId];
                if (k || Mr.length < 10 || E && v.duration > E.latency) {
                    if (k)
                        k.entries.push(v),
                        k.latency = Math.max(k.latency, v.duration);
                    else {
                        const E = {
                            "id": v.interactionId,
                            "latency": v.duration,
                            "entries": [v]
                        };
                        Nr[E.id] = E,
                        Mr.push(E)
                    }
                    Mr.sort(( (v, E) => E.latency - v.latency)),
                    Mr.splice(10).forEach((v => {
                        delete Nr[v.id]
                    }
                    ))
                }
            }
              , onINP = (v, E={}) => {
                whenActivated(( () => {
                    initInteractionCountPolyfill();
                    const k = initMetric("INP");
                    let R;
                    const handleEntries = v => {
                        v.forEach((v => {
                            if (v.interactionId && processEntry(v),
                            "first-input" === v.entryType) {
                                !Mr.some((E => E.entries.some((E => v.duration === E.duration && v.startTime === E.startTime)))) && processEntry(v)
                            }
                        }
                        ));
                        const E = ( () => {
                            const v = Math.min(Mr.length - 1, Math.floor(getInteractionCountForNavigation() / 50));
                            return Mr[v]
                        }
                        )();
                        E && E.latency !== k.value && (k.value = E.latency,
                        k.entries = E.entries,
                        R())
                    }
                      , U = observe("event", handleEntries, {
                        "durationThreshold": null != E.durationThreshold ? E.durationThreshold : 40
                    });
                    R = bindReporter(v, k, Rr, E.reportAllChanges),
                    U && ("PerformanceEventTiming"in _t && "interactionId"in PerformanceEventTiming.prototype && U.observe({
                        "type": "first-input",
                        "buffered": !0
                    }),
                    onHidden(( () => {
                        handleEntries(U.takeRecords()),
                        k.value < 0 && getInteractionCountForNavigation() > 0 && (k.value = 0,
                        k.entries = []),
                        R(!0)
                    }
                    )))
                }
                ))
            }
              , Dr = [2500, 4e3]
              , $r = {}
              , onLCP = (v, E={}) => {
                whenActivated(( () => {
                    const k = getVisibilityWatcher()
                      , R = initMetric("LCP");
                    let U;
                    const handleEntries = v => {
                        const E = v[v.length - 1];
                        E && E.startTime < k.firstHiddenTime && (R.value = Math.max(E.startTime - getActivationStart(), 0),
                        R.entries = [E],
                        U())
                    }
                      , H = observe("largest-contentful-paint", handleEntries);
                    if (H) {
                        U = bindReporter(v, R, Dr, E.reportAllChanges);
                        const k = runOnce(( () => {
                            $r[R.id] || (handleEntries(H.takeRecords()),
                            H.disconnect(),
                            $r[R.id] = !0,
                            U(!0))
                        }
                        ));
                        ["keydown", "click"].forEach((v => {
                            _t.document && addEventListener(v, ( () => setTimeout(k, 0)), !0)
                        }
                        )),
                        onHidden(k)
                    }
                }
                ))
            }
              , Lr = [800, 1800]
              , whenReady = v => {
                _t.document && _t.document.prerendering ? whenActivated(( () => whenReady(v))) : _t.document && "complete" !== _t.document.readyState ? addEventListener("load", ( () => whenReady(v)), !0) : setTimeout(v, 0)
            }
              , onTTFB = (v, E={}) => {
                const k = initMetric("TTFB")
                  , R = bindReporter(v, k, Lr, E.reportAllChanges);
                whenReady(( () => {
                    const v = getNavigationEntry();
                    if (v) {
                        const E = v.responseStart;
                        if (E <= 0 || E > performance.now())
                            return;
                        k.value = Math.max(E - getActivationStart(), 0),
                        k.entries = [v],
                        R(!0)
                    }
                }
                ))
            }
              , Fr = {}
              , jr = {};
            let Br, Ur, Hr, zr, qr;
            function addClsInstrumentationHandler(v, E=!1) {
                return addMetricObserver("cls", v, instrumentCls, Br, E)
            }
            function addLcpInstrumentationHandler(v, E=!1) {
                return addMetricObserver("lcp", v, instrumentLcp, Hr, E)
            }
            function addFidInstrumentationHandler(v) {
                return addMetricObserver("fid", v, instrumentFid, Ur)
            }
            function addInpInstrumentationHandler(v) {
                return addMetricObserver("inp", v, instrumentInp, qr)
            }
            function addPerformanceInstrumentationHandler(v, E) {
                return instrument_addHandler(v, E),
                jr[v] || (!function instrumentPerformanceObserver(v) {
                    const E = {};
                    "event" === v && (E.durationThreshold = 0);
                    observe(v, (E => {
                        instrument_triggerHandlers(v, {
                            "entries": E
                        })
                    }
                    ), E)
                }(v),
                jr[v] = !0),
                getCleanupCallback(v, E)
            }
            function instrument_triggerHandlers(v, E) {
                const k = Fr[v];
                if (k && k.length)
                    for (const R of k)
                        try {
                            R(E)
                        } catch (E) {
                            rn && dt.error(`Error while triggering instrumentation handler.\nType: ${v}\nName: ${stacktrace_getFunctionName(R)}\nError:`, E)
                        }
            }
            function instrumentCls() {
                return onCLS((v => {
                    instrument_triggerHandlers("cls", {
                        "metric": v
                    }),
                    Br = v
                }
                ), {
                    "reportAllChanges": !0
                })
            }
            function instrumentFid() {
                return onFID((v => {
                    instrument_triggerHandlers("fid", {
                        "metric": v
                    }),
                    Ur = v
                }
                ))
            }
            function instrumentLcp() {
                return onLCP((v => {
                    instrument_triggerHandlers("lcp", {
                        "metric": v
                    }),
                    Hr = v
                }
                ), {
                    "reportAllChanges": !0
                })
            }
            function instrumentTtfb() {
                return onTTFB((v => {
                    instrument_triggerHandlers("ttfb", {
                        "metric": v
                    }),
                    zr = v
                }
                ))
            }
            function instrumentInp() {
                return onINP((v => {
                    instrument_triggerHandlers("inp", {
                        "metric": v
                    }),
                    qr = v
                }
                ))
            }
            function addMetricObserver(v, E, k, R, U=!1) {
                let H;
                return instrument_addHandler(v, E),
                jr[v] || (H = k(),
                jr[v] = !0),
                R && E({
                    "metric": R
                }),
                getCleanupCallback(v, E, U ? H : void 0)
            }
            function instrument_addHandler(v, E) {
                Fr[v] = Fr[v] || [],
                Fr[v].push(E)
            }
            function getCleanupCallback(v, E, k) {
                return () => {
                    k && k();
                    const R = Fr[v];
                    if (!R)
                        return;
                    const U = R.indexOf(E);
                    -1 !== U && R.splice(U, 1)
                }
            }
            const Gr = qn
              , Vr = "sentryReplaySession"
              , Wr = "replay_event"
              , Zr = "Unable to send Replay"
              , Yr = 15e4
              , Jr = 5e3
              , Kr = 2e7
              , Xr = 36e5;
            function _nullishCoalesce$1(v, E) {
                return null != v ? v : E()
            }
            function _optionalChain$5(v) {
                let E, k = v[0], R = 1;
                for (; R < v.length; ) {
                    const U = v[R]
                      , H = v[R + 1];
                    if (R += 2,
                    ("optionalAccess" === U || "optionalCall" === U) && null == k)
                        return;
                    "access" === U || "optionalAccess" === U ? (E = k,
                    k = H(k)) : "call" !== U && "optionalCall" !== U || (k = H(( (...v) => k.call(E, ...v))),
                    E = void 0)
                }
                return k
            }
            var Qr;
            function isShadowRoot(v) {
                const E = _optionalChain$5([v, "optionalAccess", v => v.host]);
                return Boolean(_optionalChain$5([E, "optionalAccess", v => v.shadowRoot]) === v)
            }
            function isNativeShadowDom(v) {
                return "[object ShadowRoot]" === Object.prototype.toString.call(v)
            }
            function stringifyStylesheet(v) {
                try {
                    const E = v.rules || v.cssRules;
                    return E ? function fixBrowserCompatibilityIssuesInCSS(v) {
                        return v.includes(" background-clip: text;") && !v.includes(" -webkit-background-clip: text;") && (v = v.replace(" background-clip: text;", " -webkit-background-clip: text; background-clip: text;")),
                        v
                    }(Array.from(E, stringifyRule).join("")) : null
                } catch (v) {
                    return null
                }
            }
            function stringifyRule(v) {
                let E;
                if (function isCSSImportRule(v) {
                    return "styleSheet"in v
                }(v))
                    try {
                        E = stringifyStylesheet(v.styleSheet) || function escapeImportStatement(v) {
                            const {"cssText": E} = v;
                            if (E.split('"').length < 3)
                                return E;
                            const k = ["@import", `url(${JSON.stringify(v.href)})`];
                            return "" === v.layerName ? k.push("layer") : v.layerName && k.push(`layer(${v.layerName})`),
                            v.supportsText && k.push(`supports(${v.supportsText})`),
                            v.media.length && k.push(v.media.mediaText),
                            k.join(" ") + ";"
                        }(v)
                    } catch (v) {}
                else if (function isCSSStyleRule(v) {
                    return "selectorText"in v
                }(v) && v.selectorText.includes(":"))
                    return function fixSafariColons(v) {
                        const E = /(\[(?:[\w-]+)[^\\])(:(?:[\w-]+)\])/gm;
                        return v.replace(E, "$1\\$2")
                    }(v.cssText);
                return E || v.cssText
            }
            !function(v) {
                v[v.Document = 0] = "Document",
                v[v.DocumentType = 1] = "DocumentType",
                v[v.Element = 2] = "Element",
                v[v.Text = 3] = "Text",
                v[v.CDATA = 4] = "CDATA",
                v[v.Comment = 5] = "Comment"
            }(Qr || (Qr = {}));
            class Mirror {
                "constructor"() {
                    this.idNodeMap = new Map,
                    this.nodeMetaMap = new WeakMap
                }
                "getId"(v) {
                    if (!v)
                        return -1;
                    return _nullishCoalesce$1(_optionalChain$5([this, "access", v => v.getMeta, "call", E => E(v), "optionalAccess", v => v.id]), ( () => -1))
                }
                "getNode"(v) {
                    return this.idNodeMap.get(v) || null
                }
                "getIds"() {
                    return Array.from(this.idNodeMap.keys())
                }
                "getMeta"(v) {
                    return this.nodeMetaMap.get(v) || null
                }
                "removeNodeFromMap"(v) {
                    const E = this.getId(v);
                    this.idNodeMap.delete(E),
                    v.childNodes && v.childNodes.forEach((v => this.removeNodeFromMap(v)))
                }
                "has"(v) {
                    return this.idNodeMap.has(v)
                }
                "hasNode"(v) {
                    return this.nodeMetaMap.has(v)
                }
                "add"(v, E) {
                    const k = E.id;
                    this.idNodeMap.set(k, v),
                    this.nodeMetaMap.set(v, E)
                }
                "replace"(v, E) {
                    const k = this.getNode(v);
                    if (k) {
                        const v = this.nodeMetaMap.get(k);
                        v && this.nodeMetaMap.set(E, v)
                    }
                    this.idNodeMap.set(v, E)
                }
                "reset"() {
                    this.idNodeMap = new Map,
                    this.nodeMetaMap = new WeakMap
                }
            }
            function shouldMaskInput({"maskInputOptions": v, "tagName": E, "type": k}) {
                return "OPTION" === E && (E = "SELECT"),
                Boolean(v[E.toLowerCase()] || k && v[k] || "password" === k || "INPUT" === E && !k && v.text)
            }
            function maskInputValue({"isMasked": v, "element": E, "value": k, "maskInputFn": R}) {
                let U = k || "";
                return v ? (R && (U = R(U, E)),
                "*".repeat(U.length)) : U
            }
            function toLowerCase(v) {
                return v.toLowerCase()
            }
            function toUpperCase(v) {
                return v.toUpperCase()
            }
            const eo = "__rrweb_original__";
            function getInputType(v) {
                const E = v.type;
                return v.hasAttribute("data-rr-is-password") ? "password" : E ? toLowerCase(E) : null
            }
            function getInputValue(v, E, k) {
                return "INPUT" !== E || "radio" !== k && "checkbox" !== k ? v.value : v.getAttribute("value") || ""
            }
            function extractFileExtension(v, E) {
                let k;
                try {
                    k = new URL(v,_nullishCoalesce$1(E, ( () => window.location.href)))
                } catch (v) {
                    return null
                }
                return _nullishCoalesce$1(_optionalChain$5([k.pathname.match(/\.([0-9a-z]+)(?:$)/i), "optionalAccess", v => v[1]]), ( () => null))
            }
            const to = {};
            function getImplementation$1(v) {
                const E = to[v];
                if (E)
                    return E;
                const k = window.document;
                let R = window[v];
                if (k && "function" == typeof k.createElement)
                    try {
                        const E = k.createElement("iframe");
                        E.hidden = !0,
                        k.head.appendChild(E);
                        const U = E.contentWindow;
                        U && U[v] && (R = U[v]),
                        k.head.removeChild(E)
                    } catch (v) {}
                return to[v] = R.bind(window)
            }
            function setTimeout$2(...v) {
                return getImplementation$1("setTimeout")(...v)
            }
            function clearTimeout$2(...v) {
                return getImplementation$1("clearTimeout")(...v)
            }
            let no = 1;
            const ro = new RegExp("[^a-z0-9-_:]")
              , oo = -2;
            function genId() {
                return no++
            }
            let io, ao;
            const so = /url\((?:(')([^']*)'|(")(.*?)"|([^)]*))\)/gm
              , co = /^(?:[a-z+]+:)?\/\//i
              , lo = /^www\..*/i
              , uo = /^(data:)([^,]*),(.*)/i;
            function absoluteToStylesheet(v, E) {
                return (v || "").replace(so, ( (v, k, R, U, H, G) => {
                    const W = R || H || G
                      , Z = k || U || "";
                    if (!W)
                        return v;
                    if (co.test(W) || lo.test(W))
                        return `url(${Z}${W}${Z})`;
                    if (uo.test(W))
                        return `url(${Z}${W}${Z})`;
                    if ("/" === W[0])
                        return `url(${Z}${function extractOrigin(v) {
                            letE = "";
                            return E = v.indexOf("//") > -1 ? v.split("/").slice(0, 3).join("/") : v.split("/")[0],
                            E = E.split("?")[0],
                            E
                        }(E) + W}${Z})`;
                    const Y = E.split("/")
                      , J = W.split("/");
                    Y.pop();
                    for (const v of J)
                        "." !== v && (".." === v ? Y.pop() : Y.push(v));
                    return `url(${Z}${Y.join("/")}${Z})`
                }
                ))
            }
            const po = /^[^ \t\n\r\u000c]+/
              , fo = /^[, \t\n\r\u000c]+/;
            function absoluteToDoc(v, E) {
                if (!E || "" === E.trim())
                    return E;
                const k = v.createElement("a");
                return k.href = E,
                k.href
            }
            function isSVGElement(v) {
                return Boolean("svg" === v.tagName || v.ownerSVGElement)
            }
            function getHref() {
                const v = document.createElement("a");
                return v.href = "",
                v.href
            }
            function transformAttribute(v, E, k, R, U, H) {
                return R ? "src" === k || "href" === k && ("use" !== E || "#" !== R[0]) || "xlink:href" === k && "#" !== R[0] ? absoluteToDoc(v, R) : "background" !== k || "table" !== E && "td" !== E && "th" !== E ? "srcset" === k ? function getAbsoluteSrcsetString(v, E) {
                    if ("" === E.trim())
                        return E;
                    let k = 0;
                    function collectCharacters(v) {
                        let R;
                        const U = v.exec(E.substring(k));
                        return U ? (R = U[0],
                        k += R.length,
                        R) : ""
                    }
                    const R = [];
                    for (; collectCharacters(fo),
                    !(k >= E.length); ) {
                        let U = collectCharacters(po);
                        if ("," === U.slice(-1))
                            U = absoluteToDoc(v, U.substring(0, U.length - 1)),
                            R.push(U);
                        else {
                            let H = "";
                            U = absoluteToDoc(v, U);
                            let G = !1;
                            for (; ; ) {
                                const v = E.charAt(k);
                                if ("" === v) {
                                    R.push((U + H).trim());
                                    break
                                }
                                if (G)
                                    ")" === v && (G = !1);
                                else {
                                    if ("," === v) {
                                        k += 1,
                                        R.push((U + H).trim());
                                        break
                                    }
                                    "(" === v && (G = !0)
                                }
                                H += v,
                                k += 1
                            }
                        }
                    }
                    return R.join(", ")
                }(v, R) : "style" === k ? absoluteToStylesheet(R, getHref()) : "object" === E && "data" === k ? absoluteToDoc(v, R) : "function" == typeof H ? H(k, R, U) : R : absoluteToDoc(v, R) : R
            }
            function ignoreAttribute(v, E, k) {
                return ("video" === v || "audio" === v) && "autoplay" === E
            }
            function distanceToMatch(v, E, k=1 / 0, R=0) {
                return v ? v.nodeType !== v.ELEMENT_NODE || R > k ? -1 : E(v) ? R : distanceToMatch(v.parentNode, E, k, R + 1) : -1
            }
            function createMatchPredicate(v, E) {
                return k => {
                    const R = k;
                    if (null === R)
                        return !1;
                    try {
                        if (v)
                            if ("string" == typeof v) {
                                if (R.matches(`.${v}`))
                                    return !0
                            } else if (function elementClassMatchesRegex(v, E) {
                                for (let k = v.classList.length; k--; ) {
                                    const R = v.classList[k];
                                    if (E.test(R))
                                        return !0
                                }
                                return !1
                            }(R, v))
                                return !0;
                        return !(!E || !R.matches(E))
                    } catch (v) {
                        return !1
                    }
                }
            }
            function needMaskingText(v, E, k, R, U, H) {
                try {
                    const G = v.nodeType === v.ELEMENT_NODE ? v : v.parentElement;
                    if (null === G)
                        return !1;
                    if ("INPUT" === G.tagName) {
                        const v = G.getAttribute("autocomplete");
                        if (["current-password", "new-password", "cc-number", "cc-exp", "cc-exp-month", "cc-exp-year", "cc-csc"].includes(v))
                            return !0
                    }
                    let W = -1
                      , Z = -1;
                    if (H) {
                        if (Z = distanceToMatch(G, createMatchPredicate(R, U)),
                        Z < 0)
                            return !0;
                        W = distanceToMatch(G, createMatchPredicate(E, k), Z >= 0 ? Z : 1 / 0)
                    } else {
                        if (W = distanceToMatch(G, createMatchPredicate(E, k)),
                        W < 0)
                            return !1;
                        Z = distanceToMatch(G, createMatchPredicate(R, U), W >= 0 ? W : 1 / 0)
                    }
                    return W >= 0 ? !(Z >= 0) || W <= Z : !(Z >= 0) && !!H
                } catch (v) {}
                return !!H
            }
            function serializeNode(v, E) {
                const {"doc": k, "mirror": R, "blockClass": U, "blockSelector": H, "unblockSelector": G, "maskAllText": W, "maskAttributeFn": Z, "maskTextClass": Y, "unmaskTextClass": J, "maskTextSelector": K, "unmaskTextSelector": X, "inlineStylesheet": Q, "maskInputOptions": ee={}, "maskTextFn": te, "maskInputFn": ne, "dataURLOptions": re={}, "inlineImages": oe, "recordCanvas": ie, "keepIframeSrcFn": ae, "newlyAddedElement": se=!1} = E
                  , ce = function getRootId(v, E) {
                    if (!E.hasNode(v))
                        return;
                    const k = E.getId(v);
                    return 1 === k ? void 0 : k
                }(k, R);
                switch (v.nodeType) {
                case v.DOCUMENT_NODE:
                    return "CSS1Compat" !== v.compatMode ? {
                        "type": Qr.Document,
                        "childNodes": [],
                        "compatMode": v.compatMode
                    } : {
                        "type": Qr.Document,
                        "childNodes": []
                    };
                case v.DOCUMENT_TYPE_NODE:
                    return {
                        "type": Qr.DocumentType,
                        "name": v.name,
                        "publicId": v.publicId,
                        "systemId": v.systemId,
                        "rootId": ce
                    };
                case v.ELEMENT_NODE:
                    return function serializeElementNode(v, E) {
                        const {"doc": k, "blockClass": R, "blockSelector": U, "unblockSelector": H, "inlineStylesheet": G, "maskInputOptions": W={}, "maskAttributeFn": Z, "maskInputFn": Y, "dataURLOptions": J={}, "inlineImages": K, "recordCanvas": X, "keepIframeSrcFn": Q, "newlyAddedElement": ee=!1, "rootId": te, "maskAllText": ne, "maskTextClass": re, "unmaskTextClass": oe, "maskTextSelector": ie, "unmaskTextSelector": ae} = E
                          , se = function _isBlockedElement(v, E, k, R) {
                            try {
                                if (R && v.matches(R))
                                    return !1;
                                if ("string" == typeof E) {
                                    if (v.classList.contains(E))
                                        return !0
                                } else
                                    for (let k = v.classList.length; k--; ) {
                                        const R = v.classList[k];
                                        if (E.test(R))
                                            return !0
                                    }
                                if (k)
                                    return v.matches(k)
                            } catch (v) {}
                            return !1
                        }(v, R, U, H)
                          , ce = function getValidTagName(v) {
                            if (v instanceof HTMLFormElement)
                                return "form";
                            const E = toLowerCase(v.tagName);
                            return ro.test(E) ? "div" : E
                        }(v);
                        let le = {};
                        const ue = v.attributes.length;
                        for (let E = 0; E < ue; E++) {
                            const R = v.attributes[E];
                            R.name && !ignoreAttribute(ce, R.name, R.value) && (le[R.name] = transformAttribute(k, ce, toLowerCase(R.name), R.value, v, Z))
                        }
                        if ("link" === ce && G) {
                            const E = Array.from(k.styleSheets).find((E => E.href === v.href));
                            let R = null;
                            E && (R = stringifyStylesheet(E)),
                            R && (delete le.rel,
                            delete le.href,
                            le._cssText = absoluteToStylesheet(R, E.href))
                        }
                        if ("style" === ce && v.sheet && !(v.innerText || v.textContent || "").trim().length) {
                            const E = stringifyStylesheet(v.sheet);
                            E && (le._cssText = absoluteToStylesheet(E, getHref()))
                        }
                        if ("input" === ce || "textarea" === ce || "select" === ce || "option" === ce) {
                            const E = v
                              , k = getInputType(E)
                              , R = getInputValue(E, toUpperCase(ce), k)
                              , U = E.checked;
                            if ("submit" !== k && "button" !== k && R) {
                                const v = needMaskingText(E, re, ie, oe, ae, shouldMaskInput({
                                    "type": k,
                                    "tagName": toUpperCase(ce),
                                    "maskInputOptions": W
                                }));
                                le.value = maskInputValue({
                                    "isMasked": v,
                                    "element": E,
                                    "value": R,
                                    "maskInputFn": Y
                                })
                            }
                            U && (le.checked = U)
                        }
                        "option" === ce && (v.selected && !W.select ? le.selected = !0 : delete le.selected);
                        if ("canvas" === ce && X)
                            if ("2d" === v.__context)
                                (function is2DCanvasBlank(v) {
                                    const E = v.getContext("2d");
                                    if (!E)
                                        return !0;
                                    for (let k = 0; k < v.width; k += 50)
                                        for (let R = 0; R < v.height; R += 50) {
                                            const U = E.getImageData
                                              , H = eo in U ? U[eo] : U;
                                            if (new Uint32Array(H.call(E, k, R, Math.min(50, v.width - k), Math.min(50, v.height - R)).data.buffer).some((v => 0 !== v)))
                                                return !1
                                        }
                                    return !0
                                }
                                )(v) || (le.rr_dataURL = v.toDataURL(J.type, J.quality));
                            else if (!("__context"in v)) {
                                const E = v.toDataURL(J.type, J.quality)
                                  , k = document.createElement("canvas");
                                k.width = v.width,
                                k.height = v.height;
                                E !== k.toDataURL(J.type, J.quality) && (le.rr_dataURL = E)
                            }
                        if ("img" === ce && K) {
                            io || (io = k.createElement("canvas"),
                            ao = io.getContext("2d"));
                            const E = v
                              , R = E.crossOrigin;
                            E.crossOrigin = "anonymous";
                            const recordInlineImage = () => {
                                E.removeEventListener("load", recordInlineImage);
                                try {
                                    io.width = E.naturalWidth,
                                    io.height = E.naturalHeight,
                                    ao.drawImage(E, 0, 0),
                                    le.rr_dataURL = io.toDataURL(J.type, J.quality)
                                } catch (v) {
                                    console.warn(`Cannot inline img src=${E.currentSrc}! Error: ${v}`)
                                }
                                R ? le.crossOrigin = R : E.removeAttribute("crossorigin")
                            }
                            ;
                            E.complete && 0 !== E.naturalWidth ? recordInlineImage() : E.addEventListener("load", recordInlineImage)
                        }
                        "audio" !== ce && "video" !== ce || (le.rr_mediaState = v.paused ? "paused" : "played",
                        le.rr_mediaCurrentTime = v.currentTime);
                        ee || (v.scrollLeft && (le.rr_scrollLeft = v.scrollLeft),
                        v.scrollTop && (le.rr_scrollTop = v.scrollTop));
                        if (se) {
                            const {"width": E, "height": k} = v.getBoundingClientRect();
                            le = {
                                "class": le.class,
                                "rr_width": `${E}px`,
                                "rr_height": `${k}px`
                            }
                        }
                        "iframe" !== ce || Q(le.src) || (se || v.contentDocument || (le.rr_src = le.src),
                        delete le.src);
                        let de;
                        try {
                            customElements.get(ce) && (de = !0)
                        } catch (v) {}
                        return {
                            "type": Qr.Element,
                            "tagName": ce,
                            "attributes": le,
                            "childNodes": [],
                            "isSVG": isSVGElement(v) || void 0,
                            "needBlock": se,
                            "rootId": te,
                            "isCustom": de
                        }
                    }(v, {
                        "doc": k,
                        "blockClass": U,
                        "blockSelector": H,
                        "unblockSelector": G,
                        "inlineStylesheet": Q,
                        "maskAttributeFn": Z,
                        "maskInputOptions": ee,
                        "maskInputFn": ne,
                        "dataURLOptions": re,
                        "inlineImages": oe,
                        "recordCanvas": ie,
                        "keepIframeSrcFn": ae,
                        "newlyAddedElement": se,
                        "rootId": ce,
                        "maskAllText": W,
                        "maskTextClass": Y,
                        "unmaskTextClass": J,
                        "maskTextSelector": K,
                        "unmaskTextSelector": X
                    });
                case v.TEXT_NODE:
                    return function serializeTextNode(v, E) {
                        const {"maskAllText": k, "maskTextClass": R, "unmaskTextClass": U, "maskTextSelector": H, "unmaskTextSelector": G, "maskTextFn": W, "maskInputOptions": Z, "maskInputFn": Y, "rootId": J} = E
                          , K = v.parentNode && v.parentNode.tagName;
                        let X = v.textContent;
                        const Q = "STYLE" === K || void 0
                          , ee = "SCRIPT" === K || void 0
                          , te = "TEXTAREA" === K || void 0;
                        if (Q && X) {
                            try {
                                v.nextSibling || v.previousSibling || _optionalChain$5([v, "access", v => v.parentNode, "access", v => v.sheet, "optionalAccess", v => v.cssRules]) && (X = stringifyStylesheet(v.parentNode.sheet))
                            } catch (E) {
                                console.warn(`Cannot get CSS styles from text's parentNode. Error: ${E}`, v)
                            }
                            X = absoluteToStylesheet(X, getHref())
                        }
                        ee && (X = "SCRIPT_PLACEHOLDER");
                        const ne = needMaskingText(v, R, H, U, G, k);
                        Q || ee || te || !X || !ne || (X = W ? W(X, v.parentElement) : X.replace(/[\S]/g, "*"));
                        te && X && (Z.textarea || ne) && (X = Y ? Y(X, v.parentNode) : X.replace(/[\S]/g, "*"));
                        if ("OPTION" === K && X) {
                            X = maskInputValue({
                                "isMasked": needMaskingText(v, R, H, U, G, shouldMaskInput({
                                    "type": null,
                                    "tagName": K,
                                    "maskInputOptions": Z
                                })),
                                "element": v,
                                "value": X,
                                "maskInputFn": Y
                            })
                        }
                        return {
                            "type": Qr.Text,
                            "textContent": X || "",
                            "isStyle": Q,
                            "rootId": J
                        }
                    }(v, {
                        "maskAllText": W,
                        "maskTextClass": Y,
                        "unmaskTextClass": J,
                        "maskTextSelector": K,
                        "unmaskTextSelector": X,
                        "maskTextFn": te,
                        "maskInputOptions": ee,
                        "maskInputFn": ne,
                        "rootId": ce
                    });
                case v.CDATA_SECTION_NODE:
                    return {
                        "type": Qr.CDATA,
                        "textContent": "",
                        "rootId": ce
                    };
                case v.COMMENT_NODE:
                    return {
                        "type": Qr.Comment,
                        "textContent": v.textContent || "",
                        "rootId": ce
                    };
                default:
                    return !1
                }
            }
            function lowerIfExists(v) {
                return null == v ? "" : v.toLowerCase()
            }
            function serializeNodeWithId(v, E) {
                const {"doc": k, "mirror": R, "blockClass": U, "blockSelector": H, "unblockSelector": G, "maskAllText": W, "maskTextClass": Z, "unmaskTextClass": Y, "maskTextSelector": J, "unmaskTextSelector": K, "skipChild": X=!1, "inlineStylesheet": Q=!0, "maskInputOptions": ee={}, "maskAttributeFn": te, "maskTextFn": ne, "maskInputFn": re, "slimDOMOptions": oe, "dataURLOptions": ie={}, "inlineImages": ae=!1, "recordCanvas": se=!1, "onSerialize": ce, "onIframeLoad": le, "iframeLoadTimeout": ue=5e3, "onStylesheetLoad": de, "stylesheetLoadTimeout": pe=5e3, "keepIframeSrcFn": fe=( () => !1), "newlyAddedElement": he=!1} = E;
                let {"preserveWhiteSpace": me=!0} = E;
                const ge = serializeNode(v, {
                    "doc": k,
                    "mirror": R,
                    "blockClass": U,
                    "blockSelector": H,
                    "maskAllText": W,
                    "unblockSelector": G,
                    "maskTextClass": Z,
                    "unmaskTextClass": Y,
                    "maskTextSelector": J,
                    "unmaskTextSelector": K,
                    "inlineStylesheet": Q,
                    "maskInputOptions": ee,
                    "maskAttributeFn": te,
                    "maskTextFn": ne,
                    "maskInputFn": re,
                    "dataURLOptions": ie,
                    "inlineImages": ae,
                    "recordCanvas": se,
                    "keepIframeSrcFn": fe,
                    "newlyAddedElement": he
                });
                if (!ge)
                    return console.warn(v, "not serialized"),
                    null;
                let _e;
                _e = R.hasNode(v) ? R.getId(v) : !function slimDOMExcluded(v, E) {
                    if (E.comment && v.type === Qr.Comment)
                        return !0;
                    if (v.type === Qr.Element) {
                        if (E.script && ("script" === v.tagName || "link" === v.tagName && ("preload" === v.attributes.rel || "modulepreload" === v.attributes.rel) && "script" === v.attributes.as || "link" === v.tagName && "prefetch" === v.attributes.rel && "string" == typeof v.attributes.href && "js" === extractFileExtension(v.attributes.href)))
                            return !0;
                        if (E.headFavicon && ("link" === v.tagName && "shortcut icon" === v.attributes.rel || "meta" === v.tagName && (lowerIfExists(v.attributes.name).match(/^msapplication-tile(image|color)$/) || "application-name" === lowerIfExists(v.attributes.name) || "icon" === lowerIfExists(v.attributes.rel) || "apple-touch-icon" === lowerIfExists(v.attributes.rel) || "shortcut icon" === lowerIfExists(v.attributes.rel))))
                            return !0;
                        if ("meta" === v.tagName) {
                            if (E.headMetaDescKeywords && lowerIfExists(v.attributes.name).match(/^description|keywords$/))
                                return !0;
                            if (E.headMetaSocial && (lowerIfExists(v.attributes.property).match(/^(og|twitter|fb):/) || lowerIfExists(v.attributes.name).match(/^(og|twitter):/) || "pinterest" === lowerIfExists(v.attributes.name)))
                                return !0;
                            if (E.headMetaRobots && ("robots" === lowerIfExists(v.attributes.name) || "googlebot" === lowerIfExists(v.attributes.name) || "bingbot" === lowerIfExists(v.attributes.name)))
                                return !0;
                            if (E.headMetaHttpEquiv && void 0 !== v.attributes["http-equiv"])
                                return !0;
                            if (E.headMetaAuthorship && ("author" === lowerIfExists(v.attributes.name) || "generator" === lowerIfExists(v.attributes.name) || "framework" === lowerIfExists(v.attributes.name) || "publisher" === lowerIfExists(v.attributes.name) || "progid" === lowerIfExists(v.attributes.name) || lowerIfExists(v.attributes.property).match(/^article:/) || lowerIfExists(v.attributes.property).match(/^product:/)))
                                return !0;
                            if (E.headMetaVerification && ("google-site-verification" === lowerIfExists(v.attributes.name) || "yandex-verification" === lowerIfExists(v.attributes.name) || "csrf-token" === lowerIfExists(v.attributes.name) || "p:domain_verify" === lowerIfExists(v.attributes.name) || "verify-v1" === lowerIfExists(v.attributes.name) || "verification" === lowerIfExists(v.attributes.name) || "shopify-checkout-api-token" === lowerIfExists(v.attributes.name)))
                                return !0
                        }
                    }
                    return !1
                }(ge, oe) && (me || ge.type !== Qr.Text || ge.isStyle || ge.textContent.replace(/^\s+|\s+$/gm, "").length) ? genId() : oo;
                const ve = Object.assign(ge, {
                    "id": _e
                });
                if (R.add(v, ve),
                _e === oo)
                    return null;
                ce && ce(v);
                let ye = !X;
                if (ve.type === Qr.Element) {
                    ye = ye && !ve.needBlock,
                    delete ve.needBlock;
                    const E = v.shadowRoot;
                    E && isNativeShadowDom(E) && (ve.isShadowHost = !0)
                }
                if ((ve.type === Qr.Document || ve.type === Qr.Element) && ye) {
                    oe.headWhitespace && ve.type === Qr.Element && "head" === ve.tagName && (me = !1);
                    const E = {
                        "doc": k,
                        "mirror": R,
                        "blockClass": U,
                        "blockSelector": H,
                        "maskAllText": W,
                        "unblockSelector": G,
                        "maskTextClass": Z,
                        "unmaskTextClass": Y,
                        "maskTextSelector": J,
                        "unmaskTextSelector": K,
                        "skipChild": X,
                        "inlineStylesheet": Q,
                        "maskInputOptions": ee,
                        "maskAttributeFn": te,
                        "maskTextFn": ne,
                        "maskInputFn": re,
                        "slimDOMOptions": oe,
                        "dataURLOptions": ie,
                        "inlineImages": ae,
                        "recordCanvas": se,
                        "preserveWhiteSpace": me,
                        "onSerialize": ce,
                        "onIframeLoad": le,
                        "iframeLoadTimeout": ue,
                        "onStylesheetLoad": de,
                        "stylesheetLoadTimeout": pe,
                        "keepIframeSrcFn": fe
                    };
                    for (const k of Array.from(v.childNodes)) {
                        const v = serializeNodeWithId(k, E);
                        v && ve.childNodes.push(v)
                    }
                    if (function isElement$1(v) {
                        return v.nodeType === v.ELEMENT_NODE
                    }(v) && v.shadowRoot)
                        for (const k of Array.from(v.shadowRoot.childNodes)) {
                            const R = serializeNodeWithId(k, E);
                            R && (isNativeShadowDom(v.shadowRoot) && (R.isShadow = !0),
                            ve.childNodes.push(R))
                        }
                }
                return v.parentNode && isShadowRoot(v.parentNode) && isNativeShadowDom(v.parentNode) && (ve.isShadow = !0),
                ve.type === Qr.Element && "iframe" === ve.tagName && function onceIframeLoaded(v, E, k) {
                    const R = v.contentWindow;
                    if (!R)
                        return;
                    let U, H = !1;
                    try {
                        U = R.document.readyState
                    } catch (v) {
                        return
                    }
                    if ("complete" !== U) {
                        const R = setTimeout$2(( () => {
                            H || (E(),
                            H = !0)
                        }
                        ), k);
                        return void v.addEventListener("load", ( () => {
                            clearTimeout$2(R),
                            H = !0,
                            E()
                        }
                        ))
                    }
                    const G = "about:blank";
                    if (R.location.href !== G || v.src === G || "" === v.src)
                        return setTimeout$2(E, 0),
                        v.addEventListener("load", E);
                    v.addEventListener("load", E)
                }(v, ( () => {
                    const E = v.contentDocument;
                    if (E && le) {
                        const k = serializeNodeWithId(E, {
                            "doc": E,
                            "mirror": R,
                            "blockClass": U,
                            "blockSelector": H,
                            "unblockSelector": G,
                            "maskAllText": W,
                            "maskTextClass": Z,
                            "unmaskTextClass": Y,
                            "maskTextSelector": J,
                            "unmaskTextSelector": K,
                            "skipChild": !1,
                            "inlineStylesheet": Q,
                            "maskInputOptions": ee,
                            "maskAttributeFn": te,
                            "maskTextFn": ne,
                            "maskInputFn": re,
                            "slimDOMOptions": oe,
                            "dataURLOptions": ie,
                            "inlineImages": ae,
                            "recordCanvas": se,
                            "preserveWhiteSpace": me,
                            "onSerialize": ce,
                            "onIframeLoad": le,
                            "iframeLoadTimeout": ue,
                            "onStylesheetLoad": de,
                            "stylesheetLoadTimeout": pe,
                            "keepIframeSrcFn": fe
                        });
                        k && le(v, k)
                    }
                }
                ), ue),
                ve.type === Qr.Element && "link" === ve.tagName && "string" == typeof ve.attributes.rel && ("stylesheet" === ve.attributes.rel || "preload" === ve.attributes.rel && "string" == typeof ve.attributes.href && "css" === extractFileExtension(ve.attributes.href)) && function onceStylesheetLoaded(v, E, k) {
                    let R, U = !1;
                    try {
                        R = v.sheet
                    } catch (v) {
                        return
                    }
                    if (R)
                        return;
                    const H = setTimeout$2(( () => {
                        U || (E(),
                        U = !0)
                    }
                    ), k);
                    v.addEventListener("load", ( () => {
                        clearTimeout$2(H),
                        U = !0,
                        E()
                    }
                    ))
                }(v, ( () => {
                    if (de) {
                        const E = serializeNodeWithId(v, {
                            "doc": k,
                            "mirror": R,
                            "blockClass": U,
                            "blockSelector": H,
                            "unblockSelector": G,
                            "maskAllText": W,
                            "maskTextClass": Z,
                            "unmaskTextClass": Y,
                            "maskTextSelector": J,
                            "unmaskTextSelector": K,
                            "skipChild": !1,
                            "inlineStylesheet": Q,
                            "maskInputOptions": ee,
                            "maskAttributeFn": te,
                            "maskTextFn": ne,
                            "maskInputFn": re,
                            "slimDOMOptions": oe,
                            "dataURLOptions": ie,
                            "inlineImages": ae,
                            "recordCanvas": se,
                            "preserveWhiteSpace": me,
                            "onSerialize": ce,
                            "onIframeLoad": le,
                            "iframeLoadTimeout": ue,
                            "onStylesheetLoad": de,
                            "stylesheetLoadTimeout": pe,
                            "keepIframeSrcFn": fe
                        });
                        E && de(v, E)
                    }
                }
                ), pe),
                ve
            }
            function _optionalChain$4(v) {
                let E, k = v[0], R = 1;
                for (; R < v.length; ) {
                    const U = v[R]
                      , H = v[R + 1];
                    if (R += 2,
                    ("optionalAccess" === U || "optionalCall" === U) && null == k)
                        return;
                    "access" === U || "optionalAccess" === U ? (E = k,
                    k = H(k)) : "call" !== U && "optionalCall" !== U || (k = H(( (...v) => k.call(E, ...v))),
                    E = void 0)
                }
                return k
            }
            function on(v, E, k=document) {
                const R = {
                    "capture": !0,
                    "passive": !0
                };
                return k.addEventListener(v, E, R),
                () => k.removeEventListener(v, E, R)
            }
            const ho = "Please stop import mirror directly. Instead of that,\r\nnow you can use replayer.getMirror() to access the mirror instance of a replayer,\r\nor you can use record.mirror to access the mirror instance during recording.";
            let mo = {
                "map": {},
                "getId"() {
                    return console.error(ho),
                    -1
                },
                "getNode"() {
                    return console.error(ho),
                    null
                },
                "removeNodeFromMap"() {
                    console.error(ho)
                },
                "has"() {
                    return console.error(ho),
                    !1
                },
                "reset"() {
                    console.error(ho)
                }
            };
            function throttle$1(v, E, k={}) {
                let R = null
                  , U = 0;
                return function(...H) {
                    const G = Date.now();
                    U || !1 !== k.leading || (U = G);
                    const W = E - (G - U)
                      , Z = this;
                    W <= 0 || W > E ? (R && (!function clearTimeout$1(...v) {
                        return getImplementation("clearTimeout")(...v)
                    }(R),
                    R = null),
                    U = G,
                    v.apply(Z, H)) : R || !1 === k.trailing || (R = setTimeout$1(( () => {
                        U = !1 === k.leading ? 0 : Date.now(),
                        R = null,
                        v.apply(Z, H)
                    }
                    ), W))
                }
            }
            function hookSetter(v, E, k, R, U=window) {
                const H = U.Object.getOwnPropertyDescriptor(v, E);
                return U.Object.defineProperty(v, E, R ? k : {
                    "set"(v) {
                        setTimeout$1(( () => {
                            k.set.call(this, v)
                        }
                        ), 0),
                        H && H.set && H.set.call(this, v)
                    }
                }),
                () => hookSetter(v, E, H || {}, !0)
            }
            function patch(v, E, k) {
                try {
                    if (!(E in v))
                        return () => {}
                        ;
                    const R = v[E]
                      , U = k(R);
                    return "function" == typeof U && (U.prototype = U.prototype || {},
                    Object.defineProperties(U, {
                        "__rrweb_original__": {
                            "enumerable": !1,
                            "value": R
                        }
                    })),
                    v[E] = U,
                    () => {
                        v[E] = R
                    }
                } catch (v) {
                    return () => {}
                }
            }
            "undefined" != typeof window && window.Proxy && window.Reflect && (mo = new Proxy(mo,{
                "get"(v, E, k) {
                    return "map" === E && console.error(ho),
                    Reflect.get(v, E, k)
                }
            }));
            let _o = Date.now;
            function getWindowScroll(v) {
                const E = v.document;
                return {
                    "left": E.scrollingElement ? E.scrollingElement.scrollLeft : void 0 !== v.pageXOffset ? v.pageXOffset : _optionalChain$4([E, "optionalAccess", v => v.documentElement, "access", v => v.scrollLeft]) || _optionalChain$4([E, "optionalAccess", v => v.body, "optionalAccess", v => v.parentElement, "optionalAccess", v => v.scrollLeft]) || _optionalChain$4([E, "optionalAccess", v => v.body, "optionalAccess", v => v.scrollLeft]) || 0,
                    "top": E.scrollingElement ? E.scrollingElement.scrollTop : void 0 !== v.pageYOffset ? v.pageYOffset : _optionalChain$4([E, "optionalAccess", v => v.documentElement, "access", v => v.scrollTop]) || _optionalChain$4([E, "optionalAccess", v => v.body, "optionalAccess", v => v.parentElement, "optionalAccess", v => v.scrollTop]) || _optionalChain$4([E, "optionalAccess", v => v.body, "optionalAccess", v => v.scrollTop]) || 0
                }
            }
            function getWindowHeight() {
                return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight
            }
            function getWindowWidth() {
                return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth
            }
            function closestElementOfNode(v) {
                if (!v)
                    return null;
                return v.nodeType === v.ELEMENT_NODE ? v : v.parentElement
            }
            function isBlocked(v, E, k, R, U) {
                if (!v)
                    return !1;
                const H = closestElementOfNode(v);
                if (!H)
                    return !1;
                const G = createMatchPredicate(E, k);
                if (!U) {
                    const v = R && H.matches(R);
                    return G(H) && !v
                }
                const W = distanceToMatch(H, G);
                let Z = -1;
                return !(W < 0) && (R && (Z = distanceToMatch(H, createMatchPredicate(null, R))),
                W > -1 && Z < 0 || W < Z)
            }
            function isIgnored(v, E) {
                return E.getId(v) === oo
            }
            function isAncestorRemoved(v, E) {
                if (isShadowRoot(v))
                    return !1;
                const k = E.getId(v);
                return !E.has(k) || (!v.parentNode || v.parentNode.nodeType !== v.DOCUMENT_NODE) && (!v.parentNode || isAncestorRemoved(v.parentNode, E))
            }
            function legacy_isTouchEvent(v) {
                return Boolean(v.changedTouches)
            }
            function isSerializedIframe(v, E) {
                return Boolean("IFRAME" === v.nodeName && E.getMeta(v))
            }
            function isSerializedStylesheet(v, E) {
                return Boolean("LINK" === v.nodeName && v.nodeType === v.ELEMENT_NODE && v.getAttribute && "stylesheet" === v.getAttribute("rel") && E.getMeta(v))
            }
            function hasShadowRoot(v) {
                return Boolean(_optionalChain$4([v, "optionalAccess", v => v.shadowRoot]))
            }
            /[1-9][0-9]{12}/.test(Date.now().toString()) || (_o = () => (new Date).getTime());
            class StyleSheetMirror {
                "constructor"() {
                    this.id = 1,
                    this.styleIDMap = new WeakMap,
                    this.idStyleMap = new Map
                }
                "getId"(v) {
                    return function _nullishCoalesce(v, E) {
                        return null != v ? v : E()
                    }(this.styleIDMap.get(v), ( () => -1))
                }
                "has"(v) {
                    return this.styleIDMap.has(v)
                }
                "add"(v, E) {
                    if (this.has(v))
                        return this.getId(v);
                    let k;
                    return k = void 0 === E ? this.id++ : E,
                    this.styleIDMap.set(v, k),
                    this.idStyleMap.set(k, v),
                    k
                }
                "getStyle"(v) {
                    return this.idStyleMap.get(v) || null
                }
                "reset"() {
                    this.styleIDMap = new WeakMap,
                    this.idStyleMap = new Map,
                    this.id = 1
                }
                "generateId"() {
                    return this.id++
                }
            }
            function getShadowHost(v) {
                let E = null;
                return _optionalChain$4([v, "access", v => v.getRootNode, "optionalCall", v => v(), "optionalAccess", v => v.nodeType]) === Node.DOCUMENT_FRAGMENT_NODE && v.getRootNode().host && (E = v.getRootNode().host),
                E
            }
            function shadowHostInDom(v) {
                const E = v.ownerDocument;
                if (!E)
                    return !1;
                const k = function getRootShadowHost(v) {
                    let E, k = v;
                    for (; E = getShadowHost(k); )
                        k = E;
                    return k
                }(v);
                return E.contains(k)
            }
            function inDom(v) {
                const E = v.ownerDocument;
                return !!E && (E.contains(v) || shadowHostInDom(v))
            }
            const vo = {};
            function getImplementation(v) {
                const E = vo[v];
                if (E)
                    return E;
                const k = window.document;
                let R = window[v];
                if (k && "function" == typeof k.createElement)
                    try {
                        const E = k.createElement("iframe");
                        E.hidden = !0,
                        k.head.appendChild(E);
                        const U = E.contentWindow;
                        U && U[v] && (R = U[v]),
                        k.head.removeChild(E)
                    } catch (v) {}
                return vo[v] = R.bind(window)
            }
            function setTimeout$1(...v) {
                return getImplementation("setTimeout")(...v)
            }
            var yo = (v => (v[v.DomContentLoaded = 0] = "DomContentLoaded",
            v[v.Load = 1] = "Load",
            v[v.FullSnapshot = 2] = "FullSnapshot",
            v[v.IncrementalSnapshot = 3] = "IncrementalSnapshot",
            v[v.Meta = 4] = "Meta",
            v[v.Custom = 5] = "Custom",
            v[v.Plugin = 6] = "Plugin",
            v))(yo || {})
              , bo = (v => (v[v.Mutation = 0] = "Mutation",
            v[v.MouseMove = 1] = "MouseMove",
            v[v.MouseInteraction = 2] = "MouseInteraction",
            v[v.Scroll = 3] = "Scroll",
            v[v.ViewportResize = 4] = "ViewportResize",
            v[v.Input = 5] = "Input",
            v[v.TouchMove = 6] = "TouchMove",
            v[v.MediaInteraction = 7] = "MediaInteraction",
            v[v.StyleSheetRule = 8] = "StyleSheetRule",
            v[v.CanvasMutation = 9] = "CanvasMutation",
            v[v.Font = 10] = "Font",
            v[v.Log = 11] = "Log",
            v[v.Drag = 12] = "Drag",
            v[v.StyleDeclaration = 13] = "StyleDeclaration",
            v[v.Selection = 14] = "Selection",
            v[v.AdoptedStyleSheet = 15] = "AdoptedStyleSheet",
            v[v.CustomElement = 16] = "CustomElement",
            v))(bo || {})
              , So = (v => (v[v.MouseUp = 0] = "MouseUp",
            v[v.MouseDown = 1] = "MouseDown",
            v[v.Click = 2] = "Click",
            v[v.ContextMenu = 3] = "ContextMenu",
            v[v.DblClick = 4] = "DblClick",
            v[v.Focus = 5] = "Focus",
            v[v.Blur = 6] = "Blur",
            v[v.TouchStart = 7] = "TouchStart",
            v[v.TouchMove_Departed = 8] = "TouchMove_Departed",
            v[v.TouchEnd = 9] = "TouchEnd",
            v[v.TouchCancel = 10] = "TouchCancel",
            v))(So || {})
              , wo = (v => (v[v.Mouse = 0] = "Mouse",
            v[v.Pen = 1] = "Pen",
            v[v.Touch = 2] = "Touch",
            v))(wo || {});
            function _optionalChain$3(v) {
                let E, k = v[0], R = 1;
                for (; R < v.length; ) {
                    const U = v[R]
                      , H = v[R + 1];
                    if (R += 2,
                    ("optionalAccess" === U || "optionalCall" === U) && null == k)
                        return;
                    "access" === U || "optionalAccess" === U ? (E = k,
                    k = H(k)) : "call" !== U && "optionalCall" !== U || (k = H(( (...v) => k.call(E, ...v))),
                    E = void 0)
                }
                return k
            }
            function isNodeInLinkedList(v) {
                return "__ln"in v
            }
            class DoubleLinkedList {
                "constructor"() {
                    this.length = 0,
                    this.head = null,
                    this.tail = null
                }
                "get"(v) {
                    if (v >= this.length)
                        throw new Error("Position outside of list range");
                    let E = this.head;
                    for (let k = 0; k < v; k++)
                        E = _optionalChain$3([E, "optionalAccess", v => v.next]) || null;
                    return E
                }
                "addNode"(v) {
                    const E = {
                        "value": v,
                        "previous": null,
                        "next": null
                    };
                    if (v.__ln = E,
                    v.previousSibling && isNodeInLinkedList(v.previousSibling)) {
                        const k = v.previousSibling.__ln.next;
                        E.next = k,
                        E.previous = v.previousSibling.__ln,
                        v.previousSibling.__ln.next = E,
                        k && (k.previous = E)
                    } else if (v.nextSibling && isNodeInLinkedList(v.nextSibling) && v.nextSibling.__ln.previous) {
                        const k = v.nextSibling.__ln.previous;
                        E.previous = k,
                        E.next = v.nextSibling.__ln,
                        v.nextSibling.__ln.previous = E,
                        k && (k.next = E)
                    } else
                        this.head && (this.head.previous = E),
                        E.next = this.head,
                        this.head = E;
                    null === E.next && (this.tail = E),
                    this.length++
                }
                "removeNode"(v) {
                    const E = v.__ln;
                    this.head && (E.previous ? (E.previous.next = E.next,
                    E.next ? E.next.previous = E.previous : this.tail = E.previous) : (this.head = E.next,
                    this.head ? this.head.previous = null : this.tail = null),
                    v.__ln && delete v.__ln,
                    this.length--)
                }
            }
            const moveKey = (v, E) => `${v}@${E}`;
            class MutationBuffer {
                "constructor"() {
                    this.frozen = !1,
                    this.locked = !1,
                    this.texts = [],
                    this.attributes = [],
                    this.attributeMap = new WeakMap,
                    this.removes = [],
                    this.mapRemoves = [],
                    this.movedMap = {},
                    this.addedSet = new Set,
                    this.movedSet = new Set,
                    this.droppedSet = new Set,
                    this.processMutations = v => {
                        v.forEach(this.processMutation),
                        this.emit()
                    }
                    ,
                    this.emit = () => {
                        if (this.frozen || this.locked)
                            return;
                        const v = []
                          , E = new Set
                          , k = new DoubleLinkedList
                          , getNextId = v => {
                            let E = v
                              , k = oo;
                            for (; k === oo; )
                                E = E && E.nextSibling,
                                k = E && this.mirror.getId(E);
                            return k
                        }
                          , pushAdd = R => {
                            if (!R.parentNode || !inDom(R))
                                return;
                            const U = isShadowRoot(R.parentNode) ? this.mirror.getId(getShadowHost(R)) : this.mirror.getId(R.parentNode)
                              , H = getNextId(R);
                            if (-1 === U || -1 === H)
                                return k.addNode(R);
                            const G = serializeNodeWithId(R, {
                                "doc": this.doc,
                                "mirror": this.mirror,
                                "blockClass": this.blockClass,
                                "blockSelector": this.blockSelector,
                                "maskAllText": this.maskAllText,
                                "unblockSelector": this.unblockSelector,
                                "maskTextClass": this.maskTextClass,
                                "unmaskTextClass": this.unmaskTextClass,
                                "maskTextSelector": this.maskTextSelector,
                                "unmaskTextSelector": this.unmaskTextSelector,
                                "skipChild": !0,
                                "newlyAddedElement": !0,
                                "inlineStylesheet": this.inlineStylesheet,
                                "maskInputOptions": this.maskInputOptions,
                                "maskAttributeFn": this.maskAttributeFn,
                                "maskTextFn": this.maskTextFn,
                                "maskInputFn": this.maskInputFn,
                                "slimDOMOptions": this.slimDOMOptions,
                                "dataURLOptions": this.dataURLOptions,
                                "recordCanvas": this.recordCanvas,
                                "inlineImages": this.inlineImages,
                                "onSerialize": v => {
                                    isSerializedIframe(v, this.mirror) && !isBlocked(v, this.blockClass, this.blockSelector, this.unblockSelector, !1) && this.iframeManager.addIframe(v),
                                    isSerializedStylesheet(v, this.mirror) && this.stylesheetManager.trackLinkElement(v),
                                    hasShadowRoot(R) && this.shadowDomManager.addShadowRoot(R.shadowRoot, this.doc)
                                }
                                ,
                                "onIframeLoad": (v, E) => {
                                    isBlocked(v, this.blockClass, this.blockSelector, this.unblockSelector, !1) || (this.iframeManager.attachIframe(v, E),
                                    v.contentWindow && this.canvasManager.addWindow(v.contentWindow),
                                    this.shadowDomManager.observeAttachShadow(v))
                                }
                                ,
                                "onStylesheetLoad": (v, E) => {
                                    this.stylesheetManager.attachLinkElement(v, E)
                                }
                            });
                            G && (v.push({
                                "parentId": U,
                                "nextId": H,
                                "node": G
                            }),
                            E.add(G.id))
                        }
                        ;
                        for (; this.mapRemoves.length; )
                            this.mirror.removeNodeFromMap(this.mapRemoves.shift());
                        for (const v of this.movedSet)
                            isParentRemoved(this.removes, v, this.mirror) && !this.movedSet.has(v.parentNode) || pushAdd(v);
                        for (const v of this.addedSet)
                            isAncestorInSet(this.droppedSet, v) || isParentRemoved(this.removes, v, this.mirror) ? isAncestorInSet(this.movedSet, v) ? pushAdd(v) : this.droppedSet.add(v) : pushAdd(v);
                        let R = null;
                        for (; k.length; ) {
                            let v = null;
                            if (R) {
                                const E = this.mirror.getId(R.value.parentNode)
                                  , k = getNextId(R.value);
                                -1 !== E && -1 !== k && (v = R)
                            }
                            if (!v) {
                                let E = k.tail;
                                for (; E; ) {
                                    const k = E;
                                    if (E = E.previous,
                                    k) {
                                        const E = this.mirror.getId(k.value.parentNode);
                                        if (-1 === getNextId(k.value))
                                            continue;
                                        if (-1 !== E) {
                                            v = k;
                                            break
                                        }
                                        {
                                            const E = k.value;
                                            if (E.parentNode && E.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                                                const R = E.parentNode.host;
                                                if (-1 !== this.mirror.getId(R)) {
                                                    v = k;
                                                    break
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            if (!v) {
                                for (; k.head; )
                                    k.removeNode(k.head.value);
                                break
                            }
                            R = v.previous,
                            k.removeNode(v.value),
                            pushAdd(v.value)
                        }
                        const U = {
                            "texts": this.texts.map((v => ({
                                "id": this.mirror.getId(v.node),
                                "value": v.value
                            }))).filter((v => !E.has(v.id))).filter((v => this.mirror.has(v.id))),
                            "attributes": this.attributes.map((v => {
                                const {"attributes": E} = v;
                                if ("string" == typeof E.style) {
                                    const k = JSON.stringify(v.styleDiff)
                                      , R = JSON.stringify(v._unchangedStyles);
                                    k.length < E.style.length && (k + R).split("var(").length === E.style.split("var(").length && (E.style = v.styleDiff)
                                }
                                return {
                                    "id": this.mirror.getId(v.node),
                                    "attributes": E
                                }
                            }
                            )).filter((v => !E.has(v.id))).filter((v => this.mirror.has(v.id))),
                            "removes": this.removes,
                            "adds": v
                        };
                        (U.texts.length || U.attributes.length || U.removes.length || U.adds.length) && (this.texts = [],
                        this.attributes = [],
                        this.attributeMap = new WeakMap,
                        this.removes = [],
                        this.addedSet = new Set,
                        this.movedSet = new Set,
                        this.droppedSet = new Set,
                        this.movedMap = {},
                        this.mutationCb(U))
                    }
                    ,
                    this.processMutation = v => {
                        if (!isIgnored(v.target, this.mirror))
                            switch (v.type) {
                            case "characterData":
                                {
                                    const E = v.target.textContent;
                                    isBlocked(v.target, this.blockClass, this.blockSelector, this.unblockSelector, !1) || E === v.oldValue || this.texts.push({
                                        "value": needMaskingText(v.target, this.maskTextClass, this.maskTextSelector, this.unmaskTextClass, this.unmaskTextSelector, this.maskAllText) && E ? this.maskTextFn ? this.maskTextFn(E, closestElementOfNode(v.target)) : E.replace(/[\S]/g, "*") : E,
                                        "node": v.target
                                    });
                                    break
                                }
                            case "attributes":
                                {
                                    const E = v.target;
                                    let k = v.attributeName
                                      , R = v.target.getAttribute(k);
                                    if ("value" === k) {
                                        const k = getInputType(E)
                                          , U = E.tagName;
                                        R = getInputValue(E, U, k);
                                        const H = shouldMaskInput({
                                            "maskInputOptions": this.maskInputOptions,
                                            "tagName": U,
                                            "type": k
                                        });
                                        R = maskInputValue({
                                            "isMasked": needMaskingText(v.target, this.maskTextClass, this.maskTextSelector, this.unmaskTextClass, this.unmaskTextSelector, H),
                                            "element": E,
                                            "value": R,
                                            "maskInputFn": this.maskInputFn
                                        })
                                    }
                                    if (isBlocked(v.target, this.blockClass, this.blockSelector, this.unblockSelector, !1) || R === v.oldValue)
                                        return;
                                    let U = this.attributeMap.get(v.target);
                                    if ("IFRAME" === E.tagName && "src" === k && !this.keepIframeSrcFn(R)) {
                                        if (E.contentDocument)
                                            return;
                                        k = "rr_src"
                                    }
                                    if (U || (U = {
                                        "node": v.target,
                                        "attributes": {},
                                        "styleDiff": {},
                                        "_unchangedStyles": {}
                                    },
                                    this.attributes.push(U),
                                    this.attributeMap.set(v.target, U)),
                                    "type" === k && "INPUT" === E.tagName && "password" === (v.oldValue || "").toLowerCase() && E.setAttribute("data-rr-is-password", "true"),
                                    !ignoreAttribute(E.tagName, k) && (U.attributes[k] = transformAttribute(this.doc, toLowerCase(E.tagName), toLowerCase(k), R, E, this.maskAttributeFn),
                                    "style" === k)) {
                                        if (!this.unattachedDoc)
                                            try {
                                                this.unattachedDoc = document.implementation.createHTMLDocument()
                                            } catch (v) {
                                                this.unattachedDoc = this.doc
                                            }
                                        const k = this.unattachedDoc.createElement("span");
                                        v.oldValue && k.setAttribute("style", v.oldValue);
                                        for (const v of Array.from(E.style)) {
                                            const R = E.style.getPropertyValue(v)
                                              , H = E.style.getPropertyPriority(v);
                                            R !== k.style.getPropertyValue(v) || H !== k.style.getPropertyPriority(v) ? U.styleDiff[v] = "" === H ? R : [R, H] : U._unchangedStyles[v] = [R, H]
                                        }
                                        for (const v of Array.from(k.style))
                                            "" === E.style.getPropertyValue(v) && (U.styleDiff[v] = !1)
                                    }
                                    break
                                }
                            case "childList":
                                if (isBlocked(v.target, this.blockClass, this.blockSelector, this.unblockSelector, !0))
                                    return;
                                v.addedNodes.forEach((E => this.genAdds(E, v.target))),
                                v.removedNodes.forEach((E => {
                                    const k = this.mirror.getId(E)
                                      , R = isShadowRoot(v.target) ? this.mirror.getId(v.target.host) : this.mirror.getId(v.target);
                                    isBlocked(v.target, this.blockClass, this.blockSelector, this.unblockSelector, !1) || isIgnored(E, this.mirror) || !function isSerialized(v, E) {
                                        return -1 !== E.getId(v)
                                    }(E, this.mirror) || (this.addedSet.has(E) ? (deepDelete(this.addedSet, E),
                                    this.droppedSet.add(E)) : this.addedSet.has(v.target) && -1 === k || isAncestorRemoved(v.target, this.mirror) || (this.movedSet.has(E) && this.movedMap[moveKey(k, R)] ? deepDelete(this.movedSet, E) : this.removes.push({
                                        "parentId": R,
                                        "id": k,
                                        "isShadow": !(!isShadowRoot(v.target) || !isNativeShadowDom(v.target)) || void 0
                                    })),
                                    this.mapRemoves.push(E))
                                }
                                ))
                            }
                    }
                    ,
                    this.genAdds = (v, E) => {
                        if (!this.processedNodeManager.inOtherBuffer(v, this) && !this.addedSet.has(v) && !this.movedSet.has(v)) {
                            if (this.mirror.hasNode(v)) {
                                if (isIgnored(v, this.mirror))
                                    return;
                                this.movedSet.add(v);
                                let k = null;
                                E && this.mirror.hasNode(E) && (k = this.mirror.getId(E)),
                                k && -1 !== k && (this.movedMap[moveKey(this.mirror.getId(v), k)] = !0)
                            } else
                                this.addedSet.add(v),
                                this.droppedSet.delete(v);
                            isBlocked(v, this.blockClass, this.blockSelector, this.unblockSelector, !1) || (v.childNodes.forEach((v => this.genAdds(v))),
                            hasShadowRoot(v) && v.shadowRoot.childNodes.forEach((E => {
                                this.processedNodeManager.add(E, this),
                                this.genAdds(E, v)
                            }
                            )))
                        }
                    }
                }
                "init"(v) {
                    ["mutationCb", "blockClass", "blockSelector", "unblockSelector", "maskAllText", "maskTextClass", "unmaskTextClass", "maskTextSelector", "unmaskTextSelector", "inlineStylesheet", "maskInputOptions", "maskAttributeFn", "maskTextFn", "maskInputFn", "keepIframeSrcFn", "recordCanvas", "inlineImages", "slimDOMOptions", "dataURLOptions", "doc", "mirror", "iframeManager", "stylesheetManager", "shadowDomManager", "canvasManager", "processedNodeManager"].forEach((E => {
                        this[E] = v[E]
                    }
                    ))
                }
                "freeze"() {
                    this.frozen = !0,
                    this.canvasManager.freeze()
                }
                "unfreeze"() {
                    this.frozen = !1,
                    this.canvasManager.unfreeze(),
                    this.emit()
                }
                "isFrozen"() {
                    return this.frozen
                }
                "lock"() {
                    this.locked = !0,
                    this.canvasManager.lock()
                }
                "unlock"() {
                    this.locked = !1,
                    this.canvasManager.unlock(),
                    this.emit()
                }
                "reset"() {
                    this.shadowDomManager.reset(),
                    this.canvasManager.reset()
                }
            }
            function deepDelete(v, E) {
                v.delete(E),
                E.childNodes.forEach((E => deepDelete(v, E)))
            }
            function isParentRemoved(v, E, k) {
                return 0 !== v.length && _isParentRemoved(v, E, k)
            }
            function _isParentRemoved(v, E, k) {
                const {"parentNode": R} = E;
                if (!R)
                    return !1;
                const U = k.getId(R);
                return !!v.some((v => v.id === U)) || _isParentRemoved(v, R, k)
            }
            function isAncestorInSet(v, E) {
                return 0 !== v.size && _isAncestorInSet(v, E)
            }
            function _isAncestorInSet(v, E) {
                const {"parentNode": k} = E;
                return !!k && (!!v.has(k) || _isAncestorInSet(v, k))
            }
            let Eo;
            function registerErrorHandler(v) {
                Eo = v
            }
            function unregisterErrorHandler() {
                Eo = void 0
            }
            const callbackWrapper = v => {
                if (!Eo)
                    return v;
                return (...E) => {
                    try {
                        return v(...E)
                    } catch (v) {
                        if (Eo && !0 === Eo(v))
                            return () => {}
                            ;
                        throw v
                    }
                }
            }
            ;
            function _optionalChain$2(v) {
                let E, k = v[0], R = 1;
                for (; R < v.length; ) {
                    const U = v[R]
                      , H = v[R + 1];
                    if (R += 2,
                    ("optionalAccess" === U || "optionalCall" === U) && null == k)
                        return;
                    "access" === U || "optionalAccess" === U ? (E = k,
                    k = H(k)) : "call" !== U && "optionalCall" !== U || (k = H(( (...v) => k.call(E, ...v))),
                    E = void 0)
                }
                return k
            }
            const Co = [];
            function esm_getEventTarget(v) {
                try {
                    if ("composedPath"in v) {
                        const E = v.composedPath();
                        if (E.length)
                            return E[0]
                    } else if ("path"in v && v.path.length)
                        return v.path[0]
                } catch (v) {}
                return v && v.target
            }
            function initMutationObserver(v, E) {
                const k = new MutationBuffer;
                Co.push(k),
                k.init(v);
                let R = window.MutationObserver || window.__rrMutationObserver;
                const U = _optionalChain$2([window, "optionalAccess", v => v.Zone, "optionalAccess", v => v.__symbol__, "optionalCall", v => v("MutationObserver")]);
                U && window[U] && (R = window[U]);
                const H = new R(callbackWrapper((E => {
                    v.onMutation && !1 === v.onMutation(E) || k.processMutations.bind(k)(E)
                }
                )));
                return H.observe(E, {
                    "attributes": !0,
                    "attributeOldValue": !0,
                    "characterData": !0,
                    "characterDataOldValue": !0,
                    "childList": !0,
                    "subtree": !0
                }),
                H
            }
            function initMouseInteractionObserver({"mouseInteractionCb": v, "doc": E, "mirror": k, "blockClass": R, "blockSelector": U, "unblockSelector": H, "sampling": G}) {
                if (!1 === G.mouseInteraction)
                    return () => {}
                    ;
                const W = !0 === G.mouseInteraction || void 0 === G.mouseInteraction ? {} : G.mouseInteraction
                  , Z = [];
                let Y = null;
                return Object.keys(So).filter((v => Number.isNaN(Number(v)) && !v.endsWith("_Departed") && !1 !== W[v])).forEach((G => {
                    let W = toLowerCase(G);
                    const J = (E => G => {
                        const W = esm_getEventTarget(G);
                        if (isBlocked(W, R, U, H, !0))
                            return;
                        let Z = null
                          , J = E;
                        if ("pointerType"in G) {
                            switch (G.pointerType) {
                            case "mouse":
                                Z = wo.Mouse;
                                break;
                            case "touch":
                                Z = wo.Touch;
                                break;
                            case "pen":
                                Z = wo.Pen
                            }
                            Z === wo.Touch ? So[E] === So.MouseDown ? J = "TouchStart" : So[E] === So.MouseUp && (J = "TouchEnd") : wo.Pen
                        } else
                            legacy_isTouchEvent(G) && (Z = wo.Touch);
                        null !== Z ? (Y = Z,
                        (J.startsWith("Touch") && Z === wo.Touch || J.startsWith("Mouse") && Z === wo.Mouse) && (Z = null)) : So[E] === So.Click && (Z = Y,
                        Y = null);
                        const K = legacy_isTouchEvent(G) ? G.changedTouches[0] : G;
                        if (!K)
                            return;
                        const X = k.getId(W)
                          , {"clientX": Q, "clientY": ee} = K;
                        callbackWrapper(v)({
                            "type": So[J],
                            "id": X,
                            "x": Q,
                            "y": ee,
                            ...null !== Z && {
                                "pointerType": Z
                            }
                        })
                    }
                    )(G);
                    if (window.PointerEvent)
                        switch (So[G]) {
                        case So.MouseDown:
                        case So.MouseUp:
                            W = W.replace("mouse", "pointer");
                            break;
                        case So.TouchStart:
                        case So.TouchEnd:
                            return
                        }
                    Z.push(on(W, J, E))
                }
                )),
                callbackWrapper(( () => {
                    Z.forEach((v => v()))
                }
                ))
            }
            function initScrollObserver({"scrollCb": v, "doc": E, "mirror": k, "blockClass": R, "blockSelector": U, "unblockSelector": H, "sampling": G}) {
                return on("scroll", callbackWrapper(throttle$1(callbackWrapper((G => {
                    const W = esm_getEventTarget(G);
                    if (!W || isBlocked(W, R, U, H, !0))
                        return;
                    const Z = k.getId(W);
                    if (W === E && E.defaultView) {
                        const k = getWindowScroll(E.defaultView);
                        v({
                            "id": Z,
                            "x": k.left,
                            "y": k.top
                        })
                    } else
                        v({
                            "id": Z,
                            "x": W.scrollLeft,
                            "y": W.scrollTop
                        })
                }
                )), G.scroll || 100)), E)
            }
            const To = ["INPUT", "TEXTAREA", "SELECT"]
              , xo = new WeakMap;
            function initInputObserver({"inputCb": v, "doc": E, "mirror": k, "blockClass": R, "blockSelector": U, "unblockSelector": H, "ignoreClass": G, "ignoreSelector": W, "maskInputOptions": Z, "maskInputFn": Y, "sampling": J, "userTriggeredOnInput": K, "maskTextClass": X, "unmaskTextClass": Q, "maskTextSelector": ee, "unmaskTextSelector": te}) {
                function eventHandler(v) {
                    let k = esm_getEventTarget(v);
                    const J = v.isTrusted
                      , ne = k && toUpperCase(k.tagName);
                    if ("OPTION" === ne && (k = k.parentElement),
                    !k || !ne || To.indexOf(ne) < 0 || isBlocked(k, R, U, H, !0))
                        return;
                    const re = k;
                    if (re.classList.contains(G) || W && re.matches(W))
                        return;
                    const oe = getInputType(k);
                    let ie = getInputValue(re, ne, oe)
                      , ae = !1;
                    const se = shouldMaskInput({
                        "maskInputOptions": Z,
                        "tagName": ne,
                        "type": oe
                    })
                      , ce = needMaskingText(k, X, ee, Q, te, se);
                    "radio" !== oe && "checkbox" !== oe || (ae = k.checked),
                    ie = maskInputValue({
                        "isMasked": ce,
                        "element": k,
                        "value": ie,
                        "maskInputFn": Y
                    }),
                    cbWithDedup(k, K ? {
                        "text": ie,
                        "isChecked": ae,
                        "userTriggered": J
                    } : {
                        "text": ie,
                        "isChecked": ae
                    });
                    const le = k.name;
                    "radio" === oe && le && ae && E.querySelectorAll(`input[type="radio"][name="${le}"]`).forEach((v => {
                        if (v !== k) {
                            const E = maskInputValue({
                                "isMasked": ce,
                                "element": v,
                                "value": getInputValue(v, ne, oe),
                                "maskInputFn": Y
                            });
                            cbWithDedup(v, K ? {
                                "text": E,
                                "isChecked": !ae,
                                "userTriggered": !1
                            } : {
                                "text": E,
                                "isChecked": !ae
                            })
                        }
                    }
                    ))
                }
                function cbWithDedup(E, R) {
                    const U = xo.get(E);
                    if (!U || U.text !== R.text || U.isChecked !== R.isChecked) {
                        xo.set(E, R);
                        const U = k.getId(E);
                        callbackWrapper(v)({
                            ...R,
                            "id": U
                        })
                    }
                }
                const ne = ("last" === J.input ? ["change"] : ["input", "change"]).map((v => on(v, callbackWrapper(eventHandler), E)))
                  , re = E.defaultView;
                if (!re)
                    return () => {
                        ne.forEach((v => v()))
                    }
                    ;
                const oe = re.Object.getOwnPropertyDescriptor(re.HTMLInputElement.prototype, "value")
                  , ie = [[re.HTMLInputElement.prototype, "value"], [re.HTMLInputElement.prototype, "checked"], [re.HTMLSelectElement.prototype, "value"], [re.HTMLTextAreaElement.prototype, "value"], [re.HTMLSelectElement.prototype, "selectedIndex"], [re.HTMLOptionElement.prototype, "selected"]];
                return oe && oe.set && ne.push(...ie.map((v => hookSetter(v[0], v[1], {
                    "set"() {
                        callbackWrapper(eventHandler)({
                            "target": this,
                            "isTrusted": !1
                        })
                    }
                }, !1, re)))),
                callbackWrapper(( () => {
                    ne.forEach((v => v()))
                }
                ))
            }
            function getNestedCSSRulePositions(v) {
                return function recurse(v, E) {
                    if (hasNestedCSSRule("CSSGroupingRule") && v.parentRule instanceof CSSGroupingRule || hasNestedCSSRule("CSSMediaRule") && v.parentRule instanceof CSSMediaRule || hasNestedCSSRule("CSSSupportsRule") && v.parentRule instanceof CSSSupportsRule || hasNestedCSSRule("CSSConditionRule") && v.parentRule instanceof CSSConditionRule) {
                        const k = Array.from(v.parentRule.cssRules).indexOf(v);
                        E.unshift(k)
                    } else if (v.parentStyleSheet) {
                        const k = Array.from(v.parentStyleSheet.cssRules).indexOf(v);
                        E.unshift(k)
                    }
                    return E
                }(v, [])
            }
            function getIdAndStyleId(v, E, k) {
                let R, U;
                return v ? (v.ownerNode ? R = E.getId(v.ownerNode) : U = k.getId(v),
                {
                    "styleId": U,
                    "id": R
                }) : {}
            }
            function initAdoptedStyleSheetObserver({"mirror": v, "stylesheetManager": E}, k) {
                let R = null;
                R = "#document" === k.nodeName ? v.getId(k) : v.getId(k.host);
                const U = "#document" === k.nodeName ? _optionalChain$2([k, "access", v => v.defaultView, "optionalAccess", v => v.Document]) : _optionalChain$2([k, "access", v => v.ownerDocument, "optionalAccess", v => v.defaultView, "optionalAccess", v => v.ShadowRoot])
                  , H = _optionalChain$2([U, "optionalAccess", v => v.prototype]) ? Object.getOwnPropertyDescriptor(_optionalChain$2([U, "optionalAccess", v => v.prototype]), "adoptedStyleSheets") : void 0;
                return null !== R && -1 !== R && U && H ? (Object.defineProperty(k, "adoptedStyleSheets", {
                    "configurable": H.configurable,
                    "enumerable": H.enumerable,
                    "get"() {
                        return _optionalChain$2([H, "access", v => v.get, "optionalAccess", v => v.call, "call", v => v(this)])
                    },
                    "set"(v) {
                        const k = _optionalChain$2([H, "access", v => v.set, "optionalAccess", v => v.call, "call", E => E(this, v)]);
                        if (null !== R && -1 !== R)
                            try {
                                E.adoptStyleSheets(v, R)
                            } catch (v) {}
                        return k
                    }
                }),
                callbackWrapper(( () => {
                    Object.defineProperty(k, "adoptedStyleSheets", {
                        "configurable": H.configurable,
                        "enumerable": H.enumerable,
                        "get": H.get,
                        "set": H.set
                    })
                }
                ))) : () => {}
            }
            function initObservers(v, E={}) {
                const k = v.doc.defaultView;
                if (!k)
                    return () => {}
                    ;
                let R;
                v.recordDOM && (R = initMutationObserver(v, v.doc));
                const U = function initMoveObserver({"mousemoveCb": v, "sampling": E, "doc": k, "mirror": R}) {
                    if (!1 === E.mousemove)
                        return () => {}
                        ;
                    const U = "number" == typeof E.mousemove ? E.mousemove : 50
                      , H = "number" == typeof E.mousemoveCallback ? E.mousemoveCallback : 500;
                    let G, W = [];
                    const Z = throttle$1(callbackWrapper((E => {
                        const k = Date.now() - G;
                        v(W.map((v => (v.timeOffset -= k,
                        v))), E),
                        W = [],
                        G = null
                    }
                    )), H)
                      , Y = callbackWrapper(throttle$1(callbackWrapper((v => {
                        const E = esm_getEventTarget(v)
                          , {"clientX": k, "clientY": U} = legacy_isTouchEvent(v) ? v.changedTouches[0] : v;
                        G || (G = _o()),
                        W.push({
                            "x": k,
                            "y": U,
                            "id": R.getId(E),
                            "timeOffset": _o() - G
                        }),
                        Z("undefined" != typeof DragEvent && v instanceof DragEvent ? bo.Drag : v instanceof MouseEvent ? bo.MouseMove : bo.TouchMove)
                    }
                    )), U, {
                        "trailing": !1
                    }))
                      , J = [on("mousemove", Y, k), on("touchmove", Y, k), on("drag", Y, k)];
                    return callbackWrapper(( () => {
                        J.forEach((v => v()))
                    }
                    ))
                }(v)
                  , H = initMouseInteractionObserver(v)
                  , G = initScrollObserver(v)
                  , W = function initViewportResizeObserver({"viewportResizeCb": v}, {"win": E}) {
                    let k = -1
                      , R = -1;
                    return on("resize", callbackWrapper(throttle$1(callbackWrapper(( () => {
                        const E = getWindowHeight()
                          , U = getWindowWidth();
                        k === E && R === U || (v({
                            "width": Number(U),
                            "height": Number(E)
                        }),
                        k = E,
                        R = U)
                    }
                    )), 200)), E)
                }(v, {
                    "win": k
                })
                  , Z = initInputObserver(v)
                  , Y = function initMediaInteractionObserver({"mediaInteractionCb": v, "blockClass": E, "blockSelector": k, "unblockSelector": R, "mirror": U, "sampling": H, "doc": G}) {
                    const W = callbackWrapper((G => throttle$1(callbackWrapper((H => {
                        const W = esm_getEventTarget(H);
                        if (!W || isBlocked(W, E, k, R, !0))
                            return;
                        const {"currentTime": Z, "volume": Y, "muted": J, "playbackRate": K} = W;
                        v({
                            "type": G,
                            "id": U.getId(W),
                            "currentTime": Z,
                            "volume": Y,
                            "muted": J,
                            "playbackRate": K
                        })
                    }
                    )), H.media || 500)))
                      , Z = [on("play", W(0), G), on("pause", W(1), G), on("seeked", W(2), G), on("volumechange", W(3), G), on("ratechange", W(4), G)];
                    return callbackWrapper(( () => {
                        Z.forEach((v => v()))
                    }
                    ))
                }(v);
                let styleSheetObserver = () => {}
                  , adoptedStyleSheetObserver = () => {}
                  , styleDeclarationObserver = () => {}
                  , fontObserver = () => {}
                ;
                v.recordDOM && (styleSheetObserver = function initStyleSheetObserver({"styleSheetRuleCb": v, "mirror": E, "stylesheetManager": k}, {"win": R}) {
                    if (!R.CSSStyleSheet || !R.CSSStyleSheet.prototype)
                        return () => {}
                        ;
                    const U = R.CSSStyleSheet.prototype.insertRule;
                    R.CSSStyleSheet.prototype.insertRule = new Proxy(U,{
                        "apply": callbackWrapper(( (R, U, H) => {
                            const [G,W] = H
                              , {"id": Z, "styleId": Y} = getIdAndStyleId(U, E, k.styleMirror);
                            return (Z && -1 !== Z || Y && -1 !== Y) && v({
                                "id": Z,
                                "styleId": Y,
                                "adds": [{
                                    "rule": G,
                                    "index": W
                                }]
                            }),
                            R.apply(U, H)
                        }
                        ))
                    });
                    const H = R.CSSStyleSheet.prototype.deleteRule;
                    let G, W;
                    R.CSSStyleSheet.prototype.deleteRule = new Proxy(H,{
                        "apply": callbackWrapper(( (R, U, H) => {
                            const [G] = H
                              , {"id": W, "styleId": Z} = getIdAndStyleId(U, E, k.styleMirror);
                            return (W && -1 !== W || Z && -1 !== Z) && v({
                                "id": W,
                                "styleId": Z,
                                "removes": [{
                                    "index": G
                                }]
                            }),
                            R.apply(U, H)
                        }
                        ))
                    }),
                    R.CSSStyleSheet.prototype.replace && (G = R.CSSStyleSheet.prototype.replace,
                    R.CSSStyleSheet.prototype.replace = new Proxy(G,{
                        "apply": callbackWrapper(( (R, U, H) => {
                            const [G] = H
                              , {"id": W, "styleId": Z} = getIdAndStyleId(U, E, k.styleMirror);
                            return (W && -1 !== W || Z && -1 !== Z) && v({
                                "id": W,
                                "styleId": Z,
                                "replace": G
                            }),
                            R.apply(U, H)
                        }
                        ))
                    })),
                    R.CSSStyleSheet.prototype.replaceSync && (W = R.CSSStyleSheet.prototype.replaceSync,
                    R.CSSStyleSheet.prototype.replaceSync = new Proxy(W,{
                        "apply": callbackWrapper(( (R, U, H) => {
                            const [G] = H
                              , {"id": W, "styleId": Z} = getIdAndStyleId(U, E, k.styleMirror);
                            return (W && -1 !== W || Z && -1 !== Z) && v({
                                "id": W,
                                "styleId": Z,
                                "replaceSync": G
                            }),
                            R.apply(U, H)
                        }
                        ))
                    }));
                    const Z = {};
                    canMonkeyPatchNestedCSSRule("CSSGroupingRule") ? Z.CSSGroupingRule = R.CSSGroupingRule : (canMonkeyPatchNestedCSSRule("CSSMediaRule") && (Z.CSSMediaRule = R.CSSMediaRule),
                    canMonkeyPatchNestedCSSRule("CSSConditionRule") && (Z.CSSConditionRule = R.CSSConditionRule),
                    canMonkeyPatchNestedCSSRule("CSSSupportsRule") && (Z.CSSSupportsRule = R.CSSSupportsRule));
                    const Y = {};
                    return Object.entries(Z).forEach(( ([R,U]) => {
                        Y[R] = {
                            "insertRule": U.prototype.insertRule,
                            "deleteRule": U.prototype.deleteRule
                        },
                        U.prototype.insertRule = new Proxy(Y[R].insertRule,{
                            "apply": callbackWrapper(( (R, U, H) => {
                                const [G,W] = H
                                  , {"id": Z, "styleId": Y} = getIdAndStyleId(U.parentStyleSheet, E, k.styleMirror);
                                return (Z && -1 !== Z || Y && -1 !== Y) && v({
                                    "id": Z,
                                    "styleId": Y,
                                    "adds": [{
                                        "rule": G,
                                        "index": [...getNestedCSSRulePositions(U), W || 0]
                                    }]
                                }),
                                R.apply(U, H)
                            }
                            ))
                        }),
                        U.prototype.deleteRule = new Proxy(Y[R].deleteRule,{
                            "apply": callbackWrapper(( (R, U, H) => {
                                const [G] = H
                                  , {"id": W, "styleId": Z} = getIdAndStyleId(U.parentStyleSheet, E, k.styleMirror);
                                return (W && -1 !== W || Z && -1 !== Z) && v({
                                    "id": W,
                                    "styleId": Z,
                                    "removes": [{
                                        "index": [...getNestedCSSRulePositions(U), G]
                                    }]
                                }),
                                R.apply(U, H)
                            }
                            ))
                        })
                    }
                    )),
                    callbackWrapper(( () => {
                        R.CSSStyleSheet.prototype.insertRule = U,
                        R.CSSStyleSheet.prototype.deleteRule = H,
                        G && (R.CSSStyleSheet.prototype.replace = G),
                        W && (R.CSSStyleSheet.prototype.replaceSync = W),
                        Object.entries(Z).forEach(( ([v,E]) => {
                            E.prototype.insertRule = Y[v].insertRule,
                            E.prototype.deleteRule = Y[v].deleteRule
                        }
                        ))
                    }
                    ))
                }(v, {
                    "win": k
                }),
                adoptedStyleSheetObserver = initAdoptedStyleSheetObserver(v, v.doc),
                styleDeclarationObserver = function initStyleDeclarationObserver({"styleDeclarationCb": v, "mirror": E, "ignoreCSSAttributes": k, "stylesheetManager": R}, {"win": U}) {
                    const H = U.CSSStyleDeclaration.prototype.setProperty;
                    U.CSSStyleDeclaration.prototype.setProperty = new Proxy(H,{
                        "apply": callbackWrapper(( (U, G, W) => {
                            const [Z,Y,J] = W;
                            if (k.has(Z))
                                return H.apply(G, [Z, Y, J]);
                            const {"id": K, "styleId": X} = getIdAndStyleId(_optionalChain$2([G, "access", v => v.parentRule, "optionalAccess", v => v.parentStyleSheet]), E, R.styleMirror);
                            return (K && -1 !== K || X && -1 !== X) && v({
                                "id": K,
                                "styleId": X,
                                "set": {
                                    "property": Z,
                                    "value": Y,
                                    "priority": J
                                },
                                "index": getNestedCSSRulePositions(G.parentRule)
                            }),
                            U.apply(G, W)
                        }
                        ))
                    });
                    const G = U.CSSStyleDeclaration.prototype.removeProperty;
                    return U.CSSStyleDeclaration.prototype.removeProperty = new Proxy(G,{
                        "apply": callbackWrapper(( (U, H, W) => {
                            const [Z] = W;
                            if (k.has(Z))
                                return G.apply(H, [Z]);
                            const {"id": Y, "styleId": J} = getIdAndStyleId(_optionalChain$2([H, "access", v => v.parentRule, "optionalAccess", v => v.parentStyleSheet]), E, R.styleMirror);
                            return (Y && -1 !== Y || J && -1 !== J) && v({
                                "id": Y,
                                "styleId": J,
                                "remove": {
                                    "property": Z
                                },
                                "index": getNestedCSSRulePositions(H.parentRule)
                            }),
                            U.apply(H, W)
                        }
                        ))
                    }),
                    callbackWrapper(( () => {
                        U.CSSStyleDeclaration.prototype.setProperty = H,
                        U.CSSStyleDeclaration.prototype.removeProperty = G
                    }
                    ))
                }(v, {
                    "win": k
                }),
                v.collectFonts && (fontObserver = function initFontObserver({"fontCb": v, "doc": E}) {
                    const k = E.defaultView;
                    if (!k)
                        return () => {}
                        ;
                    const R = []
                      , U = new WeakMap
                      , H = k.FontFace;
                    k.FontFace = function FontFace(v, E, k) {
                        const R = new H(v,E,k);
                        return U.set(R, {
                            "family": v,
                            "buffer": "string" != typeof E,
                            "descriptors": k,
                            "fontSource": "string" == typeof E ? E : JSON.stringify(Array.from(new Uint8Array(E)))
                        }),
                        R
                    }
                    ;
                    const G = patch(E.fonts, "add", (function(E) {
                        return function(k) {
                            return setTimeout$1(callbackWrapper(( () => {
                                const E = U.get(k);
                                E && (v(E),
                                U.delete(k))
                            }
                            )), 0),
                            E.apply(this, [k])
                        }
                    }
                    ));
                    return R.push(( () => {
                        k.FontFace = H
                    }
                    )),
                    R.push(G),
                    callbackWrapper(( () => {
                        R.forEach((v => v()))
                    }
                    ))
                }(v)));
                const J = function initSelectionObserver(v) {
                    const {"doc": E, "mirror": k, "blockClass": R, "blockSelector": U, "unblockSelector": H, "selectionCb": G} = v;
                    let W = !0;
                    const Z = callbackWrapper(( () => {
                        const v = E.getSelection();
                        if (!v || W && _optionalChain$2([v, "optionalAccess", v => v.isCollapsed]))
                            return;
                        W = v.isCollapsed || !1;
                        const Z = []
                          , Y = v.rangeCount || 0;
                        for (let E = 0; E < Y; E++) {
                            const G = v.getRangeAt(E)
                              , {"startContainer": W, "startOffset": Y, "endContainer": J, "endOffset": K} = G;
                            isBlocked(W, R, U, H, !0) || isBlocked(J, R, U, H, !0) || Z.push({
                                "start": k.getId(W),
                                "startOffset": Y,
                                "end": k.getId(J),
                                "endOffset": K
                            })
                        }
                        G({
                            "ranges": Z
                        })
                    }
                    ));
                    return Z(),
                    on("selectionchange", Z)
                }(v)
                  , K = function initCustomElementObserver({"doc": v, "customElementCb": E}) {
                    const k = v.defaultView;
                    return k && k.customElements ? patch(k.customElements, "define", (function(v) {
                        return function(k, R, U) {
                            try {
                                E({
                                    "define": {
                                        "name": k
                                    }
                                })
                            } catch (v) {}
                            return v.apply(this, [k, R, U])
                        }
                    }
                    )) : () => {}
                }(v)
                  , X = [];
                for (const E of v.plugins)
                    X.push(E.observer(E.callback, k, E.options));
                return callbackWrapper(( () => {
                    Co.forEach((v => v.reset())),
                    _optionalChain$2([R, "optionalAccess", v => v.disconnect, "call", v => v()]),
                    U(),
                    H(),
                    G(),
                    W(),
                    Z(),
                    Y(),
                    styleSheetObserver(),
                    adoptedStyleSheetObserver(),
                    styleDeclarationObserver(),
                    fontObserver(),
                    J(),
                    K(),
                    X.forEach((v => v()))
                }
                ))
            }
            function hasNestedCSSRule(v) {
                return void 0 !== window[v]
            }
            function canMonkeyPatchNestedCSSRule(v) {
                return Boolean(void 0 !== window[v] && window[v].prototype && "insertRule"in window[v].prototype && "deleteRule"in window[v].prototype)
            }
            class CrossOriginIframeMirror {
                "constructor"(v) {
                    this.generateIdFn = v,
                    this.iframeIdToRemoteIdMap = new WeakMap,
                    this.iframeRemoteIdToIdMap = new WeakMap
                }
                "getId"(v, E, k, R) {
                    const U = k || this.getIdToRemoteIdMap(v)
                      , H = R || this.getRemoteIdToIdMap(v);
                    let G = U.get(E);
                    return G || (G = this.generateIdFn(),
                    U.set(E, G),
                    H.set(G, E)),
                    G
                }
                "getIds"(v, E) {
                    const k = this.getIdToRemoteIdMap(v)
                      , R = this.getRemoteIdToIdMap(v);
                    return E.map((E => this.getId(v, E, k, R)))
                }
                "getRemoteId"(v, E, k) {
                    const R = k || this.getRemoteIdToIdMap(v);
                    if ("number" != typeof E)
                        return E;
                    const U = R.get(E);
                    return U || -1
                }
                "getRemoteIds"(v, E) {
                    const k = this.getRemoteIdToIdMap(v);
                    return E.map((E => this.getRemoteId(v, E, k)))
                }
                "reset"(v) {
                    if (!v)
                        return this.iframeIdToRemoteIdMap = new WeakMap,
                        void (this.iframeRemoteIdToIdMap = new WeakMap);
                    this.iframeIdToRemoteIdMap.delete(v),
                    this.iframeRemoteIdToIdMap.delete(v)
                }
                "getIdToRemoteIdMap"(v) {
                    let E = this.iframeIdToRemoteIdMap.get(v);
                    return E || (E = new Map,
                    this.iframeIdToRemoteIdMap.set(v, E)),
                    E
                }
                "getRemoteIdToIdMap"(v) {
                    let E = this.iframeRemoteIdToIdMap.get(v);
                    return E || (E = new Map,
                    this.iframeRemoteIdToIdMap.set(v, E)),
                    E
                }
            }
            function _optionalChain$1(v) {
                let E, k = v[0], R = 1;
                for (; R < v.length; ) {
                    const U = v[R]
                      , H = v[R + 1];
                    if (R += 2,
                    ("optionalAccess" === U || "optionalCall" === U) && null == k)
                        return;
                    "access" === U || "optionalAccess" === U ? (E = k,
                    k = H(k)) : "call" !== U && "optionalCall" !== U || (k = H(( (...v) => k.call(E, ...v))),
                    E = void 0)
                }
                return k
            }
            class IframeManagerNoop {
                "constructor"() {
                    this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId),
                    this.crossOriginIframeRootIdMap = new WeakMap
                }
                "addIframe"() {}
                "addLoadListener"() {}
                "attachIframe"() {}
            }
            class IframeManager {
                "constructor"(v) {
                    this.iframes = new WeakMap,
                    this.crossOriginIframeMap = new WeakMap,
                    this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId),
                    this.crossOriginIframeRootIdMap = new WeakMap,
                    this.mutationCb = v.mutationCb,
                    this.wrappedEmit = v.wrappedEmit,
                    this.stylesheetManager = v.stylesheetManager,
                    this.recordCrossOriginIframes = v.recordCrossOriginIframes,
                    this.crossOriginIframeStyleMirror = new CrossOriginIframeMirror(this.stylesheetManager.styleMirror.generateId.bind(this.stylesheetManager.styleMirror)),
                    this.mirror = v.mirror,
                    this.recordCrossOriginIframes && window.addEventListener("message", this.handleMessage.bind(this))
                }
                "addIframe"(v) {
                    this.iframes.set(v, !0),
                    v.contentWindow && this.crossOriginIframeMap.set(v.contentWindow, v)
                }
                "addLoadListener"(v) {
                    this.loadListener = v
                }
                "attachIframe"(v, E) {
                    this.mutationCb({
                        "adds": [{
                            "parentId": this.mirror.getId(v),
                            "nextId": null,
                            "node": E
                        }],
                        "removes": [],
                        "texts": [],
                        "attributes": [],
                        "isAttachIframe": !0
                    }),
                    _optionalChain$1([this, "access", v => v.loadListener, "optionalCall", E => E(v)]),
                    v.contentDocument && v.contentDocument.adoptedStyleSheets && v.contentDocument.adoptedStyleSheets.length > 0 && this.stylesheetManager.adoptStyleSheets(v.contentDocument.adoptedStyleSheets, this.mirror.getId(v.contentDocument))
                }
                "handleMessage"(v) {
                    const E = v;
                    if ("rrweb" !== E.data.type || E.origin !== E.data.origin)
                        return;
                    if (!v.source)
                        return;
                    const k = this.crossOriginIframeMap.get(v.source);
                    if (!k)
                        return;
                    const R = this.transformCrossOriginEvent(k, E.data.event);
                    R && this.wrappedEmit(R, E.data.isCheckout)
                }
                "transformCrossOriginEvent"(v, E) {
                    switch (E.type) {
                    case yo.FullSnapshot:
                        {
                            this.crossOriginIframeMirror.reset(v),
                            this.crossOriginIframeStyleMirror.reset(v),
                            this.replaceIdOnNode(E.data.node, v);
                            const k = E.data.node.id;
                            return this.crossOriginIframeRootIdMap.set(v, k),
                            this.patchRootIdOnNode(E.data.node, k),
                            {
                                "timestamp": E.timestamp,
                                "type": yo.IncrementalSnapshot,
                                "data": {
                                    "source": bo.Mutation,
                                    "adds": [{
                                        "parentId": this.mirror.getId(v),
                                        "nextId": null,
                                        "node": E.data.node
                                    }],
                                    "removes": [],
                                    "texts": [],
                                    "attributes": [],
                                    "isAttachIframe": !0
                                }
                            }
                        }
                    case yo.Meta:
                    case yo.Load:
                    case yo.DomContentLoaded:
                        return !1;
                    case yo.Plugin:
                        return E;
                    case yo.Custom:
                        return this.replaceIds(E.data.payload, v, ["id", "parentId", "previousId", "nextId"]),
                        E;
                    case yo.IncrementalSnapshot:
                        switch (E.data.source) {
                        case bo.Mutation:
                            return E.data.adds.forEach((E => {
                                this.replaceIds(E, v, ["parentId", "nextId", "previousId"]),
                                this.replaceIdOnNode(E.node, v);
                                const k = this.crossOriginIframeRootIdMap.get(v);
                                k && this.patchRootIdOnNode(E.node, k)
                            }
                            )),
                            E.data.removes.forEach((E => {
                                this.replaceIds(E, v, ["parentId", "id"])
                            }
                            )),
                            E.data.attributes.forEach((E => {
                                this.replaceIds(E, v, ["id"])
                            }
                            )),
                            E.data.texts.forEach((E => {
                                this.replaceIds(E, v, ["id"])
                            }
                            )),
                            E;
                        case bo.Drag:
                        case bo.TouchMove:
                        case bo.MouseMove:
                            return E.data.positions.forEach((E => {
                                this.replaceIds(E, v, ["id"])
                            }
                            )),
                            E;
                        case bo.ViewportResize:
                            return !1;
                        case bo.MediaInteraction:
                        case bo.MouseInteraction:
                        case bo.Scroll:
                        case bo.CanvasMutation:
                        case bo.Input:
                            return this.replaceIds(E.data, v, ["id"]),
                            E;
                        case bo.StyleSheetRule:
                        case bo.StyleDeclaration:
                            return this.replaceIds(E.data, v, ["id"]),
                            this.replaceStyleIds(E.data, v, ["styleId"]),
                            E;
                        case bo.Font:
                            return E;
                        case bo.Selection:
                            return E.data.ranges.forEach((E => {
                                this.replaceIds(E, v, ["start", "end"])
                            }
                            )),
                            E;
                        case bo.AdoptedStyleSheet:
                            return this.replaceIds(E.data, v, ["id"]),
                            this.replaceStyleIds(E.data, v, ["styleIds"]),
                            _optionalChain$1([E, "access", v => v.data, "access", v => v.styles, "optionalAccess", v => v.forEach, "call", E => E((E => {
                                this.replaceStyleIds(E, v, ["styleId"])
                            }
                            ))]),
                            E
                        }
                    }
                    return !1
                }
                "replace"(v, E, k, R) {
                    for (const U of R)
                        (Array.isArray(E[U]) || "number" == typeof E[U]) && (Array.isArray(E[U]) ? E[U] = v.getIds(k, E[U]) : E[U] = v.getId(k, E[U]));
                    return E
                }
                "replaceIds"(v, E, k) {
                    return this.replace(this.crossOriginIframeMirror, v, E, k)
                }
                "replaceStyleIds"(v, E, k) {
                    return this.replace(this.crossOriginIframeStyleMirror, v, E, k)
                }
                "replaceIdOnNode"(v, E) {
                    this.replaceIds(v, E, ["id", "rootId"]),
                    "childNodes"in v && v.childNodes.forEach((v => {
                        this.replaceIdOnNode(v, E)
                    }
                    ))
                }
                "patchRootIdOnNode"(v, E) {
                    v.type === Qr.Document || v.rootId || (v.rootId = E),
                    "childNodes"in v && v.childNodes.forEach((v => {
                        this.patchRootIdOnNode(v, E)
                    }
                    ))
                }
            }
            class ShadowDomManagerNoop {
                "init"() {}
                "addShadowRoot"() {}
                "observeAttachShadow"() {}
                "reset"() {}
            }
            class ShadowDomManager {
                "constructor"(v) {
                    this.shadowDoms = new WeakSet,
                    this.restoreHandlers = [],
                    this.mutationCb = v.mutationCb,
                    this.scrollCb = v.scrollCb,
                    this.bypassOptions = v.bypassOptions,
                    this.mirror = v.mirror,
                    this.init()
                }
                "init"() {
                    this.reset(),
                    this.patchAttachShadow(Element, document)
                }
                "addShadowRoot"(v, E) {
                    if (!isNativeShadowDom(v))
                        return;
                    if (this.shadowDoms.has(v))
                        return;
                    this.shadowDoms.add(v),
                    this.bypassOptions.canvasManager.addShadowRoot(v);
                    const k = initMutationObserver({
                        ...this.bypassOptions,
                        "doc": E,
                        "mutationCb": this.mutationCb,
                        "mirror": this.mirror,
                        "shadowDomManager": this
                    }, v);
                    this.restoreHandlers.push(( () => k.disconnect())),
                    this.restoreHandlers.push(initScrollObserver({
                        ...this.bypassOptions,
                        "scrollCb": this.scrollCb,
                        "doc": v,
                        "mirror": this.mirror
                    })),
                    setTimeout$1(( () => {
                        v.adoptedStyleSheets && v.adoptedStyleSheets.length > 0 && this.bypassOptions.stylesheetManager.adoptStyleSheets(v.adoptedStyleSheets, this.mirror.getId(v.host)),
                        this.restoreHandlers.push(initAdoptedStyleSheetObserver({
                            "mirror": this.mirror,
                            "stylesheetManager": this.bypassOptions.stylesheetManager
                        }, v))
                    }
                    ), 0)
                }
                "observeAttachShadow"(v) {
                    v.contentWindow && v.contentDocument && this.patchAttachShadow(v.contentWindow.Element, v.contentDocument)
                }
                "patchAttachShadow"(v, E) {
                    const k = this;
                    this.restoreHandlers.push(patch(v.prototype, "attachShadow", (function(v) {
                        return function(R) {
                            const U = v.call(this, R);
                            return this.shadowRoot && inDom(this) && k.addShadowRoot(this.shadowRoot, E),
                            U
                        }
                    }
                    )))
                }
                "reset"() {
                    this.restoreHandlers.forEach((v => {
                        try {
                            v()
                        } catch (v) {}
                    }
                    )),
                    this.restoreHandlers = [],
                    this.shadowDoms = new WeakSet,
                    this.bypassOptions.canvasManager.resetShadowRoots()
                }
            }
            class CanvasManagerNoop {
                "reset"() {}
                "freeze"() {}
                "unfreeze"() {}
                "lock"() {}
                "unlock"() {}
                "snapshot"() {}
                "addWindow"() {}
                "addShadowRoot"() {}
                "resetShadowRoots"() {}
            }
            class StylesheetManager {
                "constructor"(v) {
                    this.trackedLinkElements = new WeakSet,
                    this.styleMirror = new StyleSheetMirror,
                    this.mutationCb = v.mutationCb,
                    this.adoptedStyleSheetCb = v.adoptedStyleSheetCb
                }
                "attachLinkElement"(v, E) {
                    "_cssText"in E.attributes && this.mutationCb({
                        "adds": [],
                        "removes": [],
                        "texts": [],
                        "attributes": [{
                            "id": E.id,
                            "attributes": E.attributes
                        }]
                    }),
                    this.trackLinkElement(v)
                }
                "trackLinkElement"(v) {
                    this.trackedLinkElements.has(v) || (this.trackedLinkElements.add(v),
                    this.trackStylesheetInLinkElement(v))
                }
                "adoptStyleSheets"(v, E) {
                    if (0 === v.length)
                        return;
                    const k = {
                        "id": E,
                        "styleIds": []
                    }
                      , R = [];
                    for (const E of v) {
                        let v;
                        this.styleMirror.has(E) ? v = this.styleMirror.getId(E) : (v = this.styleMirror.add(E),
                        R.push({
                            "styleId": v,
                            "rules": Array.from(E.rules || CSSRule, ( (v, E) => ({
                                "rule": stringifyRule(v),
                                "index": E
                            })))
                        })),
                        k.styleIds.push(v)
                    }
                    R.length > 0 && (k.styles = R),
                    this.adoptedStyleSheetCb(k)
                }
                "reset"() {
                    this.styleMirror.reset(),
                    this.trackedLinkElements = new WeakSet
                }
                "trackStylesheetInLinkElement"(v) {}
            }
            class ProcessedNodeManager {
                "constructor"() {
                    this.nodeMap = new WeakMap,
                    this.loop = !0,
                    this.periodicallyClear()
                }
                "periodicallyClear"() {
                    !function onRequestAnimationFrame(...v) {
                        return getImplementation("requestAnimationFrame")(...v)
                    }(( () => {
                        this.clear(),
                        this.loop && this.periodicallyClear()
                    }
                    ))
                }
                "inOtherBuffer"(v, E) {
                    const k = this.nodeMap.get(v);
                    return k && Array.from(k).some((v => v !== E))
                }
                "add"(v, E) {
                    this.nodeMap.set(v, (this.nodeMap.get(v) || new Set).add(E))
                }
                "clear"() {
                    this.nodeMap = new WeakMap
                }
                "destroy"() {
                    this.loop = !1
                }
            }
            let Ao, Io;
            try {
                if (2 !== Array.from([1], (v => 2 * v))[0]) {
                    const v = document.createElement("iframe");
                    document.body.appendChild(v),
                    Array.from = _optionalChain([v, "access", v => v.contentWindow, "optionalAccess", v => v.Array, "access", v => v.from]) || Array.from,
                    document.body.removeChild(v)
                }
            } catch (v) {
                console.debug("Unable to override Array.from", v)
            }
            const ko = function createMirror() {
                return new Mirror
            }();
            function record(v={}) {
                const {"emit": E, "checkoutEveryNms": k, "checkoutEveryNth": R, "blockClass": U="rr-block", "blockSelector": H=null, "unblockSelector": G=null, "ignoreClass": W="rr-ignore", "ignoreSelector": Z=null, "maskAllText": Y=!1, "maskTextClass": J="rr-mask", "unmaskTextClass": K=null, "maskTextSelector": X=null, "unmaskTextSelector": Q=null, "inlineStylesheet": ee=!0, "maskAllInputs": te, "maskInputOptions": ne, "slimDOMOptions": re, "maskAttributeFn": oe, "maskInputFn": ie, "maskTextFn": ae, "maxCanvasSize": se=null, "packFn": ce, "sampling": le={}, "dataURLOptions": ue={}, "mousemoveWait": de, "recordDOM": pe=!0, "recordCanvas": fe=!1, "recordCrossOriginIframes": he=!1, "recordAfter": me=("DOMContentLoaded" === v.recordAfter ? v.recordAfter : "load"), "userTriggeredOnInput": ge=!1, "collectFonts": _e=!1, "inlineImages": ve=!1, "plugins": ye, "keepIframeSrcFn": be=( () => !1), "ignoreCSSAttributes": Se=new Set([]), "errorHandler": we, "onMutation": Ee, "getCanvasManager": Ce} = v;
                registerErrorHandler(we);
                const Te = !he || window.parent === window;
                let xe = !1;
                if (!Te)
                    try {
                        window.parent.document && (xe = !1)
                    } catch (v) {
                        xe = !0
                    }
                if (Te && !E)
                    throw new Error("emit function is required");
                void 0 !== de && void 0 === le.mousemove && (le.mousemove = de),
                ko.reset();
                const Ae = !0 === te ? {
                    "color": !0,
                    "date": !0,
                    "datetime-local": !0,
                    "email": !0,
                    "month": !0,
                    "number": !0,
                    "range": !0,
                    "search": !0,
                    "tel": !0,
                    "text": !0,
                    "time": !0,
                    "url": !0,
                    "week": !0,
                    "textarea": !0,
                    "select": !0,
                    "radio": !0,
                    "checkbox": !0
                } : void 0 !== ne ? ne : {}
                  , Ie = !0 === re || "all" === re ? {
                    "script": !0,
                    "comment": !0,
                    "headFavicon": !0,
                    "headWhitespace": !0,
                    "headMetaSocial": !0,
                    "headMetaRobots": !0,
                    "headMetaHttpEquiv": !0,
                    "headMetaVerification": !0,
                    "headMetaAuthorship": "all" === re,
                    "headMetaDescKeywords": "all" === re
                } : re || {};
                let ke;
                !function polyfill(v=window) {
                    "NodeList"in v && !v.NodeList.prototype.forEach && (v.NodeList.prototype.forEach = Array.prototype.forEach),
                    "DOMTokenList"in v && !v.DOMTokenList.prototype.forEach && (v.DOMTokenList.prototype.forEach = Array.prototype.forEach),
                    Node.prototype.contains || (Node.prototype.contains = (...v) => {
                        let E = v[0];
                        if (!(0 in v))
                            throw new TypeError("1 argument is required");
                        do {
                            if (this === E)
                                return !0
                        } while (E = E && E.parentNode);
                        return !1
                    }
                    )
                }();
                let Oe = 0;
                const eventProcessor = v => {
                    for (const E of ye || [])
                        E.eventProcessor && (v = E.eventProcessor(v));
                    return ce && !xe && (v = ce(v)),
                    v
                }
                ;
                Ao = (v, U) => {
                    const H = v;
                    if (H.timestamp = _o(),
                    !_optionalChain([Co, "access", v => v[0], "optionalAccess", v => v.isFrozen, "call", v => v()]) || H.type === yo.FullSnapshot || H.type === yo.IncrementalSnapshot && H.data.source === bo.Mutation || Co.forEach((v => v.unfreeze())),
                    Te)
                        _optionalChain([E, "optionalCall", v => v(eventProcessor(H), U)]);
                    else if (xe) {
                        const v = {
                            "type": "rrweb",
                            "event": eventProcessor(H),
                            "origin": window.location.origin,
                            "isCheckout": U
                        };
                        window.parent.postMessage(v, "*")
                    }
                    if (H.type === yo.FullSnapshot)
                        ke = H,
                        Oe = 0;
                    else if (H.type === yo.IncrementalSnapshot) {
                        if (H.data.source === bo.Mutation && H.data.isAttachIframe)
                            return;
                        Oe++;
                        const v = R && Oe >= R
                          , E = k && ke && H.timestamp - ke.timestamp > k;
                        (v || E) && takeFullSnapshot(!0)
                    }
                }
                ;
                const wrappedMutationEmit = v => {
                    Ao({
                        "type": yo.IncrementalSnapshot,
                        "data": {
                            "source": bo.Mutation,
                            ...v
                        }
                    })
                }
                  , wrappedScrollEmit = v => Ao({
                    "type": yo.IncrementalSnapshot,
                    "data": {
                        "source": bo.Scroll,
                        ...v
                    }
                })
                  , wrappedCanvasMutationEmit = v => Ao({
                    "type": yo.IncrementalSnapshot,
                    "data": {
                        "source": bo.CanvasMutation,
                        ...v
                    }
                })
                  , Pe = new StylesheetManager({
                    "mutationCb": wrappedMutationEmit,
                    "adoptedStyleSheetCb": v => Ao({
                        "type": yo.IncrementalSnapshot,
                        "data": {
                            "source": bo.AdoptedStyleSheet,
                            ...v
                        }
                    })
                })
                  , Re = "boolean" == typeof __RRWEB_EXCLUDE_IFRAME__ && __RRWEB_EXCLUDE_IFRAME__ ? new IframeManagerNoop : new IframeManager({
                    "mirror": ko,
                    "mutationCb": wrappedMutationEmit,
                    "stylesheetManager": Pe,
                    "recordCrossOriginIframes": he,
                    "wrappedEmit": Ao
                });
                for (const v of ye || [])
                    v.getMirror && v.getMirror({
                        "nodeMirror": ko,
                        "crossOriginIframeMirror": Re.crossOriginIframeMirror,
                        "crossOriginIframeStyleMirror": Re.crossOriginIframeStyleMirror
                    });
                const Me = new ProcessedNodeManager
                  , Ne = function _getCanvasManager(v, E) {
                    try {
                        return v ? v(E) : new CanvasManagerNoop
                    } catch (v) {
                        return console.warn("Unable to initialize CanvasManager"),
                        new CanvasManagerNoop
                    }
                }(Ce, {
                    "mirror": ko,
                    "win": window,
                    "mutationCb": v => Ao({
                        "type": yo.IncrementalSnapshot,
                        "data": {
                            "source": bo.CanvasMutation,
                            ...v
                        }
                    }),
                    "recordCanvas": fe,
                    "blockClass": U,
                    "blockSelector": H,
                    "unblockSelector": G,
                    "maxCanvasSize": se,
                    "sampling": le.canvas,
                    "dataURLOptions": ue,
                    "errorHandler": we
                })
                  , De = "boolean" == typeof __RRWEB_EXCLUDE_SHADOW_DOM__ && __RRWEB_EXCLUDE_SHADOW_DOM__ ? new ShadowDomManagerNoop : new ShadowDomManager({
                    "mutationCb": wrappedMutationEmit,
                    "scrollCb": wrappedScrollEmit,
                    "bypassOptions": {
                        "onMutation": Ee,
                        "blockClass": U,
                        "blockSelector": H,
                        "unblockSelector": G,
                        "maskAllText": Y,
                        "maskTextClass": J,
                        "unmaskTextClass": K,
                        "maskTextSelector": X,
                        "unmaskTextSelector": Q,
                        "inlineStylesheet": ee,
                        "maskInputOptions": Ae,
                        "dataURLOptions": ue,
                        "maskAttributeFn": oe,
                        "maskTextFn": ae,
                        "maskInputFn": ie,
                        "recordCanvas": fe,
                        "inlineImages": ve,
                        "sampling": le,
                        "slimDOMOptions": Ie,
                        "iframeManager": Re,
                        "stylesheetManager": Pe,
                        "canvasManager": Ne,
                        "keepIframeSrcFn": be,
                        "processedNodeManager": Me
                    },
                    "mirror": ko
                })
                  , takeFullSnapshot = (v=!1) => {
                    if (!pe)
                        return;
                    Ao({
                        "type": yo.Meta,
                        "data": {
                            "href": window.location.href,
                            "width": getWindowWidth(),
                            "height": getWindowHeight()
                        }
                    }, v),
                    Pe.reset(),
                    De.init(),
                    Co.forEach((v => v.lock()));
                    const E = function snapshot(v, E) {
                        const {"mirror": k=new Mirror, "blockClass": R="rr-block", "blockSelector": U=null, "unblockSelector": H=null, "maskAllText": G=!1, "maskTextClass": W="rr-mask", "unmaskTextClass": Z=null, "maskTextSelector": Y=null, "unmaskTextSelector": J=null, "inlineStylesheet": K=!0, "inlineImages": X=!1, "recordCanvas": Q=!1, "maskAllInputs": ee=!1, "maskAttributeFn": te, "maskTextFn": ne, "maskInputFn": re, "slimDOM": oe=!1, "dataURLOptions": ie, "preserveWhiteSpace": ae, "onSerialize": se, "onIframeLoad": ce, "iframeLoadTimeout": le, "onStylesheetLoad": ue, "stylesheetLoadTimeout": de, "keepIframeSrcFn": pe=( () => !1)} = E || {};
                        return serializeNodeWithId(v, {
                            "doc": v,
                            "mirror": k,
                            "blockClass": R,
                            "blockSelector": U,
                            "unblockSelector": H,
                            "maskAllText": G,
                            "maskTextClass": W,
                            "unmaskTextClass": Z,
                            "maskTextSelector": Y,
                            "unmaskTextSelector": J,
                            "skipChild": !1,
                            "inlineStylesheet": K,
                            "maskInputOptions": !0 === ee ? {
                                "color": !0,
                                "date": !0,
                                "datetime-local": !0,
                                "email": !0,
                                "month": !0,
                                "number": !0,
                                "range": !0,
                                "search": !0,
                                "tel": !0,
                                "text": !0,
                                "time": !0,
                                "url": !0,
                                "week": !0,
                                "textarea": !0,
                                "select": !0
                            } : !1 === ee ? {} : ee,
                            "maskAttributeFn": te,
                            "maskTextFn": ne,
                            "maskInputFn": re,
                            "slimDOMOptions": !0 === oe || "all" === oe ? {
                                "script": !0,
                                "comment": !0,
                                "headFavicon": !0,
                                "headWhitespace": !0,
                                "headMetaDescKeywords": "all" === oe,
                                "headMetaSocial": !0,
                                "headMetaRobots": !0,
                                "headMetaHttpEquiv": !0,
                                "headMetaAuthorship": !0,
                                "headMetaVerification": !0
                            } : !1 === oe ? {} : oe,
                            "dataURLOptions": ie,
                            "inlineImages": X,
                            "recordCanvas": Q,
                            "preserveWhiteSpace": ae,
                            "onSerialize": se,
                            "onIframeLoad": ce,
                            "iframeLoadTimeout": le,
                            "onStylesheetLoad": ue,
                            "stylesheetLoadTimeout": de,
                            "keepIframeSrcFn": pe,
                            "newlyAddedElement": !1
                        })
                    }(document, {
                        "mirror": ko,
                        "blockClass": U,
                        "blockSelector": H,
                        "unblockSelector": G,
                        "maskAllText": Y,
                        "maskTextClass": J,
                        "unmaskTextClass": K,
                        "maskTextSelector": X,
                        "unmaskTextSelector": Q,
                        "inlineStylesheet": ee,
                        "maskAllInputs": Ae,
                        "maskAttributeFn": oe,
                        "maskInputFn": ie,
                        "maskTextFn": ae,
                        "slimDOM": Ie,
                        "dataURLOptions": ue,
                        "recordCanvas": fe,
                        "inlineImages": ve,
                        "onSerialize": v => {
                            isSerializedIframe(v, ko) && Re.addIframe(v),
                            isSerializedStylesheet(v, ko) && Pe.trackLinkElement(v),
                            hasShadowRoot(v) && De.addShadowRoot(v.shadowRoot, document)
                        }
                        ,
                        "onIframeLoad": (v, E) => {
                            Re.attachIframe(v, E),
                            v.contentWindow && Ne.addWindow(v.contentWindow),
                            De.observeAttachShadow(v)
                        }
                        ,
                        "onStylesheetLoad": (v, E) => {
                            Pe.attachLinkElement(v, E)
                        }
                        ,
                        "keepIframeSrcFn": be
                    });
                    if (!E)
                        return console.warn("Failed to snapshot the document");
                    Ao({
                        "type": yo.FullSnapshot,
                        "data": {
                            "node": E,
                            "initialOffset": getWindowScroll(window)
                        }
                    }),
                    Co.forEach((v => v.unlock())),
                    document.adoptedStyleSheets && document.adoptedStyleSheets.length > 0 && Pe.adoptStyleSheets(document.adoptedStyleSheets, ko.getId(document))
                }
                ;
                Io = takeFullSnapshot;
                try {
                    const v = []
                      , observe = v => callbackWrapper(initObservers)({
                        "onMutation": Ee,
                        "mutationCb": wrappedMutationEmit,
                        "mousemoveCb": (v, E) => Ao({
                            "type": yo.IncrementalSnapshot,
                            "data": {
                                "source": E,
                                "positions": v
                            }
                        }),
                        "mouseInteractionCb": v => Ao({
                            "type": yo.IncrementalSnapshot,
                            "data": {
                                "source": bo.MouseInteraction,
                                ...v
                            }
                        }),
                        "scrollCb": wrappedScrollEmit,
                        "viewportResizeCb": v => Ao({
                            "type": yo.IncrementalSnapshot,
                            "data": {
                                "source": bo.ViewportResize,
                                ...v
                            }
                        }),
                        "inputCb": v => Ao({
                            "type": yo.IncrementalSnapshot,
                            "data": {
                                "source": bo.Input,
                                ...v
                            }
                        }),
                        "mediaInteractionCb": v => Ao({
                            "type": yo.IncrementalSnapshot,
                            "data": {
                                "source": bo.MediaInteraction,
                                ...v
                            }
                        }),
                        "styleSheetRuleCb": v => Ao({
                            "type": yo.IncrementalSnapshot,
                            "data": {
                                "source": bo.StyleSheetRule,
                                ...v
                            }
                        }),
                        "styleDeclarationCb": v => Ao({
                            "type": yo.IncrementalSnapshot,
                            "data": {
                                "source": bo.StyleDeclaration,
                                ...v
                            }
                        }),
                        "canvasMutationCb": wrappedCanvasMutationEmit,
                        "fontCb": v => Ao({
                            "type": yo.IncrementalSnapshot,
                            "data": {
                                "source": bo.Font,
                                ...v
                            }
                        }),
                        "selectionCb": v => {
                            Ao({
                                "type": yo.IncrementalSnapshot,
                                "data": {
                                    "source": bo.Selection,
                                    ...v
                                }
                            })
                        }
                        ,
                        "customElementCb": v => {
                            Ao({
                                "type": yo.IncrementalSnapshot,
                                "data": {
                                    "source": bo.CustomElement,
                                    ...v
                                }
                            })
                        }
                        ,
                        "blockClass": U,
                        "ignoreClass": W,
                        "ignoreSelector": Z,
                        "maskAllText": Y,
                        "maskTextClass": J,
                        "unmaskTextClass": K,
                        "maskTextSelector": X,
                        "unmaskTextSelector": Q,
                        "maskInputOptions": Ae,
                        "inlineStylesheet": ee,
                        "sampling": le,
                        "recordDOM": pe,
                        "recordCanvas": fe,
                        "inlineImages": ve,
                        "userTriggeredOnInput": ge,
                        "collectFonts": _e,
                        "doc": v,
                        "maskAttributeFn": oe,
                        "maskInputFn": ie,
                        "maskTextFn": ae,
                        "keepIframeSrcFn": be,
                        "blockSelector": H,
                        "unblockSelector": G,
                        "slimDOMOptions": Ie,
                        "dataURLOptions": ue,
                        "mirror": ko,
                        "iframeManager": Re,
                        "stylesheetManager": Pe,
                        "shadowDomManager": De,
                        "processedNodeManager": Me,
                        "canvasManager": Ne,
                        "ignoreCSSAttributes": Se,
                        "plugins": _optionalChain([ye, "optionalAccess", v => v.filter, "call", v => v((v => v.observer)), "optionalAccess", v => v.map, "call", v => v((v => ({
                            "observer": v.observer,
                            "options": v.options,
                            "callback": E => Ao({
                                "type": yo.Plugin,
                                "data": {
                                    "plugin": v.name,
                                    "payload": E
                                }
                            })
                        })))]) || []
                    }, {});
                    Re.addLoadListener((E => {
                        try {
                            v.push(observe(E.contentDocument))
                        } catch (v) {
                            console.warn(v)
                        }
                    }
                    ));
                    const init = () => {
                        takeFullSnapshot(),
                        v.push(observe(document))
                    }
                    ;
                    return "interactive" === document.readyState || "complete" === document.readyState ? init() : (v.push(on("DOMContentLoaded", ( () => {
                        Ao({
                            "type": yo.DomContentLoaded,
                            "data": {}
                        }),
                        "DOMContentLoaded" === me && init()
                    }
                    ))),
                    v.push(on("load", ( () => {
                        Ao({
                            "type": yo.Load,
                            "data": {}
                        }),
                        "load" === me && init()
                    }
                    ), window))),
                    () => {
                        v.forEach((v => v())),
                        Me.destroy(),
                        Io = void 0,
                        unregisterErrorHandler()
                    }
                } catch (v) {
                    console.warn(v)
                }
            }
            record.mirror = ko,
            record.takeFullSnapshot = function takeFullSnapshot(v) {
                if (!Io)
                    throw new Error("please take full snapshot after start recording");
                Io(v)
            }
            ;
            const Oo = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__
              , Po = ["info", "warn", "error", "log"]
              , Ro = "[Replay] ";
            function _addBreadcrumb(v, E="info") {
                !function breadcrumbs_addBreadcrumb(v, E) {
                    const k = build_esm_currentScopes_getClient()
                      , R = build_esm_currentScopes_getIsolationScope();
                    if (!k)
                        return;
                    const {"beforeBreadcrumb": U=null, "maxBreadcrumbs": H=or} = k.getOptions();
                    if (H <= 0)
                        return;
                    const G = {
                        "timestamp": utils_build_esm_time_dateTimestampInSeconds(),
                        ...v
                    }
                      , W = U ? utils_build_esm_logger_consoleSandbox(( () => U(G, E))) : G;
                    null !== W && (k.emit && k.emit("beforeAddBreadcrumb", W, E),
                    R.addBreadcrumb(W, H))
                }({
                    "category": "console",
                    "data": {
                        "logger": "replay"
                    },
                    "level": E,
                    "message": `${Ro}${v}`
                }, {
                    "level": E
                })
            }
            const Mo = function makeReplayLogger() {
                let v = !1
                  , E = !1;
                const k = {
                    "exception": () => {}
                    ,
                    "infoTick": () => {}
                    ,
                    "setConfig": k => {
                        v = k.captureExceptions,
                        E = k.traceInternals
                    }
                };
                return Oo ? (Po.forEach((v => {
                    k[v] = (...k) => {
                        Xn[v](Ro, ...k),
                        E && _addBreadcrumb(k[0])
                    }
                }
                )),
                k.exception = (R, ...U) => {
                    k.error && k.error(...U),
                    Xn.error(Ro, R),
                    v ? esm_exports_captureException(R) : E && _addBreadcrumb(R)
                }
                ,
                k.infoTick = (...v) => {
                    Xn.info(Ro, ...v),
                    E && setTimeout(( () => _addBreadcrumb(v[0])), 0)
                }
                ) : Po.forEach((v => {
                    k[v] = () => {}
                }
                )),
                k
            }()
              , No = 3;
            function timestampToMs(v) {
                return v > 9999999999 ? v : 1e3 * v
            }
            function timestampToS(v) {
                return v > 9999999999 ? v / 1e3 : v
            }
            function addBreadcrumbEvent(v, E) {
                "sentry.transaction" !== E.category && (["ui.click", "ui.input"].includes(E.category) ? v.triggerUserActivity() : v.checkAndHandleExpiredSession(),
                v.addUpdate(( () => (v.throttledAddEvent({
                    "type": yo.Custom,
                    "timestamp": 1e3 * (E.timestamp || 0),
                    "data": {
                        "tag": "breadcrumb",
                        "payload": esm_normalize_normalize(E, 10, 1e3)
                    }
                }),
                "console" === E.category))))
            }
            const Do = "button,a";
            function getClosestInteractive(v) {
                return v.closest(Do) || v
            }
            function getClickTargetNode(v) {
                const E = getTargetNode(v);
                return E && E instanceof Element ? getClosestInteractive(E) : E
            }
            function getTargetNode(v) {
                return function isEventWithTarget(v) {
                    return "object" == typeof v && !!v && "target"in v
                }(v) ? v.target : v
            }
            let $o;
            function onWindowOpen(v) {
                return $o || ($o = [],
                function monkeyPatchWindowOpen() {
                    build_esm_object_fill(Gr, "open", (function(v) {
                        return function(...E) {
                            if ($o)
                                try {
                                    $o.forEach((v => v()))
                                } catch (v) {}
                            return v.apply(Gr, E)
                        }
                    }
                    ))
                }()),
                $o.push(v),
                () => {
                    const E = $o ? $o.indexOf(v) : -1;
                    E > -1 && $o.splice(E, 1)
                }
            }
            const Lo = new Set([bo.Mutation, bo.StyleSheetRule, bo.StyleDeclaration, bo.AdoptedStyleSheet, bo.CanvasMutation, bo.Selection, bo.MediaInteraction]);
            class ClickDetector {
                "constructor"(v, E, k=addBreadcrumbEvent) {
                    this._lastMutation = 0,
                    this._lastScroll = 0,
                    this._clicks = [],
                    this._timeout = E.timeout / 1e3,
                    this._threshold = E.threshold / 1e3,
                    this._scollTimeout = E.scrollTimeout / 1e3,
                    this._replay = v,
                    this._ignoreSelector = E.ignoreSelector,
                    this._addBreadcrumbEvent = k
                }
                "addListeners"() {
                    const v = onWindowOpen(( () => {
                        this._lastMutation = nowInSeconds()
                    }
                    ));
                    this._teardown = () => {
                        v(),
                        this._clicks = [],
                        this._lastMutation = 0,
                        this._lastScroll = 0
                    }
                }
                "removeListeners"() {
                    this._teardown && this._teardown(),
                    this._checkClickTimeout && clearTimeout(this._checkClickTimeout)
                }
                "handleClick"(v, E) {
                    if (function ignoreElement(v, E) {
                        if (!Fo.includes(v.tagName))
                            return !0;
                        if ("INPUT" === v.tagName && !["submit", "button"].includes(v.getAttribute("type") || ""))
                            return !0;
                        if ("A" === v.tagName && (v.hasAttribute("download") || v.hasAttribute("target") && "_self" !== v.getAttribute("target")))
                            return !0;
                        if (E && v.matches(E))
                            return !0;
                        return !1
                    }(E, this._ignoreSelector) || !function isClickBreadcrumb(v) {
                        return !(!v.data || "number" != typeof v.data.nodeId || !v.timestamp)
                    }(v))
                        return;
                    const k = {
                        "timestamp": timestampToS(v.timestamp),
                        "clickBreadcrumb": v,
                        "clickCount": 0,
                        "node": E
                    };
                    this._clicks.some((v => v.node === k.node && Math.abs(v.timestamp - k.timestamp) < 1)) || (this._clicks.push(k),
                    1 === this._clicks.length && this._scheduleCheckClicks())
                }
                "registerMutation"(v=Date.now()) {
                    this._lastMutation = timestampToS(v)
                }
                "registerScroll"(v=Date.now()) {
                    this._lastScroll = timestampToS(v)
                }
                "registerClick"(v) {
                    const E = getClosestInteractive(v);
                    this._handleMultiClick(E)
                }
                "_handleMultiClick"(v) {
                    this._getClicks(v).forEach((v => {
                        v.clickCount++
                    }
                    ))
                }
                "_getClicks"(v) {
                    return this._clicks.filter((E => E.node === v))
                }
                "_checkClicks"() {
                    const v = []
                      , E = nowInSeconds();
                    this._clicks.forEach((k => {
                        !k.mutationAfter && this._lastMutation && (k.mutationAfter = k.timestamp <= this._lastMutation ? this._lastMutation - k.timestamp : void 0),
                        !k.scrollAfter && this._lastScroll && (k.scrollAfter = k.timestamp <= this._lastScroll ? this._lastScroll - k.timestamp : void 0),
                        k.timestamp + this._timeout <= E && v.push(k)
                    }
                    ));
                    for (const E of v) {
                        const v = this._clicks.indexOf(E);
                        v > -1 && (this._generateBreadcrumbs(E),
                        this._clicks.splice(v, 1))
                    }
                    this._clicks.length && this._scheduleCheckClicks()
                }
                "_generateBreadcrumbs"(v) {
                    const E = this._replay
                      , k = v.scrollAfter && v.scrollAfter <= this._scollTimeout
                      , R = v.mutationAfter && v.mutationAfter <= this._threshold
                      , U = !k && !R
                      , {"clickCount": H, "clickBreadcrumb": G} = v;
                    if (U) {
                        const k = 1e3 * Math.min(v.mutationAfter || this._timeout, this._timeout)
                          , R = k < 1e3 * this._timeout ? "mutation" : "timeout"
                          , U = {
                            "type": "default",
                            "message": G.message,
                            "timestamp": G.timestamp,
                            "category": "ui.slowClickDetected",
                            "data": {
                                ...G.data,
                                "url": Gr.location.href,
                                "route": E.getCurrentRoute(),
                                "timeAfterClickMs": k,
                                "endReason": R,
                                "clickCount": H || 1
                            }
                        };
                        this._addBreadcrumbEvent(E, U)
                    } else if (H > 1) {
                        const v = {
                            "type": "default",
                            "message": G.message,
                            "timestamp": G.timestamp,
                            "category": "ui.multiClick",
                            "data": {
                                ...G.data,
                                "url": Gr.location.href,
                                "route": E.getCurrentRoute(),
                                "clickCount": H,
                                "metric": !0
                            }
                        };
                        this._addBreadcrumbEvent(E, v)
                    }
                }
                "_scheduleCheckClicks"() {
                    this._checkClickTimeout && clearTimeout(this._checkClickTimeout),
                    this._checkClickTimeout = getNativeImplementation_setTimeout(( () => this._checkClicks()), 1e3)
                }
            }
            const Fo = ["A", "BUTTON", "INPUT"];
            function nowInSeconds() {
                return Date.now() / 1e3
            }
            function updateClickDetectorForRecordingEvent(v, E) {
                try {
                    if (!function isIncrementalEvent(v) {
                        return v.type === No
                    }(E))
                        return;
                    const {"source": k} = E.data;
                    if (Lo.has(k) && v.registerMutation(E.timestamp),
                    k === bo.Scroll && v.registerScroll(E.timestamp),
                    function isIncrementalMouseInteraction(v) {
                        return v.data.source === bo.MouseInteraction
                    }(E)) {
                        const {"type": k, "id": R} = E.data
                          , U = record.mirror.getNode(R);
                        U instanceof HTMLElement && k === So.Click && v.registerClick(U)
                    }
                } catch (v) {}
            }
            function createBreadcrumb(v) {
                return {
                    "timestamp": Date.now() / 1e3,
                    "type": "default",
                    ...v
                }
            }
            var jo;
            !function(v) {
                v[v.Document = 0] = "Document",
                v[v.DocumentType = 1] = "DocumentType",
                v[v.Element = 2] = "Element",
                v[v.Text = 3] = "Text",
                v[v.CDATA = 4] = "CDATA",
                v[v.Comment = 5] = "Comment"
            }(jo || (jo = {}));
            const Bo = new Set(["id", "class", "aria-label", "role", "name", "alt", "title", "data-test-id", "data-testid", "disabled", "aria-disabled", "data-sentry-component"]);
            function getAttributesToRecord(v) {
                const E = {};
                !v["data-sentry-component"] && v["data-sentry-element"] && (v["data-sentry-component"] = v["data-sentry-element"]);
                for (const k in v)
                    if (Bo.has(k)) {
                        let R = k;
                        "data-testid" !== k && "data-test-id" !== k || (R = "testId"),
                        E[R] = v[k]
                    }
                return E
            }
            const handleDomListener = v => E => {
                if (!v.isEnabled())
                    return;
                const k = function handleDom(v) {
                    const {"target": E, "message": k} = function getDomTarget(v) {
                        const E = "click" === v.name;
                        let k, R = null;
                        try {
                            R = E ? getClickTargetNode(v.event) : getTargetNode(v.event),
                            k = esm_browser_htmlTreeAsString(R, {
                                "maxStringLength": 200
                            }) || "<unknown>"
                        } catch (v) {
                            k = "<unknown>"
                        }
                        return {
                            "target": R,
                            "message": k
                        }
                    }(v);
                    return createBreadcrumb({
                        "category": `ui.${v.name}`,
                        ...getBaseDomBreadcrumb(E, k)
                    })
                }(E);
                if (!k)
                    return;
                const R = "click" === E.name
                  , U = R ? E.event : void 0;
                !(R && v.clickDetector && U && U.target) || U.altKey || U.metaKey || U.ctrlKey || U.shiftKey || function handleClick(v, E, k) {
                    v.handleClick(E, k)
                }(v.clickDetector, k, getClickTargetNode(E.event)),
                addBreadcrumbEvent(v, k)
            }
            ;
            function getBaseDomBreadcrumb(v, E) {
                const k = record.mirror.getId(v)
                  , R = k && record.mirror.getNode(k)
                  , U = R && record.mirror.getMeta(R)
                  , H = U && function esm_isElement(v) {
                    return v.type === jo.Element
                }(U) ? U : null;
                return {
                    "message": E,
                    "data": H ? {
                        "nodeId": k,
                        "node": {
                            "id": k,
                            "tagName": H.tagName,
                            "textContent": Array.from(H.childNodes).map((v => v.type === jo.Text && v.textContent)).filter(Boolean).map((v => v.trim())).join(""),
                            "attributes": getAttributesToRecord(H.attributes)
                        }
                    } : {}
                }
            }
            function handleKeyboardEvent(v, E) {
                if (!v.isEnabled())
                    return;
                v.updateUserActivity();
                const k = function getKeyboardBreadcrumb(v) {
                    const {"metaKey": E, "shiftKey": k, "ctrlKey": R, "altKey": U, "key": H, "target": G} = v;
                    if (!G || function isInputElement(v) {
                        return "INPUT" === v.tagName || "TEXTAREA" === v.tagName || v.isContentEditable
                    }(G) || !H)
                        return null;
                    const W = E || R || U
                      , Z = 1 === H.length;
                    if (!W && Z)
                        return null;
                    const Y = esm_browser_htmlTreeAsString(G, {
                        "maxStringLength": 200
                    }) || "<unknown>"
                      , J = getBaseDomBreadcrumb(G, Y);
                    return createBreadcrumb({
                        "category": "ui.keyDown",
                        "message": Y,
                        "data": {
                            ...J.data,
                            "metaKey": E,
                            "shiftKey": k,
                            "ctrlKey": R,
                            "altKey": U,
                            "key": H
                        }
                    })
                }(E);
                k && addBreadcrumbEvent(v, k)
            }
            const Uo = {
                "resource": function createResourceEntry(v) {
                    const {"entryType": E, "initiatorType": k, "name": R, "responseEnd": U, "startTime": H, "decodedBodySize": G, "encodedBodySize": W, "responseStatus": Z, "transferSize": Y} = v;
                    if (["fetch", "xmlhttprequest"].includes(k))
                        return null;
                    return {
                        "type": `${E}.${k}`,
                        "start": getAbsoluteTime(H),
                        "end": getAbsoluteTime(U),
                        "name": R,
                        "data": {
                            "size": Y,
                            "statusCode": Z,
                            "decodedBodySize": G,
                            "encodedBodySize": W
                        }
                    }
                },
                "paint": function createPaintEntry(v) {
                    const {"duration": E, "entryType": k, "name": R, "startTime": U} = v
                      , H = getAbsoluteTime(U);
                    return {
                        "type": k,
                        "name": R,
                        "start": H,
                        "end": H + E,
                        "data": void 0
                    }
                },
                "navigation": function createNavigationEntry(v) {
                    const {"entryType": E, "name": k, "decodedBodySize": R, "duration": U, "domComplete": H, "encodedBodySize": G, "domContentLoadedEventStart": W, "domContentLoadedEventEnd": Z, "domInteractive": Y, "loadEventStart": J, "loadEventEnd": K, "redirectCount": X, "startTime": Q, "transferSize": ee, "type": te} = v;
                    if (0 === U)
                        return null;
                    return {
                        "type": `${E}.${te}`,
                        "start": getAbsoluteTime(Q),
                        "end": getAbsoluteTime(H),
                        "name": k,
                        "data": {
                            "size": ee,
                            "decodedBodySize": R,
                            "encodedBodySize": G,
                            "duration": U,
                            "domInteractive": Y,
                            "domContentLoadedEventStart": W,
                            "domContentLoadedEventEnd": Z,
                            "loadEventStart": J,
                            "loadEventEnd": K,
                            "domComplete": H,
                            "redirectCount": X
                        }
                    }
                }
            };
            function webVitalHandler(v, E) {
                return ({"metric": k}) => {
                    E.replayPerformanceEntries.push(v(k))
                }
            }
            function createPerformanceEntry(v) {
                const E = Uo[v.entryType];
                return E ? E(v) : null
            }
            function getAbsoluteTime(v) {
                return ((Zn || Gr.performance.timeOrigin) + v) / 1e3
            }
            function getLargestContentfulPaint(v) {
                const E = v.entries[v.entries.length - 1];
                return getWebVital(v, "largest-contentful-paint", E && E.element ? [E.element] : void 0)
            }
            function isLayoutShift(v) {
                return void 0 !== v.sources
            }
            function getCumulativeLayoutShift(v) {
                const E = []
                  , k = [];
                for (const R of v.entries)
                    if (isLayoutShift(R)) {
                        const v = [];
                        for (const E of R.sources)
                            if (E.node) {
                                k.push(E.node);
                                const R = record.mirror.getId(E.node);
                                R && v.push(R)
                            }
                        E.push({
                            "value": R.value,
                            "nodeIds": v.length ? v : void 0
                        })
                    }
                return getWebVital(v, "cumulative-layout-shift", k, E)
            }
            function getFirstInputDelay(v) {
                const E = v.entries[v.entries.length - 1];
                return getWebVital(v, "first-input-delay", E && E.target ? [E.target] : void 0)
            }
            function getInteractionToNextPaint(v) {
                const E = v.entries[v.entries.length - 1];
                return getWebVital(v, "interaction-to-next-paint", E && E.target ? [E.target] : void 0)
            }
            function getWebVital(v, E, k, R) {
                const U = v.value
                  , H = v.rating
                  , G = getAbsoluteTime(U);
                return {
                    "type": "web-vital",
                    "name": E,
                    "start": G,
                    "end": G,
                    "data": {
                        "value": U,
                        "size": U,
                        "rating": H,
                        "nodeIds": k ? k.map((v => record.mirror.getId(v))) : void 0,
                        "attributions": R
                    }
                }
            }
            const Ho = 'var t=Uint8Array,n=Uint16Array,r=Int32Array,e=new t([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),i=new t([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),a=new t([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),s=function(t,e){for(var i=new n(31),a=0;a<31;++a)i[a]=e+=1<<t[a-1];var s=new r(i[30]);for(a=1;a<30;++a)for(var o=i[a];o<i[a+1];++o)s[o]=o-i[a]<<5|a;return{b:i,r:s}},o=s(e,2),f=o.b,h=o.r;f[28]=258,h[258]=28;for(var l=s(i,0).r,u=new n(32768),c=0;c<32768;++c){var v=(43690&c)>>1|(21845&c)<<1;v=(61680&(v=(52428&v)>>2|(13107&v)<<2))>>4|(3855&v)<<4,u[c]=((65280&v)>>8|(255&v)<<8)>>1}var d=function(t,r,e){for(var i=t.length,a=0,s=new n(r);a<i;++a)t[a]&&++s[t[a]-1];var o,f=new n(r);for(a=1;a<r;++a)f[a]=f[a-1]+s[a-1]<<1;if(e){o=new n(1<<r);var h=15-r;for(a=0;a<i;++a)if(t[a])for(var l=a<<4|t[a],c=r-t[a],v=f[t[a]-1]++<<c,d=v|(1<<c)-1;v<=d;++v)o[u[v]>>h]=l}else for(o=new n(i),a=0;a<i;++a)t[a]&&(o[a]=u[f[t[a]-1]++]>>15-t[a]);return o},g=new t(288);for(c=0;c<144;++c)g[c]=8;for(c=144;c<256;++c)g[c]=9;for(c=256;c<280;++c)g[c]=7;for(c=280;c<288;++c)g[c]=8;var w=new t(32);for(c=0;c<32;++c)w[c]=5;var p=d(g,9,0),y=d(w,5,0),m=function(t){return(t+7)/8|0},b=function(n,r,e){return(null==r||r<0)&&(r=0),(null==e||e>n.length)&&(e=n.length),new t(n.subarray(r,e))},M=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],E=function(t,n,r){var e=new Error(n||M[t]);if(e.code=t,Error.captureStackTrace&&Error.captureStackTrace(e,E),!r)throw e;return e},z=function(t,n,r){r<<=7&n;var e=n/8|0;t[e]|=r,t[e+1]|=r>>8},A=function(t,n,r){r<<=7&n;var e=n/8|0;t[e]|=r,t[e+1]|=r>>8,t[e+2]|=r>>16},_=function(r,e){for(var i=[],a=0;a<r.length;++a)r[a]&&i.push({s:a,f:r[a]});var s=i.length,o=i.slice();if(!s)return{t:F,l:0};if(1==s){var f=new t(i[0].s+1);return f[i[0].s]=1,{t:f,l:1}}i.sort((function(t,n){return t.f-n.f})),i.push({s:-1,f:25001});var h=i[0],l=i[1],u=0,c=1,v=2;for(i[0]={s:-1,f:h.f+l.f,l:h,r:l};c!=s-1;)h=i[i[u].f<i[v].f?u++:v++],l=i[u!=c&&i[u].f<i[v].f?u++:v++],i[c++]={s:-1,f:h.f+l.f,l:h,r:l};var d=o[0].s;for(a=1;a<s;++a)o[a].s>d&&(d=o[a].s);var g=new n(d+1),w=x(i[c-1],g,0);if(w>e){a=0;var p=0,y=w-e,m=1<<y;for(o.sort((function(t,n){return g[n.s]-g[t.s]||t.f-n.f}));a<s;++a){var b=o[a].s;if(!(g[b]>e))break;p+=m-(1<<w-g[b]),g[b]=e}for(p>>=y;p>0;){var M=o[a].s;g[M]<e?p-=1<<e-g[M]++-1:++a}for(;a>=0&&p;--a){var E=o[a].s;g[E]==e&&(--g[E],++p)}w=e}return{t:new t(g),l:w}},x=function(t,n,r){return-1==t.s?Math.max(x(t.l,n,r+1),x(t.r,n,r+1)):n[t.s]=r},D=function(t){for(var r=t.length;r&&!t[--r];);for(var e=new n(++r),i=0,a=t[0],s=1,o=function(t){e[i++]=t},f=1;f<=r;++f)if(t[f]==a&&f!=r)++s;else{if(!a&&s>2){for(;s>138;s-=138)o(32754);s>2&&(o(s>10?s-11<<5|28690:s-3<<5|12305),s=0)}else if(s>3){for(o(a),--s;s>6;s-=6)o(8304);s>2&&(o(s-3<<5|8208),s=0)}for(;s--;)o(a);s=1,a=t[f]}return{c:e.subarray(0,i),n:r}},T=function(t,n){for(var r=0,e=0;e<n.length;++e)r+=t[e]*n[e];return r},k=function(t,n,r){var e=r.length,i=m(n+2);t[i]=255&e,t[i+1]=e>>8,t[i+2]=255^t[i],t[i+3]=255^t[i+1];for(var a=0;a<e;++a)t[i+a+4]=r[a];return 8*(i+4+e)},C=function(t,r,s,o,f,h,l,u,c,v,m){z(r,m++,s),++f[256];for(var b=_(f,15),M=b.t,E=b.l,x=_(h,15),C=x.t,U=x.l,F=D(M),I=F.c,S=F.n,L=D(C),O=L.c,j=L.n,q=new n(19),B=0;B<I.length;++B)++q[31&I[B]];for(B=0;B<O.length;++B)++q[31&O[B]];for(var G=_(q,7),H=G.t,J=G.l,K=19;K>4&&!H[a[K-1]];--K);var N,P,Q,R,V=v+5<<3,W=T(f,g)+T(h,w)+l,X=T(f,M)+T(h,C)+l+14+3*K+T(q,H)+2*q[16]+3*q[17]+7*q[18];if(c>=0&&V<=W&&V<=X)return k(r,m,t.subarray(c,c+v));if(z(r,m,1+(X<W)),m+=2,X<W){N=d(M,E,0),P=M,Q=d(C,U,0),R=C;var Y=d(H,J,0);z(r,m,S-257),z(r,m+5,j-1),z(r,m+10,K-4),m+=14;for(B=0;B<K;++B)z(r,m+3*B,H[a[B]]);m+=3*K;for(var Z=[I,O],$=0;$<2;++$){var tt=Z[$];for(B=0;B<tt.length;++B){var nt=31&tt[B];z(r,m,Y[nt]),m+=H[nt],nt>15&&(z(r,m,tt[B]>>5&127),m+=tt[B]>>12)}}}else N=p,P=g,Q=y,R=w;for(B=0;B<u;++B){var rt=o[B];if(rt>255){A(r,m,N[(nt=rt>>18&31)+257]),m+=P[nt+257],nt>7&&(z(r,m,rt>>23&31),m+=e[nt]);var et=31&rt;A(r,m,Q[et]),m+=R[et],et>3&&(A(r,m,rt>>5&8191),m+=i[et])}else A(r,m,N[rt]),m+=P[rt]}return A(r,m,N[256]),m+P[256]},U=new r([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),F=new t(0),I=function(){for(var t=new Int32Array(256),n=0;n<256;++n){for(var r=n,e=9;--e;)r=(1&r&&-306674912)^r>>>1;t[n]=r}return t}(),S=function(){var t=-1;return{p:function(n){for(var r=t,e=0;e<n.length;++e)r=I[255&r^n[e]]^r>>>8;t=r},d:function(){return~t}}},L=function(){var t=1,n=0;return{p:function(r){for(var e=t,i=n,a=0|r.length,s=0;s!=a;){for(var o=Math.min(s+2655,a);s<o;++s)i+=e+=r[s];e=(65535&e)+15*(e>>16),i=(65535&i)+15*(i>>16)}t=e,n=i},d:function(){return(255&(t%=65521))<<24|(65280&t)<<8|(255&(n%=65521))<<8|n>>8}}},O=function(a,s,o,f,u){if(!u&&(u={l:1},s.dictionary)){var c=s.dictionary.subarray(-32768),v=new t(c.length+a.length);v.set(c),v.set(a,c.length),a=v,u.w=c.length}return function(a,s,o,f,u,c){var v=c.z||a.length,d=new t(f+v+5*(1+Math.ceil(v/7e3))+u),g=d.subarray(f,d.length-u),w=c.l,p=7&(c.r||0);if(s){p&&(g[0]=c.r>>3);for(var y=U[s-1],M=y>>13,E=8191&y,z=(1<<o)-1,A=c.p||new n(32768),_=c.h||new n(z+1),x=Math.ceil(o/3),D=2*x,T=function(t){return(a[t]^a[t+1]<<x^a[t+2]<<D)&z},F=new r(25e3),I=new n(288),S=new n(32),L=0,O=0,j=c.i||0,q=0,B=c.w||0,G=0;j+2<v;++j){var H=T(j),J=32767&j,K=_[H];if(A[J]=K,_[H]=J,B<=j){var N=v-j;if((L>7e3||q>24576)&&(N>423||!w)){p=C(a,g,0,F,I,S,O,q,G,j-G,p),q=L=O=0,G=j;for(var P=0;P<286;++P)I[P]=0;for(P=0;P<30;++P)S[P]=0}var Q=2,R=0,V=E,W=J-K&32767;if(N>2&&H==T(j-W))for(var X=Math.min(M,N)-1,Y=Math.min(32767,j),Z=Math.min(258,N);W<=Y&&--V&&J!=K;){if(a[j+Q]==a[j+Q-W]){for(var $=0;$<Z&&a[j+$]==a[j+$-W];++$);if($>Q){if(Q=$,R=W,$>X)break;var tt=Math.min(W,$-2),nt=0;for(P=0;P<tt;++P){var rt=j-W+P&32767,et=rt-A[rt]&32767;et>nt&&(nt=et,K=rt)}}}W+=(J=K)-(K=A[J])&32767}if(R){F[q++]=268435456|h[Q]<<18|l[R];var it=31&h[Q],at=31&l[R];O+=e[it]+i[at],++I[257+it],++S[at],B=j+Q,++L}else F[q++]=a[j],++I[a[j]]}}for(j=Math.max(j,B);j<v;++j)F[q++]=a[j],++I[a[j]];p=C(a,g,w,F,I,S,O,q,G,j-G,p),w||(c.r=7&p|g[p/8|0]<<3,p-=7,c.h=_,c.p=A,c.i=j,c.w=B)}else{for(j=c.w||0;j<v+w;j+=65535){var st=j+65535;st>=v&&(g[p/8|0]=w,st=v),p=k(g,p+1,a.subarray(j,st))}c.i=v}return b(d,0,f+m(p)+u)}(a,null==s.level?6:s.level,null==s.mem?Math.ceil(1.5*Math.max(8,Math.min(13,Math.log(a.length)))):12+s.mem,o,f,u)},j=function(t,n,r){for(;r;++n)t[n]=r,r>>>=8},q=function(t,n){var r=n.filename;if(t[0]=31,t[1]=139,t[2]=8,t[8]=n.level<2?4:9==n.level?2:0,t[9]=3,0!=n.mtime&&j(t,4,Math.floor(new Date(n.mtime||Date.now())/1e3)),r){t[3]=8;for(var e=0;e<=r.length;++e)t[e+10]=r.charCodeAt(e)}},B=function(t){return 10+(t.filename?t.filename.length+1:0)},G=function(){function n(n,r){if("function"==typeof n&&(r=n,n={}),this.ondata=r,this.o=n||{},this.s={l:0,i:32768,w:32768,z:32768},this.b=new t(98304),this.o.dictionary){var e=this.o.dictionary.subarray(-32768);this.b.set(e,32768-e.length),this.s.i=32768-e.length}}return n.prototype.p=function(t,n){this.ondata(O(t,this.o,0,0,this.s),n)},n.prototype.push=function(n,r){this.ondata||E(5),this.s.l&&E(4);var e=n.length+this.s.z;if(e>this.b.length){if(e>2*this.b.length-32768){var i=new t(-32768&e);i.set(this.b.subarray(0,this.s.z)),this.b=i}var a=this.b.length-this.s.z;a&&(this.b.set(n.subarray(0,a),this.s.z),this.s.z=this.b.length,this.p(this.b,!1)),this.b.set(this.b.subarray(-32768)),this.b.set(n.subarray(a),32768),this.s.z=n.length-a+32768,this.s.i=32766,this.s.w=32768}else this.b.set(n,this.s.z),this.s.z+=n.length;this.s.l=1&r,(this.s.z>this.s.w+8191||r)&&(this.p(this.b,r||!1),this.s.w=this.s.i,this.s.i-=2)},n}();var H=function(){function t(t,n){this.c=L(),this.v=1,G.call(this,t,n)}return t.prototype.push=function(t,n){this.c.p(t),G.prototype.push.call(this,t,n)},t.prototype.p=function(t,n){var r=O(t,this.o,this.v&&(this.o.dictionary?6:2),n&&4,this.s);this.v&&(function(t,n){var r=n.level,e=0==r?0:r<6?1:9==r?3:2;if(t[0]=120,t[1]=e<<6|(n.dictionary&&32),t[1]|=31-(t[0]<<8|t[1])%31,n.dictionary){var i=L();i.p(n.dictionary),j(t,2,i.d())}}(r,this.o),this.v=0),n&&j(r,r.length-4,this.c.d()),this.ondata(r,n)},t}(),J="undefined"!=typeof TextEncoder&&new TextEncoder,K="undefined"!=typeof TextDecoder&&new TextDecoder;try{K.decode(F,{stream:!0})}catch(t){}var N=function(){function t(t){this.ondata=t}return t.prototype.push=function(t,n){this.ondata||E(5),this.d&&E(4),this.ondata(P(t),this.d=n||!1)},t}();function P(n,r){if(r){for(var e=new t(n.length),i=0;i<n.length;++i)e[i]=n.charCodeAt(i);return e}if(J)return J.encode(n);var a=n.length,s=new t(n.length+(n.length>>1)),o=0,f=function(t){s[o++]=t};for(i=0;i<a;++i){if(o+5>s.length){var h=new t(o+8+(a-i<<1));h.set(s),s=h}var l=n.charCodeAt(i);l<128||r?f(l):l<2048?(f(192|l>>6),f(128|63&l)):l>55295&&l<57344?(f(240|(l=65536+(1047552&l)|1023&n.charCodeAt(++i))>>18),f(128|l>>12&63),f(128|l>>6&63),f(128|63&l)):(f(224|l>>12),f(128|l>>6&63),f(128|63&l))}return b(s,0,o)}function Q(t){return function(t,n){n||(n={});var r=S(),e=t.length;r.p(t);var i=O(t,n,B(n),8),a=i.length;return q(i,n),j(i,a-8,r.d()),j(i,a-4,e),i}(P(t))}const R=new class{constructor(){this._init()}clear(){this._init()}addEvent(t){if(!t)throw new Error("Adding invalid event");const n=this._hasEvents?",":"";this.stream.push(n+t),this._hasEvents=!0}finish(){this.stream.push("]",!0);const t=function(t){let n=0;for(const r of t)n+=r.length;const r=new Uint8Array(n);for(let n=0,e=0,i=t.length;n<i;n++){const i=t[n];r.set(i,e),e+=i.length}return r}(this._deflatedData);return this._init(),t}_init(){this._hasEvents=!1,this._deflatedData=[],this.deflate=new H,this.deflate.ondata=(t,n)=>{this._deflatedData.push(t)},this.stream=new N(((t,n)=>{this.deflate.push(t,n)})),this.stream.push("[")}},V={clear:()=>{R.clear()},addEvent:t=>R.addEvent(t),finish:()=>R.finish(),compress:t=>Q(t)};addEventListener("message",(function(t){const n=t.data.method,r=t.data.id,e=t.data.arg;if(n in V&&"function"==typeof V[n])try{const t=V[n](e);postMessage({id:r,method:n,success:!0,response:t})}catch(t){postMessage({id:r,method:n,success:!1,response:t.message}),console.error(t)}})),postMessage({id:void 0,method:"init",success:!0,response:void 0});';
            class EventBufferSizeExceededError extends Error {
                "constructor"() {
                    super("Event buffer exceeded maximum size of 20000000.")
                }
            }
            class EventBufferArray {
                "constructor"() {
                    this.events = [],
                    this._totalSize = 0,
                    this.hasCheckout = !1
                }
                get "hasEvents"() {
                    return this.events.length > 0
                }
                get "type"() {
                    return "sync"
                }
                "destroy"() {
                    this.events = []
                }
                async "addEvent"(v) {
                    const E = JSON.stringify(v).length;
                    if (this._totalSize += E,
                    this._totalSize > Kr)
                        throw new EventBufferSizeExceededError;
                    this.events.push(v)
                }
                "finish"() {
                    return new Promise((v => {
                        const E = this.events;
                        this.clear(),
                        v(JSON.stringify(E))
                    }
                    ))
                }
                "clear"() {
                    this.events = [],
                    this._totalSize = 0,
                    this.hasCheckout = !1
                }
                "getEarliestTimestamp"() {
                    const v = this.events.map((v => v.timestamp)).sort()[0];
                    return v ? timestampToMs(v) : null
                }
            }
            class WorkerHandler {
                "constructor"(v) {
                    this._worker = v,
                    this._id = 0
                }
                "ensureReady"() {
                    return this._ensureReadyPromise || (this._ensureReadyPromise = new Promise(( (v, E) => {
                        this._worker.addEventListener("message", ( ({"data": k}) => {
                            k.success ? v() : E()
                        }
                        ), {
                            "once": !0
                        }),
                        this._worker.addEventListener("error", (v => {
                            E(v)
                        }
                        ), {
                            "once": !0
                        })
                    }
                    ))),
                    this._ensureReadyPromise
                }
                "destroy"() {
                    Oo && Mo.info("Destroying compression worker"),
                    this._worker.terminate()
                }
                "postMessage"(v, E) {
                    const k = this._getAndIncrementId();
                    return new Promise(( (R, U) => {
                        const listener = ({"data": E}) => {
                            const H = E;
                            if (H.method === v && H.id === k) {
                                if (this._worker.removeEventListener("message", listener),
                                !H.success)
                                    return Oo && Mo.error("Error in compression worker: ", H.response),
                                    void U(new Error("Error in compression worker"));
                                R(H.response)
                            }
                        }
                        ;
                        this._worker.addEventListener("message", listener),
                        this._worker.postMessage({
                            "id": k,
                            "method": v,
                            "arg": E
                        })
                    }
                    ))
                }
                "_getAndIncrementId"() {
                    return this._id++
                }
            }
            class EventBufferCompressionWorker {
                "constructor"(v) {
                    this._worker = new WorkerHandler(v),
                    this._earliestTimestamp = null,
                    this._totalSize = 0,
                    this.hasCheckout = !1
                }
                get "hasEvents"() {
                    return !!this._earliestTimestamp
                }
                get "type"() {
                    return "worker"
                }
                "ensureReady"() {
                    return this._worker.ensureReady()
                }
                "destroy"() {
                    this._worker.destroy()
                }
                "addEvent"(v) {
                    const E = timestampToMs(v.timestamp);
                    (!this._earliestTimestamp || E < this._earliestTimestamp) && (this._earliestTimestamp = E);
                    const k = JSON.stringify(v);
                    return this._totalSize += k.length,
                    this._totalSize > Kr ? Promise.reject(new EventBufferSizeExceededError) : this._sendEventToWorker(k)
                }
                "finish"() {
                    return this._finishRequest()
                }
                "clear"() {
                    this._earliestTimestamp = null,
                    this._totalSize = 0,
                    this.hasCheckout = !1,
                    this._worker.postMessage("clear").then(null, (v => {
                        Oo && Mo.exception(v, 'Sending "clear" message to worker failed', v)
                    }
                    ))
                }
                "getEarliestTimestamp"() {
                    return this._earliestTimestamp
                }
                "_sendEventToWorker"(v) {
                    return this._worker.postMessage("addEvent", v)
                }
                async "_finishRequest"() {
                    const v = await this._worker.postMessage("finish");
                    return this._earliestTimestamp = null,
                    this._totalSize = 0,
                    v
                }
            }
            class EventBufferProxy {
                "constructor"(v) {
                    this._fallback = new EventBufferArray,
                    this._compression = new EventBufferCompressionWorker(v),
                    this._used = this._fallback,
                    this._ensureWorkerIsLoadedPromise = this._ensureWorkerIsLoaded()
                }
                get "type"() {
                    return this._used.type
                }
                get "hasEvents"() {
                    return this._used.hasEvents
                }
                get "hasCheckout"() {
                    return this._used.hasCheckout
                }
                set "hasCheckout"(v) {
                    this._used.hasCheckout = v
                }
                "destroy"() {
                    this._fallback.destroy(),
                    this._compression.destroy()
                }
                "clear"() {
                    return this._used.clear()
                }
                "getEarliestTimestamp"() {
                    return this._used.getEarliestTimestamp()
                }
                "addEvent"(v) {
                    return this._used.addEvent(v)
                }
                async "finish"() {
                    return await this.ensureWorkerIsLoaded(),
                    this._used.finish()
                }
                "ensureWorkerIsLoaded"() {
                    return this._ensureWorkerIsLoadedPromise
                }
                async "_ensureWorkerIsLoaded"() {
                    try {
                        await this._compression.ensureReady()
                    } catch (v) {
                        return void (Oo && Mo.exception(v, "Failed to load the compression worker, falling back to simple buffer"))
                    }
                    await this._switchToCompressionWorker()
                }
                async "_switchToCompressionWorker"() {
                    const {"events": v, "hasCheckout": E} = this._fallback
                      , k = [];
                    for (const E of v)
                        k.push(this._compression.addEvent(E));
                    this._compression.hasCheckout = E,
                    this._used = this._compression;
                    try {
                        await Promise.all(k)
                    } catch (v) {
                        Oo && Mo.exception(v, "Failed to add events when switching buffers.")
                    }
                }
            }
            function createEventBuffer({"useCompression": v, "workerUrl": E}) {
                if (v && window.Worker) {
                    const v = function _loadWorker(v) {
                        try {
                            const E = v || function _getWorkerUrl() {
                                if ("undefined" == typeof __SENTRY_EXCLUDE_REPLAY_WORKER__ || !__SENTRY_EXCLUDE_REPLAY_WORKER__)
                                    return function e() {
                                        const v = new Blob([Ho]);
                                        return URL.createObjectURL(v)
                                    }();
                                return ""
                            }();
                            if (!E)
                                return;
                            Oo && Mo.info("Using compression worker" + (v ? ` from ${v}` : ""));
                            const k = new Worker(E);
                            return new EventBufferProxy(k)
                        } catch (v) {
                            Oo && Mo.exception(v, "Failed to create compression worker")
                        }
                    }(E);
                    if (v)
                        return v
                }
                return Oo && Mo.info("Using simple buffer"),
                new EventBufferArray
            }
            function hasSessionStorage() {
                try {
                    return "sessionStorage"in Gr && !!Gr.sessionStorage
                } catch (v) {
                    return !1
                }
            }
            function clearSession(v) {
                !function deleteSession() {
                    if (!hasSessionStorage())
                        return;
                    try {
                        Gr.sessionStorage.removeItem(Vr)
                    } catch (v) {}
                }(),
                v.session = void 0
            }
            function isSampled(v) {
                return void 0 !== v && Math.random() < v
            }
            function esm_makeSession(v) {
                const E = Date.now();
                return {
                    "id": v.id || utils_build_esm_misc_uuid4(),
                    "started": v.started || E,
                    "lastActivity": v.lastActivity || E,
                    "segmentId": v.segmentId || 0,
                    "sampled": v.sampled,
                    "previousSessionId": v.previousSessionId
                }
            }
            function saveSession(v) {
                if (hasSessionStorage())
                    try {
                        Gr.sessionStorage.setItem(Vr, JSON.stringify(v))
                    } catch (v) {}
            }
            function createSession({"sessionSampleRate": v, "allowBuffering": E, "stickySession": k=!1}, {"previousSessionId": R}={}) {
                const U = function getSessionSampleType(v, E) {
                    return isSampled(v) ? "session" : !!E && "buffer"
                }(v, E)
                  , H = esm_makeSession({
                    "sampled": U,
                    "previousSessionId": R
                });
                return k && saveSession(H),
                H
            }
            function isExpired(v, E, k=+new Date) {
                return null === v || void 0 === E || E < 0 || 0 !== E && v + E <= k
            }
            function isSessionExpired(v, {"maxReplayDuration": E, "sessionIdleExpire": k, "targetTime": R=Date.now()}) {
                return isExpired(v.started, E, R) || isExpired(v.lastActivity, k, R)
            }
            function shouldRefreshSession(v, {"sessionIdleExpire": E, "maxReplayDuration": k}) {
                return !!isSessionExpired(v, {
                    "sessionIdleExpire": E,
                    "maxReplayDuration": k
                }) && ("buffer" !== v.sampled || 0 !== v.segmentId)
            }
            function loadOrCreateSession({"sessionIdleExpire": v, "maxReplayDuration": E, "previousSessionId": k}, R) {
                const U = R.stickySession && function fetchSession() {
                    if (!hasSessionStorage())
                        return null;
                    try {
                        const v = Gr.sessionStorage.getItem(Vr);
                        if (!v)
                            return null;
                        const E = JSON.parse(v);
                        return Oo && Mo.infoTick("Loading existing session"),
                        esm_makeSession(E)
                    } catch (v) {
                        return null
                    }
                }();
                return U ? shouldRefreshSession(U, {
                    "sessionIdleExpire": v,
                    "maxReplayDuration": E
                }) ? (Oo && Mo.infoTick("Session in sessionStorage is expired, creating new one..."),
                createSession(R, {
                    "previousSessionId": U.id
                })) : U : (Oo && Mo.infoTick("Creating new session"),
                createSession(R, {
                    "previousSessionId": k
                }))
            }
            function addEventSync(v, E, k) {
                return !!shouldAddEvent(v, E) && (_addEvent(v, E, k),
                !0)
            }
            async function _addEvent(v, E, k) {
                if (!v.eventBuffer)
                    return null;
                try {
                    k && "buffer" === v.recordingMode && v.eventBuffer.clear(),
                    k && (v.eventBuffer.hasCheckout = !0);
                    const R = function maybeApplyCallback(v, E) {
                        try {
                            if ("function" == typeof E && function isCustomEvent(v) {
                                return v.type === yo.Custom
                            }(v))
                                return E(v)
                        } catch (v) {
                            return Oo && Mo.exception(v, "An error occured in the `beforeAddRecordingEvent` callback, skipping the event..."),
                            null
                        }
                        return v
                    }(E, v.getOptions().beforeAddRecordingEvent);
                    if (!R)
                        return;
                    return await v.eventBuffer.addEvent(R)
                } catch (E) {
                    const k = E && E instanceof EventBufferSizeExceededError ? "addEventSizeExceeded" : "addEvent";
                    v.handleException(E),
                    await v.stop({
                        "reason": k
                    });
                    const R = build_esm_currentScopes_getClient();
                    R && R.recordDroppedEvent("internal_sdk_error", "replay")
                }
            }
            function shouldAddEvent(v, E) {
                if (!v.eventBuffer || v.isPaused() || !v.isEnabled())
                    return !1;
                const k = timestampToMs(E.timestamp);
                return !(k + v.timeouts.sessionIdlePause < Date.now()) && (!(k > v.getContext().initialTimestamp + v.getOptions().maxReplayDuration) || (Oo && Mo.infoTick(`Skipping event with timestamp ${k} because it is after maxReplayDuration`),
                !1))
            }
            function esm_isErrorEvent(v) {
                return !v.type
            }
            function esm_isTransactionEvent(v) {
                return "transaction" === v.type
            }
            function isFeedbackEvent(v) {
                return "feedback" === v.type
            }
            function handleAfterSendEvent(v) {
                return (E, k) => {
                    if (!v.isEnabled() || !esm_isErrorEvent(E) && !esm_isTransactionEvent(E))
                        return;
                    const R = k && k.statusCode;
                    !R || R < 200 || R >= 300 || (esm_isTransactionEvent(E) ? function handleTransactionEvent(v, E) {
                        const k = v.getContext();
                        E.contexts && E.contexts.trace && E.contexts.trace.trace_id && k.traceIds.size < 100 && k.traceIds.add(E.contexts.trace.trace_id)
                    }(v, E) : function handleErrorEvent(v, E) {
                        const k = v.getContext();
                        E.event_id && k.errorIds.size < 100 && k.errorIds.add(E.event_id);
                        if ("buffer" !== v.recordingMode || !E.tags || !E.tags.replayId)
                            return;
                        const {"beforeErrorSampling": R} = v.getOptions();
                        if ("function" == typeof R && !R(E))
                            return;
                        getNativeImplementation_setTimeout(( () => {
                            v.sendBufferedReplayOrFlush()
                        }
                        ))
                    }(v, E))
                }
            }
            function handleBeforeSendEvent(v) {
                return E => {
                    v.isEnabled() && esm_isErrorEvent(E) && function handleHydrationError(v, E) {
                        const k = E.exception && E.exception.values && E.exception.values[0] && E.exception.values[0].value;
                        if ("string" != typeof k)
                            return;
                        if (k.match(/(reactjs\.org\/docs\/error-decoder\.html\?invariant=|react\.dev\/errors\/)(418|419|422|423|425)/) || k.match(/(does not match server-rendered HTML|Hydration failed because)/i)) {
                            addBreadcrumbEvent(v, createBreadcrumb({
                                "category": "replay.hydrate-error",
                                "data": {
                                    "url": browser_getLocationHref()
                                }
                            }))
                        }
                    }(v, E)
                }
            }
            function handleBreadcrumbs(v) {
                const E = build_esm_currentScopes_getClient();
                E && E.on("beforeAddBreadcrumb", (E => function beforeAddBreadcrumb(v, E) {
                    if (!v.isEnabled() || !isBreadcrumbWithCategory(E))
                        return;
                    const k = function normalizeBreadcrumb(v) {
                        if (!isBreadcrumbWithCategory(v) || ["fetch", "xhr", "sentry.event", "sentry.transaction"].includes(v.category) || v.category.startsWith("ui."))
                            return null;
                        if ("console" === v.category)
                            return function normalizeConsoleBreadcrumb(v) {
                                const E = v.data && v.data.arguments;
                                if (!Array.isArray(E) || 0 === E.length)
                                    return createBreadcrumb(v);
                                let k = !1;
                                const R = E.map((v => {
                                    if (!v)
                                        return v;
                                    if ("string" == typeof v)
                                        return v.length > Jr ? (k = !0,
                                        `${v.slice(0, Jr)}…`) : v;
                                    if ("object" == typeof v)
                                        try {
                                            const E = esm_normalize_normalize(v, 7);
                                            return JSON.stringify(E).length > Jr ? (k = !0,
                                            `${JSON.stringify(E, null, 2).slice(0, Jr)}…`) : E
                                        } catch (v) {}
                                    return v
                                }
                                ));
                                return createBreadcrumb({
                                    ...v,
                                    "data": {
                                        ...v.data,
                                        "arguments": R,
                                        ...k ? {
                                            "_meta": {
                                                "warnings": ["CONSOLE_ARG_TRUNCATED"]
                                            }
                                        } : {}
                                    }
                                })
                            }(v);
                        return createBreadcrumb(v)
                    }(E);
                    k && addBreadcrumbEvent(v, k)
                }(v, E)))
            }
            function isBreadcrumbWithCategory(v) {
                return !!v.category
            }
            function handleGlobalEventListener(v) {
                return Object.assign(( (E, k) => {
                    if (!v.isEnabled())
                        return E;
                    if (function isReplayEvent(v) {
                        return "replay_event" === v.type
                    }(E))
                        return delete E.breadcrumbs,
                        E;
                    if (!esm_isErrorEvent(E) && !esm_isTransactionEvent(E) && !isFeedbackEvent(E))
                        return E;
                    if (!v.checkAndHandleExpiredSession())
                        return E;
                    if (isFeedbackEvent(E))
                        return v.flush(),
                        E.contexts.feedback.replay_id = v.getSessionId(),
                        function addFeedbackBreadcrumb(v, E) {
                            v.triggerUserActivity(),
                            v.addUpdate(( () => !E.timestamp || (v.throttledAddEvent({
                                "type": yo.Custom,
                                "timestamp": 1e3 * E.timestamp,
                                "data": {
                                    "tag": "breadcrumb",
                                    "payload": {
                                        "timestamp": E.timestamp,
                                        "type": "default",
                                        "category": "sentry.feedback",
                                        "data": {
                                            "feedbackId": E.event_id
                                        }
                                    }
                                }
                            }),
                            !1)))
                        }(v, E),
                        E;
                    if (function isRrwebError(v, E) {
                        return !(v.type || !v.exception || !v.exception.values || !v.exception.values.length || !E.originalException || !E.originalException.__rrweb__)
                    }(E, k) && !v.getOptions()._experiments.captureExceptions)
                        return Oo && Mo.log("Ignoring error from rrweb internals", E),
                        null;
                    const R = function shouldSampleForBufferEvent(v, E) {
                        return "buffer" === v.recordingMode && E.message !== Zr && !(!E.exception || E.type) && isSampled(v.getOptions().errorSampleRate)
                    }(v, E);
                    return (R || "session" === v.recordingMode) && (E.tags = {
                        ...E.tags,
                        "replayId": v.getSessionId()
                    }),
                    E
                }
                ), {
                    "id": "Replay"
                })
            }
            function createPerformanceSpans(v, E) {
                return E.map(( ({"type": E, "start": k, "end": R, "name": U, "data": H}) => {
                    const G = v.throttledAddEvent({
                        "type": yo.Custom,
                        "timestamp": k,
                        "data": {
                            "tag": "performanceSpan",
                            "payload": {
                                "op": E,
                                "description": U,
                                "startTimestamp": k,
                                "endTimestamp": R,
                                "data": H
                            }
                        }
                    });
                    return "string" == typeof G ? Promise.resolve(null) : G
                }
                ))
            }
            function handleHistorySpanListener(v) {
                return E => {
                    if (!v.isEnabled())
                        return;
                    const k = function handleHistory(v) {
                        const {"from": E, "to": k} = v
                          , R = Date.now() / 1e3;
                        return {
                            "type": "navigation.push",
                            "start": R,
                            "end": R,
                            "name": k,
                            "data": {
                                "previous": E
                            }
                        }
                    }(E);
                    null !== k && (v.getContext().urls.push(k.name),
                    v.triggerUserActivity(),
                    v.addUpdate(( () => (createPerformanceSpans(v, [k]),
                    !1))))
                }
            }
            function addNetworkBreadcrumb(v, E) {
                v.isEnabled() && null !== E && (function shouldFilterRequest(v, E) {
                    return (!Oo || !v.getOptions()._experiments.traceInternals) && isSentryRequestUrl_isSentryRequestUrl(E, build_esm_currentScopes_getClient())
                }(v, E.name) || v.addUpdate(( () => (createPerformanceSpans(v, [E]),
                !0))))
            }
            function getBodySize(v) {
                if (!v)
                    return;
                const E = new TextEncoder;
                try {
                    if ("string" == typeof v)
                        return E.encode(v).length;
                    if (v instanceof URLSearchParams)
                        return E.encode(v.toString()).length;
                    if (v instanceof FormData) {
                        const k = _serializeFormData(v);
                        return E.encode(k).length
                    }
                    if (v instanceof Blob)
                        return v.size;
                    if (v instanceof ArrayBuffer)
                        return v.byteLength
                } catch (v) {}
            }
            function parseContentLengthHeader(v) {
                if (!v)
                    return;
                const E = parseInt(v, 10);
                return isNaN(E) ? void 0 : E
            }
            function getBodyString(v) {
                try {
                    if ("string" == typeof v)
                        return [v];
                    if (v instanceof URLSearchParams)
                        return [v.toString()];
                    if (v instanceof FormData)
                        return [_serializeFormData(v)];
                    if (!v)
                        return [void 0]
                } catch (E) {
                    return Oo && Mo.exception(E, "Failed to serialize body", v),
                    [void 0, "BODY_PARSE_ERROR"]
                }
                return Oo && Mo.info("Skipping network body because of body type", v),
                [void 0, "UNPARSEABLE_BODY_TYPE"]
            }
            function mergeWarning(v, E) {
                if (!v)
                    return {
                        "headers": {},
                        "size": void 0,
                        "_meta": {
                            "warnings": [E]
                        }
                    };
                const k = {
                    ...v._meta
                }
                  , R = k.warnings || [];
                return k.warnings = [...R, E],
                v._meta = k,
                v
            }
            function makeNetworkReplayBreadcrumb(v, E) {
                if (!E)
                    return null;
                const {"startTimestamp": k, "endTimestamp": R, "url": U, "method": H, "statusCode": G, "request": W, "response": Z} = E;
                return {
                    "type": v,
                    "start": k / 1e3,
                    "end": R / 1e3,
                    "name": U,
                    "data": node_modules_sentry_utils_build_esm_object_dropUndefinedKeys({
                        "method": H,
                        "statusCode": G,
                        "request": W,
                        "response": Z
                    })
                }
            }
            function buildSkippedNetworkRequestOrResponse(v) {
                return {
                    "headers": {},
                    "size": v,
                    "_meta": {
                        "warnings": ["URL_SKIPPED"]
                    }
                }
            }
            function buildNetworkRequestOrResponse(v, E, k) {
                if (!E && 0 === Object.keys(v).length)
                    return;
                if (!E)
                    return {
                        "headers": v
                    };
                if (!k)
                    return {
                        "headers": v,
                        "size": E
                    };
                const R = {
                    "headers": v,
                    "size": E
                }
                  , {"body": U, "warnings": H} = function normalizeNetworkBody(v) {
                    if (!v || "string" != typeof v)
                        return {
                            "body": v
                        };
                    const E = v.length > Yr
                      , k = function _strIsProbablyJson(v) {
                        const E = v[0]
                          , k = v[v.length - 1];
                        return "[" === E && "]" === k || "{" === E && "}" === k
                    }(v);
                    if (E) {
                        const E = v.slice(0, Yr);
                        return k ? {
                            "body": E,
                            "warnings": ["MAYBE_JSON_TRUNCATED"]
                        } : {
                            "body": `${E}…`,
                            "warnings": ["TEXT_TRUNCATED"]
                        }
                    }
                    if (k)
                        try {
                            return {
                                "body": JSON.parse(v)
                            }
                        } catch (v) {}
                    return {
                        "body": v
                    }
                }(k);
                return R.body = U,
                H && H.length > 0 && (R._meta = {
                    "warnings": H
                }),
                R
            }
            function getAllowedHeaders(v, E) {
                return Object.entries(v).reduce(( (k, [R,U]) => {
                    const H = R.toLowerCase();
                    return E.includes(H) && v[R] && (k[H] = U),
                    k
                }
                ), {})
            }
            function _serializeFormData(v) {
                return new URLSearchParams(v).toString()
            }
            function urlMatches(v, E) {
                const k = function getFullUrl(v, E=Gr.document.baseURI) {
                    if (v.startsWith("http://") || v.startsWith("https://") || v.startsWith(Gr.location.origin))
                        return v;
                    const k = new URL(v,E);
                    if (k.origin !== new URL(E).origin)
                        return v;
                    const R = k.href;
                    if (!v.endsWith("/") && R.endsWith("/"))
                        return R.slice(0, -1);
                    return R
                }(v);
                return function string_stringMatchesSomePattern(v, E=[], k=!1) {
                    return E.some((E => string_isMatchingPattern(v, E, k)))
                }(k, E)
            }
            async function captureFetchBreadcrumbToReplay(v, E, k) {
                try {
                    const R = await async function _prepareFetchData(v, E, k) {
                        const R = Date.now()
                          , {"startTimestamp": U=R, "endTimestamp": H=R} = E
                          , {"url": G, "method": W, "status_code": Z=0, "request_body_size": Y, "response_body_size": J} = v.data
                          , K = urlMatches(G, k.networkDetailAllowUrls) && !urlMatches(G, k.networkDetailDenyUrls)
                          , X = K ? function _getRequestInfo({"networkCaptureBodies": v, "networkRequestHeaders": E}, k, R) {
                            const U = k ? function getRequestHeaders(v, E) {
                                if (1 === v.length && "string" != typeof v[0])
                                    return getHeadersFromOptions(v[0], E);
                                if (2 === v.length)
                                    return getHeadersFromOptions(v[1], E);
                                return {}
                            }(k, E) : {};
                            if (!v)
                                return buildNetworkRequestOrResponse(U, R, void 0);
                            const H = _getFetchRequestArgBody(k)
                              , [G,W] = getBodyString(H)
                              , Z = buildNetworkRequestOrResponse(U, R, G);
                            if (W)
                                return mergeWarning(Z, W);
                            return Z
                        }(k, E.input, Y) : buildSkippedNetworkRequestOrResponse(Y)
                          , Q = await async function _getResponseInfo(v, {"networkCaptureBodies": E, "networkResponseHeaders": k}, R, U) {
                            if (!v && void 0 !== U)
                                return buildSkippedNetworkRequestOrResponse(U);
                            const H = R ? getAllHeaders(R.headers, k) : {};
                            if (!R || !E && void 0 !== U)
                                return buildNetworkRequestOrResponse(H, U, void 0);
                            const [G,W] = await async function _parseFetchResponseBody(v) {
                                const E = function _tryCloneResponse(v) {
                                    try {
                                        return v.clone()
                                    } catch (v) {
                                        Oo && Mo.exception(v, "Failed to clone response body")
                                    }
                                }(v);
                                if (!E)
                                    return [void 0, "BODY_PARSE_ERROR"];
                                try {
                                    const v = await function _tryGetResponseText(v) {
                                        return new Promise(( (E, k) => {
                                            const R = getNativeImplementation_setTimeout(( () => k(new Error("Timeout while trying to read response body"))), 500);
                                            (async function _getResponseText(v) {
                                                return await v.text()
                                            }
                                            )(v).then((v => E(v)), (v => k(v))).finally(( () => clearTimeout(R)))
                                        }
                                        ))
                                    }(E);
                                    return [v]
                                } catch (v) {
                                    return Oo && Mo.exception(v, "Failed to get text body from response"),
                                    [void 0, "BODY_PARSE_ERROR"]
                                }
                            }(R)
                              , Z = function getResponseData(v, {"networkCaptureBodies": E, "responseBodySize": k, "captureDetails": R, "headers": U}) {
                                try {
                                    const H = v && v.length && void 0 === k ? getBodySize(v) : k;
                                    return R ? buildNetworkRequestOrResponse(U, H, E ? v : void 0) : buildSkippedNetworkRequestOrResponse(H)
                                } catch (v) {
                                    return Oo && Mo.exception(v, "Failed to serialize response body"),
                                    buildNetworkRequestOrResponse(U, k, void 0)
                                }
                            }(G, {
                                "networkCaptureBodies": E,
                                "responseBodySize": U,
                                "captureDetails": v,
                                "headers": H
                            });
                            if (W)
                                return mergeWarning(Z, W);
                            return Z
                        }(K, k, E.response, J);
                        return {
                            "startTimestamp": U,
                            "endTimestamp": H,
                            "url": G,
                            "method": W,
                            "statusCode": Z,
                            "request": X,
                            "response": Q
                        }
                    }(v, E, k)
                      , U = makeNetworkReplayBreadcrumb("resource.fetch", R);
                    addNetworkBreadcrumb(k.replay, U)
                } catch (v) {
                    Oo && Mo.exception(v, "Failed to capture fetch breadcrumb")
                }
            }
            function _getFetchRequestArgBody(v=[]) {
                if (2 === v.length && "object" == typeof v[1])
                    return v[1].body
            }
            function getAllHeaders(v, E) {
                const k = {};
                return E.forEach((E => {
                    v.get(E) && (k[E] = v.get(E))
                }
                )),
                k
            }
            function getHeadersFromOptions(v, E) {
                if (!v)
                    return {};
                const k = v.headers;
                return k ? k instanceof Headers ? getAllHeaders(k, E) : Array.isArray(k) ? {} : getAllowedHeaders(k, E) : {}
            }
            async function captureXhrBreadcrumbToReplay(v, E, k) {
                try {
                    const R = function _prepareXhrData(v, E, k) {
                        const R = Date.now()
                          , {"startTimestamp": U=R, "endTimestamp": H=R, "input": G, "xhr": W} = E
                          , {"url": Z, "method": Y, "status_code": J=0, "request_body_size": K, "response_body_size": X} = v.data;
                        if (!Z)
                            return null;
                        if (!W || !urlMatches(Z, k.networkDetailAllowUrls) || urlMatches(Z, k.networkDetailDenyUrls)) {
                            return {
                                "startTimestamp": U,
                                "endTimestamp": H,
                                "url": Z,
                                "method": Y,
                                "statusCode": J,
                                "request": buildSkippedNetworkRequestOrResponse(K),
                                "response": buildSkippedNetworkRequestOrResponse(X)
                            }
                        }
                        const Q = W[Mt]
                          , ee = Q ? getAllowedHeaders(Q.request_headers, k.networkRequestHeaders) : {}
                          , te = getAllowedHeaders(function getResponseHeaders(v) {
                            const E = v.getAllResponseHeaders();
                            if (!E)
                                return {};
                            return E.split("\r\n").reduce(( (v, E) => {
                                const [k,R] = E.split(": ");
                                return R && (v[k.toLowerCase()] = R),
                                v
                            }
                            ), {})
                        }(W), k.networkResponseHeaders)
                          , [ne,re] = k.networkCaptureBodies ? getBodyString(G) : [void 0]
                          , [oe,ie] = k.networkCaptureBodies ? function _getXhrResponseBody(v) {
                            const E = [];
                            try {
                                return [v.responseText]
                            } catch (v) {
                                E.push(v)
                            }
                            try {
                                return function _parseXhrResponse(v, E) {
                                    try {
                                        if ("string" == typeof v)
                                            return [v];
                                        if (v instanceof Document)
                                            return [v.body.outerHTML];
                                        if ("json" === E && v && "object" == typeof v)
                                            return [JSON.stringify(v)];
                                        if (!v)
                                            return [void 0]
                                    } catch (E) {
                                        return Oo && Mo.exception(E, "Failed to serialize body", v),
                                        [void 0, "BODY_PARSE_ERROR"]
                                    }
                                    return Oo && Mo.info("Skipping network body because of body type", v),
                                    [void 0, "UNPARSEABLE_BODY_TYPE"]
                                }(v.response, v.responseType)
                            } catch (v) {
                                E.push(v)
                            }
                            return Oo && Mo.warn("Failed to get xhr response body", ...E),
                            [void 0]
                        }(W) : [void 0]
                          , ae = buildNetworkRequestOrResponse(ee, K, ne)
                          , se = buildNetworkRequestOrResponse(te, X, oe);
                        return {
                            "startTimestamp": U,
                            "endTimestamp": H,
                            "url": Z,
                            "method": Y,
                            "statusCode": J,
                            "request": re ? mergeWarning(ae, re) : ae,
                            "response": ie ? mergeWarning(se, ie) : se
                        }
                    }(v, E, k)
                      , U = makeNetworkReplayBreadcrumb("resource.xhr", R);
                    addNetworkBreadcrumb(k.replay, U)
                } catch (v) {
                    Oo && Mo.exception(v, "Failed to capture xhr breadcrumb")
                }
            }
            function enrichXhrBreadcrumb(v, E) {
                const {"xhr": k, "input": R} = E;
                if (!k)
                    return;
                const U = getBodySize(R)
                  , H = k.getResponseHeader("content-length") ? parseContentLengthHeader(k.getResponseHeader("content-length")) : function _getBodySize(v, E) {
                    try {
                        return getBodySize("json" === E && v && "object" == typeof v ? JSON.stringify(v) : v)
                    } catch (v) {
                        return
                    }
                }(k.response, k.responseType);
                void 0 !== U && (v.data.request_body_size = U),
                void 0 !== H && (v.data.response_body_size = H)
            }
            function handleNetworkBreadcrumbs(v) {
                const E = build_esm_currentScopes_getClient();
                try {
                    const {"networkDetailAllowUrls": k, "networkDetailDenyUrls": R, "networkCaptureBodies": U, "networkRequestHeaders": H, "networkResponseHeaders": G} = v.getOptions()
                      , W = {
                        "replay": v,
                        "networkDetailAllowUrls": k,
                        "networkDetailDenyUrls": R,
                        "networkCaptureBodies": U,
                        "networkRequestHeaders": H,
                        "networkResponseHeaders": G
                    };
                    E && E.on("beforeAddBreadcrumb", ( (v, E) => function beforeAddNetworkBreadcrumb(v, E, k) {
                        if (!E.data)
                            return;
                        try {
                            (function _isXhrBreadcrumb(v) {
                                return "xhr" === v.category
                            }
                            )(E) && function _isXhrHint(v) {
                                return v && v.xhr
                            }(k) && (enrichXhrBreadcrumb(E, k),
                            captureXhrBreadcrumbToReplay(E, k, v)),
                            function _isFetchBreadcrumb(v) {
                                return "fetch" === v.category
                            }(E) && function _isFetchHint(v) {
                                return v && v.response
                            }(k) && (!function enrichFetchBreadcrumb(v, E) {
                                const {"input": k, "response": R} = E
                                  , U = getBodySize(k ? _getFetchRequestArgBody(k) : void 0)
                                  , H = R ? parseContentLengthHeader(R.headers.get("content-length")) : void 0;
                                void 0 !== U && (v.data.request_body_size = U),
                                void 0 !== H && (v.data.response_body_size = H)
                            }(E, k),
                            captureFetchBreadcrumbToReplay(E, k, v))
                        } catch (v) {
                            Oo && Mo.exception(v, "Error when enriching network breadcrumb")
                        }
                    }(W, v, E)))
                } catch (v) {}
            }
            function addGlobalListeners(v) {
                const E = build_esm_currentScopes_getClient();
                addClickKeypressInstrumentationHandler(handleDomListener(v)),
                addHistoryInstrumentationHandler(handleHistorySpanListener(v)),
                handleBreadcrumbs(v),
                handleNetworkBreadcrumbs(v);
                !function esm_exports_addEventProcessor(v) {
                    build_esm_currentScopes_getIsolationScope().addEventProcessor(v)
                }(handleGlobalEventListener(v)),
                E && (E.on("beforeSendEvent", handleBeforeSendEvent(v)),
                E.on("afterSendEvent", handleAfterSendEvent(v)),
                E.on("createDsc", (E => {
                    const k = v.getSessionId();
                    if (k && v.isEnabled() && "session" === v.recordingMode) {
                        v.checkAndHandleExpiredSession() && (E.replay_id = k)
                    }
                }
                )),
                E.on("spanStart", (E => {
                    v.lastActiveSpan = E
                }
                )),
                E.on("spanEnd", (E => {
                    v.lastActiveSpan = E
                }
                )),
                E.on("beforeSendFeedback", ( (E, k) => {
                    const R = v.getSessionId();
                    k && k.includeReplay && v.isEnabled() && R && E.contexts && E.contexts.feedback && (E.contexts.feedback.replay_id = R)
                }
                )))
            }
            function createMemoryEntry(v) {
                const {"jsHeapSizeLimit": E, "totalJSHeapSize": k, "usedJSHeapSize": R} = v
                  , U = Date.now() / 1e3;
                return {
                    "type": "memory",
                    "name": "memory",
                    "start": U,
                    "end": U,
                    "data": {
                        "memory": {
                            "jsHeapSizeLimit": E,
                            "totalJSHeapSize": k,
                            "usedJSHeapSize": R
                        }
                    }
                }
            }
            function getHandleRecordingEmit(v) {
                let E = !1;
                return (k, R) => {
                    if (!v.checkAndHandleExpiredSession())
                        return void (Oo && Mo.warn("Received replay event after session expired."));
                    const U = R || !E;
                    E = !0,
                    v.clickDetector && updateClickDetectorForRecordingEvent(v.clickDetector, k),
                    v.addUpdate(( () => {
                        if ("buffer" === v.recordingMode && U && v.setInitialState(),
                        !addEventSync(v, k, U))
                            return !0;
                        if (!U)
                            return !1;
                        if (function addSettingsEvent(v, E) {
                            if (!E || !v.session || 0 !== v.session.segmentId)
                                return;
                            addEventSync(v, function createOptionsEvent(v) {
                                const E = v.getOptions();
                                return {
                                    "type": yo.Custom,
                                    "timestamp": Date.now(),
                                    "data": {
                                        "tag": "options",
                                        "payload": {
                                            "shouldRecordCanvas": v.isRecordingCanvas(),
                                            "sessionSampleRate": E.sessionSampleRate,
                                            "errorSampleRate": E.errorSampleRate,
                                            "useCompressionOption": E.useCompression,
                                            "blockAllMedia": E.blockAllMedia,
                                            "maskAllText": E.maskAllText,
                                            "maskAllInputs": E.maskAllInputs,
                                            "useCompression": !!v.eventBuffer && "worker" === v.eventBuffer.type,
                                            "networkDetailHasUrls": E.networkDetailAllowUrls.length > 0,
                                            "networkCaptureBodies": E.networkCaptureBodies,
                                            "networkRequestHasHeaders": E.networkRequestHeaders.length > 0,
                                            "networkResponseHasHeaders": E.networkResponseHeaders.length > 0
                                        }
                                    }
                                }
                            }(v), !1)
                        }(v, U),
                        v.session && v.session.previousSessionId)
                            return !0;
                        if ("buffer" === v.recordingMode && v.session && v.eventBuffer) {
                            const E = v.eventBuffer.getEarliestTimestamp();
                            E && (Oo && Mo.info(`Updating session start time to earliest event in buffer to ${new Date(E)}`),
                            v.session.started = E,
                            v.getOptions().stickySession && saveSession(v.session))
                        }
                        return "session" === v.recordingMode && v.flush(),
                        !0
                    }
                    ))
                }
            }
            function createReplayEnvelope(v, E, k, R) {
                return function esm_envelope_createEnvelope(v, E=[]) {
                    return [v, E]
                }(function esm_envelope_createEventEnvelopeHeaders(v, E, k, R) {
                    const U = v.sdkProcessingMetadata && v.sdkProcessingMetadata.dynamicSamplingContext;
                    return {
                        "event_id": v.event_id,
                        "sent_at": (new Date).toISOString(),
                        ...E && {
                            "sdk": E
                        },
                        ...!!k && R && {
                            "dsn": esm_dsn_dsnToString(R)
                        },
                        ...U && {
                            "trace": node_modules_sentry_utils_build_esm_object_dropUndefinedKeys({
                                ...U
                            })
                        }
                    }
                }(v, function esm_envelope_getSdkMetadataForEnvelopeHeader(v) {
                    if (!v || !v.sdk)
                        return;
                    const {"name": E, "version": k} = v.sdk;
                    return {
                        "name": E,
                        "version": k
                    }
                }(v), R, k), [[{
                    "type": "replay_event"
                }, v], [{
                    "type": "replay_recording",
                    "length": "string" == typeof E ? (new TextEncoder).encode(E).length : E.length
                }, E]])
            }
            async function sendReplayRequest({"recordingData": v, "replayId": E, "segmentId": k, "eventContext": R, "timestamp": U, "session": H}) {
                const G = function prepareRecordingData({"recordingData": v, "headers": E}) {
                    let k;
                    const R = `${JSON.stringify(E)}\n`;
                    if ("string" == typeof v)
                        k = `${R}${v}`;
                    else {
                        const E = (new TextEncoder).encode(R);
                        k = new Uint8Array(E.length + v.length),
                        k.set(E),
                        k.set(v, E.length)
                    }
                    return k
                }({
                    "recordingData": v,
                    "headers": {
                        "segment_id": k
                    }
                })
                  , {"urls": W, "errorIds": Z, "traceIds": Y, "initialTimestamp": J} = R
                  , K = build_esm_currentScopes_getClient()
                  , X = build_esm_currentScopes_getCurrentScope()
                  , Q = K && K.getTransport()
                  , ee = K && K.getDsn();
                if (!(K && Q && ee && H.sampled))
                    return syncpromise_resolvedSyncPromise({});
                const te = {
                    "type": Wr,
                    "replay_start_timestamp": J / 1e3,
                    "timestamp": U / 1e3,
                    "error_ids": Z,
                    "trace_ids": Y,
                    "urls": W,
                    "replay_id": E,
                    "segment_id": k,
                    "replay_type": H.sampled
                }
                  , ne = await async function prepareReplayEvent({"client": v, "scope": E, "replayId": k, "event": R}) {
                    const U = {
                        "event_id": k,
                        "integrations": "object" != typeof v._integrations || null === v._integrations || Array.isArray(v._integrations) ? void 0 : Object.keys(v._integrations)
                    };
                    v.emit("preprocessEvent", R, U);
                    const H = await utils_prepareEvent_prepareEvent(v.getOptions(), R, U, E, v, build_esm_currentScopes_getIsolationScope());
                    if (!H)
                        return null;
                    H.platform = H.platform || "javascript";
                    const G = v.getSdkMetadata()
                      , {"name": W, "version": Z} = G && G.sdk || {};
                    return H.sdk = {
                        ...H.sdk,
                        "name": W || "sentry.javascript.unknown",
                        "version": Z || "0.0.0"
                    },
                    H
                }({
                    "scope": X,
                    "client": K,
                    "replayId": E,
                    "event": te
                });
                if (!ne)
                    return K.recordDroppedEvent("event_processor", "replay", te),
                    Oo && Mo.info("An event processor returned `null`, will not send event."),
                    syncpromise_resolvedSyncPromise({});
                delete ne.sdkProcessingMetadata;
                const re = createReplayEnvelope(ne, G, ee, K.getOptions().tunnel);
                let oe;
                try {
                    oe = await Q.send(re)
                } catch (v) {
                    const E = new Error(Zr);
                    try {
                        E.cause = v
                    } catch (v) {}
                    throw E
                }
                if ("number" == typeof oe.statusCode && (oe.statusCode < 200 || oe.statusCode >= 300))
                    throw new TransportStatusCodeError(oe.statusCode);
                const ie = ratelimit_updateRateLimits({}, oe);
                if (function ratelimit_isRateLimited(v, E, k=Date.now()) {
                    return function ratelimit_disabledUntil(v, E) {
                        return v[E] || v.all || 0
                    }(v, E) > k
                }(ie, "replay"))
                    throw new RateLimitError(ie);
                return oe
            }
            class TransportStatusCodeError extends Error {
                "constructor"(v) {
                    super(`Transport returned status code ${v}`)
                }
            }
            class RateLimitError extends Error {
                "constructor"(v) {
                    super("Rate limit hit"),
                    this.rateLimits = v
                }
            }
            async function sendReplay(v, E={
                "count": 0,
                "interval": 5e3
            }) {
                const {"recordingData": k, "options": R} = v;
                if (k.length)
                    try {
                        return await sendReplayRequest(v),
                        !0
                    } catch (k) {
                        if (k instanceof TransportStatusCodeError || k instanceof RateLimitError)
                            throw k;
                        if (function esm_exports_setContext(v, E) {
                            build_esm_currentScopes_getIsolationScope().setContext(v, E)
                        }("Replays", {
                            "_retryCount": E.count
                        }),
                        Oo && R._experiments && R._experiments.captureExceptions && esm_exports_captureException(k),
                        E.count >= 3) {
                            const v = new Error(`${Zr} - max retries exceeded`);
                            try {
                                v.cause = k
                            } catch (v) {}
                            throw v
                        }
                        return E.interval *= ++E.count,
                        new Promise(( (k, R) => {
                            getNativeImplementation_setTimeout((async () => {
                                try {
                                    await sendReplay(v, E),
                                    k(!0)
                                } catch (v) {
                                    R(v)
                                }
                            }
                            ), E.interval)
                        }
                        ))
                    }
            }
            const zo = "__THROTTLED";
            function throttle(v, E, k) {
                const R = new Map;
                let U = !1;
                return (...H) => {
                    const G = Math.floor(Date.now() / 1e3);
                    if ((v => {
                        const E = v - k;
                        R.forEach(( (v, k) => {
                            k < E && R.delete(k)
                        }
                        ))
                    }
                    )(G),
                    [...R.values()].reduce(( (v, E) => v + E), 0) >= E) {
                        const v = U;
                        return U = !0,
                        v ? "__SKIPPED" : zo
                    }
                    U = !1;
                    const W = R.get(G) || 0;
                    return R.set(G, W + 1),
                    v(...H)
                }
            }
            class ReplayContainer {
                "constructor"({"options": v, "recordingOptions": E}) {
                    ReplayContainer.prototype.__init.call(this),
                    ReplayContainer.prototype.__init2.call(this),
                    ReplayContainer.prototype.__init3.call(this),
                    ReplayContainer.prototype.__init4.call(this),
                    ReplayContainer.prototype.__init5.call(this),
                    ReplayContainer.prototype.__init6.call(this),
                    this.eventBuffer = null,
                    this.performanceEntries = [],
                    this.replayPerformanceEntries = [],
                    this.recordingMode = "session",
                    this.timeouts = {
                        "sessionIdlePause": 3e5,
                        "sessionIdleExpire": 9e5
                    },
                    this._lastActivity = Date.now(),
                    this._isEnabled = !1,
                    this._isPaused = !1,
                    this._requiresManualStart = !1,
                    this._hasInitializedCoreListeners = !1,
                    this._context = {
                        "errorIds": new Set,
                        "traceIds": new Set,
                        "urls": [],
                        "initialTimestamp": Date.now(),
                        "initialUrl": ""
                    },
                    this._recordingOptions = E,
                    this._options = v,
                    this._debouncedFlush = function debounce(v, E, k) {
                        let R, U, H;
                        const G = k && k.maxWait ? Math.max(k.maxWait, E) : 0;
                        function invokeFunc() {
                            return cancelTimers(),
                            R = v(),
                            R
                        }
                        function cancelTimers() {
                            void 0 !== U && clearTimeout(U),
                            void 0 !== H && clearTimeout(H),
                            U = H = void 0
                        }
                        function debounced() {
                            return U && clearTimeout(U),
                            U = getNativeImplementation_setTimeout(invokeFunc, E),
                            G && void 0 === H && (H = getNativeImplementation_setTimeout(invokeFunc, G)),
                            R
                        }
                        return debounced.cancel = cancelTimers,
                        debounced.flush = function flush() {
                            return void 0 !== U || void 0 !== H ? invokeFunc() : R
                        }
                        ,
                        debounced
                    }(( () => this._flush()), this._options.flushMinDelay, {
                        "maxWait": this._options.flushMaxDelay
                    }),
                    this._throttledAddEvent = throttle(( (v, E) => function addEvent(v, E, k) {
                        return shouldAddEvent(v, E) ? _addEvent(v, E, k) : Promise.resolve(null)
                    }(this, v, E)), 300, 5);
                    const {"slowClickTimeout": k, "slowClickIgnoreSelectors": R} = this.getOptions()
                      , U = k ? {
                        "threshold": Math.min(3e3, k),
                        "timeout": k,
                        "scrollTimeout": 300,
                        "ignoreSelector": R ? R.join(",") : ""
                    } : void 0;
                    if (U && (this.clickDetector = new ClickDetector(this,U)),
                    Oo) {
                        const E = v._experiments;
                        Mo.setConfig({
                            "captureExceptions": !!E.captureExceptions,
                            "traceInternals": !!E.traceInternals
                        })
                    }
                }
                "getContext"() {
                    return this._context
                }
                "isEnabled"() {
                    return this._isEnabled
                }
                "isPaused"() {
                    return this._isPaused
                }
                "isRecordingCanvas"() {
                    return Boolean(this._canvas)
                }
                "getOptions"() {
                    return this._options
                }
                "handleException"(v) {
                    Oo && Mo.exception(v)
                }
                "initializeSampling"(v) {
                    const {"errorSampleRate": E, "sessionSampleRate": k} = this._options
                      , R = E <= 0 && k <= 0;
                    this._requiresManualStart = R,
                    R || (this._initializeSessionForSampling(v),
                    this.session ? !1 !== this.session.sampled && (this.recordingMode = "buffer" === this.session.sampled && 0 === this.session.segmentId ? "buffer" : "session",
                    Oo && Mo.infoTick(`Starting replay in ${this.recordingMode} mode`),
                    this._initializeRecording()) : Oo && Mo.exception(new Error("Unable to initialize and create session")))
                }
                "start"() {
                    if (this._isEnabled && "session" === this.recordingMode)
                        return void (Oo && Mo.info("Recording is already in progress"));
                    if (this._isEnabled && "buffer" === this.recordingMode)
                        return void (Oo && Mo.info("Buffering is in progress, call `flush()` to save the replay"));
                    Oo && Mo.infoTick("Starting replay in session mode"),
                    this._updateUserActivity();
                    const v = loadOrCreateSession({
                        "maxReplayDuration": this._options.maxReplayDuration,
                        "sessionIdleExpire": this.timeouts.sessionIdleExpire
                    }, {
                        "stickySession": this._options.stickySession,
                        "sessionSampleRate": 1,
                        "allowBuffering": !1
                    });
                    this.session = v,
                    this._initializeRecording()
                }
                "startBuffering"() {
                    if (this._isEnabled)
                        return void (Oo && Mo.info("Buffering is in progress, call `flush()` to save the replay"));
                    Oo && Mo.infoTick("Starting replay in buffer mode");
                    const v = loadOrCreateSession({
                        "sessionIdleExpire": this.timeouts.sessionIdleExpire,
                        "maxReplayDuration": this._options.maxReplayDuration
                    }, {
                        "stickySession": this._options.stickySession,
                        "sessionSampleRate": 0,
                        "allowBuffering": !0
                    });
                    this.session = v,
                    this.recordingMode = "buffer",
                    this._initializeRecording()
                }
                "startRecording"() {
                    try {
                        const v = this._canvas;
                        this._stopRecording = record({
                            ...this._recordingOptions,
                            ..."buffer" === this.recordingMode && {
                                "checkoutEveryNms": 6e4
                            },
                            "emit": getHandleRecordingEmit(this),
                            "onMutation": this._onMutationHandler,
                            ...v ? {
                                "recordCanvas": v.recordCanvas,
                                "getCanvasManager": v.getCanvasManager,
                                "sampling": v.sampling,
                                "dataURLOptions": v.dataURLOptions
                            } : {}
                        })
                    } catch (v) {
                        this.handleException(v)
                    }
                }
                "stopRecording"() {
                    try {
                        return this._stopRecording && (this._stopRecording(),
                        this._stopRecording = void 0),
                        !0
                    } catch (v) {
                        return this.handleException(v),
                        !1
                    }
                }
                async "stop"({"forceFlush": v=!1, "reason": E}={}) {
                    if (this._isEnabled) {
                        this._isEnabled = !1;
                        try {
                            Oo && Mo.info("Stopping Replay" + (E ? ` triggered by ${E}` : "")),
                            this._removeListeners(),
                            this.stopRecording(),
                            this._debouncedFlush.cancel(),
                            v && await this._flush({
                                "force": !0
                            }),
                            this.eventBuffer && this.eventBuffer.destroy(),
                            this.eventBuffer = null,
                            clearSession(this)
                        } catch (v) {
                            this.handleException(v)
                        }
                    }
                }
                "pause"() {
                    this._isPaused || (this._isPaused = !0,
                    this.stopRecording(),
                    Oo && Mo.info("Pausing replay"))
                }
                "resume"() {
                    this._isPaused && this._checkSession() && (this._isPaused = !1,
                    this.startRecording(),
                    Oo && Mo.info("Resuming replay"))
                }
                async "sendBufferedReplayOrFlush"({"continueRecording": v=!0}={}) {
                    if ("session" === this.recordingMode)
                        return this.flushImmediate();
                    const E = Date.now();
                    Oo && Mo.info("Converting buffer to session"),
                    await this.flushImmediate();
                    const k = this.stopRecording();
                    v && k && "session" !== this.recordingMode && (this.recordingMode = "session",
                    this.session && (this._updateUserActivity(E),
                    this._updateSessionActivity(E),
                    this._maybeSaveSession()),
                    this.startRecording())
                }
                "addUpdate"(v) {
                    const E = v();
                    "buffer" !== this.recordingMode && !0 !== E && this._debouncedFlush()
                }
                "triggerUserActivity"() {
                    if (this._updateUserActivity(),
                    this._stopRecording)
                        this.checkAndHandleExpiredSession(),
                        this._updateSessionActivity();
                    else {
                        if (!this._checkSession())
                            return;
                        this.resume()
                    }
                }
                "updateUserActivity"() {
                    this._updateUserActivity(),
                    this._updateSessionActivity()
                }
                "conditionalFlush"() {
                    return "buffer" === this.recordingMode ? Promise.resolve() : this.flushImmediate()
                }
                "flush"() {
                    return this._debouncedFlush()
                }
                "flushImmediate"() {
                    return this._debouncedFlush(),
                    this._debouncedFlush.flush()
                }
                "cancelFlush"() {
                    this._debouncedFlush.cancel()
                }
                "getSessionId"() {
                    return this.session && this.session.id
                }
                "checkAndHandleExpiredSession"() {
                    if (!(this._lastActivity && isExpired(this._lastActivity, this.timeouts.sessionIdlePause) && this.session && "session" === this.session.sampled))
                        return !!this._checkSession();
                    this.pause()
                }
                "setInitialState"() {
                    const v = `${Gr.location.pathname}${Gr.location.hash}${Gr.location.search}`
                      , E = `${Gr.location.origin}${v}`;
                    this.performanceEntries = [],
                    this.replayPerformanceEntries = [],
                    this._clearContext(),
                    this._context.initialUrl = E,
                    this._context.initialTimestamp = Date.now(),
                    this._context.urls.push(E)
                }
                "throttledAddEvent"(v, E) {
                    const k = this._throttledAddEvent(v, E);
                    if (k === zo) {
                        const v = createBreadcrumb({
                            "category": "replay.throttled"
                        });
                        this.addUpdate(( () => !addEventSync(this, {
                            "type": 5,
                            "timestamp": v.timestamp || 0,
                            "data": {
                                "tag": "breadcrumb",
                                "payload": v,
                                "metric": !0
                            }
                        })))
                    }
                    return k
                }
                "getCurrentRoute"() {
                    const v = this.lastActiveSpan || spanUtils_getActiveSpan()
                      , E = v && spanUtils_getRootSpan(v)
                      , k = (E && utils_spanUtils_spanToJSON(E).data || {})[dr];
                    if (E && k && ["route", "custom"].includes(k))
                        return utils_spanUtils_spanToJSON(E).description
                }
                "_initializeRecording"() {
                    this.setInitialState(),
                    this._updateSessionActivity(),
                    this.eventBuffer = createEventBuffer({
                        "useCompression": this._options.useCompression,
                        "workerUrl": this._options.workerUrl
                    }),
                    this._removeListeners(),
                    this._addListeners(),
                    this._isEnabled = !0,
                    this._isPaused = !1,
                    this.startRecording()
                }
                "_initializeSessionForSampling"(v) {
                    const E = this._options.errorSampleRate > 0
                      , k = loadOrCreateSession({
                        "sessionIdleExpire": this.timeouts.sessionIdleExpire,
                        "maxReplayDuration": this._options.maxReplayDuration,
                        "previousSessionId": v
                    }, {
                        "stickySession": this._options.stickySession,
                        "sessionSampleRate": this._options.sessionSampleRate,
                        "allowBuffering": E
                    });
                    this.session = k
                }
                "_checkSession"() {
                    if (!this.session)
                        return !1;
                    const v = this.session;
                    return !shouldRefreshSession(v, {
                        "sessionIdleExpire": this.timeouts.sessionIdleExpire,
                        "maxReplayDuration": this._options.maxReplayDuration
                    }) || (this._refreshSession(v),
                    !1)
                }
                async "_refreshSession"(v) {
                    this._isEnabled && (await this.stop({
                        "reason": "refresh session"
                    }),
                    this.initializeSampling(v.id))
                }
                "_addListeners"() {
                    try {
                        Gr.document.addEventListener("visibilitychange", this._handleVisibilityChange),
                        Gr.addEventListener("blur", this._handleWindowBlur),
                        Gr.addEventListener("focus", this._handleWindowFocus),
                        Gr.addEventListener("keydown", this._handleKeyboardEvent),
                        this.clickDetector && this.clickDetector.addListeners(),
                        this._hasInitializedCoreListeners || (addGlobalListeners(this),
                        this._hasInitializedCoreListeners = !0)
                    } catch (v) {
                        this.handleException(v)
                    }
                    this._performanceCleanupCallback = function setupPerformanceObserver(v) {
                        function addPerformanceEntry(E) {
                            v.performanceEntries.includes(E) || v.performanceEntries.push(E)
                        }
                        function onEntries({"entries": v}) {
                            v.forEach(addPerformanceEntry)
                        }
                        const E = [];
                        return ["navigation", "paint", "resource"].forEach((v => {
                            E.push(addPerformanceInstrumentationHandler(v, onEntries))
                        }
                        )),
                        E.push(addLcpInstrumentationHandler(webVitalHandler(getLargestContentfulPaint, v)), addClsInstrumentationHandler(webVitalHandler(getCumulativeLayoutShift, v)), addFidInstrumentationHandler(webVitalHandler(getFirstInputDelay, v)), addInpInstrumentationHandler(webVitalHandler(getInteractionToNextPaint, v))),
                        () => {
                            E.forEach((v => v()))
                        }
                    }(this)
                }
                "_removeListeners"() {
                    try {
                        Gr.document.removeEventListener("visibilitychange", this._handleVisibilityChange),
                        Gr.removeEventListener("blur", this._handleWindowBlur),
                        Gr.removeEventListener("focus", this._handleWindowFocus),
                        Gr.removeEventListener("keydown", this._handleKeyboardEvent),
                        this.clickDetector && this.clickDetector.removeListeners(),
                        this._performanceCleanupCallback && this._performanceCleanupCallback()
                    } catch (v) {
                        this.handleException(v)
                    }
                }
                "__init"() {
                    this._handleVisibilityChange = () => {
                        "visible" === Gr.document.visibilityState ? this._doChangeToForegroundTasks() : this._doChangeToBackgroundTasks()
                    }
                }
                "__init2"() {
                    this._handleWindowBlur = () => {
                        const v = createBreadcrumb({
                            "category": "ui.blur"
                        });
                        this._doChangeToBackgroundTasks(v)
                    }
                }
                "__init3"() {
                    this._handleWindowFocus = () => {
                        const v = createBreadcrumb({
                            "category": "ui.focus"
                        });
                        this._doChangeToForegroundTasks(v)
                    }
                }
                "__init4"() {
                    this._handleKeyboardEvent = v => {
                        handleKeyboardEvent(this, v)
                    }
                }
                "_doChangeToBackgroundTasks"(v) {
                    if (!this.session)
                        return;
                    isSessionExpired(this.session, {
                        "maxReplayDuration": this._options.maxReplayDuration,
                        "sessionIdleExpire": this.timeouts.sessionIdleExpire
                    }) || (v && this._createCustomBreadcrumb(v),
                    this.conditionalFlush())
                }
                "_doChangeToForegroundTasks"(v) {
                    if (!this.session)
                        return;
                    this.checkAndHandleExpiredSession() ? v && this._createCustomBreadcrumb(v) : Oo && Mo.info("Document has become active, but session has expired")
                }
                "_updateUserActivity"(v=Date.now()) {
                    this._lastActivity = v
                }
                "_updateSessionActivity"(v=Date.now()) {
                    this.session && (this.session.lastActivity = v,
                    this._maybeSaveSession())
                }
                "_createCustomBreadcrumb"(v) {
                    this.addUpdate(( () => {
                        this.throttledAddEvent({
                            "type": yo.Custom,
                            "timestamp": v.timestamp || 0,
                            "data": {
                                "tag": "breadcrumb",
                                "payload": v
                            }
                        })
                    }
                    ))
                }
                "_addPerformanceEntries"() {
                    const v = function createPerformanceEntries(v) {
                        return v.map(createPerformanceEntry).filter(Boolean)
                    }(this.performanceEntries).concat(this.replayPerformanceEntries);
                    return this.performanceEntries = [],
                    this.replayPerformanceEntries = [],
                    Promise.all(createPerformanceSpans(this, v))
                }
                "_clearContext"() {
                    this._context.errorIds.clear(),
                    this._context.traceIds.clear(),
                    this._context.urls = []
                }
                "_updateInitialTimestampFromEventBuffer"() {
                    const {"session": v, "eventBuffer": E} = this;
                    if (!v || !E || this._requiresManualStart)
                        return;
                    if (v.segmentId)
                        return;
                    const k = E.getEarliestTimestamp();
                    k && k < this._context.initialTimestamp && (this._context.initialTimestamp = k)
                }
                "_popEventContext"() {
                    const v = {
                        "initialTimestamp": this._context.initialTimestamp,
                        "initialUrl": this._context.initialUrl,
                        "errorIds": Array.from(this._context.errorIds),
                        "traceIds": Array.from(this._context.traceIds),
                        "urls": this._context.urls
                    };
                    return this._clearContext(),
                    v
                }
                async "_runFlush"() {
                    const v = this.getSessionId();
                    if (this.session && this.eventBuffer && v) {
                        if (await this._addPerformanceEntries(),
                        this.eventBuffer && this.eventBuffer.hasEvents && (await async function addMemoryEntry(v) {
                            try {
                                return Promise.all(createPerformanceSpans(v, [createMemoryEntry(Gr.performance.memory)]))
                            } catch (v) {
                                return []
                            }
                        }(this),
                        this.eventBuffer && v === this.getSessionId()))
                            try {
                                this._updateInitialTimestampFromEventBuffer();
                                const E = Date.now();
                                if (E - this._context.initialTimestamp > this._options.maxReplayDuration + 3e4)
                                    throw new Error("Session is too long, not sending replay");
                                const k = this._popEventContext()
                                  , R = this.session.segmentId++;
                                this._maybeSaveSession();
                                const U = await this.eventBuffer.finish();
                                await sendReplay({
                                    "replayId": v,
                                    "recordingData": U,
                                    "segmentId": R,
                                    "eventContext": k,
                                    "session": this.session,
                                    "options": this.getOptions(),
                                    "timestamp": E
                                })
                            } catch (v) {
                                this.handleException(v),
                                this.stop({
                                    "reason": "sendReplay"
                                });
                                const E = build_esm_currentScopes_getClient();
                                E && E.recordDroppedEvent("send_error", "replay")
                            }
                    } else
                        Oo && Mo.error("No session or eventBuffer found to flush.")
                }
                "__init5"() {
                    this._flush = async ({"force": v=!1}={}) => {
                        if (!this._isEnabled && !v)
                            return;
                        if (!this.checkAndHandleExpiredSession())
                            return void (Oo && Mo.error("Attempting to finish replay event after session expired."));
                        if (!this.session)
                            return;
                        const E = this.session.started
                          , k = Date.now() - E;
                        this._debouncedFlush.cancel();
                        const R = k < this._options.minReplayDuration
                          , U = k > this._options.maxReplayDuration + 5e3;
                        if (R || U)
                            return Oo && Mo.info(`Session duration (${Math.floor(k / 1e3)}s) is too ${R ? "short" : "long"}, not sending replay.`),
                            void (R && this._debouncedFlush());
                        const H = this.eventBuffer;
                        if (H && 0 === this.session.segmentId && !H.hasCheckout && Oo && Mo.info("Flushing initial segment without checkout."),
                        !this._flushLock)
                            return this._flushLock = this._runFlush(),
                            await this._flushLock,
                            void (this._flushLock = void 0);
                        try {
                            await this._flushLock
                        } catch (v) {
                            Oo && Mo.error(v)
                        } finally {
                            this._debouncedFlush()
                        }
                    }
                }
                "_maybeSaveSession"() {
                    this.session && this._options.stickySession && saveSession(this.session)
                }
                "__init6"() {
                    this._onMutationHandler = v => {
                        const E = v.length
                          , k = this._options.mutationLimit
                          , R = k && E > k;
                        if (E > this._options.mutationBreadcrumbLimit || R) {
                            const v = createBreadcrumb({
                                "category": "replay.mutations",
                                "data": {
                                    "count": E,
                                    "limit": R
                                }
                            });
                            this._createCustomBreadcrumb(v)
                        }
                        return !R || (this.stop({
                            "reason": "mutationLimit",
                            "forceFlush": "session" === this.recordingMode
                        }),
                        !1)
                    }
                }
            }
            function getOption(v, E) {
                return [...v, ...E].join(",")
            }
            const qo = 'img,image,svg,video,object,picture,embed,map,audio,link[rel="icon"],link[rel="apple-touch-icon"]'
              , Go = ["content-length", "content-type", "accept"];
            let Vo = !1;
            const replayIntegration = v => new Replay(v);
            class Replay {
                static "__initStatic"() {
                    this.id = "Replay"
                }
                "constructor"({"flushMinDelay": v=5e3, "flushMaxDelay": E=5500, "minReplayDuration": k=4999, "maxReplayDuration": R=36e5, "stickySession": U=!0, "useCompression": H=!0, "workerUrl": G, "_experiments": W={}, "maskAllText": Z=!0, "maskAllInputs": Y=!0, "blockAllMedia": J=!0, "mutationBreadcrumbLimit": K=750, "mutationLimit": X=1e4, "slowClickTimeout": Q=7e3, "slowClickIgnoreSelectors": ee=[], "networkDetailAllowUrls": te=[], "networkDetailDenyUrls": ne=[], "networkCaptureBodies": re=!0, "networkRequestHeaders": oe=[], "networkResponseHeaders": ie=[], "mask": ae=[], "maskAttributes": se=["title", "placeholder"], "unmask": ce=[], "block": le=[], "unblock": ue=[], "ignore": de=[], "maskFn": pe, "beforeAddRecordingEvent": fe, "beforeErrorSampling": he}={}) {
                    this.name = Replay.id;
                    const me = function getPrivacyOptions({"mask": v, "unmask": E, "block": k, "unblock": R, "ignore": U}) {
                        return {
                            "maskTextSelector": getOption(v, [".sentry-mask", "[data-sentry-mask]"]),
                            "unmaskTextSelector": getOption(E, []),
                            "blockSelector": getOption(k, [".sentry-block", "[data-sentry-block]", 'base[href="/"]']),
                            "unblockSelector": getOption(R, []),
                            "ignoreSelector": getOption(U, [".sentry-ignore", "[data-sentry-ignore]", 'input[type="file"]'])
                        }
                    }({
                        "mask": ae,
                        "unmask": ce,
                        "block": le,
                        "unblock": ue,
                        "ignore": de
                    });
                    if (this._recordingOptions = {
                        "maskAllInputs": Y,
                        "maskAllText": Z,
                        "maskInputOptions": {
                            "password": !0
                        },
                        "maskTextFn": pe,
                        "maskInputFn": pe,
                        "maskAttributeFn": (v, E, k) => function maskAttribute({"el": v, "key": E, "maskAttributes": k, "maskAllText": R, "privacyOptions": U, "value": H}) {
                            return R ? U.unmaskTextSelector && v.matches(U.unmaskTextSelector) ? H : k.includes(E) || "value" === E && "INPUT" === v.tagName && ["submit", "button"].includes(v.getAttribute("type") || "") ? H.replace(/[\S]/g, "*") : H : H
                        }({
                            "maskAttributes": se,
                            "maskAllText": Z,
                            "privacyOptions": me,
                            "key": v,
                            "value": E,
                            "el": k
                        }),
                        ...me,
                        "slimDOMOptions": "all",
                        "inlineStylesheet": !0,
                        "inlineImages": !1,
                        "collectFonts": !0,
                        "errorHandler": v => {
                            try {
                                v.__rrweb__ = !0
                            } catch (v) {}
                        }
                    },
                    this._initialOptions = {
                        "flushMinDelay": v,
                        "flushMaxDelay": E,
                        "minReplayDuration": Math.min(k, 15e3),
                        "maxReplayDuration": Math.min(R, Xr),
                        "stickySession": U,
                        "useCompression": H,
                        "workerUrl": G,
                        "blockAllMedia": J,
                        "maskAllInputs": Y,
                        "maskAllText": Z,
                        "mutationBreadcrumbLimit": K,
                        "mutationLimit": X,
                        "slowClickTimeout": Q,
                        "slowClickIgnoreSelectors": ee,
                        "networkDetailAllowUrls": te,
                        "networkDetailDenyUrls": ne,
                        "networkCaptureBodies": re,
                        "networkRequestHeaders": _getMergedNetworkHeaders(oe),
                        "networkResponseHeaders": _getMergedNetworkHeaders(ie),
                        "beforeAddRecordingEvent": fe,
                        "beforeErrorSampling": he,
                        "_experiments": W
                    },
                    this._initialOptions.blockAllMedia && (this._recordingOptions.blockSelector = this._recordingOptions.blockSelector ? `${this._recordingOptions.blockSelector},${qo}` : qo),
                    this._isInitialized && isBrowser())
                        throw new Error("Multiple Sentry Session Replay instances are not supported");
                    this._isInitialized = !0
                }
                get "_isInitialized"() {
                    return Vo
                }
                set "_isInitialized"(v) {
                    Vo = v
                }
                "afterAllSetup"(v) {
                    isBrowser() && !this._replay && (this._setup(v),
                    this._initialize(v))
                }
                "start"() {
                    this._replay && this._replay.start()
                }
                "startBuffering"() {
                    this._replay && this._replay.startBuffering()
                }
                "stop"() {
                    return this._replay ? this._replay.stop({
                        "forceFlush": "session" === this._replay.recordingMode
                    }) : Promise.resolve()
                }
                "flush"(v) {
                    return this._replay ? this._replay.isEnabled() ? this._replay.sendBufferedReplayOrFlush(v) : (this._replay.start(),
                    Promise.resolve()) : Promise.resolve()
                }
                "getReplayId"() {
                    if (this._replay && this._replay.isEnabled())
                        return this._replay.getSessionId()
                }
                "_initialize"(v) {
                    this._replay && (this._maybeLoadFromReplayCanvasIntegration(v),
                    this._replay.initializeSampling())
                }
                "_setup"(v) {
                    const E = function loadReplayOptionsFromClient(v, E) {
                        const k = E.getOptions()
                          , R = {
                            "sessionSampleRate": 0,
                            "errorSampleRate": 0,
                            ...node_modules_sentry_utils_build_esm_object_dropUndefinedKeys(v)
                        }
                          , U = parseSampleRate_parseSampleRate(k.replaysSessionSampleRate)
                          , H = parseSampleRate_parseSampleRate(k.replaysOnErrorSampleRate);
                        null == U && null == H && utils_build_esm_logger_consoleSandbox(( () => {
                            console.warn("Replay is disabled because neither `replaysSessionSampleRate` nor `replaysOnErrorSampleRate` are set.")
                        }
                        ));
                        null != U && (R.sessionSampleRate = U);
                        null != H && (R.errorSampleRate = H);
                        return R
                    }(this._initialOptions, v);
                    this._replay = new ReplayContainer({
                        "options": E,
                        "recordingOptions": this._recordingOptions
                    })
                }
                "_maybeLoadFromReplayCanvasIntegration"(v) {
                    try {
                        const E = v.getIntegrationByName("ReplayCanvas");
                        if (!E)
                            return;
                        this._replay._canvas = E.getOptions()
                    } catch (v) {}
                }
            }
            function _getMergedNetworkHeaders(v) {
                return [...Go, ...v.map((v => v.toLowerCase()))]
            }
            function getReplay() {
                const v = build_esm_currentScopes_getClient();
                return v && v.getIntegrationByName("Replay")
            }
            function _optionalChain_optionalChain(v) {
                let E, k = v[0], R = 1;
                for (; R < v.length; ) {
                    const U = v[R]
                      , H = v[R + 1];
                    if (R += 2,
                    ("optionalAccess" === U || "optionalCall" === U) && null == k)
                        return;
                    "access" === U || "optionalAccess" === U ? (E = k,
                    k = H(k)) : "call" !== U && "optionalCall" !== U || (k = H(( (...v) => k.call(E, ...v))),
                    E = void 0)
                }
                return k
            }
            Replay.__initStatic();
            var Wo;
            function esm_distanceToMatch(v, E, k=1 / 0, R=0) {
                return v ? v.nodeType !== v.ELEMENT_NODE || R > k ? -1 : E(v) ? R : esm_distanceToMatch(v.parentNode, E, k, R + 1) : -1
            }
            function esm_createMatchPredicate(v, E) {
                return k => {
                    const R = k;
                    if (null === R)
                        return !1;
                    try {
                        if (v)
                            if ("string" == typeof v) {
                                if (R.matches(`.${v}`))
                                    return !0
                            } else if (function esm_elementClassMatchesRegex(v, E) {
                                for (let k = v.classList.length; k--; ) {
                                    const R = v.classList[k];
                                    if (E.test(R))
                                        return !0
                                }
                                return !1
                            }(R, v))
                                return !0;
                        return !(!E || !R.matches(E))
                    } catch (v) {
                        return !1
                    }
                }
            }
            !function(v) {
                v[v.Document = 0] = "Document",
                v[v.DocumentType = 1] = "DocumentType",
                v[v.Element = 2] = "Element",
                v[v.Text = 3] = "Text",
                v[v.CDATA = 4] = "CDATA",
                v[v.Comment = 5] = "Comment"
            }(Wo || (Wo = {}));
            const Zo = "Please stop import mirror directly. Instead of that,\r\nnow you can use replayer.getMirror() to access the mirror instance of a replayer,\r\nor you can use record.mirror to access the mirror instance during recording.";
            let Yo = {
                "map": {},
                "getId"() {
                    return console.error(Zo),
                    -1
                },
                "getNode"() {
                    return console.error(Zo),
                    null
                },
                "removeNodeFromMap"() {
                    console.error(Zo)
                },
                "has"() {
                    return console.error(Zo),
                    !1
                },
                "reset"() {
                    console.error(Zo)
                }
            };
            function esm_hookSetter(v, E, k, R, U=window) {
                const H = U.Object.getOwnPropertyDescriptor(v, E);
                return U.Object.defineProperty(v, E, R ? k : {
                    "set"(v) {
                        esm_setTimeout(( () => {
                            k.set.call(this, v)
                        }
                        ), 0),
                        H && H.set && H.set.call(this, v)
                    }
                }),
                () => esm_hookSetter(v, E, H || {}, !0)
            }
            function esm_patch(v, E, k) {
                try {
                    if (!(E in v))
                        return () => {}
                        ;
                    const R = v[E]
                      , U = k(R);
                    return "function" == typeof U && (U.prototype = U.prototype || {},
                    Object.defineProperties(U, {
                        "__rrweb_original__": {
                            "enumerable": !1,
                            "value": R
                        }
                    })),
                    v[E] = U,
                    () => {
                        v[E] = R
                    }
                } catch (v) {
                    return () => {}
                }
            }
            function esm_isBlocked(v, E, k, R, U) {
                if (!v)
                    return !1;
                const H = function esm_closestElementOfNode(v) {
                    return v ? v.nodeType === v.ELEMENT_NODE ? v : v.parentElement : null
                }(v);
                if (!H)
                    return !1;
                const G = esm_createMatchPredicate(E, k);
                if (!U) {
                    const v = R && H.matches(R);
                    return G(H) && !v
                }
                const W = esm_distanceToMatch(H, G);
                let Z = -1;
                return !(W < 0) && (R && (Z = esm_distanceToMatch(H, esm_createMatchPredicate(null, R))),
                W > -1 && Z < 0 || W < Z)
            }
            "undefined" != typeof window && window.Proxy && window.Reflect && (Yo = new Proxy(Yo,{
                "get"(v, E, k) {
                    return "map" === E && console.error(Zo),
                    Reflect.get(v, E, k)
                }
            })),
            /[1-9][0-9]{12}/.test(Date.now().toString());
            const Jo = {};
            function esm_getImplementation(v) {
                const E = Jo[v];
                if (E)
                    return E;
                const k = window.document;
                let R = window[v];
                if (k && "function" == typeof k.createElement)
                    try {
                        const E = k.createElement("iframe");
                        E.hidden = !0,
                        k.head.appendChild(E);
                        const U = E.contentWindow;
                        U && U[v] && (R = U[v]),
                        k.head.removeChild(E)
                    } catch (v) {}
                return Jo[v] = R.bind(window)
            }
            function esm_onRequestAnimationFrame(...v) {
                return esm_getImplementation("requestAnimationFrame")(...v)
            }
            function esm_setTimeout(...v) {
                return esm_getImplementation("setTimeout")(...v)
            }
            var Ko = (v => (v[v["2D"] = 0] = "2D",
            v[v.WebGL = 1] = "WebGL",
            v[v.WebGL2 = 2] = "WebGL2",
            v))(Ko || {});
            let Xo;
            const esm_callbackWrapper = v => {
                if (!Xo)
                    return v;
                return (...E) => {
                    try {
                        return v(...E)
                    } catch (v) {
                        if (Xo && !0 === Xo(v))
                            return () => {}
                            ;
                        throw v
                    }
                }
            }
            ;
            for (var Qo = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", ei = "undefined" == typeof Uint8Array ? [] : new Uint8Array(256), ti = 0; ti < 64; ti++)
                ei[Qo.charCodeAt(ti)] = ti;
            const ni = new Map;
            const saveWebGLVar = (v, E, k) => {
                if (!v || !isInstanceOfWebGLObject(v, E) && "object" != typeof v)
                    return;
                const R = function variableListFor(v, E) {
                    let k = ni.get(v);
                    return k || (k = new Map,
                    ni.set(v, k)),
                    k.has(E) || k.set(E, []),
                    k.get(E)
                }(k, v.constructor.name);
                let U = R.indexOf(v);
                return -1 === U && (U = R.length,
                R.push(v)),
                U
            }
            ;
            function serializeArg(v, E, k) {
                if (v instanceof Array)
                    return v.map((v => serializeArg(v, E, k)));
                if (null === v)
                    return v;
                if (v instanceof Float32Array || v instanceof Float64Array || v instanceof Int32Array || v instanceof Uint32Array || v instanceof Uint8Array || v instanceof Uint16Array || v instanceof Int16Array || v instanceof Int8Array || v instanceof Uint8ClampedArray) {
                    return {
                        "rr_type": v.constructor.name,
                        "args": [Object.values(v)]
                    }
                }
                if (v instanceof ArrayBuffer) {
                    const E = v.constructor.name
                      , k = function(v) {
                        var E, k = new Uint8Array(v), R = k.length, U = "";
                        for (E = 0; E < R; E += 3)
                            U += Qo[k[E] >> 2],
                            U += Qo[(3 & k[E]) << 4 | k[E + 1] >> 4],
                            U += Qo[(15 & k[E + 1]) << 2 | k[E + 2] >> 6],
                            U += Qo[63 & k[E + 2]];
                        return R % 3 == 2 ? U = U.substring(0, U.length - 1) + "=" : R % 3 == 1 && (U = U.substring(0, U.length - 2) + "=="),
                        U
                    }(v);
                    return {
                        "rr_type": E,
                        "base64": k
                    }
                }
                if (v instanceof DataView) {
                    return {
                        "rr_type": v.constructor.name,
                        "args": [serializeArg(v.buffer, E, k), v.byteOffset, v.byteLength]
                    }
                }
                if (v instanceof HTMLImageElement) {
                    const E = v.constructor.name
                      , {"src": k} = v;
                    return {
                        "rr_type": E,
                        "src": k
                    }
                }
                if (v instanceof HTMLCanvasElement) {
                    return {
                        "rr_type": "HTMLImageElement",
                        "src": v.toDataURL()
                    }
                }
                if (v instanceof ImageData) {
                    return {
                        "rr_type": v.constructor.name,
                        "args": [serializeArg(v.data, E, k), v.width, v.height]
                    }
                }
                if (isInstanceOfWebGLObject(v, E) || "object" == typeof v) {
                    return {
                        "rr_type": v.constructor.name,
                        "index": saveWebGLVar(v, E, k)
                    }
                }
                return v
            }
            const serializeArgs = (v, E, k) => v.map((v => serializeArg(v, E, k)))
              , isInstanceOfWebGLObject = (v, E) => {
                const k = ["WebGLActiveInfo", "WebGLBuffer", "WebGLFramebuffer", "WebGLProgram", "WebGLRenderbuffer", "WebGLShader", "WebGLShaderPrecisionFormat", "WebGLTexture", "WebGLUniformLocation", "WebGLVertexArrayObject", "WebGLVertexArrayObjectOES"].filter((v => "function" == typeof E[v]));
                return Boolean(k.find((k => v instanceof E[k])))
            }
            ;
            function initCanvasContextObserver(v, E, k, R, U) {
                const H = [];
                try {
                    const G = esm_patch(v.HTMLCanvasElement.prototype, "getContext", (function(v) {
                        return function(H, ...G) {
                            if (!esm_isBlocked(this, E, k, R, !0)) {
                                const v = function getNormalizedContextName(v) {
                                    return "experimental-webgl" === v ? "webgl" : v
                                }(H);
                                if ("__context"in this || (this.__context = v),
                                U && ["webgl", "webgl2"].includes(v))
                                    if (G[0] && "object" == typeof G[0]) {
                                        const v = G[0];
                                        v.preserveDrawingBuffer || (v.preserveDrawingBuffer = !0)
                                    } else
                                        G.splice(0, 1, {
                                            "preserveDrawingBuffer": !0
                                        })
                            }
                            return v.apply(this, [H, ...G])
                        }
                    }
                    ));
                    H.push(G)
                } catch (v) {
                    console.error("failed to patch HTMLCanvasElement.prototype.getContext")
                }
                return () => {
                    H.forEach((v => v()))
                }
            }
            function patchGLPrototype(v, E, k, R, U, H, G, W) {
                const Z = []
                  , Y = Object.getOwnPropertyNames(v);
                for (const G of Y)
                    if (!["isContextLost", "canvas", "drawingBufferWidth", "drawingBufferHeight"].includes(G))
                        try {
                            if ("function" != typeof v[G])
                                continue;
                            const Y = esm_patch(v, G, (function(v) {
                                return function(...Z) {
                                    const Y = v.apply(this, Z);
                                    if (saveWebGLVar(Y, W, this),
                                    "tagName"in this.canvas && !esm_isBlocked(this.canvas, R, U, H, !0)) {
                                        const v = serializeArgs(Z, W, this)
                                          , R = {
                                            "type": E,
                                            "property": G,
                                            "args": v
                                        };
                                        k(this.canvas, R)
                                    }
                                    return Y
                                }
                            }
                            ));
                            Z.push(Y)
                        } catch (R) {
                            const U = esm_hookSetter(v, G, {
                                "set"(v) {
                                    k(this.canvas, {
                                        "type": E,
                                        "property": G,
                                        "args": [v],
                                        "setter": !0
                                    })
                                }
                            });
                            Z.push(U)
                        }
                return Z
            }
            class CanvasManager {
                "reset"() {
                    this.pendingCanvasMutations.clear(),
                    this.restoreHandlers.forEach((v => {
                        try {
                            v()
                        } catch (v) {}
                    }
                    )),
                    this.restoreHandlers = [],
                    this.windowsSet = new WeakSet,
                    this.windows = [],
                    this.shadowDoms = new Set,
                    _optionalChain_optionalChain([this, "access", v => v.worker, "optionalAccess", v => v.terminate, "call", v => v()]),
                    this.worker = null,
                    this.snapshotInProgressMap = new Map,
                    (this.options.recordCanvas && "number" == typeof this.options.sampling || this.options.enableManualSnapshot) && (this.worker = this.initFPSWorker())
                }
                "freeze"() {
                    this.frozen = !0
                }
                "unfreeze"() {
                    this.frozen = !1
                }
                "lock"() {
                    this.locked = !0
                }
                "unlock"() {
                    this.locked = !1
                }
                "constructor"(v) {
                    this.pendingCanvasMutations = new Map,
                    this.rafStamps = {
                        "latestId": 0,
                        "invokeId": null
                    },
                    this.shadowDoms = new Set,
                    this.windowsSet = new WeakSet,
                    this.windows = [],
                    this.restoreHandlers = [],
                    this.frozen = !1,
                    this.locked = !1,
                    this.snapshotInProgressMap = new Map,
                    this.worker = null,
                    this.processMutation = (v, E) => {
                        !(this.rafStamps.invokeId && this.rafStamps.latestId !== this.rafStamps.invokeId) && this.rafStamps.invokeId || (this.rafStamps.invokeId = this.rafStamps.latestId),
                        this.pendingCanvasMutations.has(v) || this.pendingCanvasMutations.set(v, []),
                        this.pendingCanvasMutations.get(v).push(E)
                    }
                    ;
                    const {"sampling": E="all", "win": k, "blockClass": R, "blockSelector": U, "unblockSelector": H, "maxCanvasSize": G, "recordCanvas": W, "dataURLOptions": Z, "errorHandler": Y} = v;
                    this.mutationCb = v.mutationCb,
                    this.mirror = v.mirror,
                    this.options = v,
                    Y && function esm_registerErrorHandler(v) {
                        Xo = v
                    }(Y),
                    (W && "number" == typeof E || v.enableManualSnapshot) && (this.worker = this.initFPSWorker()),
                    this.addWindow(k),
                    v.enableManualSnapshot || esm_callbackWrapper(( () => {
                        W && "all" === E && (this.startRAFTimestamping(),
                        this.startPendingCanvasMutationFlusher()),
                        W && "number" == typeof E && this.initCanvasFPSObserver(E, R, U, H, G, {
                            "dataURLOptions": Z
                        })
                    }
                    ))()
                }
                "addWindow"(v) {
                    const {"sampling": E="all", "blockClass": k, "blockSelector": R, "unblockSelector": U, "recordCanvas": H, "enableManualSnapshot": G} = this.options;
                    if (!this.windowsSet.has(v)) {
                        if (G)
                            return this.windowsSet.add(v),
                            void this.windows.push(new WeakRef(v));
                        esm_callbackWrapper(( () => {
                            if (H && "all" === E && this.initCanvasMutationObserver(v, k, R, U),
                            H && "number" == typeof E) {
                                const E = initCanvasContextObserver(v, k, R, U, !0);
                                this.restoreHandlers.push(( () => {
                                    E()
                                }
                                ))
                            }
                        }
                        ))(),
                        this.windowsSet.add(v),
                        this.windows.push(new WeakRef(v))
                    }
                }
                "addShadowRoot"(v) {
                    this.shadowDoms.add(new WeakRef(v))
                }
                "resetShadowRoots"() {
                    this.shadowDoms = new Set
                }
                "initFPSWorker"() {
                    const v = new Worker(function t() {
                        const v = new Blob(['for(var e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",t="undefined"==typeof Uint8Array?[]:new Uint8Array(256),a=0;a<64;a++)t[e.charCodeAt(a)]=a;var n=function(t){var a,n=new Uint8Array(t),r=n.length,s="";for(a=0;a<r;a+=3)s+=e[n[a]>>2],s+=e[(3&n[a])<<4|n[a+1]>>4],s+=e[(15&n[a+1])<<2|n[a+2]>>6],s+=e[63&n[a+2]];return r%3==2?s=s.substring(0,s.length-1)+"=":r%3==1&&(s=s.substring(0,s.length-2)+"=="),s};const r=new Map,s=new Map;const i=self;i.onmessage=async function(e){if(!("OffscreenCanvas"in globalThis))return i.postMessage({id:e.data.id});{const{id:t,bitmap:a,width:o,height:f,maxCanvasSize:c,dataURLOptions:g}=e.data,u=async function(e,t,a){const r=e+"-"+t;if("OffscreenCanvas"in globalThis){if(s.has(r))return s.get(r);const i=new OffscreenCanvas(e,t);i.getContext("2d");const o=await i.convertToBlob(a),f=await o.arrayBuffer(),c=n(f);return s.set(r,c),c}return""}(o,f,g),[h,d]=function(e,t,a){if(!a)return[e,t];const[n,r]=a;if(e<=n&&t<=r)return[e,t];let s=e,i=t;return s>n&&(i=Math.floor(n*t/e),s=n),i>r&&(s=Math.floor(r*e/t),i=r),[s,i]}(o,f,c),l=new OffscreenCanvas(h,d),w=l.getContext("bitmaprenderer"),p=h===o&&d===f?a:await createImageBitmap(a,{resizeWidth:h,resizeHeight:d,resizeQuality:"low"});w.transferFromImageBitmap(p),a.close();const y=await l.convertToBlob(g),v=y.type,b=await y.arrayBuffer(),m=n(b);if(p.close(),!r.has(t)&&await u===m)return r.set(t,m),i.postMessage({id:t});if(r.get(t)===m)return i.postMessage({id:t});i.postMessage({id:t,type:v,base64:m,width:o,height:f}),r.set(t,m)}};']);
                        return URL.createObjectURL(v)
                    }());
                    return v.onmessage = v => {
                        const E = v.data
                          , {"id": k} = E;
                        if (this.snapshotInProgressMap.set(k, !1),
                        !("base64"in E))
                            return;
                        const {"base64": R, "type": U, "width": H, "height": G} = E;
                        this.mutationCb({
                            "id": k,
                            "type": Ko["2D"],
                            "commands": [{
                                "property": "clearRect",
                                "args": [0, 0, H, G]
                            }, {
                                "property": "drawImage",
                                "args": [{
                                    "rr_type": "ImageBitmap",
                                    "args": [{
                                        "rr_type": "Blob",
                                        "data": [{
                                            "rr_type": "ArrayBuffer",
                                            "base64": R
                                        }],
                                        "type": U
                                    }]
                                }, 0, 0, H, G]
                            }]
                        })
                    }
                    ,
                    v
                }
                "initCanvasFPSObserver"(v, E, k, R, U, H) {
                    const G = this.takeSnapshot(!1, v, E, k, R, U, H.dataURLOptions);
                    this.restoreHandlers.push(( () => {
                        cancelAnimationFrame(G)
                    }
                    ))
                }
                "initCanvasMutationObserver"(v, E, k, R) {
                    const U = initCanvasContextObserver(v, E, k, R, !1)
                      , H = function initCanvas2DMutationObserver(v, E, k, R, U) {
                        const H = []
                          , G = Object.getOwnPropertyNames(E.CanvasRenderingContext2D.prototype);
                        for (const W of G)
                            try {
                                if ("function" != typeof E.CanvasRenderingContext2D.prototype[W])
                                    continue;
                                const G = esm_patch(E.CanvasRenderingContext2D.prototype, W, (function(H) {
                                    return function(...G) {
                                        return esm_isBlocked(this.canvas, k, R, U, !0) || esm_setTimeout(( () => {
                                            const k = serializeArgs(G, E, this);
                                            v(this.canvas, {
                                                "type": Ko["2D"],
                                                "property": W,
                                                "args": k
                                            })
                                        }
                                        ), 0),
                                        H.apply(this, G)
                                    }
                                }
                                ));
                                H.push(G)
                            } catch (k) {
                                const R = esm_hookSetter(E.CanvasRenderingContext2D.prototype, W, {
                                    "set"(E) {
                                        v(this.canvas, {
                                            "type": Ko["2D"],
                                            "property": W,
                                            "args": [E],
                                            "setter": !0
                                        })
                                    }
                                });
                                H.push(R)
                            }
                        return () => {
                            H.forEach((v => v()))
                        }
                    }(this.processMutation.bind(this), v, E, k, R)
                      , G = function initCanvasWebGLMutationObserver(v, E, k, R, U, H) {
                        const G = [];
                        return G.push(...patchGLPrototype(E.WebGLRenderingContext.prototype, Ko.WebGL, v, k, R, U, 0, E)),
                        void 0 !== E.WebGL2RenderingContext && G.push(...patchGLPrototype(E.WebGL2RenderingContext.prototype, Ko.WebGL2, v, k, R, U, 0, E)),
                        () => {
                            G.forEach((v => v()))
                        }
                    }(this.processMutation.bind(this), v, E, k, R, this.mirror);
                    this.restoreHandlers.push(( () => {
                        U(),
                        H(),
                        G()
                    }
                    ))
                }
                "snapshot"(v) {
                    const {"options": E} = this
                      , k = this.takeSnapshot(!0, "all" === E.sampling ? 2 : E.sampling || 2, E.blockClass, E.blockSelector, E.unblockSelector, E.maxCanvasSize, E.dataURLOptions, v);
                    this.restoreHandlers.push(( () => {
                        cancelAnimationFrame(k)
                    }
                    ))
                }
                "takeSnapshot"(v, E, k, R, U, H, G, W) {
                    const Z = 1e3 / E;
                    let Y, J = 0;
                    const getCanvas = v => {
                        if (v)
                            return [v];
                        const E = []
                          , searchCanvas = v => {
                            v.querySelectorAll("canvas").forEach((v => {
                                esm_isBlocked(v, k, R, U, !0) || E.push(v)
                            }
                            ))
                        }
                        ;
                        for (const v of this.windows) {
                            const E = v.deref();
                            E && searchCanvas(E.document)
                        }
                        for (const v of this.shadowDoms) {
                            const E = v.deref();
                            E && searchCanvas(E)
                        }
                        return E
                    }
                      , takeCanvasSnapshots = E => {
                        this.windows.length && (J && E - J < Z ? Y = esm_onRequestAnimationFrame(takeCanvasSnapshots) : (J = E,
                        getCanvas(W).forEach((E => {
                            if (!this.mirror.hasNode(E))
                                return;
                            const k = this.mirror.getId(E);
                            if (!this.snapshotInProgressMap.get(k) && E.width && E.height) {
                                if (this.snapshotInProgressMap.set(k, !0),
                                !v && ["webgl", "webgl2"].includes(E.__context)) {
                                    const v = E.getContext(E.__context);
                                    !1 === _optionalChain_optionalChain([v, "optionalAccess", v => v.getContextAttributes, "call", v => v(), "optionalAccess", v => v.preserveDrawingBuffer]) && v.clear(v.COLOR_BUFFER_BIT)
                                }
                                createImageBitmap(E).then((v => {
                                    _optionalChain_optionalChain([this, "access", v => v.worker, "optionalAccess", v => v.postMessage, "call", R => R({
                                        "id": k,
                                        "bitmap": v,
                                        "width": E.width,
                                        "height": E.height,
                                        "dataURLOptions": G,
                                        "maxCanvasSize": H
                                    }, [v])])
                                }
                                )).catch((v => {
                                    esm_callbackWrapper(( () => {
                                        throw v
                                    }
                                    ))()
                                }
                                ))
                            }
                        }
                        )),
                        v || (Y = esm_onRequestAnimationFrame(takeCanvasSnapshots))))
                    }
                    ;
                    return Y = esm_onRequestAnimationFrame(takeCanvasSnapshots),
                    Y
                }
                "startPendingCanvasMutationFlusher"() {
                    esm_onRequestAnimationFrame(( () => this.flushPendingCanvasMutations()))
                }
                "startRAFTimestamping"() {
                    const setLatestRAFTimestamp = v => {
                        this.rafStamps.latestId = v,
                        esm_onRequestAnimationFrame(setLatestRAFTimestamp)
                    }
                    ;
                    esm_onRequestAnimationFrame(setLatestRAFTimestamp)
                }
                "flushPendingCanvasMutations"() {
                    this.pendingCanvasMutations.forEach(( (v, E) => {
                        const k = this.mirror.getId(E);
                        this.flushPendingCanvasMutationFor(E, k)
                    }
                    )),
                    esm_onRequestAnimationFrame(( () => this.flushPendingCanvasMutations()))
                }
                "flushPendingCanvasMutationFor"(v, E) {
                    if (this.frozen || this.locked)
                        return;
                    const k = this.pendingCanvasMutations.get(v);
                    if (!k || -1 === E)
                        return;
                    const R = k.map((v => {
                        const {"type": E, ...k} = v;
                        return k
                    }
                    ))
                      , {"type": U} = k[0];
                    this.mutationCb({
                        "id": E,
                        "type": U,
                        "commands": R
                    }),
                    this.pendingCanvasMutations.delete(v)
                }
            }
            const ri = {
                "low": {
                    "sampling": {
                        "canvas": 1
                    },
                    "dataURLOptions": {
                        "type": "image/webp",
                        "quality": .25
                    }
                },
                "medium": {
                    "sampling": {
                        "canvas": 2
                    },
                    "dataURLOptions": {
                        "type": "image/webp",
                        "quality": .4
                    }
                },
                "high": {
                    "sampling": {
                        "canvas": 4
                    },
                    "dataURLOptions": {
                        "type": "image/webp",
                        "quality": .5
                    }
                }
            }
              , oi = 1280
              , replayCanvasIntegration = (v={}) => {
                const [E,k] = v.maxCanvasSize || []
                  , R = {
                    "quality": v.quality || "medium",
                    "enableManualSnapshot": v.enableManualSnapshot,
                    "maxCanvasSize": [E ? Math.min(E, oi) : oi, k ? Math.min(k, oi) : oi]
                };
                let U;
                const H = new Promise((v => U = v));
                return {
                    "name": "ReplayCanvas",
                    "getOptions"() {
                        const {"quality": v, "enableManualSnapshot": E, "maxCanvasSize": k} = R;
                        return {
                            "enableManualSnapshot": E,
                            "recordCanvas": !0,
                            "getCanvasManager": v => {
                                const R = new CanvasManager({
                                    ...v,
                                    "enableManualSnapshot": E,
                                    "maxCanvasSize": k,
                                    "errorHandler": v => {
                                        try {
                                            "object" == typeof v && (v.__rrweb__ = !0)
                                        } catch (v) {}
                                    }
                                });
                                return U(R),
                                R
                            }
                            ,
                            ...ri[v || "medium"] || ri.medium
                        }
                    },
                    async "snapshot"(v) {
                        (await H).snapshot(v)
                    }
                }
            }
              , ii = "8.30.0"
              , ai = globalThis;
            function _sentry_utils_build_esm_worldwide_getGlobalSingleton(v, E, k) {
                const R = k || ai
                  , U = R.__SENTRY__ = R.__SENTRY__ || {}
                  , H = U[ii] = U[ii] || {};
                return H[v] || (H[v] = E())
            }
            function core_build_esm_carrier_getMainCarrier() {
                return core_build_esm_carrier_getSentryCarrier(ai),
                ai
            }
            function core_build_esm_carrier_getSentryCarrier(v) {
                const E = v.__SENTRY__ = v.__SENTRY__ || {};
                return E.version = E.version || ii,
                E[ii] = E[ii] || {}
            }
            const si = Object.prototype.toString;
            function utils_build_esm_is_isBuiltin(v, E) {
                return si.call(v) === `[object ${E}]`
            }
            function utils_build_esm_is_isPlainObject(v) {
                return utils_build_esm_is_isBuiltin(v, "Object")
            }
            function _sentry_utils_build_esm_misc_uuid4() {
                const v = ai
                  , E = v.crypto || v.msCrypto;
                let getRandomByte = () => 16 * Math.random();
                try {
                    if (E && E.randomUUID)
                        return E.randomUUID().replace(/-/g, "");
                    E && E.getRandomValues && (getRandomByte = () => {
                        const v = new Uint8Array(1);
                        return E.getRandomValues(v),
                        v[0]
                    }
                    )
                } catch (v) {}
                return ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, (v => (v ^ (15 & getRandomByte()) >> v / 4).toString(16)))
            }
            function utils_build_esm_propagationContext_generatePropagationContext() {
                return {
                    "traceId": _sentry_utils_build_esm_misc_uuid4(),
                    "spanId": _sentry_utils_build_esm_misc_uuid4().substring(16)
                }
            }
            const ci = 1e3;
            function _sentry_utils_build_esm_time_dateTimestampInSeconds() {
                return Date.now() / ci
            }
            const li = function utils_build_esm_time_createUnixTimestampInSecondsFunc() {
                const {"performance": v} = ai;
                if (!v || !v.now)
                    return _sentry_utils_build_esm_time_dateTimestampInSeconds;
                const E = Date.now() - v.now()
                  , k = null == v.timeOrigin ? E : v.timeOrigin;
                return () => (k + v.now()) / ci
            }();
            let ui;
            ( () => {
                const {"performance": v} = ai;
                if (!v || !v.now)
                    return void (ui = "none");
                const E = 36e5
                  , k = v.now()
                  , R = Date.now()
                  , U = v.timeOrigin ? Math.abs(v.timeOrigin + k - R) : E
                  , H = U < E
                  , G = v.timing && v.timing.navigationStart
                  , W = "number" == typeof G ? Math.abs(G + k - R) : E;
                H || W < E ? U <= W ? (ui = "timeOrigin",
                v.timeOrigin) : ui = "navigationStart" : ui = "dateNow"
            }
            )();
            const di = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__
              , pi = ["debug", "info", "warn", "error", "log", "assert", "trace"]
              , fi = {};
            const hi = _sentry_utils_build_esm_worldwide_getGlobalSingleton("logger", (function utils_build_esm_logger_makeLogger() {
                let v = !1;
                const E = {
                    "enable": () => {
                        v = !0
                    }
                    ,
                    "disable": () => {
                        v = !1
                    }
                    ,
                    "isEnabled": () => v
                };
                return di ? pi.forEach((k => {
                    E[k] = (...E) => {
                        v && function _sentry_utils_build_esm_logger_consoleSandbox(v) {
                            if (!("console"in ai))
                                return v();
                            const E = ai.console
                              , k = {}
                              , R = Object.keys(fi);
                            R.forEach((v => {
                                const R = fi[v];
                                k[v] = E[v],
                                E[v] = R
                            }
                            ));
                            try {
                                return v()
                            } finally {
                                R.forEach((v => {
                                    E[v] = k[v]
                                }
                                ))
                            }
                        }(( () => {
                            ai.console[k](`Sentry Logger [${k}]:`, ...E)
                        }
                        ))
                    }
                }
                )) : pi.forEach((v => {
                    E[v] = () => {}
                }
                )),
                E
            }
            ));
            function core_build_esm_session_updateSession(v, E={}) {
                if (E.user && (!v.ipAddress && E.user.ip_address && (v.ipAddress = E.user.ip_address),
                v.did || E.did || (v.did = E.user.id || E.user.email || E.user.username)),
                v.timestamp = E.timestamp || li(),
                E.abnormal_mechanism && (v.abnormal_mechanism = E.abnormal_mechanism),
                E.ignoreDuration && (v.ignoreDuration = E.ignoreDuration),
                E.sid && (v.sid = 32 === E.sid.length ? E.sid : _sentry_utils_build_esm_misc_uuid4()),
                void 0 !== E.init && (v.init = E.init),
                !v.did && E.did && (v.did = `${E.did}`),
                "number" == typeof E.started && (v.started = E.started),
                v.ignoreDuration)
                    v.duration = void 0;
                else if ("number" == typeof E.duration)
                    v.duration = E.duration;
                else {
                    const E = v.timestamp - v.started;
                    v.duration = E >= 0 ? E : 0
                }
                E.release && (v.release = E.release),
                E.environment && (v.environment = E.environment),
                !v.ipAddress && E.ipAddress && (v.ipAddress = E.ipAddress),
                !v.userAgent && E.userAgent && (v.userAgent = E.userAgent),
                "number" == typeof E.errors && (v.errors = E.errors),
                E.status && (v.status = E.status)
            }
            function _sentry_utils_build_esm_object_addNonEnumerableProperty(v, E, k) {
                try {
                    Object.defineProperty(v, E, {
                        "value": k,
                        "writable": !0,
                        "configurable": !0
                    })
                } catch (k) {
                    di && hi.log(`Failed to add non-enumerable property "${E}" to object`, v)
                }
            }
            function feedback_node_modules_sentry_utils_build_esm_object_dropUndefinedKeys(v) {
                return _sentry_internal_feedback_node_modules_sentry_utils_build_esm_object_dropUndefinedKeys(v, new Map)
            }
            function _sentry_internal_feedback_node_modules_sentry_utils_build_esm_object_dropUndefinedKeys(v, E) {
                if (function utils_build_esm_object_isPojo(v) {
                    if (!utils_build_esm_is_isPlainObject(v))
                        return !1;
                    try {
                        const E = Object.getPrototypeOf(v).constructor.name;
                        return !E || "Object" === E
                    } catch (v) {
                        return !0
                    }
                }(v)) {
                    const k = E.get(v);
                    if (void 0 !== k)
                        return k;
                    const R = {};
                    E.set(v, R);
                    for (const k of Object.keys(v))
                        void 0 !== v[k] && (R[k] = _sentry_internal_feedback_node_modules_sentry_utils_build_esm_object_dropUndefinedKeys(v[k], E));
                    return R
                }
                if (Array.isArray(v)) {
                    const k = E.get(v);
                    if (void 0 !== k)
                        return k;
                    const R = [];
                    return E.set(v, R),
                    v.forEach((v => {
                        R.push(_sentry_internal_feedback_node_modules_sentry_utils_build_esm_object_dropUndefinedKeys(v, E))
                    }
                    )),
                    R
                }
                return v
            }
            const mi = "_sentrySpan";
            function build_esm_utils_spanOnScope_setSpanForScope(v, E) {
                E ? _sentry_utils_build_esm_object_addNonEnumerableProperty(v, mi, E) : delete v[mi]
            }
            function esm_utils_spanOnScope_getSpanForScope(v) {
                return v[mi]
            }
            class build_esm_scope_ScopeClass {
                "constructor"() {
                    this._notifyingListeners = !1,
                    this._scopeListeners = [],
                    this._eventProcessors = [],
                    this._breadcrumbs = [],
                    this._attachments = [],
                    this._user = {},
                    this._tags = {},
                    this._extra = {},
                    this._contexts = {},
                    this._sdkProcessingMetadata = {},
                    this._propagationContext = utils_build_esm_propagationContext_generatePropagationContext()
                }
                "clone"() {
                    const v = new build_esm_scope_ScopeClass;
                    return v._breadcrumbs = [...this._breadcrumbs],
                    v._tags = {
                        ...this._tags
                    },
                    v._extra = {
                        ...this._extra
                    },
                    v._contexts = {
                        ...this._contexts
                    },
                    v._user = this._user,
                    v._level = this._level,
                    v._session = this._session,
                    v._transactionName = this._transactionName,
                    v._fingerprint = this._fingerprint,
                    v._eventProcessors = [...this._eventProcessors],
                    v._requestSession = this._requestSession,
                    v._attachments = [...this._attachments],
                    v._sdkProcessingMetadata = {
                        ...this._sdkProcessingMetadata
                    },
                    v._propagationContext = {
                        ...this._propagationContext
                    },
                    v._client = this._client,
                    v._lastEventId = this._lastEventId,
                    build_esm_utils_spanOnScope_setSpanForScope(v, esm_utils_spanOnScope_getSpanForScope(this)),
                    v
                }
                "setClient"(v) {
                    this._client = v
                }
                "setLastEventId"(v) {
                    this._lastEventId = v
                }
                "getClient"() {
                    return this._client
                }
                "lastEventId"() {
                    return this._lastEventId
                }
                "addScopeListener"(v) {
                    this._scopeListeners.push(v)
                }
                "addEventProcessor"(v) {
                    return this._eventProcessors.push(v),
                    this
                }
                "setUser"(v) {
                    return this._user = v || {
                        "email": void 0,
                        "id": void 0,
                        "ip_address": void 0,
                        "username": void 0
                    },
                    this._session && core_build_esm_session_updateSession(this._session, {
                        "user": v
                    }),
                    this._notifyScopeListeners(),
                    this
                }
                "getUser"() {
                    return this._user
                }
                "getRequestSession"() {
                    return this._requestSession
                }
                "setRequestSession"(v) {
                    return this._requestSession = v,
                    this
                }
                "setTags"(v) {
                    return this._tags = {
                        ...this._tags,
                        ...v
                    },
                    this._notifyScopeListeners(),
                    this
                }
                "setTag"(v, E) {
                    return this._tags = {
                        ...this._tags,
                        [v]: E
                    },
                    this._notifyScopeListeners(),
                    this
                }
                "setExtras"(v) {
                    return this._extra = {
                        ...this._extra,
                        ...v
                    },
                    this._notifyScopeListeners(),
                    this
                }
                "setExtra"(v, E) {
                    return this._extra = {
                        ...this._extra,
                        [v]: E
                    },
                    this._notifyScopeListeners(),
                    this
                }
                "setFingerprint"(v) {
                    return this._fingerprint = v,
                    this._notifyScopeListeners(),
                    this
                }
                "setLevel"(v) {
                    return this._level = v,
                    this._notifyScopeListeners(),
                    this
                }
                "setTransactionName"(v) {
                    return this._transactionName = v,
                    this._notifyScopeListeners(),
                    this
                }
                "setContext"(v, E) {
                    return null === E ? delete this._contexts[v] : this._contexts[v] = E,
                    this._notifyScopeListeners(),
                    this
                }
                "setSession"(v) {
                    return v ? this._session = v : delete this._session,
                    this._notifyScopeListeners(),
                    this
                }
                "getSession"() {
                    return this._session
                }
                "update"(v) {
                    if (!v)
                        return this;
                    const E = "function" == typeof v ? v(this) : v
                      , [k,R] = E instanceof gi ? [E.getScopeData(), E.getRequestSession()] : utils_build_esm_is_isPlainObject(E) ? [v, v.requestSession] : []
                      , {"tags": U, "extra": H, "user": G, "contexts": W, "level": Z, "fingerprint": Y=[], "propagationContext": J} = k || {};
                    return this._tags = {
                        ...this._tags,
                        ...U
                    },
                    this._extra = {
                        ...this._extra,
                        ...H
                    },
                    this._contexts = {
                        ...this._contexts,
                        ...W
                    },
                    G && Object.keys(G).length && (this._user = G),
                    Z && (this._level = Z),
                    Y.length && (this._fingerprint = Y),
                    J && (this._propagationContext = J),
                    R && (this._requestSession = R),
                    this
                }
                "clear"() {
                    return this._breadcrumbs = [],
                    this._tags = {},
                    this._extra = {},
                    this._user = {},
                    this._contexts = {},
                    this._level = void 0,
                    this._transactionName = void 0,
                    this._fingerprint = void 0,
                    this._requestSession = void 0,
                    this._session = void 0,
                    build_esm_utils_spanOnScope_setSpanForScope(this, void 0),
                    this._attachments = [],
                    this._propagationContext = utils_build_esm_propagationContext_generatePropagationContext(),
                    this._notifyScopeListeners(),
                    this
                }
                "addBreadcrumb"(v, E) {
                    const k = "number" == typeof E ? E : 100;
                    if (k <= 0)
                        return this;
                    const R = {
                        "timestamp": _sentry_utils_build_esm_time_dateTimestampInSeconds(),
                        ...v
                    }
                      , U = this._breadcrumbs;
                    return U.push(R),
                    this._breadcrumbs = U.length > k ? U.slice(-k) : U,
                    this._notifyScopeListeners(),
                    this
                }
                "getLastBreadcrumb"() {
                    return this._breadcrumbs[this._breadcrumbs.length - 1]
                }
                "clearBreadcrumbs"() {
                    return this._breadcrumbs = [],
                    this._notifyScopeListeners(),
                    this
                }
                "addAttachment"(v) {
                    return this._attachments.push(v),
                    this
                }
                "clearAttachments"() {
                    return this._attachments = [],
                    this
                }
                "getScopeData"() {
                    return {
                        "breadcrumbs": this._breadcrumbs,
                        "attachments": this._attachments,
                        "contexts": this._contexts,
                        "tags": this._tags,
                        "extra": this._extra,
                        "user": this._user,
                        "level": this._level,
                        "fingerprint": this._fingerprint || [],
                        "eventProcessors": this._eventProcessors,
                        "propagationContext": this._propagationContext,
                        "sdkProcessingMetadata": this._sdkProcessingMetadata,
                        "transactionName": this._transactionName,
                        "span": esm_utils_spanOnScope_getSpanForScope(this)
                    }
                }
                "setSDKProcessingMetadata"(v) {
                    return this._sdkProcessingMetadata = {
                        ...this._sdkProcessingMetadata,
                        ...v
                    },
                    this
                }
                "setPropagationContext"(v) {
                    return this._propagationContext = v,
                    this
                }
                "getPropagationContext"() {
                    return this._propagationContext
                }
                "captureException"(v, E) {
                    const k = E && E.event_id ? E.event_id : _sentry_utils_build_esm_misc_uuid4();
                    if (!this._client)
                        return hi.warn("No client configured on scope - will not capture exception!"),
                        k;
                    const R = new Error("Sentry syntheticException");
                    return this._client.captureException(v, {
                        "originalException": v,
                        "syntheticException": R,
                        ...E,
                        "event_id": k
                    }, this),
                    k
                }
                "captureMessage"(v, E, k) {
                    const R = k && k.event_id ? k.event_id : _sentry_utils_build_esm_misc_uuid4();
                    if (!this._client)
                        return hi.warn("No client configured on scope - will not capture message!"),
                        R;
                    const U = new Error(v);
                    return this._client.captureMessage(v, E, {
                        "originalException": v,
                        "syntheticException": U,
                        ...k,
                        "event_id": R
                    }, this),
                    R
                }
                "captureEvent"(v, E) {
                    const k = E && E.event_id ? E.event_id : _sentry_utils_build_esm_misc_uuid4();
                    return this._client ? (this._client.captureEvent(v, {
                        ...E,
                        "event_id": k
                    }, this),
                    k) : (hi.warn("No client configured on scope - will not capture event!"),
                    k)
                }
                "_notifyScopeListeners"() {
                    this._notifyingListeners || (this._notifyingListeners = !0,
                    this._scopeListeners.forEach((v => {
                        v(this)
                    }
                    )),
                    this._notifyingListeners = !1)
                }
            }
            const gi = build_esm_scope_ScopeClass;
            class esm_asyncContext_stackStrategy_AsyncContextStack {
                "constructor"(v, E) {
                    let k, R;
                    k = v || new gi,
                    R = E || new gi,
                    this._stack = [{
                        "scope": k
                    }],
                    this._isolationScope = R
                }
                "withScope"(v) {
                    const E = this._pushScope();
                    let k;
                    try {
                        k = v(E)
                    } catch (v) {
                        throw this._popScope(),
                        v
                    }
                    return function _sentry_utils_build_esm_is_isThenable(v) {
                        return Boolean(v && v.then && "function" == typeof v.then)
                    }(k) ? k.then((v => (this._popScope(),
                    v)), (v => {
                        throw this._popScope(),
                        v
                    }
                    )) : (this._popScope(),
                    k)
                }
                "getClient"() {
                    return this.getStackTop().client
                }
                "getScope"() {
                    return this.getStackTop().scope
                }
                "getIsolationScope"() {
                    return this._isolationScope
                }
                "getStackTop"() {
                    return this._stack[this._stack.length - 1]
                }
                "_pushScope"() {
                    const v = this.getScope().clone();
                    return this._stack.push({
                        "client": this.getClient(),
                        "scope": v
                    }),
                    v
                }
                "_popScope"() {
                    return !(this._stack.length <= 1) && !!this._stack.pop()
                }
            }
            function esm_asyncContext_stackStrategy_getAsyncContextStack() {
                const v = core_build_esm_carrier_getSentryCarrier(core_build_esm_carrier_getMainCarrier());
                return v.stack = v.stack || new esm_asyncContext_stackStrategy_AsyncContextStack(function build_esm_defaultScopes_getDefaultCurrentScope() {
                    return _sentry_utils_build_esm_worldwide_getGlobalSingleton("defaultCurrentScope", ( () => new gi))
                }(),function build_esm_defaultScopes_getDefaultIsolationScope() {
                    return _sentry_utils_build_esm_worldwide_getGlobalSingleton("defaultIsolationScope", ( () => new gi))
                }())
            }
            function build_esm_asyncContext_stackStrategy_withScope(v) {
                return esm_asyncContext_stackStrategy_getAsyncContextStack().withScope(v)
            }
            function esm_asyncContext_stackStrategy_withSetScope(v, E) {
                const k = esm_asyncContext_stackStrategy_getAsyncContextStack();
                return k.withScope(( () => (k.getStackTop().scope = v,
                E(v))))
            }
            function build_esm_asyncContext_stackStrategy_withIsolationScope(v) {
                return esm_asyncContext_stackStrategy_getAsyncContextStack().withScope(( () => v(esm_asyncContext_stackStrategy_getAsyncContextStack().getIsolationScope())))
            }
            function core_build_esm_asyncContext_getAsyncContextStrategy(v) {
                const E = core_build_esm_carrier_getSentryCarrier(v);
                return E.acs ? E.acs : function esm_asyncContext_stackStrategy_getStackAsyncContextStrategy() {
                    return {
                        "withIsolationScope": build_esm_asyncContext_stackStrategy_withIsolationScope,
                        "withScope": build_esm_asyncContext_stackStrategy_withScope,
                        "withSetScope": esm_asyncContext_stackStrategy_withSetScope,
                        "withSetIsolationScope": (v, E) => build_esm_asyncContext_stackStrategy_withIsolationScope(E),
                        "getCurrentScope": () => esm_asyncContext_stackStrategy_getAsyncContextStack().getScope(),
                        "getIsolationScope": () => esm_asyncContext_stackStrategy_getAsyncContextStack().getIsolationScope()
                    }
                }()
            }
            function core_build_esm_currentScopes_getCurrentScope() {
                return core_build_esm_asyncContext_getAsyncContextStrategy(core_build_esm_carrier_getMainCarrier()).getCurrentScope()
            }
            function core_build_esm_currentScopes_getClient() {
                return core_build_esm_currentScopes_getCurrentScope().getClient()
            }
            const _i = ai;
            function esm_browser_getLocationHref() {
                try {
                    return _i.document.location.href
                } catch (v) {
                    return ""
                }
            }
            function node_isNodeEnv() {
                return !function esm_env_isBrowserBundle() {
                    return "undefined" != typeof __SENTRY_BROWSER_BUNDLE__ && !!__SENTRY_BROWSER_BUNDLE__
                }() && "[object process]" === Object.prototype.toString.call("undefined" != typeof process ? process : 0)
            }
            function isBrowser_isBrowser() {
                return "undefined" != typeof window && (!node_isNodeEnv() || function isBrowser_isElectronNodeRenderer() {
                    return void 0 !== ai.process && "renderer" === ai.process.type
                }())
            }
            const vi = ai
              , yi = vi.document
              , bi = vi.navigator
              , Si = "Report a Bug"
              , wi = "widget"
              , sendFeedback = (v, E={
                "includeReplay": !0
            }) => {
                if (!v.message)
                    throw new Error("Unable to submit feedback with empty message");
                const k = core_build_esm_currentScopes_getClient();
                if (!k)
                    throw new Error("No client setup, cannot send feedback.");
                v.tags && Object.keys(v.tags).length && core_build_esm_currentScopes_getCurrentScope().setTags(v.tags);
                const R = function feedback_captureFeedback(v, E={}, k=core_build_esm_currentScopes_getCurrentScope()) {
                    const {"message": R, "name": U, "email": H, "url": G, "source": W, "associatedEventId": Z, "tags": Y} = v
                      , J = {
                        "contexts": {
                            "feedback": feedback_node_modules_sentry_utils_build_esm_object_dropUndefinedKeys({
                                "contact_email": H,
                                "name": U,
                                "message": R,
                                "url": G,
                                "source": W,
                                "associated_event_id": Z
                            })
                        },
                        "type": "feedback",
                        "level": "info",
                        "tags": Y
                    }
                      , K = k && k.getClient() || core_build_esm_currentScopes_getClient();
                    return K && K.emit("beforeSendFeedback", J, E),
                    k.captureEvent(J, E)
                }({
                    "source": "api",
                    "url": esm_browser_getLocationHref(),
                    ...v
                }, E);
                return new Promise(( (v, E) => {
                    const U = setTimeout(( () => E("Unable to determine if Feedback was correctly sent.")), 5e3)
                      , H = k.on("afterSendEvent", ( (k, G) => {
                        if (k.event_id === R)
                            return clearTimeout(U),
                            H(),
                            G && "number" == typeof G.statusCode && G.statusCode >= 200 && G.statusCode < 300 && v(R),
                            G && "number" == typeof G.statusCode && 0 === G.statusCode ? E("Unable to send Feedback. This is because of network issues, or because you are using an ad-blocker.") : G && "number" == typeof G.statusCode && 403 === G.statusCode ? E("Unable to send Feedback. This could be because this domain is not in your list of allowed domains.") : E("Unable to send Feedback. This could be because of network issues, or because you are using an ad-blocker")
                    }
                    ))
                }
                ))
            }
              , Ei = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__;
            function mergeOptions(v, E) {
                return {
                    ...v,
                    ...E,
                    "tags": {
                        ...v.tags,
                        ...E.tags
                    },
                    "onFormOpen": () => {
                        E.onFormOpen && E.onFormOpen(),
                        v.onFormOpen && v.onFormOpen()
                    }
                    ,
                    "onFormClose": () => {
                        E.onFormClose && E.onFormClose(),
                        v.onFormClose && v.onFormClose()
                    }
                    ,
                    "onSubmitSuccess": k => {
                        E.onSubmitSuccess && E.onSubmitSuccess(k),
                        v.onSubmitSuccess && v.onSubmitSuccess(k)
                    }
                    ,
                    "onSubmitError": k => {
                        E.onSubmitError && E.onSubmitError(k),
                        v.onSubmitError && v.onSubmitError(k)
                    }
                    ,
                    "onFormSubmitted": () => {
                        E.onFormSubmitted && E.onFormSubmitted(),
                        v.onFormSubmitted && v.onFormSubmitted()
                    }
                    ,
                    "themeDark": {
                        ...v.themeDark,
                        ...E.themeDark
                    },
                    "themeLight": {
                        ...v.themeLight,
                        ...E.themeLight
                    }
                }
            }
            function setAttributesNS(v, E) {
                return Object.entries(E).forEach(( ([E,k]) => {
                    v.setAttributeNS(null, E, k)
                }
                )),
                v
            }
            const Ci = 20
              , Ti = "http://www.w3.org/2000/svg";
            function Actor({"triggerLabel": v, "triggerAriaLabel": E, "shadow": k, "styleNonce": R}) {
                const U = yi.createElement("button");
                if (U.type = "button",
                U.className = "widget__actor",
                U.ariaHidden = "false",
                U.ariaLabel = E || v || Si,
                U.appendChild(function FeedbackIcon() {
                    const createElementNS = v => vi.document.createElementNS(Ti, v)
                      , v = setAttributesNS(createElementNS("svg"), {
                        "width": `${Ci}`,
                        "height": `${Ci}`,
                        "viewBox": `0 0 ${Ci} ${Ci}`,
                        "fill": "var(--foreground)"
                    })
                      , E = setAttributesNS(createElementNS("g"), {
                        "clipPath": "url(#clip0_57_80)"
                    })
                      , k = setAttributesNS(createElementNS("path"), {
                        "fill-rule": "evenodd",
                        "clip-rule": "evenodd",
                        "d": "M15.6622 15H12.3997C12.2129 14.9959 12.031 14.9396 11.8747 14.8375L8.04965 12.2H7.49956V19.1C7.4875 19.3348 7.3888 19.5568 7.22256 19.723C7.05632 19.8892 6.83435 19.9879 6.59956 20H2.04956C1.80193 19.9968 1.56535 19.8969 1.39023 19.7218C1.21511 19.5467 1.1153 19.3101 1.11206 19.0625V12.2H0.949652C0.824431 12.2017 0.700142 12.1783 0.584123 12.1311C0.468104 12.084 0.362708 12.014 0.274155 11.9255C0.185602 11.8369 0.115689 11.7315 0.0685419 11.6155C0.0213952 11.4995 -0.00202913 11.3752 -0.00034808 11.25V3.75C-0.00900498 3.62067 0.0092504 3.49095 0.0532651 3.36904C0.0972798 3.24712 0.166097 3.13566 0.255372 3.04168C0.344646 2.94771 0.452437 2.87327 0.571937 2.82307C0.691437 2.77286 0.82005 2.74798 0.949652 2.75H8.04965L11.8747 0.1625C12.031 0.0603649 12.2129 0.00407221 12.3997 0H15.6622C15.9098 0.00323746 16.1464 0.103049 16.3215 0.278167C16.4966 0.453286 16.5964 0.689866 16.5997 0.9375V3.25269C17.3969 3.42959 18.1345 3.83026 18.7211 4.41679C19.5322 5.22788 19.9878 6.32796 19.9878 7.47502C19.9878 8.62209 19.5322 9.72217 18.7211 10.5333C18.1345 11.1198 17.3969 11.5205 16.5997 11.6974V14.0125C16.6047 14.1393 16.5842 14.2659 16.5395 14.3847C16.4948 14.5035 16.4268 14.6121 16.3394 14.7042C16.252 14.7962 16.147 14.8698 16.0307 14.9206C15.9144 14.9714 15.7891 14.9984 15.6622 15ZM1.89695 10.325H1.88715V4.625H8.33715C8.52423 4.62301 8.70666 4.56654 8.86215 4.4625L12.6872 1.875H14.7247V13.125H12.6872L8.86215 10.4875C8.70666 10.3835 8.52423 10.327 8.33715 10.325H2.20217C2.15205 10.3167 2.10102 10.3125 2.04956 10.3125C1.9981 10.3125 1.94708 10.3167 1.89695 10.325ZM2.98706 12.2V18.1625H5.66206V12.2H2.98706ZM16.5997 9.93612V5.01393C16.6536 5.02355 16.7072 5.03495 16.7605 5.04814C17.1202 5.13709 17.4556 5.30487 17.7425 5.53934C18.0293 5.77381 18.2605 6.06912 18.4192 6.40389C18.578 6.73866 18.6603 7.10452 18.6603 7.47502C18.6603 7.84552 18.578 8.21139 18.4192 8.54616C18.2605 8.88093 18.0293 9.17624 17.7425 9.41071C17.4556 9.64518 17.1202 9.81296 16.7605 9.90191C16.7072 9.91509 16.6536 9.9265 16.5997 9.93612Z"
                    });
                    v.appendChild(E).appendChild(k);
                    const R = createElementNS("defs")
                      , U = setAttributesNS(createElementNS("clipPath"), {
                        "id": "clip0_57_80"
                    })
                      , H = setAttributesNS(createElementNS("rect"), {
                        "width": `${Ci}`,
                        "height": `${Ci}`,
                        "fill": "white"
                    });
                    return U.appendChild(H),
                    R.appendChild(U),
                    v.appendChild(R).appendChild(U).appendChild(H),
                    v
                }()),
                v) {
                    const E = yi.createElement("span");
                    E.appendChild(yi.createTextNode(v)),
                    U.appendChild(E)
                }
                const H = function createActorStyles(v) {
                    const E = yi.createElement("style");
                    return E.textContent = '\n.widget__actor {\n  position: fixed;\n  z-index: var(--z-index);\n  margin: var(--page-margin);\n  inset: var(--actor-inset);\n\n  display: flex;\n  align-items: center;\n  gap: 8px;\n  padding: 16px;\n\n  font-family: inherit;\n  font-size: var(--font-size);\n  font-weight: 600;\n  line-height: 1.14em;\n  text-decoration: none;\n\n  background: var(--actor-background, var(--background));\n  border-radius: var(--actor-border-radius, 1.7em/50%);\n  border: var(--actor-border, var(--border));\n  box-shadow: var(--actor-box-shadow, var(--box-shadow));\n  color: var(--actor-color, var(--foreground));\n  fill: var(--actor-color, var(--foreground));\n  cursor: pointer;\n  opacity: 1;\n  transition: transform 0.2s ease-in-out;\n  transform: translate(0, 0) scale(1);\n}\n.widget__actor[aria-hidden="true"] {\n  opacity: 0;\n  pointer-events: none;\n  visibility: hidden;\n  transform: translate(0, 16px) scale(0.98);\n}\n\n.widget__actor:hover {\n  background: var(--actor-hover-background, var(--background));\n  filter: var(--interactive-filter);\n}\n\n.widget__actor svg {\n  width: 1.14em;\n  height: 1.14em;\n}\n\n@media (max-width: 600px) {\n  .widget__actor span {\n    display: none;\n  }\n}\n',
                    v && E.setAttribute("nonce", v),
                    E
                }(R);
                return {
                    "el": U,
                    "appendToDom"() {
                        k.appendChild(H),
                        k.appendChild(U)
                    },
                    "removeFromDom"() {
                        k.removeChild(U),
                        k.removeChild(H)
                    },
                    "show"() {
                        U.ariaHidden = "false"
                    },
                    "hide"() {
                        U.ariaHidden = "true"
                    }
                }
            }
            const xi = "rgba(88, 74, 192, 1)"
              , Ai = {
                "foreground": "#2b2233",
                "background": "#ffffff",
                "accentForeground": "white",
                "accentBackground": xi,
                "successColor": "#268d75",
                "errorColor": "#df3338",
                "border": "1.5px solid rgba(41, 35, 47, 0.13)",
                "boxShadow": "0px 4px 24px 0px rgba(43, 34, 51, 0.12)",
                "outline": "1px auto var(--accent-background)",
                "interactiveFilter": "brightness(95%)"
            }
              , Ii = {
                "foreground": "#ebe6ef",
                "background": "#29232f",
                "accentForeground": "white",
                "accentBackground": xi,
                "successColor": "#2da98c",
                "errorColor": "#f55459",
                "border": "1.5px solid rgba(235, 230, 239, 0.15)",
                "boxShadow": "0px 4px 24px 0px rgba(43, 34, 51, 0.12)",
                "outline": "1px auto var(--accent-background)",
                "interactiveFilter": "brightness(150%)"
            };
            function getThemedCssVariables(v) {
                return `\n  --foreground: ${v.foreground};\n  --background: ${v.background};\n  --accent-foreground: ${v.accentForeground};\n  --accent-background: ${v.accentBackground};\n  --success-color: ${v.successColor};\n  --error-color: ${v.errorColor};\n  --border: ${v.border};\n  --box-shadow: ${v.boxShadow};\n  --outline: ${v.outline};\n  --interactive-filter: ${v.interactiveFilter};\n  `
            }
            const buildFeedbackIntegration = ({"lazyLoadIntegration": v, "getModalIntegration": E, "getScreenshotIntegration": k}) => ({"id": R="sentry-feedback", "autoInject": U=!0, "showBranding": H=!0, "isEmailRequired": G=!1, "isNameRequired": W=!1, "showEmail": Z=!0, "showName": Y=!0, "enableScreenshot": J=!0, "useSentryUser": K={
                "email": "email",
                "name": "username"
            }, "tags": X, "styleNonce": Q, "scriptNonce": ee, "colorScheme": te="system", "themeLight": ne={}, "themeDark": re={}, "addScreenshotButtonLabel": oe="Add a screenshot", "cancelButtonLabel": ie="Cancel", "confirmButtonLabel": ae="Confirm", "emailLabel": se="Email", "emailPlaceholder": ce="your.email@example.org", "formTitle": le="Report a Bug", "isRequiredLabel": ue="(required)", "messageLabel": de="Description", "messagePlaceholder": pe="What's the bug? What did you expect?", "nameLabel": fe="Name", "namePlaceholder": he="Your Name", "removeScreenshotButtonLabel": me="Remove screenshot", "submitButtonLabel": ge="Send Bug Report", "successMessageText": _e="Thank you for your report!", "triggerLabel": ve=Si, "triggerAriaLabel": ye="", "onFormOpen": be, "onFormClose": Se, "onSubmitSuccess": we, "onSubmitError": Ee, "onFormSubmitted": Ce}={}) => {
                const Te = {
                    "id": R,
                    "autoInject": U,
                    "showBranding": H,
                    "isEmailRequired": G,
                    "isNameRequired": W,
                    "showEmail": Z,
                    "showName": Y,
                    "enableScreenshot": J,
                    "useSentryUser": K,
                    "tags": X,
                    "styleNonce": Q,
                    "scriptNonce": ee,
                    "colorScheme": te,
                    "themeDark": re,
                    "themeLight": ne,
                    "triggerLabel": ve,
                    "triggerAriaLabel": ye,
                    "cancelButtonLabel": ie,
                    "submitButtonLabel": ge,
                    "confirmButtonLabel": ae,
                    "formTitle": le,
                    "emailLabel": se,
                    "emailPlaceholder": ce,
                    "messageLabel": de,
                    "messagePlaceholder": pe,
                    "nameLabel": fe,
                    "namePlaceholder": he,
                    "successMessageText": _e,
                    "isRequiredLabel": ue,
                    "addScreenshotButtonLabel": oe,
                    "removeScreenshotButtonLabel": me,
                    "onFormClose": Se,
                    "onFormOpen": be,
                    "onSubmitError": Ee,
                    "onSubmitSuccess": we,
                    "onFormSubmitted": Ce
                };
                let xe = null
                  , Ae = [];
                const _createShadow = v => {
                    if (!xe) {
                        const E = yi.createElement("div");
                        E.id = String(v.id),
                        yi.body.appendChild(E),
                        xe = E.attachShadow({
                            "mode": "open"
                        }),
                        xe.appendChild(function createMainStyles({"colorScheme": v, "themeDark": E, "themeLight": k, "styleNonce": R}) {
                            const U = yi.createElement("style");
                            return U.textContent = `\n:host {\n  --font-family: system-ui, 'Helvetica Neue', Arial, sans-serif;\n  --font-size: 14px;\n  --z-index: 100000;\n\n  --page-margin: 16px;\n  --inset: auto 0 0 auto;\n  --actor-inset: var(--inset);\n\n  font-family: var(--font-family);\n  font-size: var(--font-size);\n\n  ${"system" !== v ? "color-scheme: only light;" : ""}\n\n  ${getThemedCssVariables("dark" === v ? {
                                ...Ii,
                                ...E
                            } : {
                                ...Ai,
                                ...k
                            })}\n}\n\n${"system" === v ? `\n@media (prefers-color-scheme: dark) {\n  :host {\n    ${getThemedCssVariables({
                                ...Ii,
                                ...E
                            })}\n  }\n}` : ""}\n}\n`,
                            R && U.setAttribute("nonce", R),
                            U
                        }(v))
                    }
                    return xe
                }
                  , _findIntegration = async (E, k, R) => {
                    const U = core_build_esm_currentScopes_getClient()
                      , H = U && U.getIntegrationByName(E);
                    if (H)
                        return H;
                    const G = (k && k() || await v(R, ee))();
                    return U && U.addIntegration(G),
                    G
                }
                  , _loadAndRenderDialog = async v => {
                    const R = v.enableScreenshot && function isScreenshotSupported() {
                        return !(/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(bi.userAgent) || /Macintosh/i.test(bi.userAgent) && bi.maxTouchPoints && bi.maxTouchPoints > 1 || !isSecureContext)
                    }()
                      , [U,H] = await Promise.all([_findIntegration("FeedbackModal", E, "feedbackModalIntegration"), R ? _findIntegration("FeedbackScreenshot", k, "feedbackScreenshotIntegration") : void 0]);
                    if (!U)
                        throw Ei && hi.error("[Feedback] Missing feedback modal integration. Try using `feedbackSyncIntegration` in your `Sentry.init`."),
                        new Error("[Feedback] Missing feedback modal integration!");
                    R && !H && Ei && hi.error("[Feedback] Missing feedback screenshot integration. Proceeding without screenshots.");
                    const G = U.createDialog({
                        "options": {
                            ...v,
                            "onFormClose": () => {
                                G && G.close(),
                                v.onFormClose && v.onFormClose()
                            }
                            ,
                            "onFormSubmitted": () => {
                                G && G.close(),
                                v.onFormSubmitted && v.onFormSubmitted()
                            }
                        },
                        "screenshotIntegration": R ? H : void 0,
                        "sendFeedback": sendFeedback,
                        "shadow": _createShadow(v)
                    });
                    return G
                }
                  , _attachTo = (v, E={}) => {
                    const k = mergeOptions(Te, E)
                      , R = "string" == typeof v ? yi.querySelector(v) : "function" == typeof v.addEventListener ? v : null;
                    if (!R)
                        throw Ei && hi.error("[Feedback] Unable to attach to target element"),
                        new Error("Unable to attach to target element");
                    let U = null;
                    const handleClick = async () => {
                        U || (U = await _loadAndRenderDialog({
                            ...k,
                            "onFormSubmitted": () => {
                                U && U.removeFromDom(),
                                k.onFormSubmitted && k.onFormSubmitted()
                            }
                        })),
                        U.appendToDom(),
                        U.open()
                    }
                    ;
                    R.addEventListener("click", handleClick);
                    const unsubscribe = () => {
                        Ae = Ae.filter((v => v !== unsubscribe)),
                        U && U.removeFromDom(),
                        U = null,
                        R.removeEventListener("click", handleClick)
                    }
                    ;
                    return Ae.push(unsubscribe),
                    unsubscribe
                }
                  , _createActor = (v={}) => {
                    const E = mergeOptions(Te, v)
                      , k = _createShadow(E)
                      , R = Actor({
                        "triggerLabel": E.triggerLabel,
                        "triggerAriaLabel": E.triggerAriaLabel,
                        "shadow": k,
                        "styleNonce": Q
                    });
                    return _attachTo(R.el, {
                        ...E,
                        "onFormOpen"() {
                            R.hide()
                        },
                        "onFormClose"() {
                            R.show()
                        },
                        "onFormSubmitted"() {
                            R.show()
                        }
                    }),
                    R
                }
                ;
                return {
                    "name": "Feedback",
                    "setupOnce"() {
                        isBrowser_isBrowser() && Te.autoInject && ("loading" === yi.readyState ? yi.addEventListener("DOMContentLoaded", ( () => _createActor().appendToDom())) : _createActor().appendToDom())
                    },
                    "attachTo": _attachTo,
                    "createWidget"(v={}) {
                        const E = _createActor(mergeOptions(Te, v));
                        return E.appendToDom(),
                        E
                    },
                    async "createForm"(v={}) {
                        return _loadAndRenderDialog(mergeOptions(Te, v))
                    },
                    "remove"() {
                        xe && (xe.parentElement && xe.parentElement.remove(),
                        xe = null),
                        Ae.forEach((v => v())),
                        Ae = []
                    }
                }
            }
            ;
            function getFeedback() {
                const v = core_build_esm_currentScopes_getClient();
                return v && v.getIntegrationByName("Feedback")
            }
            var ki, Oi, Pi, Ri, Mi, Ni, Di, $i = {}, Li = [], Fi = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, ji = Array.isArray;
            function v$1(v, E) {
                for (var k in E)
                    v[k] = E[k];
                return v
            }
            function p$1(v) {
                var E = v.parentNode;
                E && E.removeChild(v)
            }
            function y$1(v, E, k) {
                var R, U, H, G = {};
                for (H in E)
                    "key" == H ? R = E[H] : "ref" == H ? U = E[H] : G[H] = E[H];
                if (arguments.length > 2 && (G.children = arguments.length > 3 ? ki.call(arguments, 2) : k),
                "function" == typeof v && null != v.defaultProps)
                    for (H in v.defaultProps)
                        void 0 === G[H] && (G[H] = v.defaultProps[H]);
                return d$1(v, G, R, U, null)
            }
            function d$1(v, E, k, R, U) {
                var H = {
                    "type": v,
                    "props": E,
                    "key": k,
                    "ref": R,
                    "__k": null,
                    "__": null,
                    "__b": 0,
                    "__e": null,
                    "__d": void 0,
                    "__c": null,
                    "constructor": void 0,
                    "__v": null == U ? ++Pi : U,
                    "__i": -1,
                    "__u": 0
                };
                return null == U && null != Oi.vnode && Oi.vnode(H),
                H
            }
            function g$1(v) {
                return v.children
            }
            function b$1(v, E) {
                this.props = v,
                this.context = E
            }
            function m$1(v, E) {
                if (null == E)
                    return v.__ ? m$1(v.__, v.__i + 1) : null;
                for (var k; E < v.__k.length; E++)
                    if (null != (k = v.__k[E]) && null != k.__e)
                        return k.__e;
                return "function" == typeof v.type ? m$1(v) : null
            }
            function w$1(v, E, k) {
                var R, U = v.__v, H = U.__e, G = v.__P;
                if (G)
                    return (R = v$1({}, U)).__v = U.__v + 1,
                    Oi.vnode && Oi.vnode(R),
                    M(G, R, U, v.__n, void 0 !== G.ownerSVGElement, 32 & U.__u ? [H] : null, E, null == H ? m$1(U) : H, !!(32 & U.__u), k),
                    R.__.__k[R.__i] = R,
                    R.__d = void 0,
                    R.__e != H && k$1(R),
                    R
            }
            function k$1(v) {
                var E, k;
                if (null != (v = v.__) && null != v.__c) {
                    for (v.__e = v.__c.base = null,
                    E = 0; E < v.__k.length; E++)
                        if (null != (k = v.__k[E]) && null != k.__e) {
                            v.__e = v.__c.base = k.__e;
                            break
                        }
                    return k$1(v)
                }
            }
            function x$1(v) {
                (!v.__d && (v.__d = !0) && Ri.push(v) && !C$1.__r++ || Mi !== Oi.debounceRendering) && ((Mi = Oi.debounceRendering) || Ni)(C$1)
            }
            function C$1() {
                var v, E, k, R = [], U = [];
                for (Ri.sort(Di); v = Ri.shift(); )
                    v.__d && (k = Ri.length,
                    E = w$1(v, R, U) || E,
                    0 === k || Ri.length > k ? (j$1(R, E, U),
                    U.length = R.length = 0,
                    E = void 0,
                    Ri.sort(Di)) : E && Oi.__c && Oi.__c(E, Li));
                E && j$1(R, E, U),
                C$1.__r = 0
            }
            function P$1(v, E, k, R, U, H, G, W, Z, Y, J) {
                var K, X, Q, ee, te, ne = R && R.__k || Li, re = E.length;
                for (k.__d = Z,
                function S(v, E, k) {
                    var R, U, H, G, W, Z = E.length, Y = k.length, J = Y, K = 0;
                    for (v.__k = [],
                    R = 0; R < Z; R++)
                        null != (U = v.__k[R] = null == (U = E[R]) || "boolean" == typeof U || "function" == typeof U ? null : "string" == typeof U || "number" == typeof U || "bigint" == typeof U || U.constructor == String ? d$1(null, U, null, null, U) : ji(U) ? d$1(g$1, {
                            "children": U
                        }, null, null, null) : void 0 === U.constructor && U.__b > 0 ? d$1(U.type, U.props, U.key, U.ref ? U.ref : null, U.__v) : U) ? (U.__ = v,
                        U.__b = v.__b + 1,
                        W = I(U, k, G = R + K, J),
                        U.__i = W,
                        H = null,
                        -1 !== W && (J--,
                        (H = k[W]) && (H.__u |= 131072)),
                        null == H || null === H.__v ? (-1 == W && K--,
                        "function" != typeof U.type && (U.__u |= 65536)) : W !== G && (W === G + 1 ? K++ : W > G ? J > Z - G ? K += W - G : K-- : K = W < G && W == G - 1 ? W - G : 0,
                        W !== R + K && (U.__u |= 65536))) : (H = k[R]) && null == H.key && H.__e && (H.__e == v.__d && (v.__d = m$1(H)),
                        O(H, H, !1),
                        k[R] = null,
                        J--);
                    if (J)
                        for (R = 0; R < Y; R++)
                            null != (H = k[R]) && !(131072 & H.__u) && (H.__e == v.__d && (v.__d = m$1(H)),
                            O(H, H))
                }(k, E, ne),
                Z = k.__d,
                K = 0; K < re; K++)
                    null != (Q = k.__k[K]) && "boolean" != typeof Q && "function" != typeof Q && (X = -1 === Q.__i ? $i : ne[Q.__i] || $i,
                    Q.__i = K,
                    M(v, Q, X, U, H, G, W, Z, Y, J),
                    ee = Q.__e,
                    Q.ref && X.ref != Q.ref && (X.ref && N(X.ref, null, Q),
                    J.push(Q.ref, Q.__c || ee, Q)),
                    null == te && null != ee && (te = ee),
                    65536 & Q.__u || X.__k === Q.__k ? Z = $(Q, Z, v) : "function" == typeof Q.type && void 0 !== Q.__d ? Z = Q.__d : ee && (Z = ee.nextSibling),
                    Q.__d = void 0,
                    Q.__u &= -196609);
                k.__d = Z,
                k.__e = te
            }
            function $(v, E, k) {
                var R, U;
                if ("function" == typeof v.type) {
                    for (R = v.__k,
                    U = 0; R && U < R.length; U++)
                        R[U] && (R[U].__ = v,
                        E = $(R[U], E, k));
                    return E
                }
                v.__e != E && (k.insertBefore(v.__e, E || null),
                E = v.__e);
                do {
                    E = E && E.nextSibling
                } while (null != E && 8 === E.nodeType);
                return E
            }
            function I(v, E, k, R) {
                var U = v.key
                  , H = v.type
                  , G = k - 1
                  , W = k + 1
                  , Z = E[k];
                if (null === Z || Z && U == Z.key && H === Z.type)
                    return k;
                if (R > (null == Z || 131072 & Z.__u ? 0 : 1))
                    for (; G >= 0 || W < E.length; ) {
                        if (G >= 0) {
                            if ((Z = E[G]) && !(131072 & Z.__u) && U == Z.key && H === Z.type)
                                return G;
                            G--
                        }
                        if (W < E.length) {
                            if ((Z = E[W]) && !(131072 & Z.__u) && U == Z.key && H === Z.type)
                                return W;
                            W++
                        }
                    }
                return -1
            }
            function T$1(v, E, k) {
                "-" === E[0] ? v.setProperty(E, null == k ? "" : k) : v[E] = null == k ? "" : "number" != typeof k || Fi.test(E) ? k : k + "px"
            }
            function A$1(v, E, k, R, U) {
                var H;
                e: if ("style" === E)
                    if ("string" == typeof k)
                        v.style.cssText = k;
                    else {
                        if ("string" == typeof R && (v.style.cssText = R = ""),
                        R)
                            for (E in R)
                                k && E in k || T$1(v.style, E, "");
                        if (k)
                            for (E in k)
                                R && k[E] === R[E] || T$1(v.style, E, k[E])
                    }
                else if ("o" === E[0] && "n" === E[1])
                    H = E !== (E = E.replace(/(PointerCapture)$|Capture$/i, "$1")),
                    E = E.toLowerCase()in v ? E.toLowerCase().slice(2) : E.slice(2),
                    v.l || (v.l = {}),
                    v.l[E + H] = k,
                    k ? R ? k.u = R.u : (k.u = Date.now(),
                    v.addEventListener(E, H ? L : D$1, H)) : v.removeEventListener(E, H ? L : D$1, H);
                else {
                    if (U)
                        E = E.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
                    else if ("width" !== E && "height" !== E && "href" !== E && "list" !== E && "form" !== E && "tabIndex" !== E && "download" !== E && "rowSpan" !== E && "colSpan" !== E && "role" !== E && E in v)
                        try {
                            v[E] = null == k ? "" : k;
                            break e
                        } catch (v) {}
                    "function" == typeof k || (null == k || !1 === k && "-" !== E[4] ? v.removeAttribute(E) : v.setAttribute(E, k))
                }
            }
            function D$1(v) {
                if (this.l) {
                    var E = this.l[v.type + !1];
                    if (v.t) {
                        if (v.t <= E.u)
                            return
                    } else
                        v.t = Date.now();
                    return E(Oi.event ? Oi.event(v) : v)
                }
            }
            function L(v) {
                if (this.l)
                    return this.l[v.type + !0](Oi.event ? Oi.event(v) : v)
            }
            function M(v, E, k, R, U, H, G, W, Z, Y) {
                var J, K, X, Q, ee, te, ne, re, oe, ie, ae, se, ce, le, ue, de = E.type;
                if (void 0 !== E.constructor)
                    return null;
                128 & k.__u && (Z = !!(32 & k.__u),
                H = [W = E.__e = k.__e]),
                (J = Oi.__b) && J(E);
                e: if ("function" == typeof de)
                    try {
                        if (re = E.props,
                        oe = (J = de.contextType) && R[J.__c],
                        ie = J ? oe ? oe.props.value : J.__ : R,
                        k.__c ? ne = (K = E.__c = k.__c).__ = K.__E : ("prototype"in de && de.prototype.render ? E.__c = K = new de(re,ie) : (E.__c = K = new b$1(re,ie),
                        K.constructor = de,
                        K.render = q$1),
                        oe && oe.sub(K),
                        K.props = re,
                        K.state || (K.state = {}),
                        K.context = ie,
                        K.__n = R,
                        X = K.__d = !0,
                        K.__h = [],
                        K._sb = []),
                        null == K.__s && (K.__s = K.state),
                        null != de.getDerivedStateFromProps && (K.__s == K.state && (K.__s = v$1({}, K.__s)),
                        v$1(K.__s, de.getDerivedStateFromProps(re, K.__s))),
                        Q = K.props,
                        ee = K.state,
                        K.__v = E,
                        X)
                            null == de.getDerivedStateFromProps && null != K.componentWillMount && K.componentWillMount(),
                            null != K.componentDidMount && K.__h.push(K.componentDidMount);
                        else {
                            if (null == de.getDerivedStateFromProps && re !== Q && null != K.componentWillReceiveProps && K.componentWillReceiveProps(re, ie),
                            !K.__e && (null != K.shouldComponentUpdate && !1 === K.shouldComponentUpdate(re, K.__s, ie) || E.__v === k.__v)) {
                                for (E.__v !== k.__v && (K.props = re,
                                K.state = K.__s,
                                K.__d = !1),
                                E.__e = k.__e,
                                E.__k = k.__k,
                                E.__k.forEach((function(v) {
                                    v && (v.__ = E)
                                }
                                )),
                                ae = 0; ae < K._sb.length; ae++)
                                    K.__h.push(K._sb[ae]);
                                K._sb = [],
                                K.__h.length && G.push(K);
                                break e
                            }
                            null != K.componentWillUpdate && K.componentWillUpdate(re, K.__s, ie),
                            null != K.componentDidUpdate && K.__h.push((function() {
                                K.componentDidUpdate(Q, ee, te)
                            }
                            ))
                        }
                        if (K.context = ie,
                        K.props = re,
                        K.__P = v,
                        K.__e = !1,
                        se = Oi.__r,
                        ce = 0,
                        "prototype"in de && de.prototype.render) {
                            for (K.state = K.__s,
                            K.__d = !1,
                            se && se(E),
                            J = K.render(K.props, K.state, K.context),
                            le = 0; le < K._sb.length; le++)
                                K.__h.push(K._sb[le]);
                            K._sb = []
                        } else
                            do {
                                K.__d = !1,
                                se && se(E),
                                J = K.render(K.props, K.state, K.context),
                                K.state = K.__s
                            } while (K.__d && ++ce < 25);
                        K.state = K.__s,
                        null != K.getChildContext && (R = v$1(v$1({}, R), K.getChildContext())),
                        X || null == K.getSnapshotBeforeUpdate || (te = K.getSnapshotBeforeUpdate(Q, ee)),
                        P$1(v, ji(ue = null != J && J.type === g$1 && null == J.key ? J.props.children : J) ? ue : [ue], E, k, R, U, H, G, W, Z, Y),
                        K.base = E.__e,
                        E.__u &= -161,
                        K.__h.length && G.push(K),
                        ne && (K.__E = K.__ = null)
                    } catch (v) {
                        E.__v = null,
                        Z || null != H ? (E.__e = W,
                        E.__u |= Z ? 160 : 32,
                        H[H.indexOf(W)] = null) : (E.__e = k.__e,
                        E.__k = k.__k),
                        Oi.__e(v, E, k)
                    }
                else
                    null == H && E.__v === k.__v ? (E.__k = k.__k,
                    E.__e = k.__e) : E.__e = z$1(k.__e, E, k, R, U, H, G, Z, Y);
                (J = Oi.diffed) && J(E)
            }
            function j$1(v, E, k) {
                for (var R = 0; R < k.length; R++)
                    N(k[R], k[++R], k[++R]);
                Oi.__c && Oi.__c(E, v),
                v.some((function(E) {
                    try {
                        v = E.__h,
                        E.__h = [],
                        v.some((function(v) {
                            v.call(E)
                        }
                        ))
                    } catch (v) {
                        Oi.__e(v, E.__v)
                    }
                }
                ))
            }
            function z$1(v, E, k, R, U, H, G, W, Z) {
                var Y, J, K, X, Q, ee, te, ne = k.props, re = E.props, oe = E.type;
                if ("svg" === oe && (U = !0),
                null != H)
                    for (Y = 0; Y < H.length; Y++)
                        if ((Q = H[Y]) && "setAttribute"in Q == !!oe && (oe ? Q.localName === oe : 3 === Q.nodeType)) {
                            v = Q,
                            H[Y] = null;
                            break
                        }
                if (null == v) {
                    if (null === oe)
                        return document.createTextNode(re);
                    v = U ? document.createElementNS("http://www.w3.org/2000/svg", oe) : document.createElement(oe, re.is && re),
                    H = null,
                    W = !1
                }
                if (null === oe)
                    ne === re || W && v.data === re || (v.data = re);
                else {
                    if (H = H && ki.call(v.childNodes),
                    ne = k.props || $i,
                    !W && null != H)
                        for (ne = {},
                        Y = 0; Y < v.attributes.length; Y++)
                            ne[(Q = v.attributes[Y]).name] = Q.value;
                    for (Y in ne)
                        Q = ne[Y],
                        "children" == Y || ("dangerouslySetInnerHTML" == Y ? K = Q : "key" === Y || Y in re || A$1(v, Y, null, Q, U));
                    for (Y in re)
                        Q = re[Y],
                        "children" == Y ? X = Q : "dangerouslySetInnerHTML" == Y ? J = Q : "value" == Y ? ee = Q : "checked" == Y ? te = Q : "key" === Y || W && "function" != typeof Q || ne[Y] === Q || A$1(v, Y, Q, ne[Y], U);
                    if (J)
                        W || K && (J.__html === K.__html || J.__html === v.innerHTML) || (v.innerHTML = J.__html),
                        E.__k = [];
                    else if (K && (v.innerHTML = ""),
                    P$1(v, ji(X) ? X : [X], E, k, R, U && "foreignObject" !== oe, H, G, H ? H[0] : k.__k && m$1(k, 0), W, Z),
                    null != H)
                        for (Y = H.length; Y--; )
                            null != H[Y] && p$1(H[Y]);
                    W || (Y = "value",
                    void 0 !== ee && (ee !== v[Y] || "progress" === oe && !ee || "option" === oe && ee !== ne[Y]) && A$1(v, Y, ee, ne[Y], !1),
                    Y = "checked",
                    void 0 !== te && te !== v[Y] && A$1(v, Y, te, ne[Y], !1))
                }
                return v
            }
            function N(v, E, k) {
                try {
                    "function" == typeof v ? v(E) : v.current = E
                } catch (v) {
                    Oi.__e(v, k)
                }
            }
            function O(v, E, k) {
                var R, U;
                if (Oi.unmount && Oi.unmount(v),
                (R = v.ref) && (R.current && R.current !== v.__e || N(R, null, E)),
                null != (R = v.__c)) {
                    if (R.componentWillUnmount)
                        try {
                            R.componentWillUnmount()
                        } catch (v) {
                            Oi.__e(v, E)
                        }
                    R.base = R.__P = null,
                    v.__c = void 0
                }
                if (R = v.__k)
                    for (U = 0; U < R.length; U++)
                        R[U] && O(R[U], E, k || "function" != typeof v.type);
                k || null == v.__e || p$1(v.__e),
                v.__ = v.__e = v.__d = void 0
            }
            function q$1(v, E, k) {
                return this.constructor(v, k)
            }
            ki = Li.slice,
            Oi = {
                "__e": function(v, E, k, R) {
                    for (var U, H, G; E = E.__; )
                        if ((U = E.__c) && !U.__)
                            try {
                                if ((H = U.constructor) && null != H.getDerivedStateFromError && (U.setState(H.getDerivedStateFromError(v)),
                                G = U.__d),
                                null != U.componentDidCatch && (U.componentDidCatch(v, R || {}),
                                G = U.__d),
                                G)
                                    return U.__E = U
                            } catch (E) {
                                v = E
                            }
                    throw v
                }
            },
            Pi = 0,
            b$1.prototype.setState = function(v, E) {
                var k;
                k = null != this.__s && this.__s !== this.state ? this.__s : this.__s = v$1({}, this.state),
                "function" == typeof v && (v = v(v$1({}, k), this.props)),
                v && v$1(k, v),
                null != v && this.__v && (E && this._sb.push(E),
                x$1(this))
            }
            ,
            b$1.prototype.forceUpdate = function(v) {
                this.__v && (this.__e = !0,
                v && this.__h.push(v),
                x$1(this))
            }
            ,
            b$1.prototype.render = g$1,
            Ri = [],
            Ni = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout,
            Di = function(v, E) {
                return v.__v.__b - E.__v.__b
            }
            ,
            C$1.__r = 0;
            var Bi, Ui, Hi, zi, qi = 0, Gi = [], Vi = [], Wi = Oi, Zi = Wi.__b, Yi = Wi.__r, Ji = Wi.diffed, Ki = Wi.__c, Xi = Wi.unmount, Qi = Wi.__;
            function h(v, E) {
                Wi.__h && Wi.__h(Ui, v, qi || E),
                qi = 0;
                var k = Ui.__H || (Ui.__H = {
                    "__": [],
                    "__h": []
                });
                return v >= k.__.length && k.__.push({
                    "__V": Vi
                }),
                k.__[v]
            }
            function p(v) {
                return qi = 1,
                y(D, v)
            }
            function y(v, E, k) {
                var R = h(Bi++, 2);
                if (R.t = v,
                !R.__c && (R.__ = [k ? k(E) : D(void 0, E), function(v) {
                    var E = R.__N ? R.__N[0] : R.__[0]
                      , k = R.t(E, v);
                    E !== k && (R.__N = [k, R.__[1]],
                    R.__c.setState({}))
                }
                ],
                R.__c = Ui,
                !Ui.u)) {
                    var f = function(v, E, k) {
                        if (!R.__c.__H)
                            return !0;
                        var H = R.__c.__H.__.filter((function(v) {
                            return !!v.__c
                        }
                        ));
                        if (H.every((function(v) {
                            return !v.__N
                        }
                        )))
                            return !U || U.call(this, v, E, k);
                        var G = !1;
                        return H.forEach((function(v) {
                            if (v.__N) {
                                var E = v.__[0];
                                v.__ = v.__N,
                                v.__N = void 0,
                                E !== v.__[0] && (G = !0)
                            }
                        }
                        )),
                        !(!G && R.__c.props === v) && (!U || U.call(this, v, E, k))
                    };
                    Ui.u = !0;
                    var U = Ui.shouldComponentUpdate
                      , H = Ui.componentWillUpdate;
                    Ui.componentWillUpdate = function(v, E, k) {
                        if (this.__e) {
                            var R = U;
                            U = void 0,
                            f(v, E, k),
                            U = R
                        }
                        H && H.call(this, v, E, k)
                    }
                    ,
                    Ui.shouldComponentUpdate = f
                }
                return R.__N || R.__
            }
            function A(v, E) {
                var k = h(Bi++, 4);
                !Wi.__s && C(k.__H, E) && (k.__ = v,
                k.i = E,
                Ui.__h.push(k))
            }
            function q(v, E) {
                var k = h(Bi++, 7);
                return C(k.__H, E) ? (k.__V = v(),
                k.i = E,
                k.__h = v,
                k.__V) : k.__
            }
            function x(v, E) {
                return qi = 8,
                q((function() {
                    return v
                }
                ), E)
            }
            function j() {
                for (var v; v = Gi.shift(); )
                    if (v.__P && v.__H)
                        try {
                            v.__H.__h.forEach(z),
                            v.__H.__h.forEach(B),
                            v.__H.__h = []
                        } catch (E) {
                            v.__H.__h = [],
                            Wi.__e(E, v.__v)
                        }
            }
            Wi.__b = function(v) {
                Ui = null,
                Zi && Zi(v)
            }
            ,
            Wi.__ = function(v, E) {
                E.__k && E.__k.__m && (v.__m = E.__k.__m),
                Qi && Qi(v, E)
            }
            ,
            Wi.__r = function(v) {
                Yi && Yi(v),
                Bi = 0;
                var E = (Ui = v.__c).__H;
                E && (Hi === Ui ? (E.__h = [],
                Ui.__h = [],
                E.__.forEach((function(v) {
                    v.__N && (v.__ = v.__N),
                    v.__V = Vi,
                    v.__N = v.i = void 0
                }
                ))) : (E.__h.forEach(z),
                E.__h.forEach(B),
                E.__h = [],
                Bi = 0)),
                Hi = Ui
            }
            ,
            Wi.diffed = function(v) {
                Ji && Ji(v);
                var E = v.__c;
                E && E.__H && (E.__H.__h.length && (1 !== Gi.push(E) && zi === Wi.requestAnimationFrame || ((zi = Wi.requestAnimationFrame) || w)(j)),
                E.__H.__.forEach((function(v) {
                    v.i && (v.__H = v.i),
                    v.__V !== Vi && (v.__ = v.__V),
                    v.i = void 0,
                    v.__V = Vi
                }
                ))),
                Hi = Ui = null
            }
            ,
            Wi.__c = function(v, E) {
                E.some((function(v) {
                    try {
                        v.__h.forEach(z),
                        v.__h = v.__h.filter((function(v) {
                            return !v.__ || B(v)
                        }
                        ))
                    } catch (k) {
                        E.some((function(v) {
                            v.__h && (v.__h = [])
                        }
                        )),
                        E = [],
                        Wi.__e(k, v.__v)
                    }
                }
                )),
                Ki && Ki(v, E)
            }
            ,
            Wi.unmount = function(v) {
                Xi && Xi(v);
                var E, k = v.__c;
                k && k.__H && (k.__H.__.forEach((function(v) {
                    try {
                        z(v)
                    } catch (v) {
                        E = v
                    }
                }
                )),
                k.__H = void 0,
                E && Wi.__e(E, k.__v))
            }
            ;
            var ea = "function" == typeof requestAnimationFrame;
            function w(v) {
                var E, r = function() {
                    clearTimeout(k),
                    ea && cancelAnimationFrame(E),
                    setTimeout(v)
                }, k = setTimeout(r, 100);
                ea && (E = requestAnimationFrame(r))
            }
            function z(v) {
                var E = Ui
                  , k = v.__c;
                "function" == typeof k && (v.__c = void 0,
                k()),
                Ui = E
            }
            function B(v) {
                var E = Ui;
                v.__c = v.__(),
                Ui = E
            }
            function C(v, E) {
                return !v || v.length !== E.length || E.some((function(E, k) {
                    return E !== v[k]
                }
                ))
            }
            function D(v, E) {
                return "function" == typeof E ? E(v) : E
            }
            const ta = {
                "__proto__": null,
                "useCallback": x,
                "useContext": function P(v) {
                    var E = Ui.context[v.__c]
                      , k = h(Bi++, 9);
                    return k.c = v,
                    E ? (null == k.__ && (k.__ = !0,
                    E.sub(Ui)),
                    E.props.value) : v.__
                },
                "useDebugValue": function V(v, E) {
                    Wi.useDebugValue && Wi.useDebugValue(E ? E(v) : v)
                },
                "useEffect": function _(v, E) {
                    var k = h(Bi++, 3);
                    !Wi.__s && C(k.__H, E) && (k.__ = v,
                    k.i = E,
                    Ui.__H.__h.push(k))
                },
                "useErrorBoundary": function b(v) {
                    var E = h(Bi++, 10)
                      , k = p();
                    return E.__ = v,
                    Ui.componentDidCatch || (Ui.componentDidCatch = function(v, R) {
                        E.__ && E.__(v, R),
                        k[1](v)
                    }
                    ),
                    [k[0], function() {
                        k[1](void 0)
                    }
                    ]
                },
                "useId": function g() {
                    var v = h(Bi++, 11);
                    if (!v.__) {
                        for (var E = Ui.__v; null !== E && !E.__m && null !== E.__; )
                            E = E.__;
                        var k = E.__m || (E.__m = [0, 0]);
                        v.__ = "P" + k[0] + "-" + k[1]++
                    }
                    return v.__
                },
                "useImperativeHandle": function T(v, E, k) {
                    qi = 6,
                    A((function() {
                        return "function" == typeof v ? (v(E()),
                        function() {
                            return v(null)
                        }
                        ) : v ? (v.current = E(),
                        function() {
                            return v.current = null
                        }
                        ) : void 0
                    }
                    ), null == k ? k : k.concat(v))
                },
                "useLayoutEffect": A,
                "useMemo": q,
                "useReducer": y,
                "useRef": function F(v) {
                    return qi = 5,
                    q((function() {
                        return {
                            "current": v
                        }
                    }
                    ), [])
                },
                "useState": p
            }
              , na = "http://www.w3.org/2000/svg";
            function SentryLogo() {
                const createElementNS = v => yi.createElementNS(na, v)
                  , v = setAttributesNS(createElementNS("svg"), {
                    "width": "32",
                    "height": "30",
                    "viewBox": "0 0 72 66",
                    "fill": "inherit"
                })
                  , E = setAttributesNS(createElementNS("path"), {
                    "transform": "translate(11, 11)",
                    "d": "M29,2.26a4.67,4.67,0,0,0-8,0L14.42,13.53A32.21,32.21,0,0,1,32.17,40.19H27.55A27.68,27.68,0,0,0,12.09,17.47L6,28a15.92,15.92,0,0,1,9.23,12.17H4.62A.76.76,0,0,1,4,39.06l2.94-5a10.74,10.74,0,0,0-3.36-1.9l-2.91,5a4.54,4.54,0,0,0,1.69,6.24A4.66,4.66,0,0,0,4.62,44H19.15a19.4,19.4,0,0,0-8-17.31l2.31-4A23.87,23.87,0,0,1,23.76,44H36.07a35.88,35.88,0,0,0-16.41-31.8l4.67-8a.77.77,0,0,1,1.05-.27c.53.29,20.29,34.77,20.66,35.17a.76.76,0,0,1-.68,1.13H40.6q.09,1.91,0,3.81h4.78A4.59,4.59,0,0,0,50,39.43a4.49,4.49,0,0,0-.62-2.28Z"
                });
                return v.appendChild(E),
                v
            }
            const ra = "/home/runner/work/sentry-javascript/sentry-javascript/packages/feedback/src/modal/components/DialogHeader.tsx";
            function DialogHeader({"options": v}) {
                const E = q(( () => ({
                    "__html": SentryLogo().outerHTML
                })), []);
                return y$1("h2", {
                    "class": "dialog__header",
                    "__self": this,
                    "__source": {
                        "fileName": ra,
                        "lineNumber": 16
                    }
                }, v.formTitle, v.showBranding ? y$1("a", {
                    "class": "brand-link",
                    "target": "_blank",
                    "href": "https://sentry.io/welcome/",
                    "title": "Powered by Sentry",
                    "rel": "noopener noreferrer",
                    "dangerouslySetInnerHTML": E,
                    "__self": this,
                    "__source": {
                        "fileName": ra,
                        "lineNumber": 19
                    }
                }) : null)
            }
            const oa = "/home/runner/work/sentry-javascript/sentry-javascript/packages/feedback/src/modal/components/Form.tsx";
            function retrieveStringValue(v, E) {
                const k = v.get(E);
                return "string" == typeof k ? k.trim() : ""
            }
            function Form({"options": v, "defaultEmail": E, "defaultName": k, "onFormClose": R, "onSubmit": U, "onSubmitSuccess": H, "onSubmitError": G, "showEmail": W, "showName": Z, "screenshotInput": Y}) {
                const {"tags": J, "addScreenshotButtonLabel": K, "removeScreenshotButtonLabel": X, "cancelButtonLabel": Q, "emailLabel": ee, "emailPlaceholder": te, "isEmailRequired": ne, "isNameRequired": re, "messageLabel": oe, "messagePlaceholder": ie, "nameLabel": ae, "namePlaceholder": se, "submitButtonLabel": ce, "isRequiredLabel": le} = v
                  , [ue,de] = p(null)
                  , [pe,fe] = p(!1)
                  , he = Y && Y.input
                  , [me,ge] = p(null)
                  , _e = x((v => {
                    ge(v),
                    fe(!1)
                }
                ), [])
                  , ve = x((v => {
                    const E = function getMissingFields(v, E) {
                        const k = [];
                        return E.isNameRequired && !v.name && k.push(E.nameLabel),
                        E.isEmailRequired && !v.email && k.push(E.emailLabel),
                        v.message || k.push(E.messageLabel),
                        k
                    }(v, {
                        "emailLabel": ee,
                        "isEmailRequired": ne,
                        "isNameRequired": re,
                        "messageLabel": oe,
                        "nameLabel": ae
                    });
                    return E.length > 0 ? de(`Please enter in the following required fields: ${E.join(", ")}`) : de(null),
                    0 === E.length
                }
                ), [ee, ne, re, oe, ae])
                  , ye = x((async v => {
                    try {
                        if (v.preventDefault(),
                        !(v.target instanceof HTMLFormElement))
                            return;
                        const E = new FormData(v.target)
                          , k = await (Y && pe ? Y.value() : void 0)
                          , R = {
                            "name": retrieveStringValue(E, "name"),
                            "email": retrieveStringValue(E, "email"),
                            "message": retrieveStringValue(E, "message"),
                            "attachments": k ? [k] : void 0
                        };
                        if (!ve(R))
                            return;
                        try {
                            await U({
                                "name": R.name,
                                "email": R.email,
                                "message": R.message,
                                "source": wi,
                                "tags": J
                            }, {
                                "attachments": R.attachments
                            }),
                            H(R)
                        } catch (v) {
                            Ei && hi.error(v),
                            de(v),
                            G(v)
                        }
                    } catch (v) {}
                }
                ), [Y && pe, H, G]);
                return y$1("form", {
                    "class": "form",
                    "onSubmit": ye,
                    "__self": this,
                    "__source": {
                        "fileName": oa,
                        "lineNumber": 144
                    }
                }, he && pe ? y$1(he, {
                    "onError": _e,
                    "__self": this,
                    "__source": {
                        "fileName": oa,
                        "lineNumber": 146
                    }
                }) : null, y$1("div", {
                    "class": "form__right",
                    "data-sentry-feedback": !0,
                    "__self": this,
                    "__source": {
                        "fileName": oa,
                        "lineNumber": 149
                    }
                }, y$1("div", {
                    "class": "form__top",
                    "__self": this,
                    "__source": {
                        "fileName": oa,
                        "lineNumber": 150
                    }
                }, ue ? y$1("div", {
                    "class": "form__error-container",
                    "__self": this,
                    "__source": {
                        "fileName": oa,
                        "lineNumber": 151
                    }
                }, ue) : null, Z ? y$1("label", {
                    "for": "name",
                    "class": "form__label",
                    "__self": this,
                    "__source": {
                        "fileName": oa,
                        "lineNumber": 154
                    }
                }, y$1(LabelText, {
                    "label": ae,
                    "isRequiredLabel": le,
                    "isRequired": re,
                    "__self": this,
                    "__source": {
                        "fileName": oa,
                        "lineNumber": 155
                    }
                }), y$1("input", {
                    "class": "form__input",
                    "defaultValue": k,
                    "id": "name",
                    "name": "name",
                    "placeholder": se,
                    "required": re,
                    "type": "text",
                    "__self": this,
                    "__source": {
                        "fileName": oa,
                        "lineNumber": 156
                    }
                })) : y$1("input", {
                    "aria-hidden": !0,
                    "value": k,
                    "name": "name",
                    "type": "hidden",
                    "__self": this,
                    "__source": {
                        "fileName": oa,
                        "lineNumber": 167
                    }
                }), W ? y$1("label", {
                    "for": "email",
                    "class": "form__label",
                    "__self": this,
                    "__source": {
                        "fileName": oa,
                        "lineNumber": 171
                    }
                }, y$1(LabelText, {
                    "label": ee,
                    "isRequiredLabel": le,
                    "isRequired": ne,
                    "__self": this,
                    "__source": {
                        "fileName": oa,
                        "lineNumber": 172
                    }
                }), y$1("input", {
                    "class": "form__input",
                    "defaultValue": E,
                    "id": "email",
                    "name": "email",
                    "placeholder": te,
                    "required": ne,
                    "type": "email",
                    "__self": this,
                    "__source": {
                        "fileName": oa,
                        "lineNumber": 173
                    }
                })) : y$1("input", {
                    "aria-hidden": !0,
                    "value": E,
                    "name": "email",
                    "type": "hidden",
                    "__self": this,
                    "__source": {
                        "fileName": oa,
                        "lineNumber": 184
                    }
                }), y$1("label", {
                    "for": "message",
                    "class": "form__label",
                    "__self": this,
                    "__source": {
                        "fileName": oa,
                        "lineNumber": 187
                    }
                }, y$1(LabelText, {
                    "label": oe,
                    "isRequiredLabel": le,
                    "isRequired": !0,
                    "__self": this,
                    "__source": {
                        "fileName": oa,
                        "lineNumber": 188
                    }
                }), y$1("textarea", {
                    "autoFocus": !0,
                    "class": "form__input form__input--textarea",
                    "id": "message",
                    "name": "message",
                    "placeholder": ie,
                    "required": !0,
                    "rows": 5,
                    "__self": this,
                    "__source": {
                        "fileName": oa,
                        "lineNumber": 189
                    }
                })), he ? y$1("label", {
                    "for": "screenshot",
                    "class": "form__label",
                    "__self": this,
                    "__source": {
                        "fileName": oa,
                        "lineNumber": 201
                    }
                }, y$1("button", {
                    "class": "btn btn--default",
                    "type": "button",
                    "onClick": () => {
                        ge(null),
                        fe((v => !v))
                    }
                    ,
                    "__self": this,
                    "__source": {
                        "fileName": oa,
                        "lineNumber": 202
                    }
                }, pe ? X : K), me ? y$1("div", {
                    "class": "form__error-container",
                    "__self": this,
                    "__source": {
                        "fileName": oa,
                        "lineNumber": 212
                    }
                }, me.message) : null) : null), y$1("div", {
                    "class": "btn-group",
                    "__self": this,
                    "__source": {
                        "fileName": oa,
                        "lineNumber": 216
                    }
                }, y$1("button", {
                    "class": "btn btn--primary",
                    "type": "submit",
                    "__self": this,
                    "__source": {
                        "fileName": oa,
                        "lineNumber": 217
                    }
                }, ce), y$1("button", {
                    "class": "btn btn--default",
                    "type": "button",
                    "onClick": R,
                    "__self": this,
                    "__source": {
                        "fileName": oa,
                        "lineNumber": 220
                    }
                }, Q))))
            }
            function LabelText({"label": v, "isRequired": E, "isRequiredLabel": k}) {
                return y$1("span", {
                    "class": "form__label__text",
                    "__self": this,
                    "__source": {
                        "fileName": oa,
                        "lineNumber": 239
                    }
                }, v, E && y$1("span", {
                    "class": "form__label__text--required",
                    "__self": this,
                    "__source": {
                        "fileName": oa,
                        "lineNumber": 241
                    }
                }, k))
            }
            const ia = 16
              , aa = 17
              , sa = "http://www.w3.org/2000/svg";
            function SuccessIcon() {
                const createElementNS = v => vi.document.createElementNS(sa, v)
                  , v = setAttributesNS(createElementNS("svg"), {
                    "width": `${ia}`,
                    "height": `${aa}`,
                    "viewBox": `0 0 ${ia} ${aa}`,
                    "fill": "inherit"
                })
                  , E = setAttributesNS(createElementNS("g"), {
                    "clipPath": "url(#clip0_57_156)"
                })
                  , k = setAttributesNS(createElementNS("path"), {
                    "fill-rule": "evenodd",
                    "clip-rule": "evenodd",
                    "d": "M3.55544 15.1518C4.87103 16.0308 6.41775 16.5 8 16.5C10.1217 16.5 12.1566 15.6571 13.6569 14.1569C15.1571 12.6566 16 10.6217 16 8.5C16 6.91775 15.5308 5.37103 14.6518 4.05544C13.7727 2.73985 12.5233 1.71447 11.0615 1.10897C9.59966 0.503466 7.99113 0.34504 6.43928 0.653721C4.88743 0.962403 3.46197 1.72433 2.34315 2.84315C1.22433 3.96197 0.462403 5.38743 0.153721 6.93928C-0.15496 8.49113 0.00346625 10.0997 0.608967 11.5615C1.21447 13.0233 2.23985 14.2727 3.55544 15.1518ZM4.40546 3.1204C5.46945 2.40946 6.72036 2.03 8 2.03C9.71595 2.03 11.3616 2.71166 12.575 3.92502C13.7883 5.13838 14.47 6.78405 14.47 8.5C14.47 9.77965 14.0905 11.0306 13.3796 12.0945C12.6687 13.1585 11.6582 13.9878 10.476 14.4775C9.29373 14.9672 7.99283 15.0953 6.73777 14.8457C5.48271 14.596 4.32987 13.9798 3.42502 13.075C2.52018 12.1701 1.90397 11.0173 1.65432 9.76224C1.40468 8.50718 1.5328 7.20628 2.0225 6.02404C2.5122 4.8418 3.34148 3.83133 4.40546 3.1204Z"
                })
                  , R = setAttributesNS(createElementNS("path"), {
                    "d": "M6.68775 12.4297C6.78586 12.4745 6.89218 12.4984 7 12.5C7.11275 12.4955 7.22315 12.4664 7.32337 12.4145C7.4236 12.3627 7.51121 12.2894 7.58 12.2L12 5.63999C12.0848 5.47724 12.1071 5.28902 12.0625 5.11098C12.0178 4.93294 11.9095 4.77744 11.7579 4.67392C11.6064 4.57041 11.4221 4.52608 11.24 4.54931C11.0579 4.57254 10.8907 4.66173 10.77 4.79999L6.88 10.57L5.13 8.56999C5.06508 8.49566 4.98613 8.43488 4.89768 8.39111C4.80922 8.34735 4.713 8.32148 4.61453 8.31498C4.51605 8.30847 4.41727 8.32147 4.32382 8.35322C4.23038 8.38497 4.14413 8.43484 4.07 8.49999C3.92511 8.63217 3.83692 8.81523 3.82387 9.01092C3.81083 9.2066 3.87393 9.39976 4 9.54999L6.43 12.24C6.50187 12.3204 6.58964 12.385 6.68775 12.4297Z"
                });
                v.appendChild(E).append(R, k);
                const U = createElementNS("defs")
                  , H = setAttributesNS(createElementNS("clipPath"), {
                    "id": "clip0_57_156"
                })
                  , G = setAttributesNS(createElementNS("rect"), {
                    "width": `${ia}`,
                    "height": `${ia}`,
                    "fill": "white",
                    "transform": "translate(0 0.5)"
                });
                return H.appendChild(G),
                U.appendChild(H),
                v.appendChild(U).appendChild(H).appendChild(G),
                v
            }
            const ca = "/home/runner/work/sentry-javascript/sentry-javascript/packages/feedback/src/modal/components/Dialog.tsx";
            function Dialog({"open": v, "onFormSubmitted": E, ...k}) {
                const R = k.options
                  , U = q(( () => ({
                    "__html": SuccessIcon().outerHTML
                })), [])
                  , [H,G] = p(null)
                  , W = x(( () => {
                    H && (clearTimeout(H),
                    G(null)),
                    E()
                }
                ), [H])
                  , Z = x((v => {
                    k.onSubmitSuccess(v),
                    G(setTimeout(( () => {
                        E(),
                        G(null)
                    }
                    ), 5e3))
                }
                ), [E]);
                return y$1(g$1, {
                    "__self": this,
                    "__source": {
                        "fileName": ca,
                        "lineNumber": 48
                    }
                }, H ? y$1("div", {
                    "class": "success__position",
                    "onClick": W,
                    "__self": this,
                    "__source": {
                        "fileName": ca,
                        "lineNumber": 50
                    }
                }, y$1("div", {
                    "class": "success__content",
                    "__self": this,
                    "__source": {
                        "fileName": ca,
                        "lineNumber": 51
                    }
                }, R.successMessageText, y$1("span", {
                    "class": "success__icon",
                    "dangerouslySetInnerHTML": U,
                    "__self": this,
                    "__source": {
                        "fileName": ca,
                        "lineNumber": 53
                    }
                }))) : y$1("dialog", {
                    "class": "dialog",
                    "onClick": R.onFormClose,
                    "open": v,
                    "__self": this,
                    "__source": {
                        "fileName": ca,
                        "lineNumber": 57
                    }
                }, y$1("div", {
                    "class": "dialog__position",
                    "__self": this,
                    "__source": {
                        "fileName": ca,
                        "lineNumber": 58
                    }
                }, y$1("div", {
                    "class": "dialog__content",
                    "onClick": v => {
                        v.stopPropagation()
                    }
                    ,
                    "__self": this,
                    "__source": {
                        "fileName": ca,
                        "lineNumber": 59
                    }
                }, y$1(DialogHeader, {
                    "options": R,
                    "__self": this,
                    "__source": {
                        "fileName": ca,
                        "lineNumber": 66
                    }
                }), y$1(Form, {
                    ...k,
                    "onSubmitSuccess": Z,
                    "__self": this,
                    "__source": {
                        "fileName": ca,
                        "lineNumber": 67
                    }
                })))))
            }
            function getUser() {
                const v = core_build_esm_currentScopes_getCurrentScope().getUser()
                  , E = function core_build_esm_currentScopes_getIsolationScope() {
                    return core_build_esm_asyncContext_getAsyncContextStrategy(core_build_esm_carrier_getMainCarrier()).getIsolationScope()
                }().getUser()
                  , k = function core_build_esm_currentScopes_getGlobalScope() {
                    return _sentry_utils_build_esm_worldwide_getGlobalSingleton("globalScope", ( () => new gi))
                }().getUser();
                return v && Object.keys(v).length ? v : E && Object.keys(E).length ? E : k
            }
            const feedbackModalIntegration = () => ({
                "name": "FeedbackModal",
                "setupOnce"() {},
                "createDialog": ({"options": v, "screenshotIntegration": E, "sendFeedback": k, "shadow": R}) => {
                    const U = R
                      , H = v.useSentryUser
                      , G = getUser()
                      , W = yi.createElement("div")
                      , Z = function createDialogStyles(v) {
                        const E = yi.createElement("style");
                        return E.textContent = "\n:host {\n  --dialog-inset: var(--inset);\n}\n\n\n.dialog {\n  position: fixed;\n  z-index: var(--z-index);\n  margin: 0;\n  inset: 0;\n\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  padding: 0;\n  height: 100vh;\n  width: 100vw;\n\n  color: var(--dialog-color, var(--foreground));\n  fill: var(--dialog-color, var(--foreground));\n  line-height: 1.75em;\n\n  background-color: rgba(0, 0, 0, 0.05);\n  border: none;\n  inset: 0;\n  opacity: 1;\n  transition: opacity 0.2s ease-in-out;\n}\n\n.dialog__position {\n  position: fixed;\n  z-index: var(--z-index);\n  inset: var(--dialog-inset);\n  padding: var(--page-margin);\n  display: flex;\n  max-height: calc(100vh - (2 * var(--page-margin)));\n}\n@media (max-width: 600px) {\n  .dialog__position {\n    inset: var(--page-margin);\n    padding: 0;\n  }\n}\n\n.dialog__position:has(.editor) {\n  inset: var(--page-margin);\n  padding: 0;\n}\n\n.dialog:not([open]) {\n  opacity: 0;\n  pointer-events: none;\n  visibility: hidden;\n}\n.dialog:not([open]) .dialog__content {\n  transform: translate(0, -16px) scale(0.98);\n}\n\n.dialog__content {\n  display: flex;\n  flex-direction: column;\n  gap: 16px;\n  padding: var(--dialog-padding, 24px);\n  max-width: 100%;\n  width: 100%;\n  max-height: 100%;\n  overflow: auto;\n\n  background: var(--dialog-background, var(--background));\n  border-radius: var(--dialog-border-radius, 20px);\n  border: var(--dialog-border, var(--border));\n  box-shadow: var(--dialog-box-shadow, var(--box-shadow));\n  transform: translate(0, 0) scale(1);\n  transition: transform 0.2s ease-in-out;\n}\n\n\n.dialog__header {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  font-weight: var(--dialog-header-weight, 600);\n  margin: 0;\n}\n\n.brand-link {\n  display: inline-flex;\n}\n.brand-link:focus-visible {\n  outline: var(--outline);\n}\n\n\n.form {\n  display: flex;\n  overflow: auto;\n  flex-direction: row;\n  gap: 16px;\n  flex: 1 0;\n}\n\n.form__right {\n  flex: 0 0 var(--form-width, 272px);\n  width: var(--form-width, 272px);\n  display: flex;\n  overflow: auto;\n  flex-direction: column;\n  justify-content: space-between;\n  gap: 20px;\n}\n\n@media (max-width: 600px) {\n  .form__right {\n    width: auto;\n  }\n}\n\n.form__top {\n  display: flex;\n  flex-direction: column;\n  gap: 8px;\n}\n\n.form__error-container {\n  color: var(--error-color);\n  fill: var(--error-color);\n}\n\n.form__label {\n  display: flex;\n  flex-direction: column;\n  gap: 4px;\n  margin: 0px;\n}\n\n.form__label__text {\n  display: flex;\n  gap: 4px;\n  align-items: center;\n}\n\n.form__label__text--required {\n  font-size: 0.85em;\n}\n\n.form__input {\n  font-family: inherit;\n  line-height: inherit;\n  background: transparent;\n  box-sizing: border-box;\n  border: var(--input-border, var(--border));\n  border-radius: var(--input-border-radius, 6px);\n  color: var(--input-color, inherit);\n  fill: var(--input-color, inherit);\n  font-size: var(--input-font-size, inherit);\n  font-weight: var(--input-font-weight, 500);\n  padding: 6px 12px;\n}\n\n.form__input::placeholder {\n  opacity: 0.65;\n  color: var(--input-placeholder-color, inherit);\n  filter: var(--interactive-filter);\n}\n\n.form__input:focus-visible {\n  outline: var(--input-focus-outline, var(--outline));\n}\n\n.form__input--textarea {\n  font-family: inherit;\n  resize: vertical;\n}\n\n.error {\n  color: var(--error-color);\n  fill: var(--error-color);\n}\n\n\n.btn-group {\n  display: grid;\n  gap: 8px;\n}\n\n.btn {\n  line-height: inherit;\n  border: var(--button-border, var(--border));\n  border-radius: var(--button-border-radius, 6px);\n  cursor: pointer;\n  font-family: inherit;\n  font-size: var(--button-font-size, inherit);\n  font-weight: var(--button-font-weight, 600);\n  padding: var(--button-padding, 6px 16px);\n}\n.btn[disabled] {\n  opacity: 0.6;\n  pointer-events: none;\n}\n\n.btn--primary {\n  color: var(--button-primary-color, var(--accent-foreground));\n  fill: var(--button-primary-color, var(--accent-foreground));\n  background: var(--button-primary-background, var(--accent-background));\n  border: var(--button-primary-border, var(--border));\n  border-radius: var(--button-primary-border-radius, 6px);\n  font-weight: var(--button-primary-font-weight, 500);\n}\n.btn--primary:hover {\n  color: var(--button-primary-hover-color, var(--accent-foreground));\n  fill: var(--button-primary-hover-color, var(--accent-foreground));\n  background: var(--button-primary-hover-background, var(--accent-background));\n  filter: var(--interactive-filter);\n}\n.btn--primary:focus-visible {\n  background: var(--button-primary-hover-background, var(--accent-background));\n  filter: var(--interactive-filter);\n  outline: var(--button-primary-focus-outline, var(--outline));\n}\n\n.btn--default {\n  color: var(--button-color, var(--foreground));\n  fill: var(--button-color, var(--foreground));\n  background: var(--button-background, var(--background));\n  border: var(--button-border, var(--border));\n  border-radius: var(--button-border-radius, 6px);\n  font-weight: var(--button-font-weight, 500);\n}\n.btn--default:hover {\n  color: var(--button-color, var(--foreground));\n  fill: var(--button-color, var(--foreground));\n  background: var(--button-hover-background, var(--background));\n  filter: var(--interactive-filter);\n}\n.btn--default:focus-visible {\n  background: var(--button-hover-background, var(--background));\n  filter: var(--interactive-filter);\n  outline: var(--button-focus-outline, var(--outline));\n}\n\n\n.success__position {\n  position: fixed;\n  inset: var(--dialog-inset);\n  padding: var(--page-margin);\n  z-index: var(--z-index);\n}\n.success__content {\n  background: var(--success-background, var(--background));\n  border: var(--success-border, var(--border));\n  border-radius: var(--success-border-radius, 1.7em/50%);\n  box-shadow: var(--success-box-shadow, var(--box-shadow));\n  font-weight: var(--success-font-weight, 600);\n  color: var(--success-color);\n  fill: var(--success-color);\n  padding: 12px 24px;\n  line-height: 1.75em;\n\n  display: grid;\n  align-items: center;\n  grid-auto-flow: column;\n  gap: 6px;\n  cursor: default;\n}\n\n.success__icon {\n  display: flex;\n}\n\n",
                        v && E.setAttribute("nonce", v),
                        E
                    }(v.styleNonce);
                    let Y = "";
                    const J = {
                        get "el"() {
                            return W
                        },
                        "appendToDom"() {
                            U.contains(Z) || U.contains(W) || (U.appendChild(Z),
                            U.appendChild(W))
                        },
                        "removeFromDom"() {
                            U.removeChild(W),
                            U.removeChild(Z),
                            yi.body.style.overflow = Y
                        },
                        "open"() {
                            renderContent(!0),
                            v.onFormOpen && v.onFormOpen(),
                            Y = yi.body.style.overflow,
                            yi.body.style.overflow = "hidden"
                        },
                        "close"() {
                            renderContent(!1),
                            yi.body.style.overflow = Y
                        }
                    }
                      , K = E && E.createInput({
                        "h": y$1,
                        "hooks": ta,
                        "dialog": J,
                        "options": v
                    })
                      , renderContent = E => {
                        !function B$1(v, E, k) {
                            var R, U, H, G;
                            Oi.__ && Oi.__(v, E),
                            U = (R = "function" == typeof k) ? null : k && k.__k || E.__k,
                            H = [],
                            G = [],
                            M(E, v = (!R && k || E).__k = y$1(g$1, null, [v]), U || $i, $i, void 0 !== E.ownerSVGElement, !R && k ? [k] : U ? null : E.firstChild ? ki.call(E.childNodes) : null, H, !R && k ? k : U ? U.__e : E.firstChild, R, G),
                            v.__d = void 0,
                            j$1(H, v, G)
                        }(y$1(Dialog, {
                            "options": v,
                            "screenshotInput": K,
                            "showName": v.showName || v.isNameRequired,
                            "showEmail": v.showEmail || v.isEmailRequired,
                            "defaultName": H && G && G[H.name] || "",
                            "defaultEmail": H && G && G[H.email] || "",
                            "onFormClose": () => {
                                renderContent(!1),
                                v.onFormClose && v.onFormClose()
                            }
                            ,
                            "onSubmit": k,
                            "onSubmitSuccess": E => {
                                renderContent(!1),
                                v.onSubmitSuccess && v.onSubmitSuccess(E)
                            }
                            ,
                            "onSubmitError": E => {
                                v.onSubmitError && v.onSubmitError(E)
                            }
                            ,
                            "onFormSubmitted": () => {
                                v.onFormSubmitted && v.onFormSubmitted()
                            }
                            ,
                            "open": E,
                            "__self": void 0,
                            "__source": {
                                "fileName": "/home/runner/work/sentry-javascript/sentry-javascript/packages/feedback/src/modal/integration.tsx",
                                "lineNumber": 67
                            }
                        }), W)
                    }
                    ;
                    return J
                }
            })
              , la = "/home/runner/work/sentry-javascript/sentry-javascript/packages/feedback/src/screenshot/components/CropCorner.tsx";
            function createScreenshotInputStyles(v) {
                const E = yi.createElement("style")
                  , k = "#1A141F"
                  , R = "#302735";
                return E.textContent = `\n.editor {\n  padding: 10px;\n  padding-top: 65px;\n  padding-bottom: 65px;\n  flex-grow: 1;\n\n  background-color: ${k};\n  background-image: repeating-linear-gradient(\n      -145deg,\n      transparent,\n      transparent 8px,\n      ${k} 8px,\n      ${k} 11px\n    ),\n    repeating-linear-gradient(\n      -45deg,\n      transparent,\n      transparent 15px,\n      ${R} 15px,\n      ${R} 16px\n    );\n}\n\n.editor__canvas-container {\n  width: 100%;\n  height: 100%;\n  position: relative;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.editor__canvas-container canvas {\n  object-fit: contain;\n  position: relative;\n}\n\n.editor__crop-btn-group {\n  padding: 8px;\n  gap: 8px;\n  border-radius: var(--menu-border-radius, 6px);\n  background: var(--button-primary-background, var(--background));\n  width: 175px;\n  position: absolute;\n}\n\n.editor__crop-corner {\n  width: 30px;\n  height: 30px;\n  position: absolute;\n  background: none;\n  border: 3px solid #ffffff;\n}\n\n.editor__crop-corner--top-left {\n  cursor: nwse-resize;\n  border-right: none;\n  border-bottom: none;\n}\n.editor__crop-corner--top-right {\n  cursor: nesw-resize;\n  border-left: none;\n  border-bottom: none;\n}\n.editor__crop-corner--bottom-left {\n  cursor: nesw-resize;\n  border-right: none;\n  border-top: none;\n}\n.editor__crop-corner--bottom-right {\n  cursor: nwse-resize;\n  border-left: none;\n  border-top: none;\n}\n`,
                v && E.setAttribute("nonce", v),
                E
            }
            const ua = "/home/runner/work/sentry-javascript/sentry-javascript/packages/feedback/src/screenshot/components/ScreenshotEditor.tsx"
              , da = 33
              , pa = vi.devicePixelRatio
              , constructRect = v => ({
                "x": Math.min(v.startX, v.endX),
                "y": Math.min(v.startY, v.endY),
                "width": Math.abs(v.startX - v.endX),
                "height": Math.abs(v.startY - v.endY)
            })
              , getContainedSize = v => {
                const E = v.clientHeight
                  , k = v.clientWidth
                  , R = v.width / v.height;
                let U = E * R
                  , H = E;
                U > k && (U = k,
                H = k / R);
                const G = (k - U) / 2
                  , W = (E - H) / 2;
                return {
                    "startX": G,
                    "startY": W,
                    "endX": U + G,
                    "endY": H + W
                }
            }
            ;
            function ScreenshotEditorFactory({"h": v, "hooks": E, "imageBuffer": k, "dialog": R, "options": U}) {
                const H = function useTakeScreenshotFactory({"hooks": v}) {
                    return function useTakeScreenshot({"onBeforeScreenshot": E, "onScreenshot": k, "onAfterScreenshot": R, "onError": U}) {
                        v.useEffect(( () => {
                            (async () => {
                                E();
                                const v = await bi.mediaDevices.getDisplayMedia({
                                    "video": {
                                        "width": vi.innerWidth * vi.devicePixelRatio,
                                        "height": vi.innerHeight * vi.devicePixelRatio
                                    },
                                    "audio": !1,
                                    "monitorTypeSurfaces": "exclude",
                                    "preferCurrentTab": !0,
                                    "selfBrowserSurface": "include",
                                    "surfaceSwitching": "exclude"
                                })
                                  , U = yi.createElement("video");
                                await new Promise(( (E, R) => {
                                    U.srcObject = v,
                                    U.onloadedmetadata = () => {
                                        k(U),
                                        v.getTracks().forEach((v => v.stop())),
                                        E()
                                    }
                                    ,
                                    U.play().catch(R)
                                }
                                )),
                                R()
                            }
                            )().catch(U)
                        }
                        ), [])
                    }
                }({
                    "hooks": E
                });
                return function ScreenshotEditor({"onError": G}) {
                    const W = E.useMemo(( () => ({
                        "__html": createScreenshotInputStyles(U.styleNonce).innerText
                    })), [])
                      , Z = function CropCornerFactory({"h": v}) {
                        return function CropCorner({"top": E, "left": k, "corner": R, "onGrabButton": U}) {
                            return v("button", {
                                "class": `editor__crop-corner editor__crop-corner--${R} `,
                                "style": {
                                    "top": E,
                                    "left": k
                                },
                                "onMouseDown": v => {
                                    v.preventDefault(),
                                    U(v, R)
                                }
                                ,
                                "onClick": v => {
                                    v.preventDefault()
                                }
                                ,
                                "__self": this,
                                "__source": {
                                    "fileName": la,
                                    "lineNumber": 22
                                }
                            })
                        }
                    }({
                        "h": v
                    })
                      , Y = E.useRef(null)
                      , J = E.useRef(null)
                      , K = E.useRef(null)
                      , [X,Q] = E.useState({
                        "startX": 0,
                        "startY": 0,
                        "endX": 0,
                        "endY": 0
                    })
                      , [ee,te] = E.useState(!1)
                      , [ne,re] = E.useState(!1);
                    function resizeCropper() {
                        const v = K.current
                          , E = constructRect(getContainedSize(k));
                        if (v) {
                            v.width = E.width * pa,
                            v.height = E.height * pa,
                            v.style.width = `${E.width}px`,
                            v.style.height = `${E.height}px`;
                            const k = v.getContext("2d");
                            k && k.scale(pa, pa)
                        }
                        const R = J.current;
                        R && (R.style.width = `${E.width}px`,
                        R.style.height = `${E.height}px`),
                        Q({
                            "startX": 0,
                            "startY": 0,
                            "endX": E.width,
                            "endY": E.height
                        })
                    }
                    function onGrabButton(v, E) {
                        te(!1),
                        re(!0);
                        const k = oe(E)
                          , handleMouseUp = () => {
                            yi.removeEventListener("mousemove", k),
                            yi.removeEventListener("mouseup", handleMouseUp),
                            te(!0),
                            re(!1)
                        }
                        ;
                        yi.addEventListener("mouseup", handleMouseUp),
                        yi.addEventListener("mousemove", k)
                    }
                    E.useEffect(( () => {
                        vi.addEventListener("resize", resizeCropper, !1)
                    }
                    ), []),
                    E.useEffect(( () => {
                        const v = K.current;
                        if (!v)
                            return;
                        const E = v.getContext("2d");
                        if (!E)
                            return;
                        const R = constructRect(getContainedSize(k))
                          , U = constructRect(X);
                        E.clearRect(0, 0, R.width, R.height),
                        E.fillStyle = "rgba(0, 0, 0, 0.5)",
                        E.fillRect(0, 0, R.width, R.height),
                        E.clearRect(U.x, U.y, U.width, U.height),
                        E.strokeStyle = "#ffffff",
                        E.lineWidth = 3,
                        E.strokeRect(U.x + 1, U.y + 1, U.width - 2, U.height - 2),
                        E.strokeStyle = "#000000",
                        E.lineWidth = 1,
                        E.strokeRect(U.x + 3, U.y + 3, U.width - 6, U.height - 6)
                    }
                    ), [X]);
                    const oe = E.useCallback((v => function(E) {
                        if (!K.current)
                            return;
                        const k = K.current
                          , R = k.getBoundingClientRect()
                          , U = E.clientX - R.x
                          , H = E.clientY - R.y;
                        switch (v) {
                        case "top-left":
                            Q((v => ({
                                ...v,
                                "startX": Math.min(Math.max(0, U), v.endX - da),
                                "startY": Math.min(Math.max(0, H), v.endY - da)
                            })));
                            break;
                        case "top-right":
                            Q((v => ({
                                ...v,
                                "endX": Math.max(Math.min(U, k.width / pa), v.startX + da),
                                "startY": Math.min(Math.max(0, H), v.endY - da)
                            })));
                            break;
                        case "bottom-left":
                            Q((v => ({
                                ...v,
                                "startX": Math.min(Math.max(0, U), v.endX - da),
                                "endY": Math.max(Math.min(H, k.height / pa), v.startY + da)
                            })));
                            break;
                        case "bottom-right":
                            Q((v => ({
                                ...v,
                                "endX": Math.max(Math.min(U, k.width / pa), v.startX + da),
                                "endY": Math.max(Math.min(H, k.height / pa), v.startY + da)
                            })))
                        }
                    }
                    ), [])
                      , ie = E.useRef({
                        "initialX": 0,
                        "initialY": 0
                    });
                    return H({
                        "onBeforeScreenshot": E.useCallback(( () => {
                            R.el.style.display = "none"
                        }
                        ), []),
                        "onScreenshot": E.useCallback((v => {
                            const E = k.getContext("2d");
                            if (!E)
                                throw new Error("Could not get canvas context");
                            k.width = v.videoWidth,
                            k.height = v.videoHeight,
                            k.style.width = "100%",
                            k.style.height = "100%",
                            E.drawImage(v, 0, 0)
                        }
                        ), [k]),
                        "onAfterScreenshot": E.useCallback(( () => {
                            R.el.style.display = "block";
                            const v = Y.current;
                            v && v.appendChild(k),
                            resizeCropper()
                        }
                        ), []),
                        "onError": E.useCallback((v => {
                            R.el.style.display = "block",
                            G(v)
                        }
                        ), [])
                    }),
                    v("div", {
                        "class": "editor",
                        "__self": this,
                        "__source": {
                            "fileName": ua,
                            "lineNumber": 315
                        }
                    }, v("style", {
                        "nonce": U.styleNonce,
                        "dangerouslySetInnerHTML": W,
                        "__self": this,
                        "__source": {
                            "fileName": ua,
                            "lineNumber": 316
                        }
                    }), v("div", {
                        "class": "editor__canvas-container",
                        "ref": Y,
                        "__self": this,
                        "__source": {
                            "fileName": ua,
                            "lineNumber": 317
                        }
                    }, v("div", {
                        "class": "editor__crop-container",
                        "style": {
                            "position": "absolute",
                            "zIndex": 1
                        },
                        "ref": J,
                        "__self": this,
                        "__source": {
                            "fileName": ua,
                            "lineNumber": 318
                        }
                    }, v("canvas", {
                        "onMouseDown": function onDragStart(v) {
                            if (ne)
                                return;
                            ie.current = {
                                "initialX": v.clientX,
                                "initialY": v.clientY
                            };
                            const handleMouseMove = v => {
                                const E = K.current;
                                if (!E)
                                    return;
                                const k = v.clientX - ie.current.initialX
                                  , R = v.clientY - ie.current.initialY;
                                Q((U => {
                                    const H = Math.max(0, Math.min(U.startX + k, E.width / pa - (U.endX - U.startX)))
                                      , G = Math.max(0, Math.min(U.startY + R, E.height / pa - (U.endY - U.startY)))
                                      , W = H + (U.endX - U.startX)
                                      , Z = G + (U.endY - U.startY);
                                    return ie.current.initialX = v.clientX,
                                    ie.current.initialY = v.clientY,
                                    {
                                        "startX": H,
                                        "startY": G,
                                        "endX": W,
                                        "endY": Z
                                    }
                                }
                                ))
                            }
                              , handleMouseUp = () => {
                                yi.removeEventListener("mousemove", handleMouseMove),
                                yi.removeEventListener("mouseup", handleMouseUp)
                            }
                            ;
                            yi.addEventListener("mousemove", handleMouseMove),
                            yi.addEventListener("mouseup", handleMouseUp)
                        },
                        "style": {
                            "position": "absolute",
                            "cursor": ee ? "move" : "auto"
                        },
                        "ref": K,
                        "__self": this,
                        "__source": {
                            "fileName": ua,
                            "lineNumber": 319
                        }
                    }), v(Z, {
                        "left": X.startX - 3,
                        "top": X.startY - 3,
                        "onGrabButton": onGrabButton,
                        "corner": "top-left",
                        "__self": this,
                        "__source": {
                            "fileName": ua,
                            "lineNumber": 324
                        }
                    }), v(Z, {
                        "left": X.endX - 30 + 3,
                        "top": X.startY - 3,
                        "onGrabButton": onGrabButton,
                        "corner": "top-right",
                        "__self": this,
                        "__source": {
                            "fileName": ua,
                            "lineNumber": 330
                        }
                    }), v(Z, {
                        "left": X.startX - 3,
                        "top": X.endY - 30 + 3,
                        "onGrabButton": onGrabButton,
                        "corner": "bottom-left",
                        "__self": this,
                        "__source": {
                            "fileName": ua,
                            "lineNumber": 336
                        }
                    }), v(Z, {
                        "left": X.endX - 30 + 3,
                        "top": X.endY - 30 + 3,
                        "onGrabButton": onGrabButton,
                        "corner": "bottom-right",
                        "__self": this,
                        "__source": {
                            "fileName": ua,
                            "lineNumber": 342
                        }
                    }), v("div", {
                        "style": {
                            "left": Math.max(0, X.endX - 191),
                            "top": Math.max(0, X.endY + 8),
                            "display": ee ? "flex" : "none"
                        },
                        "class": "editor__crop-btn-group",
                        "__self": this,
                        "__source": {
                            "fileName": ua,
                            "lineNumber": 348
                        }
                    }, v("button", {
                        "onClick": v => {
                            v.preventDefault(),
                            K.current && Q({
                                "startX": 0,
                                "startY": 0,
                                "endX": K.current.width / pa,
                                "endY": K.current.height / pa
                            }),
                            te(!1)
                        }
                        ,
                        "class": "btn btn--default",
                        "__self": this,
                        "__source": {
                            "fileName": ua,
                            "lineNumber": 356
                        }
                    }, U.cancelButtonLabel), v("button", {
                        "onClick": v => {
                            v.preventDefault(),
                            function submit() {
                                const v = yi.createElement("canvas")
                                  , E = constructRect(getContainedSize(k))
                                  , R = constructRect(X);
                                v.width = R.width * pa,
                                v.height = R.height * pa;
                                const U = v.getContext("2d");
                                U && k && U.drawImage(k, R.x / E.width * k.width, R.y / E.height * k.height, R.width / E.width * k.width, R.height / E.height * k.height, 0, 0, v.width, v.height);
                                const H = k.getContext("2d");
                                H && (H.clearRect(0, 0, k.width, k.height),
                                k.width = v.width,
                                k.height = v.height,
                                k.style.width = `${R.width}px`,
                                k.style.height = `${R.height}px`,
                                H.drawImage(v, 0, 0),
                                resizeCropper())
                            }(),
                            te(!1)
                        }
                        ,
                        "class": "btn btn--primary",
                        "__self": this,
                        "__source": {
                            "fileName": ua,
                            "lineNumber": 373
                        }
                    }, U.confirmButtonLabel)))))
                }
            }
            const feedbackScreenshotIntegration = () => ({
                "name": "FeedbackScreenshot",
                "setupOnce"() {},
                "createInput": ({"h": v, "hooks": E, "dialog": k, "options": R}) => {
                    const U = yi.createElement("canvas");
                    return {
                        "input": ScreenshotEditorFactory({
                            "h": v,
                            "hooks": E,
                            "imageBuffer": U,
                            "dialog": k,
                            "options": R
                        }),
                        "value": async () => {
                            const v = await new Promise((v => {
                                U.toBlob(v, "image/png")
                            }
                            ));
                            if (v) {
                                return {
                                    "data": new Uint8Array(await v.arrayBuffer()),
                                    "filename": "screenshot.png",
                                    "contentType": "application/png"
                                }
                            }
                        }
                    }
                }
            })
              , fa = buildFeedbackIntegration({
                "lazyLoadIntegration": lazyLoadIntegration
            })
              , ha = buildFeedbackIntegration({
                "lazyLoadIntegration": lazyLoadIntegration,
                "getModalIntegration": () => feedbackModalIntegration,
                "getScreenshotIntegration": () => feedbackScreenshotIntegration
            })
              , ma = "c"
              , ga = "g"
              , _a = "s"
              , va = "d";
            function getMetricsAggregatorForClient(v, E) {
                const k = worldwide_getGlobalSingleton("globalMetricsAggregators", ( () => new WeakMap))
                  , R = k.get(v);
                if (R)
                    return R;
                const U = new E(v);
                return v.on("flush", ( () => U.flush())),
                v.on("close", ( () => U.close())),
                k.set(v, U),
                U
            }
            function addToMetricsAggregator(v, E, k, R, U={}) {
                const H = U.client || currentScopes_getClient();
                if (!H)
                    return;
                const G = getActiveSpan()
                  , W = G ? getRootSpan(G) : void 0
                  , Z = W && spanUtils_spanToJSON(W).description
                  , {"unit": Y, "tags": J, "timestamp": K} = U
                  , {"release": X, "environment": Q} = H.getOptions()
                  , ee = {};
                X && (ee.release = X),
                Q && (ee.environment = Q),
                Z && (ee.transaction = Z),
                _e && fe.log(`Adding value of ${R} to ${E} metric ${k}`);
                getMetricsAggregatorForClient(H, v).add(E, k, R, Y, {
                    ...ee,
                    ...J
                }, K)
            }
            function distribution(v, E, k, R) {
                addToMetricsAggregator(v, va, E, ensureNumber(k), R)
            }
            const ya = {
                "increment": function increment(v, E, k=1, R) {
                    addToMetricsAggregator(v, "c", E, ensureNumber(k), R)
                },
                "distribution": distribution,
                "set": function set(v, E, k, R) {
                    addToMetricsAggregator(v, "s", E, k, R)
                },
                "gauge": function gauge(v, E, k, R) {
                    addToMetricsAggregator(v, "g", E, ensureNumber(k), R)
                },
                "timing": function timing(v, E, k, R="second", U) {
                    if ("function" == typeof k) {
                        const R = ye();
                        return startSpanManual({
                            "op": "metrics.timing",
                            "name": E,
                            "startTime": R,
                            "onlyIfParent": !0
                        }, (H => handleCallbackErrors_handleCallbackErrors(( () => k()), ( () => {}
                        ), ( () => {
                            const k = ye();
                            distribution(v, E, k - R, {
                                ...U,
                                "unit": "second"
                            }),
                            H.end(k)
                        }
                        ))))
                    }
                    distribution(v, E, k, {
                        ...U,
                        "unit": R
                    })
                },
                "getMetricsAggregatorForClient": getMetricsAggregatorForClient
            };
            function ensureNumber(v) {
                return "string" == typeof v ? parseInt(v) : v
            }
            function sanitizeTagKey(v) {
                return v.replace(/[^\w\-./]+/gi, "")
            }
            const ba = [["\n", "\\n"], ["\r", "\\r"], ["\t", "\\t"], ["\\", "\\\\"], ["|", "\\u{7c}"], [",", "\\u{2c}"]];
            function sanitizeTagValue(v) {
                return [...v].reduce(( (v, E) => v + function getCharOrReplacement(v) {
                    for (const [E,k] of ba)
                        if (v === E)
                            return k;
                    return v
                }(E)), "")
            }
            function captureAggregateMetrics(v, E) {
                fe.log(`Flushing aggregated metrics, number of metrics: ${E.length}`);
                const k = function createMetricEnvelope(v, E, k, R) {
                    const U = {
                        "sent_at": (new Date).toISOString()
                    };
                    k && k.sdk && (U.sdk = {
                        "name": k.sdk.name,
                        "version": k.sdk.version
                    });
                    R && E && (U.dsn = dsn_dsnToString(E));
                    const H = function createMetricEnvelopeItem(v) {
                        const E = function serializeMetricBuckets(v) {
                            let E = "";
                            for (const k of v) {
                                const v = Object.entries(k.tags)
                                  , R = v.length > 0 ? `|#${v.map(( ([v,E]) => `${v}:${E}`)).join(",")}` : "";
                                E += `${k.name}@${k.unit}:${k.metric}|${k.metricType}${R}|T${k.timestamp}\n`
                            }
                            return E
                        }(v);
                        return [{
                            "type": "statsd",
                            "length": E.length
                        }, E]
                    }(v);
                    return envelope_createEnvelope(U, [H])
                }(E, v.getDsn(), v.getSdkMetadata(), v.getOptions().tunnel);
                v.sendEnvelope(k)
            }
            const Sa = {
                [ma]: class CounterMetric {
                    "constructor"(v) {
                        this._value = v
                    }
                    get "weight"() {
                        return 1
                    }
                    "add"(v) {
                        this._value += v
                    }
                    "toString"() {
                        return `${this._value}`
                    }
                }
                ,
                [ga]: class GaugeMetric {
                    "constructor"(v) {
                        this._last = v,
                        this._min = v,
                        this._max = v,
                        this._sum = v,
                        this._count = 1
                    }
                    get "weight"() {
                        return 5
                    }
                    "add"(v) {
                        this._last = v,
                        v < this._min && (this._min = v),
                        v > this._max && (this._max = v),
                        this._sum += v,
                        this._count++
                    }
                    "toString"() {
                        return `${this._last}:${this._min}:${this._max}:${this._sum}:${this._count}`
                    }
                }
                ,
                [va]: class DistributionMetric {
                    "constructor"(v) {
                        this._value = [v]
                    }
                    get "weight"() {
                        return this._value.length
                    }
                    "add"(v) {
                        this._value.push(v)
                    }
                    "toString"() {
                        return this._value.join(":")
                    }
                }
                ,
                [_a]: class SetMetric {
                    "constructor"(v) {
                        this.first = v,
                        this._value = new Set([v])
                    }
                    get "weight"() {
                        return this._value.size
                    }
                    "add"(v) {
                        this._value.add(v)
                    }
                    "toString"() {
                        return Array.from(this._value).map((v => "string" == typeof v ? function simpleHash(v) {
                            let E = 0;
                            for (let k = 0; k < v.length; k++)
                                E = (E << 5) - E + v.charCodeAt(k),
                                E &= E;
                            return E >>> 0
                        }(v) : v)).join(":")
                    }
                }
            };
            class BrowserMetricsAggregator {
                "constructor"(v) {
                    this._client = v,
                    this._buckets = new Map,
                    this._interval = setInterval(( () => this.flush()), 5e3)
                }
                "add"(v, E, k, R="none", U={}, H=ye()) {
                    const G = Math.floor(H)
                      , W = function sanitizeMetricKey(v) {
                        return v.replace(/[^\w\-.]+/gi, "_")
                    }(E)
                      , Z = function sanitizeTags(v) {
                        const E = {};
                        for (const k in v)
                            Object.prototype.hasOwnProperty.call(v, k) && (E[sanitizeTagKey(k)] = sanitizeTagValue(String(v[k])));
                        return E
                    }(U)
                      , Y = function sanitizeUnit(v) {
                        return v.replace(/[^\w]+/gi, "_")
                    }(R)
                      , J = function getBucketKey(v, E, k, R) {
                        const U = Object.entries(object_dropUndefinedKeys(R)).sort(( (v, E) => v[0].localeCompare(E[0])));
                        return `${v}${E}${k}${U}`
                    }(v, W, Y, Z);
                    let K = this._buckets.get(J);
                    const X = K && "s" === v ? K.metric.weight : 0;
                    K ? (K.metric.add(k),
                    K.timestamp < G && (K.timestamp = G)) : (K = {
                        "metric": new Sa[v](k),
                        "timestamp": G,
                        "metricType": v,
                        "name": W,
                        "unit": Y,
                        "tags": Z
                    },
                    this._buckets.set(J, K));
                    updateMetricSummaryOnActiveSpan(v, W, "string" == typeof k ? K.metric.weight - X : k, Y, U, J)
                }
                "flush"() {
                    if (0 === this._buckets.size)
                        return;
                    const v = Array.from(this._buckets.values());
                    captureAggregateMetrics(this._client, v),
                    this._buckets.clear()
                }
                "close"() {
                    clearInterval(this._interval),
                    this.flush()
                }
            }
            const wa = {
                "increment": function metrics_increment(v, E=1, k) {
                    ya.increment(BrowserMetricsAggregator, v, E, k)
                },
                "distribution": function metrics_distribution(v, E, k) {
                    ya.distribution(BrowserMetricsAggregator, v, E, k)
                },
                "set": function metrics_set(v, E, k) {
                    ya.set(BrowserMetricsAggregator, v, E, k)
                },
                "gauge": function metrics_gauge(v, E, k) {
                    ya.gauge(BrowserMetricsAggregator, v, E, k)
                },
                "timing": function metrics_timing(v, E, k="second", R) {
                    return ya.timing(BrowserMetricsAggregator, v, E, k, R)
                }
            };
            function instrumentFetchRequest(v, E, k, R, U="auto.http.browser") {
                if (!v.fetchData)
                    return;
                const H = hasTracingEnabled_hasTracingEnabled() && E(v.fetchData.url);
                if (v.endTimestamp && H) {
                    const E = v.fetchData.__span;
                    if (!E)
                        return;
                    const k = R[E];
                    return void (k && (!function endSpan(v, E) {
                        if (E.response) {
                            setHttpStatus(v, E.response.status);
                            const k = E.response && E.response.headers && E.response.headers.get("content-length");
                            if (k) {
                                const E = parseInt(k);
                                E > 0 && v.setAttribute("http.response_content_length", E)
                            }
                        } else
                            E.error && v.setStatus({
                                "code": Je,
                                "message": "internal_error"
                            });
                        v.end()
                    }(k, v),
                    delete R[E]))
                }
                const G = currentScopes_getCurrentScope()
                  , W = currentScopes_getClient()
                  , {"method": Z, "url": Y} = v.fetchData
                  , J = function getFullURL(v) {
                    try {
                        return new URL(v).href
                    } catch (v) {
                        return
                    }
                }(Y)
                  , K = J ? url_parseUrl(J).host : void 0
                  , X = !!getActiveSpan()
                  , Q = H && X ? startInactiveSpan({
                    "name": `${Z} ${Y}`,
                    "attributes": {
                        "url": Y,
                        "type": "fetch",
                        "http.method": Z,
                        "http.url": J,
                        "server.address": K,
                        [He]: U,
                        [Ue]: "http.client"
                    }
                }) : new sentryNonRecordingSpan_SentryNonRecordingSpan;
                if (v.fetchData.__span = Q.spanContext().spanId,
                R[Q.spanContext().spanId] = Q,
                k(v.fetchData.url) && W) {
                    const E = v.args[0];
                    v.args[1] = v.args[1] || {};
                    const k = v.args[1];
                    k.headers = function addTracingHeadersToFetchRequest(v, E, k, R, U) {
                        const H = currentScopes_getIsolationScope()
                          , {"traceId": G, "spanId": W, "sampled": Z, "dsc": Y} = {
                            ...H.getPropagationContext(),
                            ...k.getPropagationContext()
                        }
                          , J = U ? spanToTraceHeader(U) : tracing_generateSentryTraceHeader(G, W, Z)
                          , K = baggage_dynamicSamplingContextToSentryBaggageHeader(Y || (U ? getDynamicSamplingContextFromSpan(U) : getDynamicSamplingContextFromClient(G, E)))
                          , X = R.headers || ("undefined" != typeof Request && is_isInstanceOf(v, Request) ? v.headers : void 0);
                        if (X) {
                            if ("undefined" != typeof Headers && is_isInstanceOf(X, Headers)) {
                                const v = new Headers(X);
                                return v.append("sentry-trace", J),
                                K && v.append(De, K),
                                v
                            }
                            if (Array.isArray(X)) {
                                const v = [...X, ["sentry-trace", J]];
                                return K && v.push([De, K]),
                                v
                            }
                            {
                                const v = "baggage"in X ? X.baggage : void 0
                                  , E = [];
                                return Array.isArray(v) ? E.push(...v) : v && E.push(v),
                                K && E.push(K),
                                {
                                    ...X,
                                    "sentry-trace": J,
                                    "baggage": E.length > 0 ? E.join(",") : void 0
                                }
                            }
                        }
                        return {
                            "sentry-trace": J,
                            "baggage": K
                        }
                    }(E, W, G, k, hasTracingEnabled_hasTracingEnabled() && X ? Q : void 0)
                }
                return Q
            }
            const Ea = new WeakMap
              , Ca = new Map
              , Ta = {
                "traceFetch": !0,
                "traceXHR": !0,
                "enableHTTPTimings": !0
            };
            function instrumentOutgoingRequests(v, E) {
                const {"traceFetch": k, "traceXHR": R, "shouldCreateSpanForRequest": U, "enableHTTPTimings": H, "tracePropagationTargets": G} = {
                    "traceFetch": Ta.traceFetch,
                    "traceXHR": Ta.traceXHR,
                    ...E
                }
                  , W = "function" == typeof U ? U : v => !0
                  , shouldAttachHeadersWithTargets = v => function shouldAttachHeaders(v, E) {
                    const k = Et.location && Et.location.href;
                    if (k) {
                        let R, U;
                        try {
                            R = new URL(v,k),
                            U = new URL(k).origin
                        } catch (v) {
                            return !1
                        }
                        const H = R.origin === U;
                        return E ? stringMatchesSomePattern(R.toString(), E) || H && stringMatchesSomePattern(R.pathname, E) : H
                    }
                    {
                        const k = !!v.match(/^\/(?!\/)/);
                        return E ? stringMatchesSomePattern(v, E) : k
                    }
                }(v, G)
                  , Z = {};
                k && (v.addEventProcessor((v => ("transaction" === v.type && v.spans && v.spans.forEach((v => {
                    if ("http.client" === v.op) {
                        const E = Ca.get(v.span_id);
                        E && (v.timestamp = E / 1e3,
                        Ca.delete(v.span_id))
                    }
                }
                )),
                v))),
                function addFetchEndInstrumentationHandler(v) {
                    const E = "fetch-body-resolved";
                    handlers_addHandler(E, v),
                    handlers_maybeInstrument(E, ( () => instrumentFetch(streamHandler)))
                }((v => {
                    if (v.response) {
                        const E = Ea.get(v.response);
                        E && v.endTimestamp && Ca.set(E, v.endTimestamp)
                    }
                }
                )),
                addFetchInstrumentationHandler((v => {
                    const E = instrumentFetchRequest(v, W, shouldAttachHeadersWithTargets, Z);
                    if (v.response && v.fetchData.__span && Ea.set(v.response, v.fetchData.__span),
                    E) {
                        const k = request_getFullURL(v.fetchData.url)
                          , R = k ? url_parseUrl(k).host : void 0;
                        E.setAttributes({
                            "http.url": k,
                            "server.address": R
                        })
                    }
                    H && E && addHTTPTimings(E)
                }
                ))),
                R && addXhrInstrumentationHandler((v => {
                    const E = function xhrCallback(v, E, k, R) {
                        const U = v.xhr
                          , H = U && U[Mt];
                        if (!U || U.__sentry_own_request__ || !H)
                            return;
                        const G = hasTracingEnabled_hasTracingEnabled() && E(H.url);
                        if (v.endTimestamp && G) {
                            const v = U.__sentry_xhr_span_id__;
                            if (!v)
                                return;
                            const E = R[v];
                            return void (E && void 0 !== H.status_code && (setHttpStatus(E, H.status_code),
                            E.end(),
                            delete R[v]))
                        }
                        const W = request_getFullURL(H.url)
                          , Z = W ? url_parseUrl(W).host : void 0
                          , Y = !!getActiveSpan()
                          , J = G && Y ? startInactiveSpan({
                            "name": `${H.method} ${H.url}`,
                            "attributes": {
                                "type": "xhr",
                                "http.method": H.method,
                                "http.url": W,
                                "url": H.url,
                                "server.address": Z,
                                [He]: "auto.http.browser",
                                [Ue]: "http.client"
                            }
                        }) : new sentryNonRecordingSpan_SentryNonRecordingSpan;
                        U.__sentry_xhr_span_id__ = J.spanContext().spanId,
                        R[U.__sentry_xhr_span_id__] = J;
                        const K = currentScopes_getClient();
                        U.setRequestHeader && k(H.url) && K && function addTracingHeadersToXhrRequest(v, E, k) {
                            const R = currentScopes_getCurrentScope()
                              , U = currentScopes_getIsolationScope()
                              , {"traceId": H, "spanId": G, "sampled": W, "dsc": Z} = {
                                ...U.getPropagationContext(),
                                ...R.getPropagationContext()
                            }
                              , Y = k && hasTracingEnabled_hasTracingEnabled() ? spanToTraceHeader(k) : tracing_generateSentryTraceHeader(H, G, W)
                              , J = baggage_dynamicSamplingContextToSentryBaggageHeader(Z || (k ? getDynamicSamplingContextFromSpan(k) : getDynamicSamplingContextFromClient(H, E)));
                            !function setHeaderOnXhr(v, E, k) {
                                try {
                                    v.setRequestHeader("sentry-trace", E),
                                    k && v.setRequestHeader(De, k)
                                } catch (v) {}
                            }(v, Y, J)
                        }(U, K, hasTracingEnabled_hasTracingEnabled() && Y ? J : void 0);
                        return J
                    }(v, W, shouldAttachHeadersWithTargets, Z);
                    H && E && addHTTPTimings(E)
                }
                ))
            }
            function addHTTPTimings(v) {
                const {"url": E} = spanUtils_spanToJSON(v).data || {};
                if (!E || "string" != typeof E)
                    return;
                const k = addPerformanceInstrumentationHandler("resource", ( ({"entries": R}) => {
                    R.forEach((R => {
                        if (function isPerformanceResourceTiming(v) {
                            return "resource" === v.entryType && "initiatorType"in v && "string" == typeof v.nextHopProtocol && ("fetch" === v.initiatorType || "xmlhttprequest" === v.initiatorType)
                        }(R) && R.name.endsWith(E)) {
                            (function resourceTimingEntryToSpanData(v) {
                                const {"name": E, "version": k} = function extractNetworkProtocol(v) {
                                    let E = "unknown"
                                      , k = "unknown"
                                      , R = "";
                                    for (const U of v) {
                                        if ("/" === U) {
                                            [E,k] = v.split("/");
                                            break
                                        }
                                        if (!isNaN(Number(U))) {
                                            E = "h" === R ? "http" : R,
                                            k = v.split(R)[1];
                                            break
                                        }
                                        R += U
                                    }
                                    R === v && (E = R);
                                    return {
                                        "name": E,
                                        "version": k
                                    }
                                }(v.nextHopProtocol)
                                  , R = [];
                                if (R.push(["network.protocol.version", k], ["network.protocol.name", E]),
                                !Se)
                                    return R;
                                return [...R, ["http.request.redirect_start", request_getAbsoluteTime(v.redirectStart)], ["http.request.fetch_start", request_getAbsoluteTime(v.fetchStart)], ["http.request.domain_lookup_start", request_getAbsoluteTime(v.domainLookupStart)], ["http.request.domain_lookup_end", request_getAbsoluteTime(v.domainLookupEnd)], ["http.request.connect_start", request_getAbsoluteTime(v.connectStart)], ["http.request.secure_connection_start", request_getAbsoluteTime(v.secureConnectionStart)], ["http.request.connection_end", request_getAbsoluteTime(v.connectEnd)], ["http.request.request_start", request_getAbsoluteTime(v.requestStart)], ["http.request.response_start", request_getAbsoluteTime(v.responseStart)], ["http.request.response_end", request_getAbsoluteTime(v.responseEnd)]]
                            }
                            )(R).forEach((E => v.setAttribute(...E))),
                            setTimeout(k)
                        }
                    }
                    ))
                }
                ))
            }
            function request_getAbsoluteTime(v=0) {
                return ((Se || performance.timeOrigin) + v) / 1e3
            }
            function request_getFullURL(v) {
                try {
                    return new URL(v,Et.location.origin).href
                } catch (v) {
                    return
                }
            }
            function _sentry_core_build_esm_carrier_getMainCarrier() {
                return _sentry_core_build_esm_carrier_getSentryCarrier(ct),
                ct
            }
            function _sentry_core_build_esm_carrier_getSentryCarrier(v) {
                const E = v.__SENTRY__ = v.__SENTRY__ || {};
                return E.version = E.version || st,
                E[st] = E[st] || {}
            }
            function _sentry_utils_build_esm_propagationContext_generatePropagationContext() {
                return {
                    "traceId": esm_misc_uuid4(),
                    "spanId": esm_misc_uuid4().substring(16)
                }
            }
            function _sentry_core_build_esm_session_updateSession(v, E={}) {
                if (E.user && (!v.ipAddress && E.user.ip_address && (v.ipAddress = E.user.ip_address),
                v.did || E.did || (v.did = E.user.id || E.user.email || E.user.username)),
                v.timestamp = E.timestamp || Ot(),
                E.abnormal_mechanism && (v.abnormal_mechanism = E.abnormal_mechanism),
                E.ignoreDuration && (v.ignoreDuration = E.ignoreDuration),
                E.sid && (v.sid = 32 === E.sid.length ? E.sid : esm_misc_uuid4()),
                void 0 !== E.init && (v.init = E.init),
                !v.did && E.did && (v.did = `${E.did}`),
                "number" == typeof E.started && (v.started = E.started),
                v.ignoreDuration)
                    v.duration = void 0;
                else if ("number" == typeof E.duration)
                    v.duration = E.duration;
                else {
                    const E = v.timestamp - v.started;
                    v.duration = E >= 0 ? E : 0
                }
                E.release && (v.release = E.release),
                E.environment && (v.environment = E.environment),
                !v.ipAddress && E.ipAddress && (v.ipAddress = E.ipAddress),
                !v.userAgent && E.userAgent && (v.userAgent = E.userAgent),
                "number" == typeof E.errors && (v.errors = E.errors),
                E.status && (v.status = E.status)
            }
            const xa = "_sentrySpan";
            function core_build_esm_utils_spanOnScope_setSpanForScope(v, E) {
                E ? esm_object_addNonEnumerableProperty(v, xa, E) : delete v[xa]
            }
            function build_esm_utils_spanOnScope_getSpanForScope(v) {
                return v[xa]
            }
            class core_build_esm_scope_ScopeClass {
                "constructor"() {
                    this._notifyingListeners = !1,
                    this._scopeListeners = [],
                    this._eventProcessors = [],
                    this._breadcrumbs = [],
                    this._attachments = [],
                    this._user = {},
                    this._tags = {},
                    this._extra = {},
                    this._contexts = {},
                    this._sdkProcessingMetadata = {},
                    this._propagationContext = _sentry_utils_build_esm_propagationContext_generatePropagationContext()
                }
                "clone"() {
                    const v = new core_build_esm_scope_ScopeClass;
                    return v._breadcrumbs = [...this._breadcrumbs],
                    v._tags = {
                        ...this._tags
                    },
                    v._extra = {
                        ...this._extra
                    },
                    v._contexts = {
                        ...this._contexts
                    },
                    v._user = this._user,
                    v._level = this._level,
                    v._session = this._session,
                    v._transactionName = this._transactionName,
                    v._fingerprint = this._fingerprint,
                    v._eventProcessors = [...this._eventProcessors],
                    v._requestSession = this._requestSession,
                    v._attachments = [...this._attachments],
                    v._sdkProcessingMetadata = {
                        ...this._sdkProcessingMetadata
                    },
                    v._propagationContext = {
                        ...this._propagationContext
                    },
                    v._client = this._client,
                    v._lastEventId = this._lastEventId,
                    core_build_esm_utils_spanOnScope_setSpanForScope(v, build_esm_utils_spanOnScope_getSpanForScope(this)),
                    v
                }
                "setClient"(v) {
                    this._client = v
                }
                "setLastEventId"(v) {
                    this._lastEventId = v
                }
                "getClient"() {
                    return this._client
                }
                "lastEventId"() {
                    return this._lastEventId
                }
                "addScopeListener"(v) {
                    this._scopeListeners.push(v)
                }
                "addEventProcessor"(v) {
                    return this._eventProcessors.push(v),
                    this
                }
                "setUser"(v) {
                    return this._user = v || {
                        "email": void 0,
                        "id": void 0,
                        "ip_address": void 0,
                        "username": void 0
                    },
                    this._session && _sentry_core_build_esm_session_updateSession(this._session, {
                        "user": v
                    }),
                    this._notifyScopeListeners(),
                    this
                }
                "getUser"() {
                    return this._user
                }
                "getRequestSession"() {
                    return this._requestSession
                }
                "setRequestSession"(v) {
                    return this._requestSession = v,
                    this
                }
                "setTags"(v) {
                    return this._tags = {
                        ...this._tags,
                        ...v
                    },
                    this._notifyScopeListeners(),
                    this
                }
                "setTag"(v, E) {
                    return this._tags = {
                        ...this._tags,
                        [v]: E
                    },
                    this._notifyScopeListeners(),
                    this
                }
                "setExtras"(v) {
                    return this._extra = {
                        ...this._extra,
                        ...v
                    },
                    this._notifyScopeListeners(),
                    this
                }
                "setExtra"(v, E) {
                    return this._extra = {
                        ...this._extra,
                        [v]: E
                    },
                    this._notifyScopeListeners(),
                    this
                }
                "setFingerprint"(v) {
                    return this._fingerprint = v,
                    this._notifyScopeListeners(),
                    this
                }
                "setLevel"(v) {
                    return this._level = v,
                    this._notifyScopeListeners(),
                    this
                }
                "setTransactionName"(v) {
                    return this._transactionName = v,
                    this._notifyScopeListeners(),
                    this
                }
                "setContext"(v, E) {
                    return null === E ? delete this._contexts[v] : this._contexts[v] = E,
                    this._notifyScopeListeners(),
                    this
                }
                "setSession"(v) {
                    return v ? this._session = v : delete this._session,
                    this._notifyScopeListeners(),
                    this
                }
                "getSession"() {
                    return this._session
                }
                "update"(v) {
                    if (!v)
                        return this;
                    const E = "function" == typeof v ? v(this) : v
                      , [k,R] = E instanceof Aa ? [E.getScopeData(), E.getRequestSession()] : is_isPlainObject(E) ? [v, v.requestSession] : []
                      , {"tags": U, "extra": H, "user": G, "contexts": W, "level": Z, "fingerprint": Y=[], "propagationContext": J} = k || {};
                    return this._tags = {
                        ...this._tags,
                        ...U
                    },
                    this._extra = {
                        ...this._extra,
                        ...H
                    },
                    this._contexts = {
                        ...this._contexts,
                        ...W
                    },
                    G && Object.keys(G).length && (this._user = G),
                    Z && (this._level = Z),
                    Y.length && (this._fingerprint = Y),
                    J && (this._propagationContext = J),
                    R && (this._requestSession = R),
                    this
                }
                "clear"() {
                    return this._breadcrumbs = [],
                    this._tags = {},
                    this._extra = {},
                    this._user = {},
                    this._contexts = {},
                    this._level = void 0,
                    this._transactionName = void 0,
                    this._fingerprint = void 0,
                    this._requestSession = void 0,
                    this._session = void 0,
                    core_build_esm_utils_spanOnScope_setSpanForScope(this, void 0),
                    this._attachments = [],
                    this._propagationContext = _sentry_utils_build_esm_propagationContext_generatePropagationContext(),
                    this._notifyScopeListeners(),
                    this
                }
                "addBreadcrumb"(v, E) {
                    const k = "number" == typeof E ? E : 100;
                    if (k <= 0)
                        return this;
                    const R = {
                        "timestamp": esm_time_dateTimestampInSeconds(),
                        ...v
                    }
                      , U = this._breadcrumbs;
                    return U.push(R),
                    this._breadcrumbs = U.length > k ? U.slice(-k) : U,
                    this._notifyScopeListeners(),
                    this
                }
                "getLastBreadcrumb"() {
                    return this._breadcrumbs[this._breadcrumbs.length - 1]
                }
                "clearBreadcrumbs"() {
                    return this._breadcrumbs = [],
                    this._notifyScopeListeners(),
                    this
                }
                "addAttachment"(v) {
                    return this._attachments.push(v),
                    this
                }
                "clearAttachments"() {
                    return this._attachments = [],
                    this
                }
                "getScopeData"() {
                    return {
                        "breadcrumbs": this._breadcrumbs,
                        "attachments": this._attachments,
                        "contexts": this._contexts,
                        "tags": this._tags,
                        "extra": this._extra,
                        "user": this._user,
                        "level": this._level,
                        "fingerprint": this._fingerprint || [],
                        "eventProcessors": this._eventProcessors,
                        "propagationContext": this._propagationContext,
                        "sdkProcessingMetadata": this._sdkProcessingMetadata,
                        "transactionName": this._transactionName,
                        "span": build_esm_utils_spanOnScope_getSpanForScope(this)
                    }
                }
                "setSDKProcessingMetadata"(v) {
                    return this._sdkProcessingMetadata = {
                        ...this._sdkProcessingMetadata,
                        ...v
                    },
                    this
                }
                "setPropagationContext"(v) {
                    return this._propagationContext = v,
                    this
                }
                "getPropagationContext"() {
                    return this._propagationContext
                }
                "captureException"(v, E) {
                    const k = E && E.event_id ? E.event_id : esm_misc_uuid4();
                    if (!this._client)
                        return dt.warn("No client configured on scope - will not capture exception!"),
                        k;
                    const R = new Error("Sentry syntheticException");
                    return this._client.captureException(v, {
                        "originalException": v,
                        "syntheticException": R,
                        ...E,
                        "event_id": k
                    }, this),
                    k
                }
                "captureMessage"(v, E, k) {
                    const R = k && k.event_id ? k.event_id : esm_misc_uuid4();
                    if (!this._client)
                        return dt.warn("No client configured on scope - will not capture message!"),
                        R;
                    const U = new Error(v);
                    return this._client.captureMessage(v, E, {
                        "originalException": v,
                        "syntheticException": U,
                        ...k,
                        "event_id": R
                    }, this),
                    R
                }
                "captureEvent"(v, E) {
                    const k = E && E.event_id ? E.event_id : esm_misc_uuid4();
                    return this._client ? (this._client.captureEvent(v, {
                        ...E,
                        "event_id": k
                    }, this),
                    k) : (dt.warn("No client configured on scope - will not capture event!"),
                    k)
                }
                "_notifyScopeListeners"() {
                    this._notifyingListeners || (this._notifyingListeners = !0,
                    this._scopeListeners.forEach((v => {
                        v(this)
                    }
                    )),
                    this._notifyingListeners = !1)
                }
            }
            const Aa = core_build_esm_scope_ScopeClass;
            class build_esm_asyncContext_stackStrategy_AsyncContextStack {
                "constructor"(v, E) {
                    let k, R;
                    k = v || new Aa,
                    R = E || new Aa,
                    this._stack = [{
                        "scope": k
                    }],
                    this._isolationScope = R
                }
                "withScope"(v) {
                    const E = this._pushScope();
                    let k;
                    try {
                        k = v(E)
                    } catch (v) {
                        throw this._popScope(),
                        v
                    }
                    return function esm_is_isThenable(v) {
                        return Boolean(v && v.then && "function" == typeof v.then)
                    }(k) ? k.then((v => (this._popScope(),
                    v)), (v => {
                        throw this._popScope(),
                        v
                    }
                    )) : (this._popScope(),
                    k)
                }
                "getClient"() {
                    return this.getStackTop().client
                }
                "getScope"() {
                    return this.getStackTop().scope
                }
                "getIsolationScope"() {
                    return this._isolationScope
                }
                "getStackTop"() {
                    return this._stack[this._stack.length - 1]
                }
                "_pushScope"() {
                    const v = this.getScope().clone();
                    return this._stack.push({
                        "client": this.getClient(),
                        "scope": v
                    }),
                    v
                }
                "_popScope"() {
                    return !(this._stack.length <= 1) && !!this._stack.pop()
                }
            }
            function build_esm_asyncContext_stackStrategy_getAsyncContextStack() {
                const v = _sentry_core_build_esm_carrier_getSentryCarrier(_sentry_core_build_esm_carrier_getMainCarrier());
                return v.stack = v.stack || new build_esm_asyncContext_stackStrategy_AsyncContextStack(function core_build_esm_defaultScopes_getDefaultCurrentScope() {
                    return esm_worldwide_getGlobalSingleton("defaultCurrentScope", ( () => new Aa))
                }(),function core_build_esm_defaultScopes_getDefaultIsolationScope() {
                    return esm_worldwide_getGlobalSingleton("defaultIsolationScope", ( () => new Aa))
                }())
            }
            function core_build_esm_asyncContext_stackStrategy_withScope(v) {
                return build_esm_asyncContext_stackStrategy_getAsyncContextStack().withScope(v)
            }
            function build_esm_asyncContext_stackStrategy_withSetScope(v, E) {
                const k = build_esm_asyncContext_stackStrategy_getAsyncContextStack();
                return k.withScope(( () => (k.getStackTop().scope = v,
                E(v))))
            }
            function core_build_esm_asyncContext_stackStrategy_withIsolationScope(v) {
                return build_esm_asyncContext_stackStrategy_getAsyncContextStack().withScope(( () => v(build_esm_asyncContext_stackStrategy_getAsyncContextStack().getIsolationScope())))
            }
            function _sentry_core_build_esm_asyncContext_getAsyncContextStrategy(v) {
                const E = _sentry_core_build_esm_carrier_getSentryCarrier(v);
                return E.acs ? E.acs : function build_esm_asyncContext_stackStrategy_getStackAsyncContextStrategy() {
                    return {
                        "withIsolationScope": core_build_esm_asyncContext_stackStrategy_withIsolationScope,
                        "withScope": core_build_esm_asyncContext_stackStrategy_withScope,
                        "withSetScope": build_esm_asyncContext_stackStrategy_withSetScope,
                        "withSetIsolationScope": (v, E) => core_build_esm_asyncContext_stackStrategy_withIsolationScope(E),
                        "getCurrentScope": () => build_esm_asyncContext_stackStrategy_getAsyncContextStack().getScope(),
                        "getIsolationScope": () => build_esm_asyncContext_stackStrategy_getAsyncContextStack().getIsolationScope()
                    }
                }()
            }
            function _sentry_core_build_esm_currentScopes_getCurrentScope() {
                return _sentry_core_build_esm_asyncContext_getAsyncContextStrategy(_sentry_core_build_esm_carrier_getMainCarrier()).getCurrentScope()
            }
            function _sentry_core_build_esm_currentScopes_withScope(...v) {
                const E = _sentry_core_build_esm_asyncContext_getAsyncContextStrategy(_sentry_core_build_esm_carrier_getMainCarrier());
                if (2 === v.length) {
                    const [k,R] = v;
                    return k ? E.withSetScope(k, R) : E.withScope(R)
                }
                return E.withScope(v[0])
            }
            function _sentry_core_build_esm_currentScopes_getClient() {
                return _sentry_core_build_esm_currentScopes_getCurrentScope().getClient()
            }
            const Ia = "_sentryMetrics";
            function metrics_metric_summary_getMetricSummaryJsonForSpan(v) {
                const E = v[Ia];
                if (!E)
                    return;
                const k = {};
                for (const [,[v,R]] of E) {
                    (k[v] || (k[v] = [])).push(esm_object_dropUndefinedKeys(R))
                }
                return k
            }
            const ka = "sentry.source"
              , Oa = "sentry.sample_rate"
              , Pa = "sentry.op"
              , Ra = "sentry.origin"
              , Ma = "sentry.measurement_unit"
              , Na = "sentry.measurement_value"
              , Da = "sentry.exclusive_time"
              , $a = 0
              , La = 1;
            const Fa = 1;
            function utils_spanUtils_spanToTransactionTraceContext(v) {
                const {"spanId": E, "traceId": k} = v.spanContext()
                  , {"data": R, "op": U, "parent_span_id": H, "status": G, "origin": W} = esm_utils_spanUtils_spanToJSON(v);
                return esm_object_dropUndefinedKeys({
                    "parent_span_id": H,
                    "span_id": E,
                    "trace_id": k,
                    "data": R,
                    "op": U,
                    "status": G,
                    "origin": W
                })
            }
            function utils_spanUtils_spanTimeInputToSeconds(v) {
                return "number" == typeof v ? utils_spanUtils_ensureTimestampInSeconds(v) : Array.isArray(v) ? v[0] + v[1] / 1e9 : v instanceof Date ? utils_spanUtils_ensureTimestampInSeconds(v.getTime()) : Ot()
            }
            function utils_spanUtils_ensureTimestampInSeconds(v) {
                return v > 9999999999 ? v / 1e3 : v
            }
            function esm_utils_spanUtils_spanToJSON(v) {
                if (function utils_spanUtils_spanIsSentrySpan(v) {
                    return "function" == typeof v.getSpanJSON
                }(v))
                    return v.getSpanJSON();
                try {
                    const {"spanId": E, "traceId": k} = v.spanContext();
                    if (function utils_spanUtils_spanIsOpenTelemetrySdkTraceBaseSpan(v) {
                        const E = v;
                        return !!(E.attributes && E.startTime && E.name && E.endTime && E.status)
                    }(v)) {
                        const {"attributes": R, "startTime": U, "name": H, "endTime": G, "parentSpanId": W, "status": Z} = v;
                        return esm_object_dropUndefinedKeys({
                            "span_id": E,
                            "trace_id": k,
                            "data": R,
                            "description": H,
                            "parent_span_id": W,
                            "start_timestamp": utils_spanUtils_spanTimeInputToSeconds(U),
                            "timestamp": utils_spanUtils_spanTimeInputToSeconds(G) || void 0,
                            "status": utils_spanUtils_getStatusMessage(Z),
                            "op": R[Pa],
                            "origin": R[Ra],
                            "_metrics_summary": metrics_metric_summary_getMetricSummaryJsonForSpan(v)
                        })
                    }
                    return {
                        "span_id": E,
                        "trace_id": k
                    }
                } catch (v) {
                    return {}
                }
            }
            function utils_spanUtils_spanIsSampled(v) {
                const {"traceFlags": E} = v.spanContext();
                return E === Fa
            }
            function utils_spanUtils_getStatusMessage(v) {
                if (v && v.code !== $a)
                    return v.code === La ? "ok" : v.message || "unknown_error"
            }
            const ja = "_sentryChildSpans"
              , Ba = "_sentryRootSpan";
            function utils_spanUtils_addChildSpanToSpan(v, E) {
                const k = v[Ba] || v;
                esm_object_addNonEnumerableProperty(E, Ba, k),
                v[ja] ? v[ja].add(E) : esm_object_addNonEnumerableProperty(v, ja, new Set([E]))
            }
            function utils_spanUtils_getRootSpan(v) {
                return v[Ba] || v
            }
            function utils_spanUtils_getActiveSpan() {
                const v = _sentry_core_build_esm_asyncContext_getAsyncContextStrategy(_sentry_core_build_esm_carrier_getMainCarrier());
                return v.getActiveSpan ? v.getActiveSpan() : build_esm_utils_spanOnScope_getSpanForScope(_sentry_core_build_esm_currentScopes_getCurrentScope())
            }
            function utils_hasTracingEnabled_hasTracingEnabled(v) {
                if ("boolean" == typeof __SENTRY_TRACING__ && !__SENTRY_TRACING__)
                    return !1;
                const E = _sentry_core_build_esm_currentScopes_getClient()
                  , k = v || E && E.getOptions();
                return !!k && (k.enableTracing || "tracesSampleRate"in k || "tracesSampler"in k)
            }
            const Ua = "sentry-"
              , Ha = /^sentry-/;
            function esm_baggage_baggageHeaderToDynamicSamplingContext(v) {
                const E = function esm_baggage_parseBaggageHeader(v) {
                    if (!v || !esm_is_isString(v) && !Array.isArray(v))
                        return;
                    if (Array.isArray(v))
                        return v.reduce(( (v, E) => {
                            const k = esm_baggage_baggageHeaderToObject(E);
                            return Object.entries(k).forEach(( ([E,k]) => {
                                v[E] = k
                            }
                            )),
                            v
                        }
                        ), {});
                    return esm_baggage_baggageHeaderToObject(v)
                }(v);
                if (!E)
                    return;
                const k = Object.entries(E).reduce(( (v, [E,k]) => {
                    if (E.match(Ha)) {
                        v[E.slice(Ua.length)] = k
                    }
                    return v
                }
                ), {});
                return Object.keys(k).length > 0 ? k : void 0
            }
            function esm_baggage_baggageHeaderToObject(v) {
                return v.split(",").map((v => v.split("=").map((v => decodeURIComponent(v.trim()))))).reduce(( (v, [E,k]) => (E && k && (v[E] = k),
                v)), {})
            }
            const za = "production"
              , qa = "_frozenDsc";
            function tracing_dynamicSamplingContext_freezeDscOnSpan(v, E) {
                esm_object_addNonEnumerableProperty(v, qa, E)
            }
            function tracing_dynamicSamplingContext_getDynamicSamplingContextFromSpan(v) {
                const E = _sentry_core_build_esm_currentScopes_getClient();
                if (!E)
                    return {};
                const k = function tracing_dynamicSamplingContext_getDynamicSamplingContextFromClient(v, E) {
                    const k = E.getOptions()
                      , {"publicKey": R} = E.getDsn() || {}
                      , U = esm_object_dropUndefinedKeys({
                        "environment": k.environment || za,
                        "release": k.release,
                        "public_key": R,
                        "trace_id": v
                    });
                    return E.emit("createDsc", U),
                    U
                }(esm_utils_spanUtils_spanToJSON(v).trace_id || "", E)
                  , R = utils_spanUtils_getRootSpan(v)
                  , U = R[qa];
                if (U)
                    return U;
                const H = R.spanContext().traceState
                  , G = H && H.get("sentry.dsc")
                  , W = G && esm_baggage_baggageHeaderToDynamicSamplingContext(G);
                if (W)
                    return W;
                const Z = esm_utils_spanUtils_spanToJSON(R)
                  , Y = Z.data || {}
                  , J = Y[Oa];
                null != J && (k.sample_rate = `${J}`);
                const K = Y[ka]
                  , X = Z.description;
                return "url" !== K && X && (k.transaction = X),
                k.sampled = String(utils_spanUtils_spanIsSampled(R)),
                E.emit("createDsc", k, R),
                k
            }
            const Ga = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__;
            function sampling_sampleSpan(v, E) {
                if (!utils_hasTracingEnabled_hasTracingEnabled(v))
                    return [!1];
                let k;
                k = "function" == typeof v.tracesSampler ? v.tracesSampler(E) : void 0 !== E.parentSampled ? E.parentSampled : void 0 !== v.tracesSampleRate ? v.tracesSampleRate : 1;
                const R = function utils_parseSampleRate_parseSampleRate(v) {
                    if ("boolean" == typeof v)
                        return Number(v);
                    const E = "string" == typeof v ? parseFloat(v) : v;
                    if (!("number" != typeof E || isNaN(E) || E < 0 || E > 1))
                        return E;
                    Ga && dt.warn(`[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(v)} of type ${JSON.stringify(typeof v)}.`)
                }(k);
                if (void 0 === R)
                    return Ga && dt.warn("[Tracing] Discarding transaction because of invalid sample rate."),
                    [!1];
                if (!R)
                    return Ga && dt.log("[Tracing] Discarding transaction because " + ("function" == typeof v.tracesSampler ? "tracesSampler returned 0 or false" : "a negative sampling decision was inherited or tracesSampleRate is set to 0")),
                    [!1, R];
                return Math.random() < R ? [!0, R] : (Ga && dt.log(`[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(k)})`),
                [!1, R])
            }
            class tracing_sentryNonRecordingSpan_SentryNonRecordingSpan {
                "constructor"(v={}) {
                    this._traceId = v.traceId || esm_misc_uuid4(),
                    this._spanId = v.spanId || esm_misc_uuid4().substring(16)
                }
                "spanContext"() {
                    return {
                        "spanId": this._spanId,
                        "traceId": this._traceId,
                        "traceFlags": 0
                    }
                }
                "end"(v) {}
                "setAttribute"(v, E) {
                    return this
                }
                "setAttributes"(v) {
                    return this
                }
                "setStatus"(v) {
                    return this
                }
                "updateName"(v) {
                    return this
                }
                "isRecording"() {
                    return !1
                }
                "addEvent"(v, E, k) {
                    return this
                }
                "addLink"(v) {
                    return this
                }
                "addLinks"(v) {
                    return this
                }
                "recordException"(v, E) {}
            }
            function build_esm_dsn_dsnToString(v, E=!1) {
                const {"host": k, "path": R, "pass": U, "port": H, "projectId": G, "protocol": W, "publicKey": Z} = v;
                return `${W}://${Z}${E && U ? `:${U}` : ""}@${k}${H ? `:${H}` : ""}/${R ? `${R}/` : R}${G}`
            }
            function esm_envelope_createSpanEnvelopeItem(v) {
                return [{
                    "type": "span"
                }, v]
            }
            function measurement_timedEventsToMeasurements(v) {
                if (!v || 0 === v.length)
                    return;
                const E = {};
                return v.forEach((v => {
                    const k = v.attributes || {}
                      , R = k[Ma]
                      , U = k[Na];
                    "string" == typeof R && "number" == typeof U && (E[v.name] = {
                        "value": U,
                        "unit": R
                    })
                }
                )),
                E
            }
            const Va = "_sentryScope"
              , Wa = "_sentryIsolationScope";
            function utils_getCapturedScopesOnSpan(v) {
                return {
                    "scope": v[Va],
                    "isolationScope": v[Wa]
                }
            }
            class sentrySpan_SentrySpan {
                "constructor"(v={}) {
                    this._traceId = v.traceId || esm_misc_uuid4(),
                    this._spanId = v.spanId || esm_misc_uuid4().substring(16),
                    this._startTime = v.startTimestamp || Ot(),
                    this._attributes = {},
                    this.setAttributes({
                        [Ra]: "manual",
                        [Pa]: v.op,
                        ...v.attributes
                    }),
                    this._name = v.name,
                    v.parentSpanId && (this._parentSpanId = v.parentSpanId),
                    "sampled"in v && (this._sampled = v.sampled),
                    v.endTimestamp && (this._endTime = v.endTimestamp),
                    this._events = [],
                    this._isStandaloneSpan = v.isStandalone,
                    this._endTime && this._onSpanEnded()
                }
                "addLink"(v) {
                    return this
                }
                "addLinks"(v) {
                    return this
                }
                "recordException"(v, E) {}
                "spanContext"() {
                    const {"_spanId": v, "_traceId": E, "_sampled": k} = this;
                    return {
                        "spanId": v,
                        "traceId": E,
                        "traceFlags": k ? Fa : 0
                    }
                }
                "setAttribute"(v, E) {
                    return void 0 === E ? delete this._attributes[v] : this._attributes[v] = E,
                    this
                }
                "setAttributes"(v) {
                    return Object.keys(v).forEach((E => this.setAttribute(E, v[E]))),
                    this
                }
                "updateStartTime"(v) {
                    this._startTime = utils_spanUtils_spanTimeInputToSeconds(v)
                }
                "setStatus"(v) {
                    return this._status = v,
                    this
                }
                "updateName"(v) {
                    return this._name = v,
                    this
                }
                "end"(v) {
                    this._endTime || (this._endTime = utils_spanUtils_spanTimeInputToSeconds(v),
                    function logSpans_logSpanEnd(v) {
                        if (!Ga)
                            return;
                        const {"description": E="< unknown name >", "op": k="< unknown op >"} = esm_utils_spanUtils_spanToJSON(v)
                          , {"spanId": R} = v.spanContext()
                          , U = `[Tracing] Finishing "${k}" ${utils_spanUtils_getRootSpan(v) === v ? "root " : ""}span "${E}" with ID ${R}`;
                        dt.log(U)
                    }(this),
                    this._onSpanEnded())
                }
                "getSpanJSON"() {
                    return esm_object_dropUndefinedKeys({
                        "data": this._attributes,
                        "description": this._name,
                        "op": this._attributes[Pa],
                        "parent_span_id": this._parentSpanId,
                        "span_id": this._spanId,
                        "start_timestamp": this._startTime,
                        "status": utils_spanUtils_getStatusMessage(this._status),
                        "timestamp": this._endTime,
                        "trace_id": this._traceId,
                        "origin": this._attributes[Ra],
                        "_metrics_summary": metrics_metric_summary_getMetricSummaryJsonForSpan(this),
                        "profile_id": this._attributes["sentry.profile_id"],
                        "exclusive_time": this._attributes[Da],
                        "measurements": measurement_timedEventsToMeasurements(this._events),
                        "is_segment": this._isStandaloneSpan && utils_spanUtils_getRootSpan(this) === this || void 0,
                        "segment_id": this._isStandaloneSpan ? utils_spanUtils_getRootSpan(this).spanContext().spanId : void 0
                    })
                }
                "isRecording"() {
                    return !this._endTime && !!this._sampled
                }
                "addEvent"(v, E, k) {
                    Ga && dt.log("[Tracing] Adding an event to span:", v);
                    const R = sentrySpan_isSpanTimeInput(E) ? E : k || Ot()
                      , U = sentrySpan_isSpanTimeInput(E) ? {} : E || {}
                      , H = {
                        "name": v,
                        "time": utils_spanUtils_spanTimeInputToSeconds(R),
                        "attributes": U
                    };
                    return this._events.push(H),
                    this
                }
                "isStandaloneSpan"() {
                    return !!this._isStandaloneSpan
                }
                "_onSpanEnded"() {
                    const v = _sentry_core_build_esm_currentScopes_getClient();
                    v && v.emit("spanEnd", this);
                    if (!(this._isStandaloneSpan || this === utils_spanUtils_getRootSpan(this)))
                        return;
                    if (this._isStandaloneSpan)
                        return void (this._sampled ? function sentrySpan_sendSpanEnvelope(v) {
                            const E = _sentry_core_build_esm_currentScopes_getClient();
                            if (!E)
                                return;
                            const k = v[1];
                            if (!k || 0 === k.length)
                                return void E.recordDroppedEvent("before_send", "span");
                            const R = E.getTransport();
                            R && R.send(v).then(null, (v => {
                                Ga && dt.error("Error while sending span:", v)
                            }
                            ))
                        }(function envelope_createSpanEnvelope(v, E) {
                            const k = tracing_dynamicSamplingContext_getDynamicSamplingContextFromSpan(v[0])
                              , R = E && E.getDsn()
                              , U = E && E.getOptions().tunnel
                              , H = {
                                "sent_at": (new Date).toISOString(),
                                ...function dscHasRequiredProps(v) {
                                    return !!v.trace_id && !!v.public_key
                                }(k) && {
                                    "trace": k
                                },
                                ...!!U && R && {
                                    "dsn": build_esm_dsn_dsnToString(R)
                                }
                            }
                              , G = E && E.getOptions().beforeSendSpan
                              , W = G ? v => G(esm_utils_spanUtils_spanToJSON(v)) : v => esm_utils_spanUtils_spanToJSON(v)
                              , Z = [];
                            for (const E of v) {
                                const v = W(E);
                                v && Z.push(esm_envelope_createSpanEnvelopeItem(v))
                            }
                            return function build_esm_envelope_createEnvelope(v, E=[]) {
                                return [v, E]
                            }(H, Z)
                        }([this], v)) : (Ga && dt.log("[Tracing] Discarding standalone span because its trace was not chosen to be sampled."),
                        v && v.recordDroppedEvent("sample_rate", "span")));
                    const E = this._convertSpanToTransaction();
                    if (E) {
                        (utils_getCapturedScopesOnSpan(this).scope || _sentry_core_build_esm_currentScopes_getCurrentScope()).captureEvent(E)
                    }
                }
                "_convertSpanToTransaction"() {
                    if (!sentrySpan_isFullFinishedSpan(esm_utils_spanUtils_spanToJSON(this)))
                        return;
                    this._name || (Ga && dt.warn("Transaction has no name, falling back to `<unlabeled transaction>`."),
                    this._name = "<unlabeled transaction>");
                    const {"scope": v, "isolationScope": E} = utils_getCapturedScopesOnSpan(this)
                      , k = (v || _sentry_core_build_esm_currentScopes_getCurrentScope()).getClient() || _sentry_core_build_esm_currentScopes_getClient();
                    if (!0 !== this._sampled)
                        return Ga && dt.log("[Tracing] Discarding transaction because its trace was not chosen to be sampled."),
                        void (k && k.recordDroppedEvent("sample_rate", "transaction"));
                    const R = function utils_spanUtils_getSpanDescendants(v) {
                        const E = new Set;
                        return function addSpanChildren(v) {
                            if (!E.has(v) && utils_spanUtils_spanIsSampled(v)) {
                                E.add(v);
                                const k = v[ja] ? Array.from(v[ja]) : [];
                                for (const v of k)
                                    addSpanChildren(v)
                            }
                        }(v),
                        Array.from(E)
                    }(this).filter((v => v !== this && !function sentrySpan_isStandaloneSpan(v) {
                        return v instanceof sentrySpan_SentrySpan && v.isStandaloneSpan()
                    }(v))).map((v => esm_utils_spanUtils_spanToJSON(v))).filter(sentrySpan_isFullFinishedSpan)
                      , U = this._attributes[ka]
                      , H = {
                        "contexts": {
                            "trace": utils_spanUtils_spanToTransactionTraceContext(this)
                        },
                        "spans": R.length > 1e3 ? R.sort(( (v, E) => v.start_timestamp - E.start_timestamp)).slice(0, 1e3) : R,
                        "start_timestamp": this._startTime,
                        "timestamp": this._endTime,
                        "transaction": this._name,
                        "type": "transaction",
                        "sdkProcessingMetadata": {
                            "capturedSpanScope": v,
                            "capturedSpanIsolationScope": E,
                            ...esm_object_dropUndefinedKeys({
                                "dynamicSamplingContext": tracing_dynamicSamplingContext_getDynamicSamplingContextFromSpan(this)
                            })
                        },
                        "_metrics_summary": metrics_metric_summary_getMetricSummaryJsonForSpan(this),
                        ...U && {
                            "transaction_info": {
                                "source": U
                            }
                        }
                    }
                      , G = measurement_timedEventsToMeasurements(this._events);
                    return G && Object.keys(G).length && (Ga && dt.log("[Measurements] Adding measurements to transaction event", JSON.stringify(G, void 0, 2)),
                    H.measurements = G),
                    H
                }
            }
            function sentrySpan_isSpanTimeInput(v) {
                return v && "number" == typeof v || v instanceof Date || Array.isArray(v)
            }
            function sentrySpan_isFullFinishedSpan(v) {
                return !!(v.start_timestamp && v.timestamp && v.span_id && v.trace_id)
            }
            const Za = "__SENTRY_SUPPRESS_TRACING__";
            function trace_startInactiveSpan(v) {
                const E = trace_getAcs();
                if (E.startInactiveSpan)
                    return E.startInactiveSpan(v);
                const k = trace_parseSentrySpanArguments(v)
                  , {"forceTransaction": R, "parentSpan": U} = v;
                return (v.scope ? E => _sentry_core_build_esm_currentScopes_withScope(v.scope, E) : void 0 !== U ? v => trace_withActiveSpan(U, v) : v => v())(( () => {
                    const E = _sentry_core_build_esm_currentScopes_getCurrentScope()
                      , U = trace_getParentSpan(E);
                    return v.onlyIfParent && !U ? new tracing_sentryNonRecordingSpan_SentryNonRecordingSpan : trace_createChildOrRootSpan({
                        "parentSpan": U,
                        "spanArguments": k,
                        "forceTransaction": R,
                        "scope": E
                    })
                }
                ))
            }
            function trace_withActiveSpan(v, E) {
                const k = trace_getAcs();
                return k.withActiveSpan ? k.withActiveSpan(v, E) : _sentry_core_build_esm_currentScopes_withScope((k => (core_build_esm_utils_spanOnScope_setSpanForScope(k, v || void 0),
                E(k))))
            }
            function trace_createChildOrRootSpan({"parentSpan": v, "spanArguments": E, "forceTransaction": k, "scope": R}) {
                if (!utils_hasTracingEnabled_hasTracingEnabled())
                    return new tracing_sentryNonRecordingSpan_SentryNonRecordingSpan;
                const U = function _sentry_core_build_esm_currentScopes_getIsolationScope() {
                    return _sentry_core_build_esm_asyncContext_getAsyncContextStrategy(_sentry_core_build_esm_carrier_getMainCarrier()).getIsolationScope()
                }();
                let H;
                if (v && !k)
                    H = function trace_startChildSpan(v, E, k) {
                        const {"spanId": R, "traceId": U} = v.spanContext()
                          , H = !E.getScopeData().sdkProcessingMetadata[Za] && utils_spanUtils_spanIsSampled(v)
                          , G = H ? new sentrySpan_SentrySpan({
                            ...k,
                            "parentSpanId": R,
                            "traceId": U,
                            "sampled": H
                        }) : new tracing_sentryNonRecordingSpan_SentryNonRecordingSpan({
                            "traceId": U
                        });
                        utils_spanUtils_addChildSpanToSpan(v, G);
                        const W = _sentry_core_build_esm_currentScopes_getClient();
                        W && (W.emit("spanStart", G),
                        k.endTimestamp && W.emit("spanEnd", G));
                        return G
                    }(v, R, E),
                    utils_spanUtils_addChildSpanToSpan(v, H);
                else if (v) {
                    const k = tracing_dynamicSamplingContext_getDynamicSamplingContextFromSpan(v)
                      , {"traceId": U, "spanId": G} = v.spanContext()
                      , W = utils_spanUtils_spanIsSampled(v);
                    H = trace_startRootSpan({
                        "traceId": U,
                        "parentSpanId": G,
                        ...E
                    }, R, W),
                    tracing_dynamicSamplingContext_freezeDscOnSpan(H, k)
                } else {
                    const {"traceId": v, "dsc": k, "parentSpanId": G, "sampled": W} = {
                        ...U.getPropagationContext(),
                        ...R.getPropagationContext()
                    };
                    H = trace_startRootSpan({
                        "traceId": v,
                        "parentSpanId": G,
                        ...E
                    }, R, W),
                    k && tracing_dynamicSamplingContext_freezeDscOnSpan(H, k)
                }
                return function logSpans_logSpanStart(v) {
                    if (!Ga)
                        return;
                    const {"description": E="< unknown name >", "op": k="< unknown op >", "parent_span_id": R} = esm_utils_spanUtils_spanToJSON(v)
                      , {"spanId": U} = v.spanContext()
                      , H = utils_spanUtils_spanIsSampled(v)
                      , G = utils_spanUtils_getRootSpan(v)
                      , W = G === v
                      , Z = `[Tracing] Starting ${H ? "sampled" : "unsampled"} ${W ? "root " : ""}span`
                      , Y = [`op: ${k}`, `name: ${E}`, `ID: ${U}`];
                    if (R && Y.push(`parent ID: ${R}`),
                    !W) {
                        const {"op": v, "description": E} = esm_utils_spanUtils_spanToJSON(G);
                        Y.push(`root ID: ${G.spanContext().spanId}`),
                        v && Y.push(`root op: ${v}`),
                        E && Y.push(`root description: ${E}`)
                    }
                    dt.log(`${Z}\n  ${Y.join("\n  ")}`)
                }(H),
                function utils_setCapturedScopesOnSpan(v, E, k) {
                    v && (esm_object_addNonEnumerableProperty(v, Wa, k),
                    esm_object_addNonEnumerableProperty(v, Va, E))
                }(H, R, U),
                H
            }
            function trace_parseSentrySpanArguments(v) {
                const E = {
                    "isStandalone": (v.experimental || {}).standalone,
                    ...v
                };
                if (v.startTime) {
                    const k = {
                        ...E
                    };
                    return k.startTimestamp = utils_spanUtils_spanTimeInputToSeconds(v.startTime),
                    delete k.startTime,
                    k
                }
                return E
            }
            function trace_getAcs() {
                return _sentry_core_build_esm_asyncContext_getAsyncContextStrategy(_sentry_core_build_esm_carrier_getMainCarrier())
            }
            function trace_startRootSpan(v, E, k) {
                const R = _sentry_core_build_esm_currentScopes_getClient()
                  , U = R && R.getOptions() || {}
                  , {"name": H="", "attributes": G} = v
                  , [W,Z] = E.getScopeData().sdkProcessingMetadata[Za] ? [!1] : sampling_sampleSpan(U, {
                    "name": H,
                    "parentSampled": k,
                    "attributes": G,
                    "transactionContext": {
                        "name": H,
                        "parentSampled": k
                    }
                })
                  , Y = new sentrySpan_SentrySpan({
                    ...v,
                    "attributes": {
                        [ka]: "custom",
                        ...v.attributes
                    },
                    "sampled": W
                });
                return void 0 !== Z && Y.setAttribute(Oa, Z),
                R && R.emit("spanStart", Y),
                Y
            }
            function trace_getParentSpan(v) {
                const E = build_esm_utils_spanOnScope_getSpanForScope(v);
                if (!E)
                    return;
                const k = _sentry_core_build_esm_currentScopes_getClient();
                return (k ? k.getOptions() : {}).parentSpanIsAlwaysRootSpan ? utils_spanUtils_getRootSpan(E) : E
            }
            const Ya = ct
              , Ja = 80;
            function utils_build_esm_browser_htmlTreeAsString(v, E={}) {
                if (!v)
                    return "<unknown>";
                try {
                    let k = v;
                    const R = 5
                      , U = [];
                    let H = 0
                      , G = 0;
                    const W = " > "
                      , Z = W.length;
                    let Y;
                    const J = Array.isArray(E) ? E : E.keyAttrs
                      , K = !Array.isArray(E) && E.maxStringLength || Ja;
                    for (; k && H++ < R && (Y = build_esm_browser_htmlElementAsString(k, J),
                    !("html" === Y || H > 1 && G + U.length * Z + Y.length >= K)); )
                        U.push(Y),
                        G += Y.length,
                        k = k.parentNode;
                    return U.reverse().join(W)
                } catch (v) {
                    return "<unknown>"
                }
            }
            function build_esm_browser_htmlElementAsString(v, E) {
                const k = v
                  , R = [];
                if (!k || !k.tagName)
                    return "";
                if (Ya.HTMLElement && k instanceof HTMLElement && k.dataset) {
                    if (k.dataset.sentryComponent)
                        return k.dataset.sentryComponent;
                    if (k.dataset.sentryElement)
                        return k.dataset.sentryElement
                }
                R.push(k.tagName.toLowerCase());
                const U = E && E.length ? E.filter((v => k.getAttribute(v))).map((v => [v, k.getAttribute(v)])) : null;
                if (U && U.length)
                    U.forEach((v => {
                        R.push(`[${v[0]}="${v[1]}"]`)
                    }
                    ));
                else {
                    k.id && R.push(`#${k.id}`);
                    const v = k.className;
                    if (v && esm_is_isString(v)) {
                        const E = v.split(/\s+/);
                        for (const v of E)
                            R.push(`.${v}`)
                    }
                }
                const H = ["aria-label", "type", "name", "title", "alt"];
                for (const v of H) {
                    const E = k.getAttribute(v);
                    E && R.push(`[${v}="${E}"]`)
                }
                return R.join("")
            }
            function build_esm_browser_getComponentName(v) {
                if (!Ya.HTMLElement)
                    return null;
                let E = v;
                for (let v = 0; v < 5; v++) {
                    if (!E)
                        return null;
                    if (E instanceof HTMLElement) {
                        if (E.dataset.sentryComponent)
                            return E.dataset.sentryComponent;
                        if (E.dataset.sentryElement)
                            return E.dataset.sentryElement
                    }
                    E = E.parentNode
                }
                return null
            }
            function buildPolyfills_optionalChain_optionalChain(v) {
                let E, k = v[0], R = 1;
                for (; R < v.length; ) {
                    const U = v[R]
                      , H = v[R + 1];
                    if (R += 2,
                    ("optionalAccess" === U || "optionalCall" === U) && null == k)
                        return;
                    "access" === U || "optionalAccess" === U ? (E = k,
                    k = H(k)) : "call" !== U && "optionalCall" !== U || (k = H(( (...v) => k.call(E, ...v))),
                    E = void 0)
                }
                return k
            }
            function isMeasurementValue(v) {
                return "number" == typeof v && isFinite(v)
            }
            function startAndEndSpan(v, E, k, {...R}) {
                const U = esm_utils_spanUtils_spanToJSON(v).start_timestamp;
                return U && U > E && "function" == typeof v.updateStartTime && v.updateStartTime(E),
                trace_withActiveSpan(v, ( () => {
                    const v = trace_startInactiveSpan({
                        "startTime": E,
                        ...R
                    });
                    return v && v.end(k),
                    v
                }
                ))
            }
            function startStandaloneWebVitalSpan(v) {
                const E = _sentry_core_build_esm_currentScopes_getClient();
                if (!E)
                    return;
                const {"name": k, "transaction": R, "attributes": U, "startTime": H} = v
                  , {"release": G, "environment": W} = E.getOptions()
                  , Z = E.getIntegrationByName("Replay")
                  , Y = Z && Z.getReplayId()
                  , J = _sentry_core_build_esm_currentScopes_getCurrentScope()
                  , K = J.getUser()
                  , X = void 0 !== K ? K.email || K.id || K.ip_address : void 0;
                let Q;
                try {
                    Q = J.getScopeData().contexts.profile.profile_id
                } catch (v) {}
                return trace_startInactiveSpan({
                    "name": k,
                    "attributes": {
                        "release": G,
                        "environment": W,
                        "user": X || void 0,
                        "profile_id": Q || void 0,
                        "replay_id": Y || void 0,
                        "transaction": R,
                        "user_agent.original": _t.navigator && _t.navigator.userAgent,
                        ...U
                    },
                    "startTime": H,
                    "experimental": {
                        "standalone": !0
                    }
                })
            }
            function getBrowserPerformanceAPI() {
                return _t && _t.addEventListener && _t.performance
            }
            function msToSec(v) {
                return v / 1e3
            }
            function trackClsAsStandaloneSpan() {
                let v, E, k = 0;
                if (!function supportsLayoutShift() {
                    try {
                        return buildPolyfills_optionalChain_optionalChain([PerformanceObserver, "access", v => v.supportedEntryTypes, "optionalAccess", v => v.includes, "call", v => v("layout-shift")])
                    } catch (v) {
                        return !1
                    }
                }())
                    return;
                let R = !1;
                function _collectClsOnce() {
                    R || (R = !0,
                    E && function sendStandaloneClsSpan(v, E, k) {
                        rn && dt.log(`Sending CLS span (${v})`);
                        const R = msToSec((Rt || 0) + (buildPolyfills_optionalChain_optionalChain([E, "optionalAccess", v => v.startTime]) || 0))
                          , U = _sentry_core_build_esm_currentScopes_getCurrentScope().getScopeData().transactionName
                          , H = E ? utils_build_esm_browser_htmlTreeAsString(buildPolyfills_optionalChain_optionalChain([E, "access", v => v.sources, "access", v => v[0], "optionalAccess", v => v.node])) : "Layout shift"
                          , G = esm_object_dropUndefinedKeys({
                            [Ra]: "auto.http.browser.cls",
                            [Pa]: "ui.webvital.cls",
                            [Da]: buildPolyfills_optionalChain_optionalChain([E, "optionalAccess", v => v.duration]) || 0,
                            "sentry.pageload.span_id": k
                        })
                          , W = startStandaloneWebVitalSpan({
                            "name": H,
                            "transaction": U,
                            "attributes": G,
                            "startTime": R
                        });
                        buildPolyfills_optionalChain_optionalChain([W, "optionalAccess", v => v.addEvent, "call", E => E("cls", {
                            [Ma]: "",
                            [Na]: v
                        })]),
                        buildPolyfills_optionalChain_optionalChain([W, "optionalAccess", v => v.end, "call", v => v(R)])
                    }(k, v, E),
                    U())
                }
                const U = addClsInstrumentationHandler(( ({"metric": E}) => {
                    const R = E.entries[E.entries.length - 1];
                    R && (k = E.value,
                    v = R)
                }
                ), !0);
                onHidden(( () => {
                    _collectClsOnce()
                }
                )),
                setTimeout(( () => {
                    const v = buildPolyfills_optionalChain_optionalChain([_sentry_core_build_esm_currentScopes_getClient(), "optionalAccess", v => v.on, "call", E => E("startNavigationSpan", ( () => {
                        _collectClsOnce(),
                        v && v()
                    }
                    ))])
                      , k = utils_spanUtils_getActiveSpan()
                      , R = k && utils_spanUtils_getRootSpan(k)
                      , U = R && esm_utils_spanUtils_spanToJSON(R);
                    U && "pageload" === U.op && (E = R.spanContext().spanId)
                }
                ), 0)
            }
            const Ka = 2147483647;
            let Xa, Qa, es = 0, ts = {};
            function startTrackingWebVitals({"recordClsStandaloneSpans": v}) {
                const E = getBrowserPerformanceAPI();
                if (E && Rt) {
                    E.mark && _t.performance.mark("sentry-tracing-init");
                    const k = function _trackFID() {
                        return addFidInstrumentationHandler(( ({"metric": v}) => {
                            const E = v.entries[v.entries.length - 1];
                            if (!E)
                                return;
                            const k = msToSec(Rt)
                              , R = msToSec(E.startTime);
                            rn && dt.log("[Measurements] Adding FID"),
                            ts.fid = {
                                "value": v.value,
                                "unit": "millisecond"
                            },
                            ts["mark.fid"] = {
                                "value": k + R,
                                "unit": "second"
                            }
                        }
                        ))
                    }()
                      , R = function _trackLCP() {
                        return addLcpInstrumentationHandler(( ({"metric": v}) => {
                            const E = v.entries[v.entries.length - 1];
                            E && (rn && dt.log("[Measurements] Adding LCP"),
                            ts.lcp = {
                                "value": v.value,
                                "unit": "millisecond"
                            },
                            Xa = E)
                        }
                        ), !0)
                    }()
                      , U = function _trackTtfb() {
                        return function addTtfbInstrumentationHandler(v) {
                            return addMetricObserver("ttfb", v, instrumentTtfb, zr)
                        }(( ({"metric": v}) => {
                            v.entries[v.entries.length - 1] && (rn && dt.log("[Measurements] Adding TTFB"),
                            ts.ttfb = {
                                "value": v.value,
                                "unit": "millisecond"
                            })
                        }
                        ))
                    }()
                      , H = v ? trackClsAsStandaloneSpan() : function _trackCLS() {
                        return addClsInstrumentationHandler(( ({"metric": v}) => {
                            const E = v.entries[v.entries.length - 1];
                            E && (rn && dt.log(`[Measurements] Adding CLS ${v.value}`),
                            ts.cls = {
                                "value": v.value,
                                "unit": ""
                            },
                            Qa = E)
                        }
                        ), !0)
                    }();
                    return () => {
                        k(),
                        R(),
                        U(),
                        H && H()
                    }
                }
                return () => {}
            }
            function addPerformanceEntries(v, E) {
                const k = getBrowserPerformanceAPI();
                if (!k || !_t.performance.getEntries || !Rt)
                    return;
                rn && dt.log("[Tracing] Adding & adjusting spans using Performance API");
                const R = msToSec(Rt)
                  , U = k.getEntries()
                  , {"op": H, "start_timestamp": G} = esm_utils_spanUtils_spanToJSON(v);
                if (U.slice(es).forEach((E => {
                    const k = msToSec(E.startTime)
                      , U = msToSec(Math.max(0, E.duration));
                    if (!("navigation" === H && G && R + k < G))
                        switch (E.entryType) {
                        case "navigation":
                            !function _addNavigationSpans(v, E, k) {
                                ["unloadEvent", "redirect", "domContentLoadedEvent", "loadEvent", "connect"].forEach((R => {
                                    _addPerformanceNavigationTiming(v, E, R, k)
                                }
                                )),
                                _addPerformanceNavigationTiming(v, E, "secureConnection", k, "TLS/SSL", "connectEnd"),
                                _addPerformanceNavigationTiming(v, E, "fetch", k, "cache", "domainLookupStart"),
                                _addPerformanceNavigationTiming(v, E, "domainLookup", k, "DNS"),
                                function _addRequest(v, E, k) {
                                    const R = k + msToSec(E.requestStart)
                                      , U = k + msToSec(E.responseEnd)
                                      , H = k + msToSec(E.responseStart);
                                    E.responseEnd && (startAndEndSpan(v, R, U, {
                                        "op": "browser",
                                        "name": "request",
                                        "attributes": {
                                            [Ra]: "auto.ui.browser.metrics"
                                        }
                                    }),
                                    startAndEndSpan(v, H, U, {
                                        "op": "browser",
                                        "name": "response",
                                        "attributes": {
                                            [Ra]: "auto.ui.browser.metrics"
                                        }
                                    }))
                                }(v, E, k)
                            }(v, E, R);
                            break;
                        case "mark":
                        case "paint":
                        case "measure":
                            {
                                !function _addMeasureSpans(v, E, k, R, U) {
                                    const H = getNavigationEntry()
                                      , G = msToSec(H ? H.requestStart : 0)
                                      , W = U + Math.max(k, G)
                                      , Z = U + k
                                      , Y = Z + R
                                      , J = {
                                        [Ra]: "auto.resource.browser.metrics"
                                    };
                                    W !== Z && (J["sentry.browser.measure_happened_before_request"] = !0,
                                    J["sentry.browser.measure_start_time"] = W);
                                    return startAndEndSpan(v, W, Y, {
                                        "name": E.name,
                                        "op": E.entryType,
                                        "attributes": J
                                    }),
                                    W
                                }(v, E, k, U, R);
                                const H = getVisibilityWatcher()
                                  , G = E.startTime < H.firstHiddenTime;
                                "first-paint" === E.name && G && (rn && dt.log("[Measurements] Adding FP"),
                                ts.fp = {
                                    "value": E.startTime,
                                    "unit": "millisecond"
                                }),
                                "first-contentful-paint" === E.name && G && (rn && dt.log("[Measurements] Adding FCP"),
                                ts.fcp = {
                                    "value": E.startTime,
                                    "unit": "millisecond"
                                });
                                break
                            }
                        case "resource":
                            !function _addResourceSpans(v, E, k, R, U, H) {
                                if ("xmlhttprequest" === E.initiatorType || "fetch" === E.initiatorType)
                                    return;
                                const G = function esm_url_parseUrl(v) {
                                    if (!v)
                                        return {};
                                    const E = v.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
                                    if (!E)
                                        return {};
                                    const k = E[6] || ""
                                      , R = E[8] || "";
                                    return {
                                        "host": E[4],
                                        "path": E[5],
                                        "protocol": E[2],
                                        "search": k,
                                        "hash": R,
                                        "relative": E[5] + k + R
                                    }
                                }(k)
                                  , W = {
                                    [Ra]: "auto.resource.browser.metrics"
                                };
                                setResourceEntrySizeData(W, E, "transferSize", "http.response_transfer_size"),
                                setResourceEntrySizeData(W, E, "encodedBodySize", "http.response_content_length"),
                                setResourceEntrySizeData(W, E, "decodedBodySize", "http.decoded_response_content_length"),
                                "renderBlockingStatus"in E && (W["resource.render_blocking_status"] = E.renderBlockingStatus);
                                G.protocol && (W["url.scheme"] = G.protocol.split(":").pop());
                                G.host && (W["server.address"] = G.host);
                                W["url.same_origin"] = k.includes(_t.location.origin);
                                const Z = H + R
                                  , Y = Z + U;
                                startAndEndSpan(v, Z, Y, {
                                    "name": k.replace(_t.location.origin, ""),
                                    "op": E.initiatorType ? `resource.${E.initiatorType}` : "resource.other",
                                    "attributes": W
                                })
                            }(v, E, E.name, k, U, R)
                        }
                }
                )),
                es = Math.max(U.length - 1, 0),
                function _trackNavigator(v) {
                    const E = _t.navigator;
                    if (!E)
                        return;
                    const k = E.connection;
                    k && (k.effectiveType && v.setAttribute("effectiveConnectionType", k.effectiveType),
                    k.type && v.setAttribute("connectionType", k.type),
                    isMeasurementValue(k.rtt) && (ts["connection.rtt"] = {
                        "value": k.rtt,
                        "unit": "millisecond"
                    }));
                    isMeasurementValue(E.deviceMemory) && v.setAttribute("deviceMemory", `${E.deviceMemory} GB`);
                    isMeasurementValue(E.hardwareConcurrency) && v.setAttribute("hardwareConcurrency", String(E.hardwareConcurrency))
                }(v),
                "pageload" === H) {
                    !function _addTtfbRequestTimeToMeasurements(v) {
                        const E = getNavigationEntry();
                        if (!E)
                            return;
                        const {"responseStart": k, "requestStart": R} = E;
                        R <= k && (rn && dt.log("[Measurements] Adding TTFB Request Time"),
                        v["ttfb.requestTime"] = {
                            "value": k - R,
                            "unit": "millisecond"
                        })
                    }(ts);
                    const k = ts["mark.fid"];
                    k && ts.fid && (startAndEndSpan(v, k.value, k.value + msToSec(ts.fid.value), {
                        "name": "first input delay",
                        "op": "ui.action",
                        "attributes": {
                            [Ra]: "auto.ui.browser.metrics"
                        }
                    }),
                    delete ts["mark.fid"]),
                    "fcp"in ts && E.recordClsOnPageloadSpan || delete ts.cls,
                    Object.entries(ts).forEach(( ([v,E]) => {
                        !function measurement_setMeasurement(v, E, k, R=utils_spanUtils_getActiveSpan()) {
                            const U = R && utils_spanUtils_getRootSpan(R);
                            U && U.addEvent(v, {
                                [Na]: E,
                                [Ma]: k
                            })
                        }(v, E.value, E.unit)
                    }
                    )),
                    v.setAttribute("performance.timeOrigin", R),
                    function _setWebVitalAttributes(v) {
                        Xa && (rn && dt.log("[Measurements] Adding LCP Data"),
                        Xa.element && v.setAttribute("lcp.element", utils_build_esm_browser_htmlTreeAsString(Xa.element)),
                        Xa.id && v.setAttribute("lcp.id", Xa.id),
                        Xa.url && v.setAttribute("lcp.url", Xa.url.trim().slice(0, 200)),
                        v.setAttribute("lcp.size", Xa.size));
                        Qa && Qa.sources && (rn && dt.log("[Measurements] Adding CLS Data"),
                        Qa.sources.forEach(( (E, k) => v.setAttribute(`cls.source.${k + 1}`, utils_build_esm_browser_htmlTreeAsString(E.node)))))
                    }(v)
                }
                Xa = void 0,
                Qa = void 0,
                ts = {}
            }
            function _addPerformanceNavigationTiming(v, E, k, R, U, H) {
                const G = H ? E[H] : E[`${k}End`]
                  , W = E[`${k}Start`];
                W && G && startAndEndSpan(v, R + msToSec(W), R + msToSec(G), {
                    "op": "browser",
                    "name": U || k,
                    "attributes": {
                        [Ra]: "auto.ui.browser.metrics"
                    }
                })
            }
            function setResourceEntrySizeData(v, E, k, R) {
                const U = E[k];
                null != U && U < Ka && (v[R] = U)
            }
            const ns = []
              , rs = new Map;
            function startTrackingINP() {
                if (getBrowserPerformanceAPI() && Rt) {
                    const v = function _trackINP() {
                        return addInpInstrumentationHandler(( ({"metric": v}) => {
                            if (null == v.value)
                                return;
                            const E = v.entries.find((E => E.duration === v.value && os[E.name]));
                            if (!E)
                                return;
                            const {"interactionId": k} = E
                              , R = os[E.name]
                              , U = msToSec(Rt + E.startTime)
                              , H = msToSec(v.value)
                              , G = utils_spanUtils_getActiveSpan()
                              , W = G ? utils_spanUtils_getRootSpan(G) : void 0
                              , Z = (null != k ? rs.get(k) : void 0) || W
                              , Y = Z ? esm_utils_spanUtils_spanToJSON(Z).description : _sentry_core_build_esm_currentScopes_getCurrentScope().getScopeData().transactionName
                              , J = startStandaloneWebVitalSpan({
                                "name": utils_build_esm_browser_htmlTreeAsString(E.target),
                                "transaction": Y,
                                "attributes": esm_object_dropUndefinedKeys({
                                    [Ra]: "auto.http.browser.inp",
                                    [Pa]: `ui.interaction.${R}`,
                                    [Da]: E.duration
                                }),
                                "startTime": U
                            });
                            buildPolyfills_optionalChain_optionalChain([J, "optionalAccess", v => v.addEvent, "call", E => E("inp", {
                                [Ma]: "millisecond",
                                [Na]: v.value
                            })]),
                            buildPolyfills_optionalChain_optionalChain([J, "optionalAccess", v => v.end, "call", v => v(U + H)])
                        }
                        ))
                    }();
                    return () => {
                        v()
                    }
                }
                return () => {}
            }
            const os = {
                "click": "click",
                "pointerdown": "click",
                "pointerup": "click",
                "mousedown": "click",
                "mouseup": "click",
                "touchstart": "click",
                "touchend": "click",
                "mouseover": "hover",
                "mouseout": "hover",
                "mouseenter": "hover",
                "mouseleave": "hover",
                "pointerover": "hover",
                "pointerout": "hover",
                "pointerenter": "hover",
                "pointerleave": "hover",
                "dragstart": "drag",
                "dragend": "drag",
                "drag": "drag",
                "dragenter": "drag",
                "dragleave": "drag",
                "dragover": "drag",
                "drop": "drag",
                "keydown": "press",
                "keyup": "press",
                "keypress": "press",
                "input": "press"
            };
            const as = {
                "idleTimeout": 1e3,
                "finalTimeout": 3e4,
                "childSpanTimeout": 15e3
            }
              , ss = "heartbeatFailed"
              , cs = "idleTimeout"
              , ls = "finalTimeout"
              , us = "externalFinish";
            function startIdleSpan(v, E={}) {
                const k = new Map;
                let R, U = !1, H = us, G = !E.disableAutoFinish;
                const W = []
                  , {"idleTimeout": Z=as.idleTimeout, "finalTimeout": Y=as.finalTimeout, "childSpanTimeout": J=as.childSpanTimeout, "beforeSpanEnd": K} = E
                  , X = currentScopes_getClient();
                if (!X || !hasTracingEnabled_hasTracingEnabled())
                    return new sentryNonRecordingSpan_SentryNonRecordingSpan;
                const Q = currentScopes_getCurrentScope()
                  , ee = getActiveSpan()
                  , te = function _startIdleSpan(v) {
                    const E = startInactiveSpan(v);
                    return spanOnScope_setSpanForScope(currentScopes_getCurrentScope(), E),
                    _e && fe.log("[Tracing] Started span is an idle span"),
                    E
                }(v);
                function _cancelIdleTimeout() {
                    R && (clearTimeout(R),
                    R = void 0)
                }
                function _restartIdleTimeout(v) {
                    _cancelIdleTimeout(),
                    R = setTimeout(( () => {
                        !U && 0 === k.size && G && (H = cs,
                        te.end(v))
                    }
                    ), Z)
                }
                function _restartChildSpanTimeout(v) {
                    R = setTimeout(( () => {
                        !U && G && (H = ss,
                        te.end(v))
                    }
                    ), J)
                }
                function onIdleSpanEnded(v) {
                    U = !0,
                    k.clear(),
                    W.forEach((v => v())),
                    spanOnScope_setSpanForScope(Q, ee);
                    const E = spanUtils_spanToJSON(te)
                      , {"start_timestamp": R} = E;
                    if (!R)
                        return;
                    (E.data || {})[ze] || te.setAttribute(ze, H),
                    fe.log(`[Tracing] Idle span "${E.op}" finished`);
                    const G = getSpanDescendants(te).filter((v => v !== te));
                    let J = 0;
                    G.forEach((E => {
                        E.isRecording() && (E.setStatus({
                            "code": Je,
                            "message": "cancelled"
                        }),
                        E.end(v),
                        _e && fe.log("[Tracing] Cancelling span since span ended early", JSON.stringify(E, void 0, 2)));
                        const k = spanUtils_spanToJSON(E)
                          , {"timestamp": R=0, "start_timestamp": U=0} = k
                          , H = U <= v
                          , G = R - U <= (Y + Z) / 1e3;
                        if (_e) {
                            const v = JSON.stringify(E, void 0, 2);
                            H ? G || fe.log("[Tracing] Discarding span since it finished after idle span final timeout", v) : fe.log("[Tracing] Discarding span since it happened after idle span was finished", v)
                        }
                        G && H || (!function removeChildSpanFromSpan(v, E) {
                            v[Xe] && v[Xe].delete(E)
                        }(te, E),
                        J++)
                    }
                    )),
                    J > 0 && te.setAttribute("sentry.idle_span_discarded_spans", J)
                }
                return te.end = new Proxy(te.end,{
                    "apply"(v, E, k) {
                        K && K(te);
                        const [R,...U] = k
                          , H = spanTimeInputToSeconds(R || ye())
                          , G = getSpanDescendants(te).filter((v => v !== te));
                        if (!G.length)
                            return onIdleSpanEnded(H),
                            Reflect.apply(v, E, [H, ...U]);
                        const W = G.map((v => spanUtils_spanToJSON(v).timestamp)).filter((v => !!v))
                          , Z = W.length ? Math.max(...W) : void 0
                          , J = spanUtils_spanToJSON(te).start_timestamp
                          , X = Math.min(J ? J + Y / 1e3 : 1 / 0, Math.max(J || -1 / 0, Math.min(H, Z || 1 / 0)));
                        return onIdleSpanEnded(X),
                        Reflect.apply(v, E, [X, ...U])
                    }
                }),
                W.push(X.on("spanStart", (v => {
                    if (U || v === te || spanUtils_spanToJSON(v).timestamp)
                        return;
                    getSpanDescendants(te).includes(v) && function _pushActivity(v) {
                        _cancelIdleTimeout(),
                        k.set(v, !0),
                        _restartChildSpanTimeout(ye() + J / 1e3)
                    }(v.spanContext().spanId)
                }
                ))),
                W.push(X.on("spanEnd", (v => {
                    U || function _popActivity(v) {
                        k.has(v) && k.delete(v),
                        0 === k.size && _restartIdleTimeout(ye() + Z / 1e3)
                    }(v.spanContext().spanId)
                }
                ))),
                W.push(X.on("idleSpanEnableAutoFinish", (v => {
                    v === te && (G = !0,
                    _restartIdleTimeout(),
                    k.size && _restartChildSpanTimeout())
                }
                ))),
                E.disableAutoFinish || _restartIdleTimeout(),
                setTimeout(( () => {
                    U || (te.setStatus({
                        "code": Je,
                        "message": "deadline_exceeded"
                    }),
                    H = ls,
                    te.end())
                }
                ), Y),
                te
            }
            const ds = {
                ...as,
                "instrumentNavigation": !0,
                "instrumentPageLoad": !0,
                "markBackgroundSpan": !0,
                "enableLongTask": !0,
                "enableLongAnimationFrame": !0,
                "enableInp": !0,
                "_experiments": {},
                ...Ta
            }
              , browserTracingIntegration = (v={}) => {
                registerSpanErrorInstrumentation();
                const {"enableInp": E, "enableLongTask": k, "enableLongAnimationFrame": R, "_experiments": {"enableInteractions": U, "enableStandaloneClsSpans": H}, "beforeStartSpan": G, "idleTimeout": W, "finalTimeout": Z, "childSpanTimeout": Y, "markBackgroundSpan": J, "traceFetch": K, "traceXHR": X, "shouldCreateSpanForRequest": Q, "enableHTTPTimings": ee, "instrumentPageLoad": te, "instrumentNavigation": ne} = {
                    ...ds,
                    ...v
                }
                  , re = startTrackingWebVitals({
                    "recordClsStandaloneSpans": H || !1
                });
                E && startTrackingINP(),
                R && ue.PerformanceObserver && PerformanceObserver.supportedEntryTypes && PerformanceObserver.supportedEntryTypes.includes("long-animation-frame") ? function startTrackingLongAnimationFrames() {
                    new PerformanceObserver((v => {
                        if (utils_spanUtils_getActiveSpan())
                            for (const E of v.getEntries()) {
                                if (!E.scripts[0])
                                    continue;
                                const v = msToSec(Rt + E.startTime)
                                  , k = msToSec(E.duration)
                                  , R = {
                                    [Ra]: "auto.ui.browser.metrics"
                                }
                                  , U = E.scripts[0]
                                  , {"invoker": H, "invokerType": G, "sourceURL": W, "sourceFunctionName": Z, "sourceCharPosition": Y} = U;
                                R["browser.script.invoker"] = H,
                                R["browser.script.invoker_type"] = G,
                                W && (R["code.filepath"] = W),
                                Z && (R["code.function"] = Z),
                                -1 !== Y && (R["browser.script.source_char_position"] = Y);
                                const J = trace_startInactiveSpan({
                                    "name": "Main UI thread blocked",
                                    "op": "ui.long-animation-frame",
                                    "startTime": v,
                                    "attributes": R
                                });
                                J && J.end(v + k)
                            }
                    }
                    )).observe({
                        "type": "long-animation-frame",
                        "buffered": !0
                    })
                }() : k && function startTrackingLongTasks() {
                    addPerformanceInstrumentationHandler("longtask", ( ({"entries": v}) => {
                        if (utils_spanUtils_getActiveSpan())
                            for (const E of v) {
                                const v = msToSec(Rt + E.startTime)
                                  , k = msToSec(E.duration)
                                  , R = trace_startInactiveSpan({
                                    "name": "Main UI thread blocked",
                                    "op": "ui.long-task",
                                    "startTime": v,
                                    "attributes": {
                                        [Ra]: "auto.ui.browser.metrics"
                                    }
                                });
                                R && R.end(v + k)
                            }
                    }
                    ))
                }(),
                U && function startTrackingInteractions() {
                    addPerformanceInstrumentationHandler("event", ( ({"entries": v}) => {
                        if (utils_spanUtils_getActiveSpan())
                            for (const E of v)
                                if ("click" === E.name) {
                                    const v = msToSec(Rt + E.startTime)
                                      , k = msToSec(E.duration)
                                      , R = {
                                        "name": utils_build_esm_browser_htmlTreeAsString(E.target),
                                        "op": `ui.interaction.${E.name}`,
                                        "startTime": v,
                                        "attributes": {
                                            [Ra]: "auto.ui.browser.metrics"
                                        }
                                    }
                                      , U = build_esm_browser_getComponentName(E.target);
                                    U && (R.attributes["ui.component_name"] = U);
                                    const H = trace_startInactiveSpan(R);
                                    H && H.end(v + k)
                                }
                    }
                    ))
                }();
                const oe = {
                    "name": void 0,
                    "source": void 0
                };
                function _createRouteSpan(v, E) {
                    const k = "pageload" === E.op
                      , R = G ? G(E) : E
                      , U = R.attributes || {};
                    E.name !== R.name && (U[je] = "custom",
                    R.attributes = U),
                    oe.name = R.name,
                    oe.source = U[je];
                    const J = startIdleSpan(R, {
                        "idleTimeout": W,
                        "finalTimeout": Z,
                        "childSpanTimeout": Y,
                        "disableAutoFinish": k,
                        "beforeSpanEnd": v => {
                            re(),
                            addPerformanceEntries(v, {
                                "recordClsOnPageloadSpan": !H
                            })
                        }
                    });
                    function emitFinish() {
                        ["interactive", "complete"].includes(Et.document.readyState) && v.emit("idleSpanEnableAutoFinish", J)
                    }
                    return k && Et.document && (Et.document.addEventListener("readystatechange", ( () => {
                        emitFinish()
                    }
                    )),
                    emitFinish()),
                    J
                }
                return {
                    "name": "BrowserTracing",
                    "afterAllSetup"(v) {
                        let k, R = Et.location && Et.location.href;
                        v.on("startNavigationSpan", (E => {
                            currentScopes_getClient() === v && (k && !spanUtils_spanToJSON(k).timestamp && (St && fe.log(`[Tracing] Finishing current root span with op: ${spanUtils_spanToJSON(k).op}`),
                            k.end()),
                            k = _createRouteSpan(v, {
                                "op": "navigation",
                                ...E
                            }))
                        }
                        )),
                        v.on("startPageLoadSpan", ( (E, R={}) => {
                            if (currentScopes_getClient() !== v)
                                return;
                            k && !spanUtils_spanToJSON(k).timestamp && (St && fe.log(`[Tracing] Finishing current root span with op: ${spanUtils_spanToJSON(k).op}`),
                            k.end());
                            const U = tracing_propagationContextFromHeaders(R.sentryTrace || getMetaContent("sentry-trace"), R.baggage || getMetaContent("baggage"));
                            currentScopes_getCurrentScope().setPropagationContext(U),
                            k = _createRouteSpan(v, {
                                "op": "pageload",
                                ...E
                            })
                        }
                        )),
                        v.on("spanEnd", (v => {
                            const E = spanUtils_spanToJSON(v).op;
                            if (v !== getRootSpan(v) || "navigation" !== E && "pageload" !== E)
                                return;
                            const k = currentScopes_getCurrentScope()
                              , R = k.getPropagationContext();
                            k.setPropagationContext({
                                ...R,
                                "sampled": void 0 !== R.sampled ? R.sampled : spanIsSampled(v),
                                "dsc": R.dsc || getDynamicSamplingContextFromSpan(v)
                            })
                        }
                        )),
                        Et.location && (te && startBrowserTracingPageLoadSpan(v, {
                            "name": Et.location.pathname,
                            "startTime": Se ? Se / 1e3 : void 0,
                            "attributes": {
                                [je]: "url",
                                [He]: "auto.pageload.browser"
                            }
                        }),
                        ne && addHistoryInstrumentationHandler(( ({"to": E, "from": k}) => {
                            void 0 === k && R && -1 !== R.indexOf(E) ? R = void 0 : k !== E && (R = void 0,
                            startBrowserTracingNavigationSpan(v, {
                                "name": Et.location.pathname,
                                "attributes": {
                                    [je]: "url",
                                    [He]: "auto.navigation.browser"
                                }
                            }))
                        }
                        ))),
                        J && function registerBackgroundTabDetection() {
                            Et && Et.document ? Et.document.addEventListener("visibilitychange", ( () => {
                                const v = getActiveSpan();
                                if (!v)
                                    return;
                                const E = getRootSpan(v);
                                if (Et.document.hidden && E) {
                                    const v = "cancelled"
                                      , {"op": k, "status": R} = spanUtils_spanToJSON(E);
                                    St && fe.log(`[Tracing] Transaction: ${v} -> since tab moved to the background, op: ${k}`),
                                    R || E.setStatus({
                                        "code": Je,
                                        "message": v
                                    }),
                                    E.setAttribute("sentry.cancellation_reason", "document.hidden"),
                                    E.end()
                                }
                            }
                            )) : St && fe.warn("[Tracing] Could not set up background tab detection due to lack of global document")
                        }(),
                        U && function registerInteractionListener(v, E, k, R) {
                            let U;
                            const registerInteractionTransaction = () => {
                                const H = "ui.action.click"
                                  , G = getActiveSpan()
                                  , W = G && getRootSpan(G);
                                if (W) {
                                    const v = spanUtils_spanToJSON(W).op;
                                    if (["navigation", "pageload"].includes(v))
                                        return void (St && fe.warn(`[Tracing] Did not create ${H} span because a pageload or navigation span is in progress.`))
                                }
                                U && (U.setAttribute(ze, "interactionInterrupted"),
                                U.end(),
                                U = void 0),
                                R.name ? U = startIdleSpan({
                                    "name": R.name,
                                    "op": H,
                                    "attributes": {
                                        [je]: R.source || "url"
                                    }
                                }, {
                                    "idleTimeout": v,
                                    "finalTimeout": E,
                                    "childSpanTimeout": k
                                }) : St && fe.warn(`[Tracing] Did not create ${H} transaction because _latestRouteName is missing.`)
                            }
                            ;
                            Et.document && addEventListener("click", registerInteractionTransaction, {
                                "once": !1,
                                "capture": !0
                            })
                        }(W, Z, Y, oe),
                        E && function registerInpInteractionListener(v) {
                            const handleEntries = ({"entries": v}) => {
                                const E = utils_spanUtils_getActiveSpan()
                                  , k = E && utils_spanUtils_getRootSpan(E);
                                v.forEach((v => {
                                    if (!function isPerformanceEventTiming(v) {
                                        return "duration"in v
                                    }(v) || !k)
                                        return;
                                    const E = v.interactionId;
                                    if (null != E && !rs.has(E)) {
                                        if (ns.length > 10) {
                                            const v = ns.shift();
                                            rs.delete(v)
                                        }
                                        ns.push(E),
                                        rs.set(E, k)
                                    }
                                }
                                ))
                            }
                            ;
                            addPerformanceInstrumentationHandler("event", handleEntries),
                            addPerformanceInstrumentationHandler("first-input", handleEntries)
                        }(),
                        instrumentOutgoingRequests(v, {
                            "traceFetch": K,
                            "traceXHR": X,
                            "tracePropagationTargets": v.getOptions().tracePropagationTargets,
                            "shouldCreateSpanForRequest": Q,
                            "enableHTTPTimings": ee
                        })
                    }
                }
            }
            ;
            function startBrowserTracingPageLoadSpan(v, E, k) {
                v.emit("startPageLoadSpan", E, k),
                currentScopes_getCurrentScope().setTransactionName(E.name);
                const R = getActiveSpan();
                return "pageload" === (R && spanUtils_spanToJSON(R).op) ? R : void 0
            }
            function startBrowserTracingNavigationSpan(v, E) {
                currentScopes_getIsolationScope().setPropagationContext(propagationContext_generatePropagationContext()),
                currentScopes_getCurrentScope().setPropagationContext(propagationContext_generatePropagationContext()),
                v.emit("startNavigationSpan", E),
                currentScopes_getCurrentScope().setTransactionName(E.name);
                const k = getActiveSpan();
                return "navigation" === (k && spanUtils_spanToJSON(k).op) ? k : void 0
            }
            function getMetaContent(v) {
                const E = function getDomElement(v) {
                    return me.document && me.document.querySelector ? me.document.querySelector(v) : null
                }(`meta[name=${v}]`);
                return E ? E.getAttribute("content") : void 0
            }
            const ps = 100
              , fs = 5e3
              , hs = 36e5;
            function makeOfflineTransport(v) {
                function log(...v) {
                    _e && fe.info("[Offline]:", ...v)
                }
                return E => {
                    const k = v(E);
                    if (!E.createStore)
                        throw new Error("No `createStore` function was provided");
                    const R = E.createStore(E);
                    let U, H = fs;
                    function flushIn(v) {
                        U && clearTimeout(U),
                        U = setTimeout((async () => {
                            U = void 0;
                            const v = await R.shift();
                            v && (log("Attempting to send previously queued event"),
                            v[0].sent_at = (new Date).toISOString(),
                            send(v, !0).catch((v => {
                                log("Failed to retry sending", v)
                            }
                            )))
                        }
                        ), v),
                        "number" != typeof U && U.unref && U.unref()
                    }
                    function flushWithBackOff() {
                        U || (flushIn(H),
                        H = Math.min(2 * H, hs))
                    }
                    async function send(v, U=!1) {
                        if (!U && envelopeContainsItemType(v, ["replay_event", "replay_recording"]))
                            return await R.push(v),
                            flushIn(ps),
                            {};
                        try {
                            const E = await k.send(v);
                            let R = ps;
                            if (E)
                                if (E.headers && E.headers["retry-after"])
                                    R = parseRetryAfterHeader(E.headers["retry-after"]);
                                else if (E.headers && E.headers["x-sentry-rate-limits"])
                                    R = 6e4;
                                else if ((E.statusCode || 0) >= 400)
                                    return E;
                            return flushIn(R),
                            H = fs,
                            E
                        } catch (k) {
                            if (await function shouldQueue(v, k, R) {
                                return !envelopeContainsItemType(v, ["client_report"]) && (!E.shouldStore || E.shouldStore(v, k, R))
                            }(v, k, H))
                                return U ? await R.unshift(v) : await R.push(v),
                                flushWithBackOff(),
                                log("Error sending. Event queued.", k),
                                {};
                            throw k
                        }
                    }
                    return E.flushAtStartup && flushWithBackOff(),
                    {
                        "send": send,
                        "flush": v => k.flush(v)
                    }
                }
            }
            function promisifyRequest(v) {
                return new Promise(( (E, k) => {
                    v.oncomplete = v.onsuccess = () => E(v.result),
                    v.onabort = v.onerror = () => k(v.error)
                }
                ))
            }
            function keys(v) {
                return promisifyRequest(v.getAllKeys())
            }
            function createIndexedDbStore(v) {
                let E;
                function getStore() {
                    return null == E && (E = function createStore(v, E) {
                        const k = indexedDB.open(v);
                        k.onupgradeneeded = () => k.result.createObjectStore(E);
                        const R = promisifyRequest(k);
                        return v => R.then((k => v(k.transaction(E, "readwrite").objectStore(E))))
                    }(v.dbName || "sentry-offline", v.storeName || "queue")),
                    E
                }
                return {
                    "push": async E => {
                        try {
                            const k = await serializeEnvelope(E);
                            await function push(v, E, k) {
                                return v((v => keys(v).then((R => {
                                    if (!(R.length >= k))
                                        return v.put(E, Math.max(...R, 0) + 1),
                                        promisifyRequest(v.transaction)
                                }
                                ))))
                            }(getStore(), k, v.maxQueueSize || 30)
                        } catch (v) {}
                    }
                    ,
                    "unshift": async E => {
                        try {
                            const k = await serializeEnvelope(E);
                            await function unshift(v, E, k) {
                                return v((v => keys(v).then((R => {
                                    if (!(R.length >= k))
                                        return v.put(E, Math.min(...R, 0) - 1),
                                        promisifyRequest(v.transaction)
                                }
                                ))))
                            }(getStore(), k, v.maxQueueSize || 30)
                        } catch (v) {}
                    }
                    ,
                    "shift": async () => {
                        try {
                            const v = await function shift(v) {
                                return v((v => keys(v).then((E => {
                                    const k = E[0];
                                    if (null != k)
                                        return promisifyRequest(v.get(k)).then((E => (v.delete(k),
                                        promisifyRequest(v.transaction).then(( () => E)))))
                                }
                                ))))
                            }(getStore());
                            if (v)
                                return parseEnvelope(v)
                        } catch (v) {}
                    }
                }
            }
            function makeBrowserOfflineTransport(v=makeFetchTransport) {
                return function makeIndexedDbOfflineTransport(v) {
                    return E => v({
                        ...E,
                        "createStore": createIndexedDbStore
                    })
                }(makeOfflineTransport(v))
            }
            const ms = 1e6
              , gs = String(0)
              , _s = "main";
            let vs = ""
              , ys = ""
              , bs = ""
              , Ss = Et.navigator && Et.navigator.userAgent || ""
              , ws = "";
            const Es = Et.navigator && Et.navigator.language || Et.navigator && Et.navigator.languages && Et.navigator.languages[0] || "";
            const Cs = Et.navigator && Et.navigator.userAgentData;
            function enrichWithThreadInformation(v) {
                return function isProcessedJSSelfProfile(v) {
                    return !("thread_metadata"in v)
                }(v) ? function convertJSSelfProfileToSampledFormat(v) {
                    let E, k = 0;
                    const R = {
                        "samples": [],
                        "stacks": [],
                        "frames": [],
                        "thread_metadata": {
                            [gs]: {
                                "name": _s
                            }
                        }
                    }
                      , U = v.samples[0];
                    if (!U)
                        return R;
                    const H = U.timestamp
                      , G = "number" == typeof performance.timeOrigin ? performance.timeOrigin : Se || 0
                      , W = G - (Se || G);
                    return v.samples.forEach(( (U, G) => {
                        if (void 0 === U.stackId)
                            return void 0 === E && (E = k,
                            R.stacks[E] = [],
                            k++),
                            void (R.samples[G] = {
                                "elapsed_since_start_ns": ((U.timestamp + W - H) * ms).toFixed(0),
                                "stack_id": E,
                                "thread_id": gs
                            });
                        let Z = v.stacks[U.stackId];
                        const Y = [];
                        for (; Z; ) {
                            Y.push(Z.frameId);
                            const E = v.frames[Z.frameId];
                            E && void 0 === R.frames[Z.frameId] && (R.frames[Z.frameId] = {
                                "function": E.name,
                                "abs_path": "number" == typeof E.resourceId ? v.resources[E.resourceId] : void 0,
                                "lineno": E.line,
                                "colno": E.column
                            }),
                            Z = void 0 === Z.parentId ? void 0 : v.stacks[Z.parentId]
                        }
                        const J = {
                            "elapsed_since_start_ns": ((U.timestamp + W - H) * ms).toFixed(0),
                            "stack_id": k,
                            "thread_id": gs
                        };
                        R.stacks[k] = Y,
                        R.samples[G] = J,
                        k++
                    }
                    )),
                    R
                }(v) : v
            }
            function createProfilePayload(v, E, k, R) {
                if ("transaction" !== R.type)
                    throw new TypeError("Profiling events may only be attached to transactions, this should never occur.");
                if (null == k)
                    throw new TypeError(`Cannot construct profiling event envelope without a valid profile. Got ${k} instead.`);
                const U = function getTraceId(v) {
                    const E = v && v.contexts && v.contexts.trace && v.contexts.trace.trace_id;
                    return "string" == typeof E && 32 !== E.length && St && fe.log(`[Profiling] Invalid traceId: ${E} on profiled event`),
                    "string" != typeof E ? "" : E
                }(R)
                  , H = enrichWithThreadInformation(k)
                  , G = E || ("number" == typeof R.start_timestamp ? 1e3 * R.start_timestamp : 1e3 * ye())
                  , W = "number" == typeof R.timestamp ? 1e3 * R.timestamp : 1e3 * ye();
                return {
                    "event_id": v,
                    "timestamp": new Date(G).toISOString(),
                    "platform": "javascript",
                    "version": "1",
                    "release": R.release || "",
                    "environment": R.environment || Me,
                    "runtime": {
                        "name": "javascript",
                        "version": Et.navigator.userAgent
                    },
                    "os": {
                        "name": vs,
                        "version": ys,
                        "build_number": Ss
                    },
                    "device": {
                        "locale": Es,
                        "model": ws,
                        "manufacturer": Ss,
                        "architecture": bs,
                        "is_emulator": !1
                    },
                    "debug_meta": {
                        "images": applyDebugMetadata(k.resources)
                    },
                    "profile": H,
                    "transactions": [{
                        "name": R.transaction || "",
                        "id": R.event_id || misc_uuid4(),
                        "trace_id": U,
                        "active_thread_id": gs,
                        "relative_start_ns": "0",
                        "relative_end_ns": (1e6 * (W - G)).toFixed(0)
                    }]
                }
            }
            function isAutomatedPageLoadSpan(v) {
                return "pageload" === spanUtils_spanToJSON(v).op
            }
            (function isUserAgentData(v) {
                return "object" == typeof v && null !== v && "getHighEntropyValues"in v
            }
            )(Cs) && Cs.getHighEntropyValues(["architecture", "model", "platform", "platformVersion", "fullVersionList"]).then((v => {
                if (vs = v.platform || "",
                bs = v.architecture || "",
                ws = v.model || "",
                ys = v.platformVersion || "",
                v.fullVersionList && v.fullVersionList.length > 0) {
                    const E = v.fullVersionList[v.fullVersionList.length - 1];
                    Ss = `${E.brand} ${E.version}`
                }
            }
            )).catch((v => {}
            ));
            const Ts = new WeakMap;
            function applyDebugMetadata(v) {
                const E = ue._sentryDebugIds;
                if (!E)
                    return [];
                const k = currentScopes_getClient()
                  , R = k && k.getOptions()
                  , U = R && R.stackParser;
                if (!U)
                    return [];
                let H;
                const G = Ts.get(U);
                G ? H = G : (H = new Map,
                Ts.set(U, H));
                const W = Object.keys(E).reduce(( (v, k) => {
                    let R;
                    const G = H.get(k);
                    G ? R = G : (R = U(k),
                    H.set(k, R));
                    for (let U = R.length - 1; U >= 0; U--) {
                        const H = R[U]
                          , G = H && H.filename;
                        if (H && G) {
                            v[G] = E[k];
                            break
                        }
                    }
                    return v
                }
                ), {})
                  , Z = [];
                for (const E of v)
                    E && W[E] && Z.push({
                        "type": "sourcemap",
                        "code_file": E,
                        "debug_id": W[E]
                    });
                return Z
            }
            let xs = !1;
            const As = 3e4;
            function shouldProfileSpan(v) {
                if (xs)
                    return St && fe.log("[Profiling] Profiling has been disabled for the duration of the current user session."),
                    !1;
                if (!v.isRecording())
                    return St && fe.log("[Profiling] Discarding profile because transaction was not sampled."),
                    !1;
                const E = currentScopes_getClient()
                  , k = E && E.getOptions();
                if (!k)
                    return St && fe.log("[Profiling] Profiling disabled, no options found."),
                    !1;
                const R = k.profilesSampleRate;
                if (!function isValidSampleRate(v) {
                    return "number" != typeof v && "boolean" != typeof v || "number" == typeof v && isNaN(v) ? (St && fe.warn(`[Profiling] Invalid sample rate. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(v)} of type ${JSON.stringify(typeof v)}.`),
                    !1) : !0 === v || !1 === v || !(v < 0 || v > 1) || (St && fe.warn(`[Profiling] Invalid sample rate. Sample rate must be between 0 and 1. Got ${v}.`),
                    !1)
                }(R))
                    return St && fe.warn("[Profiling] Discarding profile because of invalid sample rate."),
                    !1;
                if (!R)
                    return St && fe.log("[Profiling] Discarding profile because a negative sampling decision was inherited or profileSampleRate is set to 0"),
                    !1;
                return !!(!0 === R || Math.random() < R) || (St && fe.log(`[Profiling] Discarding profile because it's not included in the random sample (sampling rate = ${Number(R)})`),
                !1)
            }
            function createProfilingEvent(v, E, k, R) {
                return function isValidProfile(v) {
                    return v.samples.length < 2 ? (St && fe.log("[Profiling] Discarding profile because it contains less than 2 samples"),
                    !1) : !!v.frames.length || (St && fe.log("[Profiling] Discarding profile because it contains no frames"),
                    !1)
                }(k) ? createProfilePayload(v, E, k, R) : null
            }
            const Is = new Map;
            function takeProfileFromGlobalCache(v) {
                const E = Is.get(v);
                return E && Is.delete(v),
                E
            }
            function startProfileForSpan(v) {
                let E;
                isAutomatedPageLoadSpan(v) && (E = 1e3 * ye());
                const k = function startJSSelfProfile() {
                    const v = Et.Profiler;
                    if (!function isJSProfilerSupported(v) {
                        return "function" == typeof v
                    }(v))
                        return void (St && fe.log("[Profiling] Profiling is not supported by this browser, Profiler interface missing on window object."));
                    const E = Math.floor(As / 10);
                    try {
                        return new v({
                            "sampleInterval": 10,
                            "maxBufferSize": E
                        })
                    } catch (v) {
                        St && (fe.log("[Profiling] Failed to initialize the Profiling constructor, this is likely due to a missing 'Document-Policy': 'js-profiling' header."),
                        fe.log("[Profiling] Disabling profiling for current user session.")),
                        xs = !0
                    }
                }();
                if (!k)
                    return;
                St && fe.log(`[Profiling] started profiling span: ${spanUtils_spanToJSON(v).description}`);
                const R = misc_uuid4();
                async function onProfileHandler() {
                    if (v && k)
                        return k.stop().then((E => {
                            U && (Et.clearTimeout(U),
                            U = void 0),
                            St && fe.log(`[Profiling] stopped profiling of span: ${spanUtils_spanToJSON(v).description}`),
                            E ? function addProfileToGlobalCache(v, E) {
                                if (Is.set(v, E),
                                Is.size > 30) {
                                    const v = Is.keys().next().value;
                                    Is.delete(v)
                                }
                            }(R, E) : St && fe.log(`[Profiling] profiler returned null profile for: ${spanUtils_spanToJSON(v).description}`, "this may indicate an overlapping span or a call to stopProfiling with a profile title that was never started")
                        }
                        )).catch((v => {
                            St && fe.log("[Profiling] error while stopping profiler:", v)
                        }
                        ))
                }
                currentScopes_getCurrentScope().setContext("profile", {
                    "profile_id": R,
                    "start_timestamp": E
                });
                let U = Et.setTimeout(( () => {
                    St && fe.log("[Profiling] max profile duration elapsed, stopping profiling for:", spanUtils_spanToJSON(v).description),
                    onProfileHandler()
                }
                ), As);
                const H = v.end.bind(v);
                v.end = function profilingWrappedSpanEnd() {
                    return v ? (onProfileHandler().then(( () => {
                        H()
                    }
                    ), ( () => {
                        H()
                    }
                    )),
                    v) : H()
                }
            }
            const browserProfilingIntegration = () => ({
                "name": "BrowserProfiling",
                "setup"(v) {
                    const E = getActiveSpan()
                      , k = E && getRootSpan(E);
                    k && isAutomatedPageLoadSpan(k) && shouldProfileSpan(k) && startProfileForSpan(k),
                    v.on("spanStart", (v => {
                        v === getRootSpan(v) && shouldProfileSpan(v) && startProfileForSpan(v)
                    }
                    )),
                    v.on("beforeEnvelope", (v => {
                        if (!function getActiveProfilesCount() {
                            return Is.size
                        }())
                            return;
                        const E = function findProfiledTransactionsFromEnvelope(v) {
                            const E = [];
                            return forEachEnvelopeItem(v, ( (v, k) => {
                                if ("transaction" === k)
                                    for (let k = 1; k < v.length; k++) {
                                        const R = v[k];
                                        R && R.contexts && R.contexts.profile && R.contexts.profile.profile_id && E.push(v[k])
                                    }
                            }
                            )),
                            E
                        }(v);
                        if (!E.length)
                            return;
                        const k = [];
                        for (const v of E) {
                            const E = v && v.contexts
                              , R = E && E.profile && E.profile.profile_id
                              , U = E && E.profile && E.profile.start_timestamp;
                            if ("string" != typeof R) {
                                St && fe.log("[Profiling] cannot find profile for a span without a profile context");
                                continue
                            }
                            if (!R) {
                                St && fe.log("[Profiling] cannot find profile for a span without a profile context");
                                continue
                            }
                            E && E.profile && delete E.profile;
                            const H = takeProfileFromGlobalCache(R);
                            if (!H) {
                                St && fe.log(`[Profiling] Could not retrieve profile for span: ${R}`);
                                continue
                            }
                            const G = createProfilingEvent(R, U, H, v);
                            G && k.push(G)
                        }
                        !function addProfilesToEnvelope(v, E) {
                            if (!E.length)
                                return v;
                            for (const k of E)
                                v[1].push([{
                                    "type": "profile"
                                }, k]);
                            return v
                        }(v, k)
                    }
                    ))
                }
            })
              , ks = "sentry.source"
              , Os = "sentry.op"
              , Ps = "sentry.origin"
              , Rs = "_sentryMetrics";
            function esm_metrics_metric_summary_getMetricSummaryJsonForSpan(v) {
                const E = v[Rs];
                if (!E)
                    return;
                const k = {};
                for (const [,[v,R]] of E) {
                    (k[v] || (k[v] = [])).push(utils_build_esm_object_dropUndefinedKeys(R))
                }
                return k
            }
            const Ms = 0
              , Ns = 1;
            function esm_utils_spanUtils_spanTimeInputToSeconds(v) {
                return "number" == typeof v ? esm_utils_spanUtils_ensureTimestampInSeconds(v) : Array.isArray(v) ? v[0] + v[1] / 1e9 : v instanceof Date ? esm_utils_spanUtils_ensureTimestampInSeconds(v.getTime()) : fn()
            }
            function esm_utils_spanUtils_ensureTimestampInSeconds(v) {
                return v > 9999999999 ? v / 1e3 : v
            }
            function build_esm_utils_spanUtils_spanToJSON(v) {
                if (function esm_utils_spanUtils_spanIsSentrySpan(v) {
                    return "function" == typeof v.getSpanJSON
                }(v))
                    return v.getSpanJSON();
                try {
                    const {"spanId": E, "traceId": k} = v.spanContext();
                    if (function esm_utils_spanUtils_spanIsOpenTelemetrySdkTraceBaseSpan(v) {
                        const E = v;
                        return !!(E.attributes && E.startTime && E.name && E.endTime && E.status)
                    }(v)) {
                        const {"attributes": R, "startTime": U, "name": H, "endTime": G, "parentSpanId": W, "status": Z} = v;
                        return utils_build_esm_object_dropUndefinedKeys({
                            "span_id": E,
                            "trace_id": k,
                            "data": R,
                            "description": H,
                            "parent_span_id": W,
                            "start_timestamp": esm_utils_spanUtils_spanTimeInputToSeconds(U),
                            "timestamp": esm_utils_spanUtils_spanTimeInputToSeconds(G) || void 0,
                            "status": esm_utils_spanUtils_getStatusMessage(Z),
                            "op": R[Os],
                            "origin": R[Ps],
                            "_metrics_summary": esm_metrics_metric_summary_getMetricSummaryJsonForSpan(v)
                        })
                    }
                    return {
                        "span_id": E,
                        "trace_id": k
                    }
                } catch (v) {
                    return {}
                }
            }
            function esm_utils_spanUtils_getStatusMessage(v) {
                if (v && v.code !== Ms)
                    return v.code === Ns ? "ok" : v.message || "unknown_error"
            }
            const Ds = "_sentryRootSpan";
            function esm_utils_spanUtils_getActiveSpan() {
                const v = esm_asyncContext_getAsyncContextStrategy(esm_carrier_getMainCarrier());
                return v.getActiveSpan ? v.getActiveSpan() : spanOnScope_getSpanForScope(esm_currentScopes_getCurrentScope())
            }
            function instrumentVueRouter(v, E, k) {
                let R = !0;
                v.onError((v => captureException(v, {
                    "mechanism": {
                        "handled": !1
                    }
                }))),
                v.beforeEach(( (v, U, H) => {
                    const G = null == U.name && 0 === U.matched.length || void 0 === U.name && R;
                    R && (R = !1);
                    const W = {
                        [Ps]: "auto.navigation.vue"
                    };
                    for (const E of Object.keys(v.params))
                        W[`params.${E}`] = v.params[E];
                    for (const E of Object.keys(v.query)) {
                        const k = v.query[E];
                        k && (W[`query.${E}`] = k)
                    }
                    let Z = v.path
                      , Y = "url";
                    if (v.name && "path" !== E.routeLabel)
                        Z = v.name.toString(),
                        Y = "custom";
                    else if (v.matched.length > 0) {
                        const E = v.matched.length - 1;
                        Z = v.matched[E].path,
                        Y = "route"
                    }
                    if (esm_currentScopes_getCurrentScope().setTransactionName(Z),
                    E.instrumentPageLoad && G) {
                        const v = function getActiveRootSpan() {
                            const v = esm_utils_spanUtils_getActiveSpan()
                              , E = v && function esm_utils_spanUtils_getRootSpan(v) {
                                return v[Ds] || v
                            }(v);
                            if (!E)
                                return;
                            const k = build_esm_utils_spanUtils_spanToJSON(E).op;
                            return "navigation" === k || "pageload" === k ? E : void 0
                        }();
                        if (v) {
                            "custom" !== (build_esm_utils_spanUtils_spanToJSON(v).data || {})[ks] && (v.updateName(Z),
                            v.setAttribute(ks, Y)),
                            v.setAttributes({
                                ...W,
                                [Ps]: "auto.pageload.vue"
                            })
                        }
                    }
                    E.instrumentNavigation && !G && (W[ks] = Y,
                    W[Ps] = "auto.navigation.vue",
                    k({
                        "name": Z,
                        "op": "navigation",
                        "attributes": W
                    })),
                    H && H()
                }
                ))
            }
            function browserTracingIntegration_browserTracingIntegration(v={}) {
                if (!v.router)
                    return browserTracingIntegration(v);
                const E = browserTracingIntegration({
                    ...v,
                    "instrumentNavigation": !1
                })
                  , {"router": k, "instrumentNavigation": R=!0, "instrumentPageLoad": U=!0, "routeLabel": H="name"} = v;
                return {
                    ...E,
                    "afterAllSetup"(v) {
                        E.afterAllSetup(v);
                        instrumentVueRouter(k, {
                            "routeLabel": H,
                            "instrumentNavigation": R,
                            "instrumentPageLoad": U
                        }, (E => {
                            startBrowserTracingNavigationSpan(v, E)
                        }
                        ))
                    }
                }
            }
            let $s = null
              , Ls = "test";
            try {
                $s = `h5_${process.env.VERSION}`
            } catch (v) {}
            try {
                Ls = "production"
            } catch (v) {}
            const Fs = {
                "release": $s,
                "environment": Ls,
                "tracesSampleRate": 1,
                "replaysSessionSampleRate": .1,
                "replaysOnErrorSampleRate": 1,
                "tracePropagationTargets": location?.host ? ["localhost", "127.0.0.1", location.host] : ["localhost", "127.0.0.1"]
            };
            var js = {
                "init": function web_esm_init(v) {
                    sdk_init({
                        ...Fs,
                        ...v
                    })
                },
                "captureException": function web_esm_captureException(v) {
                    captureException(v)
                },
                "ext": R
            }
              , Bs = k(836)
              , Us = k(2808);
            new Error,
            ae.Y.on("nav.detail", (function(v) {
                var E = v.detailId
                  , k = v.type;
                2 === Number(k) ? window.location.href = "/wap/textDetail?detailId=".concat(E) : U.ZP.redirectTo({
                    "url": "/pages/detail/index?detailId=".concat(E)
                })
            }
            )),
            console.log("---build test taro----");
            var Hs = (0,
            Y.ri)({
                "onLaunch": function onLaunch(v) {
                    this.trackManagerInit(v),
                    this.initOpenId()
                },
                "onError": function onError(v) {
                    js.captureException(v)
                },
                "onShow": function onShow(v) {
                    var E = this;
                    this.fetchUserInfo(v),
                    ie.Z.checkLoginState({
                        "successFun": function successFun(v) {
                            var k = v.userId;
                            k && re.Z.judgeNewUser({
                                "userId": k
                            }).then((function(v) {
                                1 === v.code && v.data && E.$bus.emit("showGlobalToast", "我们给你准备了30免费积分，快来试试AI工具吧")
                            }
                            ))
                        }
                    })
                },
                "onPageNotFound": function onPageNotFound(v) {
                    var E = v.path
                      , k = v.query
                      , R = "/wap";
                    E !== "".concat(R, "/search") && E !== "".concat(R, "/home") && E !== "".concat(R, "/detail") || !k.detailId ? E === "".concat(R, "/mylike") || E === "".concat(R, "/history") || E === "".concat(R, "/workbench") ? U.ZP.redirectTo({
                        "url": "/pages/mySpace/index"
                    }) : E === "".concat(R, "/generate/byEliminateImg") || E === "".concat(R, "/generate/byCutoutImg") || E === "".concat(R, "/generate/byExtendImg") ? U.ZP.redirectTo({
                        "url": "/pages/aiDraw/index"
                    }) : (console.warn("Page Not Found:", E),
                    U.ZP.redirectTo({
                        "url": "/pages/home/index"
                    })) : this.$bus.emit("nav.detail", {
                        "detailId": k.detailId,
                        "type": k.type
                    })
                },
                "computed": (0,
                Z.Z)({}, (0,
                ee.rn)("base", ["isLogin", "userInfo"])),
                "watch": {
                    "isLogin": {
                        "immediate": !0,
                        "handler": function handler(v) {
                            var E, k = this;
                            this.getUserPoint(),
                            ne.Z.getMemberDetail({
                                "userId": null === (E = this.userInfo) || void 0 === E ? void 0 : E.userId
                            }).then((function(v) {
                                var E, R, U, H, G;
                                1 === v.code ? v.data && k.updateMemberInfo({
                                    "memberLevel": null === (E = v.data) || void 0 === E ? void 0 : E.memberLevel,
                                    "memberInfo": (0,
                                    Z.Z)((0,
                                    Z.Z)((0,
                                    Z.Z)({}, null === (R = v.data) || void 0 === R ? void 0 : R.memberInfo), null === (U = v.data) || void 0 === U ? void 0 : U.bpInfo), {}, {
                                        "memberName": null === (H = v.data) || void 0 === H ? void 0 : H.memberName,
                                        "right": null === (G = v.data) || void 0 === G ? void 0 : G.right
                                    })
                                }) : console.error("member info error", v)
                            }
                            )),
                            v && this.handleInterval(),
                            console.log("call handleTrailInterval in app"),
                            !v && this.handleTrailInterval();
                            var R = oe.Z.getItem("trailList");
                            v && (null == R ? void 0 : R.length) > 0 && (console.log(R, "trailList"),
                            this.mergeArt(R))
                        }
                    }
                },
                "methods": (0,
                Z.Z)((0,
                Z.Z)((0,
                Z.Z)((0,
                Z.Z)((0,
                Z.Z)({}, (0,
                ee.OI)("base", ["updateMemberInfo"])), (0,
                ee.nv)("base", ["getUserPoint", "mergeArt"])), (0,
                ee.nv)("artDetail", ["intervalMsg", "handleInterval"])), (0,
                ee.nv)("trailDetail", ["handleTrailInterval"])), {}, {
                    "trackManagerInit": function trackManagerInit(v) {
                        var E = Q.Z.spmA;
                        E += "-dev",
                        J.dK.setupConfigration({
                            "appId": Q.Z.appId,
                            "appName": Q.Z.appName,
                            "appVersion": Q.Z.appVersion,
                            "spmA": E,
                            "api": Q.Z.api,
                            "ext": {
                                "scene": v.scene
                            },
                            "requestOptions": Q.Z.requestOptions,
                            "isWeb": !0
                        })
                    },
                    "initOpenId": function initOpenId() {
                        var v = function getSuv() {
                            var v = new RegExp("\\bSUV=([^;]*)\\b").exec(document.cookie);
                            return v ? decodeURIComponent(v[1]) : null
                        }() || function initSuv() {
                            var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "sohu.com";
                            if (0 > document.cookie.indexOf("SUV=")) {
                                var E = (new Date).getTime() + "ce" + Math.random().toString(36).substring(2, 6);
                                document.cookie = "SUV=" + E + ";path=/;domain=" + v
                            }
                        }();
                        (0,
                        K.Fj)("userId", v)
                    },
                    "fetchUserInfo": function fetchUserInfo(v) {},
                    "getAppletOpenId": function getAppletOpenId() {
                        (0,
                        X.x4)({
                            "success": function success(v) {
                                v.code && (console.log("code", v.code),
                                re.Z.getUserOpenId({
                                    "code": v.code,
                                    "spma": Q.Z.spmA
                                }).then((function(v) {
                                    v && ((0,
                                    K.Fj)("userId", v),
                                    console.log("openId", (0,
                                    K.qu)("userId")))
                                }
                                )).catch((function(v) {
                                    console.log("error", v)
                                }
                                )))
                            }
                        })
                    },
                    "ttTokenMock": function ttTokenMock() {
                        0
                    }
                })
            });
            Hs.config.globalProperties.$bus = ae.Y,
            Hs.config.globalProperties.localStorage = oe.Z,
            Hs.use(U.ZP.setGlobalDataPlugin, {
                "globalData": {}
            }),
            Hs.use(te.Z),
            js.init({
                "app": Hs,
                "dsn": se.c$,
                "release": "h5_202412121731",
                "enabled": !0
            }),
            function requestIntercept() {
                var v = Bs.WY;
                U.ZP.request = function(E) {
                    var k = E.success;
                    E.url,
                    E.data;
                    v.apply(U.ZP, [(0,
                    Z.Z)((0,
                    Z.Z)({}, E), {}, {
                        "success": function successCallback(v) {
                            k(v)
                        }
                    })])
                }
            }(),
            function uploadIntercept() {
                var v = Us.c;
                U.ZP.uploadFile = function(E) {
                    var k = E.success
                      , R = E.fail
                      , H = (E.url,
                    E.header);
                    v.apply(U.ZP, [(0,
                    Z.Z)((0,
                    Z.Z)({}, E), {}, {
                        "success": function successCallback(v) {
                            console.log("upload success, requestId:", H.requestId),
                            k(v)
                        },
                        "fail": function failCallback(v) {
                            console.log("upload fail, requestId:", H.requestId),
                            R(v)
                        }
                    })])
                }
            }();
            var zs = Hs
              , qs = k(9465)
              , Gs = k(7626)
              , Vs = k(6252)
              , Ws = k(8948)
              , Zs = k(2778)
              , Ys = k(4588)
              , Js = {
                "router": {
                    "mode": "browser",
                    "basename": "/wap",
                    "customRoutes": {
                        "/pages/detail/index": "/detail",
                        "/pages/textDetail/index": "/textDetail",
                        "/pages/mySpace/index": "/mySpace",
                        "/pages/home/index": ["/home"],
                        "/pages/textHome/index": "/textHome",
                        "/pages/memberDetail/index": ["/memberDetail", "/paySuccess/memberDetail"],
                        "/pages/aiDraw/index": "/imageCreative",
                        "/pages/404/index": "/error",
                        "/pages/generate/index": "/generate",
                        "/pages/imgGenerate/byCardImg/index": "/generate/byCardImg",
                        "/pages/imgGenerate/byClearImg/index": "/generate/byClearImg",
                        "/pages/imgGenerate/byPersonBgImg/index": "/generate/byPersonBgImg",
                        "/pages/imgGenerate/byProImg/index": "/generate/byProImg",
                        "/pages/imgGenerate/imgToImg/index": "/generate/imgToImg",
                        "/pages/imgGenerate/textToImg/index": "/generate/textToImg",
                        "/pages/textGenerate/index": "/textGenerate",
                        "/pages/festivalCard/index": "/festivalCard",
                        "/pages/textResult/index": "/textResult",
                        "/pages/editor/index": "/editor",
                        "/pages/payIntermediate/index": "/payIntermediate",
                        "/pages/orderSuccess/index": "/orderSuccess"
                    }
                },
                "pages": ["pages/home/index", "pages/textHome/index", "pages/mySpace/index", "pages/mySpace/setting", "pages/webview/index", "pages/login/index", "pages/share/index", "pages/saveImg/index", "pages/festivalCard/index", "pages/detail/index", "pages/textDetail/index", "pages/404/index", "pages/mySpace/points", "pages/mySpace/pointsDetail", "pages/memberRule/index", "pages/imgLoading/index", "pages/aiDraw/index", "pages/payIntermediate/index", "pages/orderSuccess/index", "pages/imgGenerate/byCardImg/index", "pages/imgGenerate/byClearImg/index", "pages/imgGenerate/byPersonBgImg/index", "pages/imgGenerate/byProImg/index", "pages/imgGenerate/imgToImg/index", "pages/imgGenerate/textToImg/index", "pages/generate/index", "pages/textGenerate/index", "pages/textResult/index", "pages/memberDetail/index"],
                "subPackages": [{
                    "root": "pages/imgGenerate",
                    "pages": ["byCardImg/index", "byClearImg/index", "byPersonBgImg/index", "byProImg/index", "imgToImg/index", "textToImg/index"]
                }, {
                    "root": "pages/generate",
                    "pages": ["index"]
                }, {
                    "root": "pages/textGenerate",
                    "pages": ["index"]
                }, {
                    "root": "pages/textResult",
                    "pages": ["index"]
                }, {
                    "root": "pages/memberDetail",
                    "pages": ["index"]
                }],
                "tabBar": {
                    "custom": !0,
                    "color": "#000000",
                    "selectedColor": "#000000",
                    "backgroundColor": "#000000",
                    "list": [{
                        "pagePath": "pages/home/index",
                        "text": "主页"
                    }, {
                        "pagePath": "pages/textHome/index",
                        "text": "AI助手"
                    }, {
                        "pagePath": "pages/mySpace/index",
                        "text": "我的"
                    }, {
                        "pagePath": "pages/aiDraw/index",
                        "text": "AI生图"
                    }]
                },
                "window": {
                    "navigationBarTextStyle": "white",
                    "navigationBarTitleText": "简单AI",
                    "navigationBarBackgroundColor": "#141416",
                    "backgroundColor": "#141416"
                },
                "networkTimeout": {
                    "request": 16e3
                }
            };
            qs.u9.__taroAppConfig = Js;
            var Ks = []
              , Xs = [];
            if (Js.tabBar)
                for (var Qs = Js.tabBar.list, ec = 0; ec < Qs.length; ec++) {
                    var tc = Qs[ec];
                    tc.iconPath && (tc.iconPath = Ks[ec]),
                    tc.selectedIconPath && (tc.selectedIconPath = Xs[ec])
                }
            Js.routes = [Object.assign({
                "path": "pages/home/index",
                "load": function load(v, E) {
                    return [k.e(260).then(k.bind(k, 2260)), v, E]
                }
            }, {
                "navigationBarTitleText": "简单 AI",
                "onReachBottomDistance": 30
            }), Object.assign({
                "path": "pages/textHome/index",
                "load": function load(v, E) {
                    return [k.e(737).then(k.bind(k, 6737)), v, E]
                }
            }, {
                "navigationBarTitleText": "AI助手",
                "onReachBottomDistance": 30
            }), Object.assign({
                "path": "pages/mySpace/index",
                "load": function load(v, E) {
                    return [k.e(544).then(k.bind(k, 1544)), v, E]
                }
            }, {
                "navigationBarTitleText": "我的",
                "onReachBottomDistance": 30
            }), Object.assign({
                "path": "pages/mySpace/setting",
                "load": function load(v, E) {
                    return [k.e(862).then(k.bind(k, 8862)), v, E]
                }
            }, {
                "navigationBarTitleText": "设置"
            }), Object.assign({
                "path": "pages/webview/index",
                "load": function load(v, E) {
                    return [k.e(368).then(k.bind(k, 2368)), v, E]
                }
            }, {}), Object.assign({
                "path": "pages/login/index",
                "load": function load(v, E) {
                    return [k.e(73).then(k.bind(k, 3073)), v, E]
                }
            }, {
                "navigationBarTitleText": "登录"
            }), Object.assign({
                "path": "pages/share/index",
                "load": function load(v, E) {
                    return [k.e(322).then(k.bind(k, 8322)), v, E]
                }
            }, {
                "navigationBarTitleText": "电子贺卡",
                "navigationBarTextStyle": "black",
                "navigationBarBackgroundColor": "#FFFFFF",
                "backgroundColor": "#FFF0DE"
            }), Object.assign({
                "path": "pages/saveImg/index",
                "load": function load(v, E) {
                    return [k.e(242).then(k.bind(k, 5242)), v, E]
                }
            }, {
                "navigationBarTitleText": "下载图片"
            }), Object.assign({
                "path": "pages/festivalCard/index",
                "load": function load(v, E) {
                    return [k.e(152).then(k.bind(k, 3152)), v, E]
                }
            }, {
                "navigationBarTitleText": "海报合成",
                "navigationBarTextStyle": "black",
                "navigationBarBackgroundColor": "#FFFFFF",
                "backgroundColor": "#FFF0DE"
            }), Object.assign({
                "path": "pages/detail/index",
                "load": function load(v, E) {
                    return [k.e(940).then(k.bind(k, 9940)), v, E]
                }
            }, {
                "navigationBarTitleText": "作品详情",
                "onReachBottomDistance": 30
            }), Object.assign({
                "path": "pages/textDetail/index",
                "load": function load(v, E) {
                    return [k.e(258).then(k.bind(k, 258)), v, E]
                }
            }, {
                "navigationBarTitleText": "作品详情",
                "onReachBottomDistance": 30
            }), Object.assign({
                "path": "pages/404/index",
                "load": function load(v, E) {
                    return [k.e(118).then(k.bind(k, 1118)), v, E]
                }
            }, {
                "navigationBarTitleText": "出错啦",
                "onReachBottomDistance": 30
            }), Object.assign({
                "path": "pages/mySpace/points",
                "load": function load(v, E) {
                    return [k.e(920).then(k.bind(k, 6920)), v, E]
                }
            }, {
                "navigationBarTitleText": "积分规则"
            }), Object.assign({
                "path": "pages/mySpace/pointsDetail",
                "load": function load(v, E) {
                    return [k.e(977).then(k.bind(k, 4977)), v, E]
                }
            }, {
                "navigationBarTitleText": "积分明细"
            }), Object.assign({
                "path": "pages/memberRule/index",
                "load": function load(v, E) {
                    return [k.e(78).then(k.bind(k, 7078)), v, E]
                }
            }, {}), Object.assign({
                "path": "pages/imgLoading/index",
                "load": function load(v, E) {
                    return [k.e(791).then(k.bind(k, 4791)), v, E]
                }
            }, {
                "navigationBarTitleText": "作品生成"
            }), Object.assign({
                "path": "pages/aiDraw/index",
                "load": function load(v, E) {
                    return [k.e(570).then(k.bind(k, 7570)), v, E]
                }
            }, {
                "navigationStyle": "custom",
                "navigationBarTitleText": "简单AI"
            }), Object.assign({
                "path": "pages/payIntermediate/index",
                "load": function load(v, E) {
                    return [k.e(235).then(k.bind(k, 4235)), v, E]
                }
            }, {}), Object.assign({
                "path": "pages/orderSuccess/index",
                "load": function load(v, E) {
                    return [k.e(661).then(k.bind(k, 7661)), v, E]
                }
            }, {}), Object.assign({
                "path": "pages/imgGenerate/byCardImg/index",
                "load": function load(v, E) {
                    return [k.e(239).then(k.bind(k, 4239)), v, E]
                }
            }, {
                "navigationBarTitleText": "AI创作",
                "onReachBottomDistance": 30
            }), Object.assign({
                "path": "pages/imgGenerate/byClearImg/index",
                "load": function load(v, E) {
                    return [k.e(665).then(k.bind(k, 5665)), v, E]
                }
            }, {
                "navigationBarTitleText": "AI创作",
                "onReachBottomDistance": 30
            }), Object.assign({
                "path": "pages/imgGenerate/byPersonBgImg/index",
                "load": function load(v, E) {
                    return [k.e(904).then(k.bind(k, 5904)), v, E]
                }
            }, {
                "navigationBarTitleText": "AI创作",
                "onReachBottomDistance": 30
            }), Object.assign({
                "path": "pages/imgGenerate/byProImg/index",
                "load": function load(v, E) {
                    return [k.e(959).then(k.bind(k, 4959)), v, E]
                }
            }, {
                "navigationBarTitleText": "AI创作",
                "onReachBottomDistance": 30
            }), Object.assign({
                "path": "pages/imgGenerate/imgToImg/index",
                "load": function load(v, E) {
                    return [k.e(294).then(k.bind(k, 294)), v, E]
                }
            }, {
                "navigationBarTitleText": "AI创作",
                "onReachBottomDistance": 30
            }), Object.assign({
                "path": "pages/imgGenerate/textToImg/index",
                "load": function load(v, E) {
                    return [k.e(25).then(k.bind(k, 5025)), v, E]
                }
            }, {
                "navigationBarTitleText": "AI创作",
                "onReachBottomDistance": 30
            }), Object.assign({
                "path": "pages/generate/index",
                "load": function load(v, E) {
                    return [k.e(109).then(k.bind(k, 707)), v, E]
                }
            }, {
                "navigationBarTitleText": "AI创作",
                "onReachBottomDistance": 30
            }), Object.assign({
                "path": "pages/textGenerate/index",
                "load": function load(v, E) {
                    return [k.e(767).then(k.bind(k, 3767)), v, E]
                }
            }, {}), Object.assign({
                "path": "pages/textResult/index",
                "load": function load(v, E) {
                    return [k.e(730).then(k.bind(k, 7730)), v, E]
                }
            }, {}), Object.assign({
                "path": "pages/memberDetail/index",
                "load": function load(v, E) {
                    return [k.e(279).then(k.bind(k, 1279)), v, E]
                }
            }, {
                "navigationBarTitleText": "购买会员"
            })],
            (0,
            Ws.M)(),
            (0,
            Zs.K)(zs, Ys);
            var nc = (0,
            Gs.rj)(zs, Vs.h, Js)
              , rc = (0,
            H.lX)({
                "window": qs.u9
            });
            (0,
            G.Nf)(Js, rc),
            (0,
            W.p)(rc, nc, Js, Vs.h),
            (0,
            U.J1)({
                "designWidth": 375,
                "deviceRatio": {
                    "375": 2,
                    "640": 1.17,
                    "750": 1,
                    "828": .905
                },
                "baseFontSize": 20,
                "unitPrecision": void 0,
                "targetUnit": void 0
            })
        },
        "230": function(v, E, k) {
            "use strict";
            k.d(E, {
                "OB": function() {
                    return R
                },
                "a9": function() {
                    return G
                },
                "c$": function() {
                    return W
                },
                "uN": function() {
                    return U
                }
            });
            var R = "pre"
              , U = {
                "appId": "100023",
                "appName": "h5-简单ai",
                "spmA": "smwp-ai",
                "appVersion": "1.0.4"
            }
              , H = {
                "test": {
                    "type": "h5",
                    "appId": "100023",
                    "loginSide": 1,
                    "openKey": "",
                    "platform": "h5",
                    "loginUrl": "https://tst.passport.sohu.com/sapi/login/applet/mlogin",
                    "passportUrl": "https://tst.passport.sohu.com/sapi/g",
                    "passport": {
                        "appid": "116019",
                        "appKey": "IS6589C543EQN8wCZ",
                        "vs": "1.0.0"
                    },
                    "accessTokenName": "access_token",
                    "refreshAccessTokenName": "refresh_token",
                    "baseInfoUrl": "https://test-uis.mp.sohu.com/v3/uc",
                    "uploadImageUrl": "https://test-uis.mp.sohu.com/api/vpd/file/imgUpload",
                    "getUserInfoUrl": "https://test-uis.mp.sohu.com/v3/uc/login/",
                    "collectUrl": "https://test-uis.mp.sohu.com/v3/collect"
                },
                "development": {
                    "type": "h5",
                    "appId": "100023",
                    "loginSide": 1,
                    "openKey": "",
                    "platform": "h5",
                    "loginUrl": "https://tst.passport.sohu.com/sapi/login/applet/mlogin",
                    "passportUrl": "https://tst.passport.sohu.com/sapi/g",
                    "passport": {
                        "appid": "116019",
                        "appKey": "IS6589C543EQN8wCZ",
                        "vs": "1.0.0"
                    },
                    "accessTokenName": "access_token",
                    "refreshAccessTokenName": "refresh_token",
                    "baseInfoUrl": "https://test-uis.mp.sohu.com/v3/uc",
                    "uploadImageUrl": "https://test-uis.mp.sohu.com/api/vpd/file/imgUpload",
                    "getUserInfoUrl": "https://test-uis.mp.sohu.com/v3/uc/login/",
                    "collectUrl": "https://test-uis.mp.sohu.com/v3/collect"
                },
                "production": {
                    "type": "h5",
                    "appId": "100023",
                    "loginSide": 1,
                    "form": "smwp-ai",
                    "openKey": "",
                    "platform": "h5",
                    "loginUrl": "https://api.passport.sohu.com/sapi/login/applet/mlogin",
                    "passportUrl": "https://api.passport.sohu.com/sapi/g",
                    "collectUrl": "https://uis.mp.sohu.com/v3/collect",
                    "passport": {
                        "appid": "116019",
                        "testAppKey": "IS6589C543EQN8wCZ",
                        "appKey": "dy2053qL79wQsY1u4e2740733b1G4lJ10VczNjSLJ9y96iKf7F",
                        "vs": "1.0.0"
                    },
                    "accessTokenName": "access_token",
                    "refreshAccessTokenName": "refresh_token",
                    "lastCreateAtName": "lastCreateAt",
                    "uploadImageUrl": "https://uis.mp.sohu.com/api/vpd/file/imgUpload",
                    "baseInfoUrl": "https://uis.mp.sohu.com/v3/uc",
                    "getUserInfoUrl": "https://uis.mp.sohu.com/v3/uc/login/"
                }
            }
              , G = H[R] || H.production
              , W = "https://01a427818e2a04d47fbe92e988acad59@sentry.mp.sohu.com/39"
        },
        "5970": function(v, E, k) {
            "use strict";
            k.d(E, {
                "n": function() {
                    return R
                },
                "o": function() {
                    return U
                }
            });
            var R = "smwp-ai"
              , U = {
                "UPLOADCLICK": "10327",
                "USERCLICK": "10328",
                "SEARCHINPUTCLICK": "10329",
                "SEARCHENTER": "10330",
                "HOTWORDCLICK": "10331",
                "SORTCLICK": "10332",
                "LIKECLICK": "10333",
                "SAMESEARCHCLICK": "10334",
                "COPYLINKCLICK": "10335",
                "COPYPROMPTCLICK": "10336",
                "DOWNLOADCLICK": "10337",
                "TOOLCHOOSE": "10339",
                "PUBLISHSUCCESS": "10340",
                "SAVESUCCESS": "10341",
                "HOMESHOW": "10363",
                "LIKESHOW": "10364",
                "HISTORYSHOW": "10365",
                "WORKSHOW": "10366",
                "DETAILSHOW": "10367",
                "LOGINSUCCESS": "10342",
                "SENDCOMMENTCLICK": "10439",
                "COMMENTSUCCESS": "10338",
                "GENERATE_SUCCESS": "10496",
                "GENERATE_ERROR": "10559",
                "USE_POINT": "10588",
                "USE_ORIGIN_SIZE": "10538",
                "GENERATE_MSG_SUCCESS": "10665",
                "GENERATE_MSG_ERROR": "10667",
                "GENERATE_MSG_TIMEOUT": "10669",
                "GENERATE_SAME": "10535",
                "CARDSAVECLICK": "10739",
                "CARDSHARECLICK": "10740",
                "USERGETPOINTS": "10587",
                "JUMPTOPOINTSPAGE": "10642",
                "CLICKGENERATESAME": "10494",
                "USERCHANGETAB": "10610",
                "CLICKGENERATERPIC": "10530",
                "CLICKGENERATETRAILPIC": "10957",
                "CLICK_PROMOT": "10640",
                "CLICK_UPLOAD_EXAMPLE": "10838",
                "CLICK_UPLOAD_IMAGE": "10537",
                "CLICK_GENTERATE_IMAGE_ERROR_PROMOT": "10536",
                "ZERO_POINTS_EXPLOURE_DIALOG": "10641",
                "CLICK_GET_POINTS": "10582",
                "CLICK_DOWNLOAD_PIC": "10500",
                "SWIPER_LEFT_RIGHT": "10639",
                "SHOW_PIC_PREVIEW": "10634",
                "DELETE_PIC": "10498",
                "PICTURE_PUBLIC": "10532",
                "EXCHANGE_PICTURE": "10635",
                "CLICK_FILL_BACK": "10636",
                "CLICK_CREATE": "10637",
                "CLICK_MY_WORK": "10638",
                "CLICK_FILTER_TAB": "10633",
                "CLICK_TEXT_HOME_FILTER_TAB": "10711",
                "CLICK_SUBMIT_ADVICE": "10713",
                "CLICK_OPEN_PRIVATE": "10643",
                "CLIKC_OPEN_SERVICE": "10824",
                "CLICK_LOG_OUT": "10644",
                "CLICK_TAKE_PICTURE_EXAMPLE": "10832",
                "CREATE_Commodity_Portrait_SUCCESS": "10816",
                "POINTS_DETAIL_NETWORK_FAILD": "10805",
                "MEMBER_PAGE_EXPLORE": "10784",
                "MEMBER_PAGE_OPEN_MEMBER": "10785",
                "MEMBER_PAGE_RENEWAL_MEMBER": "10786",
                "MEMBER_PAGE_PAY_DIFFERENCE": "10789",
                "MEMBER_PAGE_OPEN_ERROR": "10787",
                "RENEWAL_DETAIL_CLICK": "10788",
                "UPGRADE_DETAIL_CLICK": "10790",
                "MEMBER_PAGE_LOGIN": "11007",
                "CLICK_CHANGE_MEMBER_COMMODITY": "11008",
                "CLICK_OPEN_MEMBER": "11009",
                "SHOW_DAILOG_OPEN_SUCCESS": "11010",
                "SHOW_DIALOG_PAY_FAIL": "11011",
                "CLICK_CONTRACT_TERM": "11015",
                "CLICK_SAVE_SIGNSTATUS": "11016",
                "CLICK_UNSAVE_SIGNSTATUS": "11017",
                "CLICK_UPLOAD_FADEBACK": "11018",
                "CLICK_GOWEB_SIGNSTATUS": "11019",
                "CLICK_GOWEB_OPENMEMBER": "11020",
                "MEMBER_OPEN_RENEWAL": "10783",
                "TEXT_RESULT_LIKE": "10719",
                "TEXT_RESULT_DISLIKE": "10722",
                "BACK_TOP": "10767",
                "NON_MEMBER_TEXT_IMAGE": 10791,
                "NON_MEMBER_POPUP_CLICK": 10792,
                "EXPRESS_LANE_ACCELERATE": 10793,
                "RENEWAL_CLICK_RENEW": 10795,
                "NON_MEMBER_QUEUE_IMAGE_POPUP": 10796,
                "NON_MEMBER_QUEUE_LIMITED_CLICK": 10797,
                "NON_MEMBER_TEMPLATE_INTRODUCTION": 10798,
                "MEMBER_IMAGE_SHORTAGE_POPUP": 10799,
                "MEMBER_LOW_TIER_SHORTAGE_UPGRADE": 10800,
                "DIAMOND_MEMBER_MAX_8_IMAGE_TOAST": 10801,
                "HOME_PAGE_SHOW": 10831,
                "DOWNLOAD_POSTER": 10739,
                "SHARE_POSTER": 10740,
                "TEMPLATE_NAV_CHANGE": 10750,
                "SHOW_STOP_GENERATE": 10820,
                "CLICK_STOP_GENERATE": 10821,
                "SHOW_HD_DOWNLOAD_ALERT": 10962,
                "HD_JUMP_MEMBER": 10963,
                "HD_DOWNLOAD_SUCCESS": 10964,
                "HD_DOWNLOAD_ALERT_CLOSE": 10965
            }
        },
        "8491": function(v, E, k) {
            "use strict";
            var R = k(2935)
              , U = k(5145)
              , H = {
                "getArtDetailBatch": function getArtDetailBatch() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return R.Z.get({
                        "url": "".concat(U.Jl, "/home/art/batch/query"),
                        "data": v,
                        "isRaw": !0
                    })
                },
                "getArtDetail": function getArtDetail() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return R.Z.get({
                        "url": "".concat(U.Jl, "/home/art/detail/query"),
                        "data": v,
                        "isRaw": !0
                    })
                },
                "likeArt": function likeArt() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return R.Z.post({
                        "url": "".concat(U.Jl, "/like/art"),
                        "data": v,
                        "isRaw": !0
                    })
                },
                "manageArt": function manageArt() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return R.Z.get({
                        "url": "".concat(U.Jl, "/home/art/manage"),
                        "data": v,
                        "isRaw": !0
                    })
                },
                "getLoadingTip": function getLoadingTip() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return R.Z.get({
                        "url": "".concat(U.Jl, "/member/pic/produce/loading"),
                        "data": v,
                        "isRaw": !0
                    })
                },
                "stopGenerate": function stopGenerate() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return R.Z.post({
                        "url": "".concat(U.Jl, "/home/art/ai/produce/stop"),
                        "data": v,
                        "isRaw": !0
                    })
                },
                "getHighResPicUrl": function getHighResPicUrl() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return R.Z.post({
                        "url": "".concat(U.Jl, "/member/download/art/pic"),
                        "data": v,
                        "isRaw": !0
                    })
                },
                "checkFirstDownloadHD": function checkFirstDownloadHD() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return R.Z.post({
                        "url": "".concat(U.Jl, "/member/download/art/pic/status"),
                        "data": v
                    })
                }
            };
            E.Z = H
        },
        "6728": function(v, E, k) {
            "use strict";
            var R = k(2935)
              , U = k(238)
              , H = k(5145)
              , G = k(3072)
              , W = k(2229)
              , Z = U.Z.CancelToken
              , Y = Z.source()
              , J = {
                "getSmartDetail": function getSmartDetail() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return R.Z.get({
                        "url": "".concat(H.Jl, "/home/art/ai/smart/paragraph/detail"),
                        "data": v,
                        "isRaw": !0
                    })
                },
                "getSmartDetailByUUid": function getSmartDetailByUUid() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return R.Z.get({
                        "url": "".concat(H.Jl, "/mpcard/info"),
                        "data": v,
                        "isRaw": !0
                    })
                },
                "getImgInfo": function getImgInfo() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return R.Z.get({
                        "url": "".concat(H.Jl, "/activity/card/create/edit/config"),
                        "data": v,
                        "isRaw": !0
                    })
                },
                "generateText": function generateText() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                      , E = (0,
                    G.xu)();
                    return W.Z.setItem("text_startTime", {
                        "time": (new Date).getTime(),
                        "requestId": E
                    }),
                    R.Z.post({
                        "url": "".concat(H.Jl, "/home/art/ai/text/produce/v2"),
                        "headers": {
                            "timeout": 26e3,
                            "requestId": E
                        },
                        "data": v,
                        "cancelToken": Y.token,
                        "isRaw": !0
                    })
                },
                "generateTrailText": function generateTrailText() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                      , E = (0,
                    G.xu)();
                    return W.Z.setItem("text_startTime", {
                        "time": (new Date).getTime(),
                        "requestId": E
                    }),
                    R.Z.post({
                        "url": "".concat(H.Jl, "/tourist/art/text/produce"),
                        "headers": {
                            "timeout": 26e3
                        },
                        "data": v,
                        "cancelToken": Y.token,
                        "isRaw": !0
                    })
                },
                "cancelGenerate": function cancelGenerate() {
                    Y.cancel("用户离开页面，取消请求"),
                    Y = Z.source()
                },
                "isCancel": function isCancel(v) {
                    return U.Z.isCancel(v)
                },
                "publishArt": function publishArt() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return R.Z.post({
                        "url": "".concat(H.Jl, "/home/art/publish/v2"),
                        "data": v,
                        "isRaw": !0
                    })
                },
                "getGuideInfo": function getGuideInfo() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return R.Z.get({
                        "url": "".concat(H.Jl, "/wap/art/ai/guide"),
                        "data": v,
                        "isRaw": !0
                    })
                },
                "getEditorText": function getEditorText() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return R.Z.get({
                        "url": "".concat(H.Jl, "/home/art/ai/user/paragraph"),
                        "data": v,
                        "isRaw": !0
                    })
                },
                "updateEditorText": function updateEditorText() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return R.Z.post({
                        "url": "".concat(H.Jl, "/home/art/ai/update/user/paragraph"),
                        "data": v,
                        "isRaw": !0
                    })
                },
                "genMaterialBg": function genMaterialBg() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return R.Z.post({
                        "url": "".concat(H.Jl, "/activity/card/pic/produce"),
                        "data": v,
                        "headers": {
                            "timeout": 26e3
                        },
                        "isRaw": !0
                    })
                },
                "getDefinitivePreview": function getDefinitivePreview() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return R.Z.post({
                        "url": "".concat(H.Jl, "/image/art/hd"),
                        "data": v,
                        "isRaw": !0
                    })
                }
            };
            E.Z = J
        },
        "5210": function(v, E, k) {
            "use strict";
            var R = k(5145)
              , U = k(2935)
              , H = {
                "getMemberDetail": function getMemberDetail() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return U.Z.get({
                        "url": "".concat(R.Jl, "/member/detail"),
                        "data": v,
                        "isRaw": !0
                    })
                },
                "getMemberCommodity": function getMemberCommodity() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return U.Z.get({
                        "url": "".concat(R.Jl, "/member/commodity/info?selectedPrice=1"),
                        "data": v,
                        "isRaw": !0
                    })
                },
                "getServiceQrcode": function getServiceQrcode() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return U.Z.get({
                        "url": "".concat(R.Jl, "/member/custom/service/qrcode"),
                        "data": v
                    })
                },
                "getMemberRule": function getMemberRule(v) {
                    return U.Z.get({
                        "url": v,
                        "data": {},
                        "customHeaders": {},
                        "isRaw": !0
                    })
                },
                "getAISign": function getAISign() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return U.Z.get({
                        "url": "".concat(R.Jl, "/member/access/sig"),
                        "data": v
                    })
                },
                "getOrderStatus": function getOrderStatus() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return U.Z.get({
                        "url": "".concat(R.Jl, "/member/order"),
                        "data": v
                    })
                },
                "getPayIntermediateUrl": function getPayIntermediateUrl() {
                    var v, E = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return U.Z.post({
                        "url": "".concat(R.Jl, "/member/open/redirect/page?userId=").concat(E.userId),
                        "data": E,
                        "headers": {
                            "payQRCodeVersion": E.payQRCodeVersion,
                            "openId": null !== (v = E.openId) && void 0 !== v ? v : ""
                        },
                        "isRaw": !0
                    })
                },
                "contractTerm": function contractTerm() {
                    return U.Z.post({
                        "url": "".concat(R.Jl, "/member/terminate/contract"),
                        "isRaw": !0
                    })
                },
                "getCurrentCommodityInfo": function getCurrentCommodityInfo() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return U.Z.get({
                        "url": "".concat(R.Jl, "/member/commodity/current"),
                        "data": v,
                        "isRaw": !0
                    })
                }
            };
            E.Z = H
        },
        "3": function(v, E, k) {
            "use strict";
            var R = k(1413)
              , U = k(2935)
              , H = k(5145)
              , G = k(5970)
              , W = k(836)
              , Z = k(5225)
              , Y = {
                "updateGenSamePoint": function updateGenSamePoint() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return U.Z.get({
                        "url": "".concat(H.Jl, "/home/art/ai/score/add"),
                        "data": v
                    })
                },
                "getPointFailTips": function getPointFailTips() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return U.Z.get({
                        "url": "".concat(H.Jl, "/wap/art/fail/tips"),
                        "data": v,
                        "isRaw": !0
                    })
                },
                "getUserPoint": function getUserPoint() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return U.Z.get({
                        "url": "".concat(H.Jl, "/personal/art/ai/score/query"),
                        "data": v,
                        "isRaw": !0
                    })
                },
                "getUserPointDetail": function getUserPointDetail() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return U.Z.get({
                        "url": "".concat(H.Jl, "/personal/art/ai/score/record/query"),
                        "data": v,
                        "isRaw": !0
                    })
                },
                "openMember": function openMember() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                      , E = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                      , k = (0,
                    R.Z)((0,
                    R.Z)({}, (0,
                    U.U)()), E);
                    return U.Z.post({
                        "url": "".concat(H.Jl, "/member/open"),
                        "data": v,
                        "isRaw": !0,
                        "headers": k
                    })
                },
                "miniProgramPayClick": function miniProgramPayClick(v, E) {
                    var k = this;
                    this.getOpenId((function(R) {
                        R ? k.doPaymentWithOpenId(v, R, E) : E && E(!1)
                    }
                    ))
                },
                "getOpenId": function getOpenId(v) {
                    (0,
                    Z.x4)({
                        "success": function success(E) {
                            E.code ? function login(E) {
                                var k = {
                                    "spma": G.n,
                                    "code": E
                                };
                                (0,
                                W.WY)({
                                    "url": "".concat(H.Sz, "/v3/uc/user/openId"),
                                    "data": k,
                                    "success": function success(E) {
                                        1 === E.data.code ? v && v(E.data.data) : v && v(null)
                                    },
                                    "fail": function fail(E) {
                                        console.log("openId request failed", E),
                                        v && v(null)
                                    }
                                })
                            }(E.code) : v && v(null)
                        },
                        "fail": function fail(E) {
                            console.log("Login request failed", E),
                            v && v(null)
                        }
                    })
                },
                "getWxOpenId": function getWxOpenId() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return U.Z.get({
                        "url": "//us.mp.sohu.com/auth/wx/offiaccount/openid",
                        "data": v,
                        "isRaw": !0
                    })
                },
                "doPaymentWithOpenId": function doPaymentWithOpenId(v, E, k) {
                    var R = {
                        "memberId": v.memberId,
                        "callBackAddress": "callBackAddress",
                        "payType": 2,
                        "buttonStatus": v.buttonStatus
                    };
                    this.openMember(R, {
                        "clientType": 2,
                        "openId": E,
                        "aiSig": v.aiSig
                    }).then((function(v) {
                        if (console.log("open memenber success", v),
                        1 !== v.code)
                            k && k(v.code);
                        else {
                            tt.requestOrder({
                                "data": v.data.data,
                                "byteAuthorization": v.data.byteAuthorization,
                                "success": function success(v) {
                                    var E = v.orderId;
                                    tt.getOrderPayment({
                                        "orderId": E,
                                        "success": function success() {
                                            k && k(!0)
                                        },
                                        "fail": function fail(v) {
                                            console.log("订单支付失败", v),
                                            k && k(!1)
                                        }
                                    })
                                },
                                "fail": function fail(v) {
                                    console.log("订单支付失败", v),
                                    k && k(!1)
                                }
                            })
                        }
                    }
                    )).catch((function() {
                        k && k(!1)
                    }
                    ))
                }
            };
            E.Z = Y
        },
        "2088": function(v, E, k) {
            "use strict";
            var R = k(2935)
              , U = k(5145)
              , H = k(2153)
              , G = k(2808)
              , W = k(238)
              , Z = k(3072)
              , Y = {
                "uploadImg": function uploadImg(v) {
                    var E = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
                        "isBWM": !0
                    }
                      , k = "?";
                    for (var R in E)
                        null !== E[R] && void 0 !== E[R] && (k += "".concat(R, "=").concat(E[R], "&"));
                    return k = k.slice(0, k.length - 1),
                    W.Z.post("".concat(U.Jl, "/image/art/upload/image").concat(k), v, {
                        "headers": {
                            "Content-Type": "multipart/form-data",
                            "authorization": (0,
                            H.qu)("access_token"),
                            "requestId": (0,
                            Z.xu)()
                        },
                        "withCredentials": !0,
                        "timeout": 15e3
                    })
                },
                "uploadPoster": function uploadPoster(v) {
                    var E = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
                        "isBWM": !0
                    };
                    return R.Z.post({
                        "url": "".concat(U.Jl, "/image/art/upload/image/1?isBWM=").concat(E.isBWM, "&picProcessType=").concat(E.picProcessType, "&isFaceDetect=").concat(E.isFaceDetect),
                        "data": v,
                        "headers": {
                            "timeout": 15e3
                        },
                        "customHeaders": {
                            "authorization": (0,
                            H.qu)("access_token")
                        },
                        "isRaw": !0
                    })
                },
                "uploadMiniImg": function uploadMiniImg(v) {
                    var E = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
                        "isBWM": !0
                    }
                      , k = "?";
                    for (var R in E)
                        null !== E[R] && void 0 !== E[R] && (k += "".concat(R, "=").concat(E[R], "&"));
                    return k = k.slice(0, k.length - 1),
                    new Promise((function(E) {
                        (0,
                        G.c)({
                            "url": "".concat(U.Jl, "/image/art/upload/image").concat(k),
                            "filePath": v,
                            "timeout": 15e3,
                            "header": {
                                "Authorization": (0,
                                H.qu)("access_token"),
                                "content-type": "multipart/form-data",
                                "openId": (0,
                                H.qu)("userId"),
                                "requestId": (0,
                                Z.xu)()
                            },
                            "name": "imgFile",
                            "success": function success(v) {
                                v.data && "string" == typeof v.data && (v.data = JSON.parse(v.data)),
                                E(v)
                            },
                            "fail": function fail(v) {
                                console.log(v),
                                E({
                                    "data": null,
                                    "code": -1
                                })
                            }
                        })
                    }
                    ))
                },
                "checkImageRule": function checkImageRule() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return R.Z.post({
                        "url": "".concat(U.Jl, "/home/art/check/image/sensitive"),
                        "data": v,
                        "isRaw": !0
                    })
                },
                "publishPrompt": function publishPrompt() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return R.Z.post({
                        "url": "".concat(U.Jl, "/home/art/publish"),
                        "data": v,
                        "isRaw": !0
                    })
                },
                "fetchPlatformList": function fetchPlatformList() {
                    return R.Z.get({
                        "url": "".concat(U.Jl, "/home/art/platform/query"),
                        "isRaw": !0
                    })
                },
                "fetchModelList": function fetchModelList() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return R.Z.get({
                        "url": "".concat(U.Jl, "/home/art/template/v2/list/query"),
                        "data": v,
                        "isRaw": !0
                    })
                },
                "fetchHomeCatalogList": function fetchHomeCatalogList() {
                    return R.Z.get({
                        "url": "".concat(U.Jl, "/home/art/catalog/list/query"),
                        "isRaw": !0
                    })
                },
                "generateImgs": function generateImgs() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                      , E = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    return R.Z.post({
                        "url": "".concat(U.Jl, "/home/art/ai/produce?picGroupId=").concat(E.requestId),
                        "data": v,
                        "headers": E,
                        "isRaw": !0
                    })
                },
                "generateTrailImgs": function generateTrailImgs() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                      , E = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    return R.Z.post({
                        "url": "".concat(U.Jl, "/tourist/art/produce?picGroupId=").concat(E.requestId),
                        "data": v,
                        "headers": E,
                        "isRaw": !0
                    })
                },
                "getHistoryList": function getHistoryList() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return R.Z.get({
                        "url": "".concat(U.Jl, "/personal/art/ai/produce/query"),
                        "data": v,
                        "isRaw": !0
                    })
                },
                "delImg": function delImg(v) {
                    return R.Z.get({
                        "url": "".concat(U.Jl, "/personal/art/ai/produce/query"),
                        "data": v,
                        "isRaw": !0
                    })
                },
                "getTodayCount": function getTodayCount() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return R.Z.get({
                        "url": "".concat(U.Jl, "/home/art/ai/produce/count"),
                        "data": v,
                        "isRaw": !0
                    })
                },
                "sensitiveText": function sensitiveText() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return R.Z.post({
                        "url": "".concat(U.Jl, "/home/art/check/sensitive"),
                        "data": v,
                        "isRaw": !0
                    })
                },
                "checkWeight": function checkWeight() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return R.Z.get({
                        "url": "".concat(U.Jl, "/home/art/template/query"),
                        "data": v,
                        "isRaw": !0
                    })
                },
                "getTemplateData": function getTemplateData() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return R.Z.get({
                        "url": "".concat(U.Jl, "/home/art/template/query"),
                        "data": v,
                        "isRaw": !0
                    })
                },
                "decodeImg": function decodeImg() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return R.Z.post({
                        "url": "".concat(U.Jl, "/image/art/decode/image"),
                        "data": v,
                        "isRaw": !0
                    })
                },
                "updateImgs": function updateImgs() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return R.Z.post({
                        "url": "".concat(U.Jl, "/home/art/ai/update"),
                        "data": v,
                        "isRaw": !0
                    })
                },
                "getGenerateMsg": function getGenerateMsg() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return R.Z.post({
                        "url": "".concat(U.Jl, "/home/art/ai/message"),
                        "data": v,
                        "isRaw": !0
                    })
                },
                "readGenerateMsg": function readGenerateMsg() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return R.Z.post({
                        "url": "".concat(U.Jl, "/home/art/ai/message/read/multi"),
                        "data": v,
                        "isRaw": !0
                    })
                },
                "getGenerateMsgMulti": function getGenerateMsgMulti() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return R.Z.post({
                        "url": "".concat(U.Jl, "/home/art/ai/message/multi"),
                        "data": v,
                        "isRaw": !0
                    })
                },
                "getTrailGenerateMsgMulti": function getTrailGenerateMsgMulti() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return R.Z.post({
                        "url": "".concat(U.Jl, "/tourist/art/message/multi"),
                        "data": v,
                        "isRaw": !0
                    })
                }
            };
            E.Z = Y
        },
        "5980": function(v, E, k) {
            "use strict";
            var R = k(2935)
              , U = k(5145)
              , H = {
                "wx": "100022",
                "bd": "100020",
                "tt": "100020"
            }
              , G = {
                "getUserInfo": function getUserInfo(v) {
                    var E = {
                        "appId": H["".concat(v)],
                        "device": "MPTCFEMOBILEUSER"
                    };
                    return R.Z.get({
                        "url": U.Sz + "/v3/uc/user/info",
                        "data": E
                    })
                },
                "judgeNewUser": function judgeNewUser() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return R.Z.get({
                        "url": "".concat(U.Jl, "/home/art/ai/new/user/judge"),
                        "data": v,
                        "isRaw": !0
                    })
                },
                "getUserOpenId": function getUserOpenId() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return R.Z.get({
                        "url": "".concat(U.Sz, "/v3/uc/user/openId"),
                        "data": v
                    })
                },
                "getTrailCount": function getTrailCount() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return R.Z.get({
                        "url": "".concat(U.Jl, "/tourist/art/count"),
                        "data": v,
                        "isRaw": !0
                    })
                },
                "mergeTrailArt": function mergeTrailArt() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                    return R.Z.post({
                        "url": "".concat(U.Jl, "/tourist/art/save"),
                        "data": v,
                        "isRaw": !0
                    })
                }
            };
            E.Z = G
        },
        "9168": function(v, E, k) {
            "use strict";
            var R = k(5671)
              , U = k(3144)
              , H = k(836)
              , G = k(3072)
              , W = {
                "development": "https://test-www.sohu.com/cisapi/cis/feeds",
                "test": "https://test-www.sohu.com/cisapi/cis/feeds",
                "pre": "https://pre-www.sohu.com/cis/feeds",
                "production": "https://cis.sohu.com/cis/feeds"
            }
              , Z = function() {
                return (0,
                U.Z)((function CisService() {
                    (0,
                    R.Z)(this, CisService),
                    this.cis = W.pre,
                    this.pvId = G.Wf()
                }
                ), [{
                    "key": "getCISFeedData",
                    "value": function getCISFeedData(v) {
                        var E = v.spm
                          , k = v.page
                          , R = v.size
                          , U = G.Wf()
                          , W = [{
                            "spm": E,
                            "page": k,
                            "size": R
                        }]
                          , Z = "?clientType=2&pvId=".concat(this.pvId, "&requestId=").concat(U, "&sceneParam=").concat(JSON.stringify(W))
                          , Y = this.cis + Z;
                        return new Promise((function(v) {
                            (0,
                            H.WY)({
                                "url": Y,
                                "method": "GET",
                                "success": function success(k) {
                                    try {
                                        if (200 == k.statusCode && k.data["".concat(E)] && k.data["".concat(E)].data) {
                                            var R = k.data["".concat(E)].data[0].resourceData.data;
                                            v(R)
                                        } else
                                            v(!1)
                                    } catch (E) {
                                        console.log("cis error", E),
                                        v(!1)
                                    }
                                },
                                "fail": function fail(E) {
                                    console.log("cis error", E),
                                    v(!1)
                                }
                            })
                        }
                        ))
                    }
                }])
            }();
            E.Z = new Z
        },
        "1894": function(v, E, k) {
            "use strict";
            k.d(E, {
                "CE": function() {
                    return U
                },
                "De": function() {
                    return Y
                },
                "NU": function() {
                    return J
                },
                "Ok": function() {
                    return ce
                },
                "SH": function() {
                    return K
                },
                "Tj": function() {
                    return H
                },
                "Ww": function() {
                    return se
                },
                "ZF": function() {
                    return ae
                },
                "eA": function() {
                    return Z
                },
                "hr": function() {
                    return oe
                },
                "iV": function() {
                    return G
                },
                "mO": function() {
                    return X
                },
                "tL": function() {
                    return te
                },
                "wF": function() {
                    return ie
                },
                "wi": function() {
                    return le
                },
                "wn": function() {
                    return ee
                },
                "wp": function() {
                    return Q
                },
                "yg": function() {
                    return W
                },
                "z2": function() {
                    return ne
                },
                "zO": function() {
                    return re
                }
            });
            var R = k(5970)
              , U = [{
                "rate": 1,
                "size": "1:1"
            }, {
                "rate": .5,
                "size": "1:2"
            }, {
                "rate": 680 / 512,
                "size": "4:3"
            }, {
                "rate": 4 / 3,
                "size": "4:3"
            }, {
                "rate": 512 / 920,
                "size": "9:16"
            }, {
                "rate": 9 / 16,
                "size": "9:16"
            }, {
                "rate": 16 / 9,
                "size": "16:9"
            }, {
                "rate": 920 / 512,
                "size": "16:9"
            }]
              , H = {
                "TEXT": "byText",
                "IMG": "byImg",
                "Commodity": "byCommodity",
                "Portrait": "byPortrait",
                "HDZoom": "byHdZoom",
                "onlyPc": "onlyPc",
                "personBg": "byPersonBg"
            }
              , G = {
                "0": "0",
                "10": "10"
            }
              , W = {
                "minWeight": 0,
                "maxWeight": 10
            }
              , Z = [{
                "id": "byText",
                "label": "文字生成图片",
                "newPath": "textToImg",
                "spmType": 2,
                "backEndType": 0
            }, {
                "id": "byImg",
                "label": "图片生成图片",
                "newPath": "imgToImg",
                "spmType": 1,
                "backEndType": 1
            }, {
                "id": "byCommodity",
                "label": "AI商品图",
                "newPath": "byProImg",
                "spmType": 3,
                "backEndType": 2
            }, {
                "id": "byPortrait",
                "label": "AI证件照",
                "newPath": "byCardImg",
                "spmType": 4,
                "backEndType": 2
            }, {
                "id": "byHdZoom",
                "label": "AI高清放大",
                "newPath": "byClearImg",
                "spmType": 8,
                "backEndType": 5
            }, {
                "id": "byPersonBg",
                "label": "AI人像换背景",
                "newPath": "byPersonBgImg",
                "spmType": 9,
                "backEndType": 2
            }]
              , Y = [{
                "type": 0,
                "label": "原图",
                "imgSrc": "https://g1.itc.cn/lapp-wapai-prod/20240410/common/image/wap/definition_origin.png"
            }, {
                "type": 1,
                "label": "高清",
                "imgSrc": "https://g1.itc.cn/lapp-wapai-prod/20240410/common/image/wap/definition_hd.png"
            }, {
                "type": 2,
                "label": "超清",
                "imgSrc": "https://g1.itc.cn/lapp-wapai-prod/20240410/common/image/wap/definition_2k.png"
            }, {
                "type": 3,
                "label": "超高清",
                "imgSrc": "https://g1.itc.cn/lapp-wapai-prod/20240410/common/image/wap/definition_4k.png"
            }]
              , J = {
                "index": 1,
                "like": 2,
                "history": 3,
                "my": 4,
                "detail-feed": 6
            }
              , K = {
                "FEED": 1,
                "DETAIL": 2,
                "BACK_RETURN": 3
            }
              , X = {
                "LIKE": 1,
                "GENERATE": 2,
                "MY": 3,
                "UPLOAD_IMG": 4
            }
              , Q = {
                "GO_BACK": {
                    "icon": "https://g1.itc.cn/lapp-wapai-prod/20240410/common/image/wap/footer-icon-next.png",
                    "text": "返回"
                },
                "GO_HOME": {
                    "icon": "https://g1.itc.cn/lapp-wapai-prod/20240410/common/image/wap/footer-icon-go-home.png",
                    "text": "去首页",
                    "path": "/home"
                },
                "GO_TEXT_HOME": {
                    "icon": "https://g1.itc.cn/lapp-wapai-prod/20240410/common/image/wap/footer-icon-text-home.png",
                    "text": "AI助手",
                    "path": "/textHome"
                }
            }
              , ee = {
                "HOME": 1,
                "DETAIL": 2,
                "MYSPACE": 3
            }
              , te = {
                "SUCCESS": 1,
                "PIC_HAS_SUCCESS": 140100,
                "PIC_HAS_FAILED": 140101,
                "SCORE_RETURN_FAILED": 140102,
                "PIC_TASK_HAS_FINISH": 140104
            }
              , ne = {
                "SUCCESS": {
                    "code": 1,
                    "title": "生图成功",
                    "label": "图片生成成功啦！快来查看吧",
                    "icon": "https://g1.itc.cn/lapp-wapai-prod/20240410/common/image/icon-success.png",
                    "jumpName": "去查看",
                    "spmA": R.o.GENERATE_MSG_SUCCESS
                },
                "STOPPED": {
                    "code": 140103,
                    "title": "停止生图",
                    "label": "停止生图成功了",
                    "icon": "https://g1.itc.cn/lapp-wapai-prod/20240410/common/image/icon-success.png",
                    "jumpName": "去查看",
                    "spmA": R.o.GENERATE_MSG_SUCCESS
                },
                "ERROR": {
                    "code": 140004,
                    "title": "生图失败",
                    "label": "图片生成失败了，积分已退还",
                    "icon": "https://g1.itc.cn/lapp-wapai-prod/20240410/common/image/icon-error.png",
                    "jumpName": "重新试试",
                    "spmA": R.o.GENERATE_MSG_ERROR
                },
                "TIMEOUT": {
                    "code": 140009,
                    "title": "生图失败",
                    "label": "图片生成失败了，平台补偿6积分",
                    "icon": "https://g1.itc.cn/lapp-wapai-prod/20240410/common/image/icon-error.png",
                    "jumpName": "重新试试",
                    "spmA": R.o.GENERATE_MSG_TIMEOUT
                }
            }
              , re = ["文本有害、不安全", "文本不符合输入的要求", "文本包含事实性错误", "文本逻辑错误、语句不通顺"]
              , oe = function textGenerateShareText(v) {
                var E = ["简单AI的AI助手【".concat(v, "】贼好用！快来试试吧："), "超级实用的AI助手【".concat(v, "】，快来体验一下："), "不可错过的AI神器【".concat(v, "】，快来试试吧！"), "业界领先的AI助手，专注于【".concat(v, "】，即刻体验："), "简单AI的AI助手【".concat(v, "】，功能如此好用，快来感受一下吧！"), "简单AI的AI助手【".concat(v, "】，功能领跑业界，赶紧来试试：")];
                return E[Math.floor(Math.random() * E.length)]
            }
              , ie = {
                "MASTER_NOT_PUBLIC": {
                    "_delete": 2,
                    "_copy": 2,
                    "_edit": 2,
                    "_public": 2,
                    "_share": 0,
                    "_like": 0
                },
                "MASTER_PUBLIC": {
                    "_delete": 2,
                    "_copy": 2,
                    "_edit": 2,
                    "_public": 0,
                    "_share": 2,
                    "_like": 2
                },
                "MASTER_AUDITING": {
                    "_delete": 1,
                    "_copy": 2,
                    "_edit": 2,
                    "_public": 1,
                    "_share": 0,
                    "_like": 0
                },
                "MASTER_UN_AUDITED": {
                    "_delete": 2,
                    "_copy": 2,
                    "_edit": 2,
                    "_public": 1,
                    "_share": 0,
                    "_like": 0
                },
                "GUEST": {
                    "_delete": 0,
                    "_copy": 2,
                    "_edit": 0,
                    "_public": 0,
                    "_share": 2,
                    "_like": 2
                }
            }
              , ae = {
                "WX_OFFICIAL_ACCOUNT": {
                    "appId": "wxb178dbc77a5f218f"
                }
            }
              , se = {
                "3": "AI消除工具",
                "4": "AI抠图工具",
                "5": "高清放大",
                "6": "AI智能扩图"
            }
              , ce = {
                "3": "1",
                "4": "2",
                "5": "4",
                "6": "3"
            }
              , le = {
                "3": "https://g1.itc.cn/lapp-wapai-prod/20240410/common/image/common/guidePic.png",
                "4": "https://g1.itc.cn/lapp-wapai-prod/20240410/common/image/common/guidePic.png",
                "5": "https://g1.itc.cn/lapp-wapai-prod/20240410/common/image/common/guidePicEx.png",
                "6": "https://g1.itc.cn/lapp-wapai-prod/20240410/common/image/common/guidePicEx.png"
            }
        },
        "2050": function(v, E, k) {
            "use strict";
            k.d(E, {
                "Nc": function() {
                    return cutFeedImg
                },
                "c9": function() {
                    return cutPicUrl
                },
                "tT": function() {
                    return cutAvatarUrl
                },
                "y1": function() {
                    return scaleImg
                }
            });
            var R = k(5145)
              , U = ["p0.itc.cn", "p1.itc.cn", "p2.itc.cn", "p3.itc.cn", "p4.itc.cn", "p5.itc.cn", "p6.itc.cn", "p7.itc.cn", "p8.itc.cn", "p9.itc.cn", "q0.itc.cn", "q1.itc.cn", "q2.itc.cn", "q3.itc.cn", "q4.itc.cn", "q5.itc.cn", "q6.itc.cn", "q7.itc.cn", "q8.itc.cn", "q9.itc.cn"]
              , H = ["5b0988e595225.cdn.sohucs.com", "29e5534ea20a8.cdn.sohucs.com", "img.mp.itc.cn", "img.mp.sohu.com", "mptc-static.itc.cn"]
              , G = ["mobileproduct.cdn.sohu.com", "mobileproducts.cdn.sohu.com"]
              , W = U.concat(H).concat(G);
            function cutPicUrl(v, E, k) {
                if (!v || "string" != typeof v)
                    return "";
                var R = E || 598
                  , U = k || 336;
                return processImgUrl(v, "".concat(arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "q_70,c_lfill", ",w_").concat(R, ",h_").concat(U, ",g_face"), R, U)
            }
            function cutFeedImg(v, E) {
                if (!v || "string" != typeof v)
                    return "";
                var k = E || 598;
                return processImgUrl(v, "".concat(arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "q_70,c_zoom", ",w_").concat(k), k)
            }
            function processImgUrl(v, E, k, W) {
                var Z = v
                  , Y = (Z.split("/") || [])[2];
                if (!Y)
                    return "";
                if (U.includes(Y)) {
                    var J = new RegExp("".concat(Y, "(.*?)/images"));
                    Z = Z.replace(J, "".concat(Y, "/").concat(E, "/images"))
                }
                if (H.includes(Y) && !E.includes("c_zoom")) {
                    if (/\/q_\d*\//.test(Z))
                        return Z;
                    Z = -1 === Z.indexOf("w_") ? Z.replace(Y, "".concat(Y, "/").concat(E)) : -1 === Z.indexOf("c_cut") ? Z.replace(/(w_[0-9]*,h_[0-9]*)|(w_[0-9]*|h_[0-9]*)/, "w_" + k + ",h_" + W) : Z.replace(/c_cut,x_[0-9]*,y_[0-9]*,((w_[0-9]*,h_[0-9]*)|(w_[0-9]*|h_[0-9]*))/, E)
                }
                if (G.includes(Y)) {
                    var K = new RegExp("".concat(Y, "(.*?)/img"));
                    Z = Z.replace(K, "".concat(Y, "/").concat(E, "/").concat(R.qd, "/img"))
                }
                return URLPrefix(Z.replace(/^http:/, ""))
            }
            function URLPrefix(v) {
                if (!v)
                    return "";
                var E = /^\/\//.test(v) ? "https:" : "";
                return "".concat(E).concat(v)
            }
            function cutAvatarUrl() {
                return function cutPicUrlNewest(v, E, k) {
                    if (!v || "string" != typeof v)
                        return "";
                    var R = v
                      , Z = E || 226
                      , Y = k || 150
                      , J = "".concat(arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "q_70,c_lfill", ",w_").concat(Z, ",h_").concat(Y, ",g_face")
                      , K = (R.split("/") || [])[2];
                    if (!W.includes(K))
                        return URLPrefix(R.replace(/^http:/, ""));
                    if (U.includes(K)) {
                        var X = new RegExp("".concat(K, "(.*?)/images"));
                        R = R.replace(X, "".concat(K, "/").concat(J, "/images"))
                    }
                    if (H.includes(K)) {
                        var Q = R.split("//")[1] && R.split("//")[1].split("/")[1];
                        R = /\/q_\d*\//.test(Q) ? R.replace(Q, J) : -1 === R.indexOf("w_") ? R.replace(K, "".concat(K, "/").concat(J)) : -1 === R.indexOf("c_cut") ? R.replace(/(w_[0-9]*,h_[0-9]*)|(w_[0-9]*|h_[0-9]*)/, "w_" + Z + ",h_" + Y) : R.replace(/c_cut,x_[0-9]*,y_[0-9]*,((w_[0-9]*,h_[0-9]*)|(w_[0-9]*|h_[0-9]*))/, J)
                    }
                    if (G.includes(K) && (function testUrl(v) {
                        return !!v && v.split("//")[1] && ("test" === v.split("//")[1].split("/")[1] || "prod" === v.split("//")[1].split("/")[1])
                    }(R) && (R = R.replace(K, K + "/" + J)),
                    function _testUrl(v) {
                        return !!v && v.split("//")[1] && ("test" === v.split("//")[1].split("/")[2] || "prod" === v.split("//")[1].split("/")[2])
                    }(R))) {
                        var ee = R.split("//")[1] && R.split("//")[1].split("/")[1];
                        R = R.replace(ee, J)
                    }
                    return URLPrefix(R.replace(/^http:/, ""))
                }(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "", arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 64, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 64, arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "q_70,c_lfill")
            }
            function scaleImg(v, E) {
                var k = E
                  , R = v.type
                  , U = v.name
                  , H = new FileReader;
                return H.readAsDataURL(v),
                new Promise((function(E) {
                    H.onload = function(H) {
                        var G = new Image;
                        G.src = H.target.result,
                        G.onload = function() {
                            var H = G.width
                              , W = G.height;
                            Math.max(H, W) <= k && E({
                                "scaledFile": v,
                                "isScaled": !1
                            });
                            var Z = 0
                              , Y = 0;
                            H > W ? (Z = k,
                            Y = Math.round(W * k / H)) : (Y = k,
                            Z = Math.round(H * k / W));
                            var J = document.createElement("canvas");
                            J.width = Z,
                            J.height = Y,
                            J.getContext("2d").drawImage(G, 0, 0, Z, Y),
                            J.toBlob((function(v) {
                                var k = new File([v],U,{
                                    "type": R
                                });
                                E({
                                    "scaledFile": k,
                                    "isScaled": !0
                                })
                            }
                            ), R)
                        }
                    }
                }
                ))
            }
        },
        "5145": function(v, E, k) {
            "use strict";
            k.d(E, {
                "G": function() {
                    return J
                },
                "Jl": function() {
                    return H
                },
                "NU": function() {
                    return Y
                },
                "Ry": function() {
                    return K
                },
                "Sz": function() {
                    return U
                },
                "bm": function() {
                    return G
                },
                "e0": function() {
                    return W
                },
                "qd": function() {
                    return Z
                }
            });
            var R = "pre"
              , U = "" + {
                "development": "//test-uis.mp.sohu.com",
                "test": "//test-uis.mp.sohu.com",
                "pre": "//pre-uis.mp.sohu.com",
                "production": "//uis.mp.sohu.com"
            }[R]
              , H = "" + {
                "development": "//test-uis.mp.sohu.com/prompt",
                "test": "//test-uis.mp.sohu.com/prompt",
                "pre": "//pre-uis.mp.sohu.com/prompt",
                "production": "//uis.mp.sohu.com/prompt"
            }[R]
              , G = {
                "development": "//test-app.sohu.com",
                "test": "//test-app.sohu.com",
                "pre": "//pre-app.sohu.com",
                "production": "//ai.sohu.com"
            }[R]
              , W = {
                "development": "//d2.m.sohu.com/wap/search",
                "test": "//d2.m.sohu.com/wap/search",
                "pre": "//t2.m.sohu.com/wap/search",
                "production": "//ai.sohu.com/wap/search"
            }[R]
              , Z = {
                "development": "test",
                "test": "test",
                "pre": "prod",
                "production": "prod"
            }[R]
              , Y = {
                "development": {
                    "host": "//test-m.sohu.com",
                    "path": "/wap-article-api/article-author/",
                    "rule": "207052111_130000278",
                    "agreement": "207052117_130000278",
                    "service": "207061303_130000278",
                    "privacy": "207157603_130000278"
                },
                "test": {
                    "host": "//test-m.sohu.com",
                    "path": "/wap-article-api/article-author/",
                    "rule": "207052111_130000278",
                    "agreement": "207052117_130000278",
                    "service": "207061303_130000278",
                    "privacy": "207157603_130000278"
                },
                "pre": {
                    "host": "//v2.sohu.com",
                    "path": "/wap-article-api/article-author/",
                    "rule": "833537091_121798712",
                    "agreement": "833530723_121798712",
                    "service": "783645693_121798712",
                    "privacy": "783630167_121798712"
                },
                "production": {
                    "host": "//v2.sohu.com",
                    "path": "/wap-article-api/article-author/",
                    "rule": "833537091_121798712",
                    "agreement": "833530723_121798712",
                    "service": "783645693_121798712",
                    "privacy": "783630167_121798712"
                }
            }[R]
              , J = {
                "development": "https://test-m.sohu.com",
                "test": "https://test-m.sohu.com",
                "pre": "https://pre-m.sohu.com",
                "production": "https://odin.sohu.com"
            }[R]
              , K = {
                "development": {
                    "bannerMenuId": "772",
                    "creativityFeedId": "2020",
                    "creativityAuditFeedId": "2046",
                    "creativityChooseDrawTextId": "767",
                    "creativityChooseDrawImgId": "768",
                    "creativityCreativeToolsId": "769",
                    "creativityVisualStylesId": "2018",
                    "homeFeedId": "2044",
                    "homeFeedWithWord": "2040",
                    "homeFeedIdWithTop": "2023",
                    "homeFeedWithWordTop": "2036",
                    "homeBannerId": "2019",
                    "homeMenuId": "764",
                    "myLikeFeedId": "2033",
                    "writingFeedId": "2028",
                    "writingFeedNOTopId": "2028",
                    "writingBannerId": "773",
                    "writingMenuId": "765",
                    "recentViewId": "2034"
                },
                "test": {
                    "bannerMenuId": "772",
                    "creativityFeedId": "2020",
                    "creativityAuditFeedId": "2046",
                    "creativityChooseDrawTextId": "767",
                    "creativityChooseDrawImgId": "768",
                    "creativityCreativeToolsId": "769",
                    "creativityVisualStylesId": "2018",
                    "homeFeedId": "2044",
                    "homeFeedWithWord": "2040",
                    "homeFeedIdWithTop": "2023",
                    "homeFeedWithWordTop": "2036",
                    "homeBannerId": "2019",
                    "homeMenuId": "764",
                    "myLikeFeedId": "2033",
                    "writingFeedId": "2028",
                    "writingFeedNOTopId": "2028",
                    "writingBannerId": "773",
                    "writingMenuId": "765",
                    "recentViewId": "2034"
                },
                "pre": {
                    "bannerMenuId": "2661",
                    "creativityFeedId": "7953",
                    "creativityAuditFeedId": "7960",
                    "creativityChooseDrawTextId": "2658",
                    "creativityChooseDrawImgId": "2659",
                    "creativityCreativeToolsId": "2660",
                    "creativityVisualStylesId": "7951",
                    "homeFeedId": "7946",
                    "homeFeedWithWord": "7942",
                    "homeFeedIdWithTop": "7944",
                    "homeFeedWithWordTop": "7938",
                    "homeBannerId": "7949",
                    "homeMenuId": "2655",
                    "myLikeFeedId": "7952",
                    "writingFeedId": "7950",
                    "writingFeedNOTopId": "7956",
                    "writingBannerId": "2653",
                    "writingMenuId": "2656",
                    "recentViewId": "7948"
                },
                "production": {
                    "bannerMenuId": "2661",
                    "creativityFeedId": "7953",
                    "creativityAuditFeedId": "7960",
                    "creativityChooseDrawTextId": "2658",
                    "creativityChooseDrawImgId": "2659",
                    "creativityCreativeToolsId": "2660",
                    "creativityVisualStylesId": "7951",
                    "homeFeedId": "7946",
                    "homeFeedWithWord": "7942",
                    "homeFeedIdWithTop": "7944",
                    "homeFeedWithWordTop": "7938",
                    "homeBannerId": "7949",
                    "homeMenuId": "2655",
                    "myLikeFeedId": "7952",
                    "writingFeedId": "7950",
                    "writingFeedNOTopId": "7956",
                    "writingBannerId": "2653",
                    "writingMenuId": "2656",
                    "recentViewId": "7948"
                }
            }[R]
        },
        "3570": function(v, E, k) {
            "use strict";
            k.d(E, {
                "Y": function() {
                    return R
                }
            });
            var R = function mitt(v) {
                return {
                    "all": v = v || new Map,
                    "on": function(E, k) {
                        var R = v.get(E);
                        R ? R.push(k) : v.set(E, [k])
                    },
                    "off": function(E, k) {
                        var R = v.get(E);
                        R && (k ? R.splice(R.indexOf(k) >>> 0, 1) : v.set(E, []))
                    },
                    "emit": function(E, k) {
                        var R = v.get(E);
                        R && R.slice().map((function(v) {
                            v(k)
                        }
                        )),
                        (R = v.get("*")) && R.slice().map((function(v) {
                            v(E, k)
                        }
                        ))
                    }
                }
            }()
        },
        "2229": function(v, E, k) {
            "use strict";
            var R = k(2153);
            E.Z = {
                "setItem": function setItem(v, E) {
                    return this.removeItem(v),
                    (0,
                    R.Fj)(v, E),
                    E
                },
                "getItem": function getItem(v) {
                    return (0,
                    R.qu)(v)
                },
                "removeItem": function removeItem(v) {
                    (0,
                    R.hq)(v)
                }
            }
        },
        "8360": function(v, E, k) {
            "use strict";
            var R = k(1413)
              , U = k(6711)
              , H = k.n(U)
              , G = k(230)
              , W = k(5547)
              , Z = k(3072)
              , Y = k(2229)
              , J = k(1490)
              , K = k(354)
              , X = k(836)
              , Q = k(2056)
              , ee = k(5145)
              , te = {
                "development": "test",
                "test": "test",
                "production": "prod"
            }[G.OB] || "prod"
              , ne = new (H())({
                "passportConfig": {
                    "appid": "100023"
                },
                "env": te
            });
            E.Z = {
                "passport": ne.passport,
                "checkLoginState": function checkLoginState(v) {
                    var E = Y.Z.getItem(G.a9.accessTokenName);
                    if (!(E && E.length > 0))
                        return ne.checkLogin((0,
                        R.Z)((0,
                        R.Z)({
                            "env": te
                        }, v), {}, {
                            "successFun": function successFun(E) {
                                E && 1 === E.code ? (W.Z.commit("base/updateUserInfo", (0,
                                R.Z)({
                                    "username": E.data.nickname
                                }, E.data)),
                                Y.Z.setItem("userInfo", E.data),
                                W.Z.commit("base/updateLoginStatus", !0),
                                "function" == typeof v.successFun && v.successFun((0,
                                R.Z)({
                                    "username": E.data.nickname
                                }, E.data))) : "function" == typeof v.failureFun && v.failureFun(E.msg)
                            },
                            "failureFun": function failureFun(E) {
                                console.log(E),
                                W.Z.commit("base/updateLoginStatus", !1),
                                W.Z.commit("base/updateUserInfo", {}),
                                Y.Z.removeItem("userInfo"),
                                ne.logout(),
                                "function" == typeof v.failureFun && v.failureFun(E)
                            }
                        }));
                    (0,
                    X.WY)({
                        "url": ee.Sz + "/v3/uc/user/info",
                        "header": {
                            "Authorization": E
                        },
                        "data": {
                            "appId": "100016",
                            "device": Q.O.SUV
                        },
                        "withCredentials": !0,
                        "success": function success(E) {
                            if (200 == E.statusCode) {
                                var k = E.data.data;
                                W.Z.commit("base/updateUserInfo", (0,
                                R.Z)({
                                    "username": k.nickname
                                }, k)),
                                Y.Z.setItem("userInfo", k),
                                W.Z.commit("base/updateLoginStatus", !0),
                                "function" == typeof v.successFun && v.successFun((0,
                                R.Z)({
                                    "username": k.nickname
                                }, E.data))
                            } else
                                "function" == typeof v.failureFun && v.failureFun(E.msg)
                        }
                    })
                },
                "logout": ne.logout,
                "loginClickHandler": function goLogin() {
                    var v, E = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).spm, k = window.location.href;
                    !function getFromLoginPath() {
                        var v = window.location
                          , E = window.location.pathname
                          , k = W.Z.state.base.isNotHasLastPage;
                        if (v.search.includes("detailId")) {
                            E += "?detailId=" + (0,
                            Z.SN)(window.location.href).detailId + "&notHasLastPage=" + k
                        } else
                            E += "?notHasLastPage=" + k;
                        console.log("fromLoginPath", E),
                        sessionStorage.setItem("fromLoginPath", E)
                    }();
                    var R = (null === (v = J.dK.currentTracker) || void 0 === v ? void 0 : v.getTrackerData()) || ""
                      , U = R.spmA
                      , H = R.spmB
                      , X = R.spmE;
                    E = E || "".concat(U || K.Z.spmA, ".").concat(H || "home", ".0.0.").concat(X),
                    Y.Z.setItem("fromLoginPath", k),
                    window.location.href = "".concat(function LoginUrl() {
                        return ["dev", "debug", "test", "development"].includes(G.OB) ? "https://test-m.sohu.com/login" : "https://m.sohu.com/login"
                    }(), "?spm=").concat(E || "", "&r=").concat(encodeURIComponent(k))
                }
            }
        },
        "2935": function(v, E, k) {
            "use strict";
            k.d(E, {
                "Z": function() {
                    return K
                },
                "U": function() {
                    return getCommonHeader
                }
            });
            var R = k(1413)
              , U = k(2153)
              , H = k(836)
              , G = k(3072);
            function getSuv() {
                var v = function getCookie(v) {
                    var E = new RegExp("".concat(v, "=([^;]*)\\b")).exec(document.cookie);
                    return null != E && E.length ? decodeURIComponent(E[1]) : null
                }("SUV");
                return v || Date.now()
            }
            var W = k(2571)
              , Z = k(230)
              , Y = !0
              , J = {
                "weapp": 1,
                "swan": 2,
                "tt": 3
            };
            function getCommonHeader(v) {
                var E = {
                    "clientType": Y ? 1 : 2,
                    "requestId": (null == v ? void 0 : v.requestId) || (0,
                    G.xu)()
                };
                if (Y) {
                    var k = (0,
                    G.uM)();
                    E = (0,
                    R.Z)((0,
                    R.Z)({}, E), {}, {
                        "suv": getSuv(),
                        "pvId": (0,
                        G.Wf)(),
                        "referSpm": k.spm,
                        "referScm": (0,
                        G.OD)(document.referrer).scm,
                        "referPath": document.referrer,
                        "refererSpm": (0,
                        W.b3)(),
                        "refererScm": k.scm,
                        "refererPath": window.location.pathname,
                        "trans": k.trans
                    })
                } else
                    E = (0,
                    R.Z)((0,
                    R.Z)({}, E), {}, {
                        "appletType": J.h5,
                        "scene": 1129,
                        "openId": (0,
                        U.qu)("userId")
                    });
                for (var H in E)
                    null == E[H] && delete E[H];
                return E
            }
            function httpServer(v, E) {
                var k = E.url
                  , G = E.data
                  , W = E.headers
                  , Y = E.isRaw
                  , J = E.token
                  , K = E.customHeaders
                  , X = getCommonHeader(W)
                  , Q = (0,
                U.qu)(Z.a9.accessTokenName)
                  , ee = null
                  , te = {
                    "method": v,
                    "url": k,
                    "timeout": (null == W ? void 0 : W.timeout) || 1e4,
                    "dataType": "json",
                    "mode": "cors",
                    "data": G,
                    "credentials": "include",
                    "header": Object.assign({}, {
                        "Content-Type": "application/json; charset=UTF-8",
                        "Authorization": J || Q
                    }, X, W)
                }
                  , ne = (ee = new AbortController).signal;
                te.signal = ne,
                K && (te.header = K);
                var re = null
                  , oe = new Promise((function(v, E) {
                    (re = (0,
                    H.WY)((0,
                    R.Z)((0,
                    R.Z)({}, te), {}, {
                        "success": function success(E) {
                            var k, R;
                            Y ? v(E.data) : 200 === E.statusCode && 1 === (null === (k = E.data) || void 0 === k ? void 0 : k.code) ? v(null === (R = E.data) || void 0 === R ? void 0 : R.data) : v(!1)
                        },
                        "fail": function fail(v) {
                            E(!!Y && v)
                        }
                    }))).abort = function() {
                        return ee.abort()
                    }
                }
                ));
                return oe.requestTask = re,
                oe
            }
            var K = ["get", "post", "put"].reduce((function(v, E) {
                return v[E] = httpServer.bind(null, E),
                v
            }
            ), {})
        },
        "354": function(v, E, k) {
            "use strict";
            var R = k(9380)
              , U = {
                "appId": "",
                "appName": "简单ai",
                "spmA": "smwp-ai",
                "appVersion": "3.1.2",
                "api": k(2268),
                "spmb": R.K4,
                "spmc": R.ff,
                "acode": R.Eq,
                "requestOptions": {
                    "keepalive": !0
                }
            };
            E.Z = U
        },
        "9380": function(v, E, k) {
            "use strict";
            k.d(E, {
                "Eq": function() {
                    return Z
                },
                "K4": function() {
                    return G
                },
                "ff": function() {
                    return W
                },
                "vX": function() {
                    return Y
                }
            });
            var R = k(1217)
              , U = k(5970)
              , H = k(1490)
              , G = R.Z.spmCode.spmb
              , W = R.Z.spmCode.spmc
              , Z = U.o
              , Y = function reportWindowSA(v) {
                var E = v.acode
                  , k = v.clkParam;
                if (E)
                    if (k) {
                        var R = {};
                        k.split(/[,;]/).map((function(v) {
                            var E = v.indexOf(":")
                              , k = v.slice(0, E)
                              , U = v.slice(E + 1);
                            R[k] = "promptCh" == k ? decodeURIComponent(U) : U
                        }
                        )),
                        H.dK.trackAction(E, R)
                    } else
                        H.dK.trackAction(E)
            }
        },
        "1217": function(v, E, k) {
            "use strict";
            var R = k(230)
              , U = k(5970)
              , H = R.uN.appId
              , G = R.uN.appName
              , W = R.uN.appVersion
              , Z = U.n;
            E.Z = {
                "appName": G,
                "appId": H,
                "appVersion": W,
                "spmCode": {
                    "spma": Z,
                    "spmb": {
                        "home": "home",
                        "textHome": "ai-assistant",
                        "webview": "webview",
                        "audit-page": "audit-page",
                        "login": "login",
                        "share": "share",
                        "festival-card": "promotion-hc",
                        "save-img": "save-img",
                        "points-detail": "points-detail",
                        "member-introduce": "member",
                        "myspace": "myspace",
                        "text-generate": "text-generate",
                        "text-result": "text-generate",
                        "generate": "generate",
                        "points": "points",
                        "preview": "preview",
                        "setting": "setting",
                        "text-to-image": "text-to-image",
                        "image-to-image": "image-to-image",
                        "product-image": "product-image",
                        "identification-image": "identification-image",
                        "enhance-image": "upscale-image",
                        "eCard-generate": "promotion-bj",
                        "eCard-result": "promotion-hc",
                        "assistant-detail": "assistant-detail"
                    },
                    "spmc": {
                        "webview": {
                            "": "0"
                        },
                        "audit-page": {
                            "": "0"
                        },
                        "login": {
                            "": "0"
                        },
                        "share": {
                            "": "0"
                        },
                        "festival-card": {
                            "": "0"
                        },
                        "save-img": {
                            "": "0"
                        },
                        "myspace": {
                            "user-info": "user-info",
                            "setting": "setting",
                            "feed-like": "feed-like",
                            "feed-history": "feed-history",
                            "feed-my": "feed-my"
                        },
                        "generate": {
                            "renew": "renew"
                        }
                    }
                }
            }
        },
        "2571": function(v, E, k) {
            "use strict";
            k.d(E, {
                "C2": function() {
                    return getPageType
                },
                "b3": function() {
                    return generateSpmCode
                }
            });
            var R = k(1217)
              , U = k(3072);
            function getPageType(v) {
                var E = v.match(/webview|festival-card|share|save-img|login|audit-page/g)
                  , k = "";
                if (E && E[0])
                    switch (E[0]) {
                    case "webview":
                        k = "1001";
                        break;
                    case "audit-page":
                        k = "1002";
                        break;
                    case "login":
                        k = "1003";
                        break;
                    case "share":
                        k = "1004";
                        break;
                    case "festival-card":
                        k = "1005";
                        break;
                    case "save-img":
                        k = "1006";
                        break;
                    default:
                        k = ""
                    }
                return k
            }
            function generateSpmCode(v, E) {
                return v && E ? "".concat(R.Z.spmCode.spma, ".").concat(R.Z.spmCode.spmb[v], ".").concat(R.Z.spmCode.spmc[v][E], ".0.").concat(function createSpmECode() {
                    return (new Date).getTime() + (0,
                    U.AL)(7)
                }()) : ""
            }
        },
        "2056": function(v, E, k) {
            "use strict";
            k.d(E, {
                "O": function() {
                    return W
                }
            });
            var R = k(6202)
              , U = k(3072)
              , H = (0,
            R.xI)()
              , G = ""
              , W = {
                "device_brand": H.brand || "",
                "device_model": H.model || "",
                "device_res": H.screenWidth + "*" + H.screenHeight,
                "device_height": H.screenHeight,
                "device_width": H.screenWidth,
                "app_version": H.version || "",
                "os_version": H.system || "",
                "os_type": H.platform || "",
                "device_type": "phone",
                "SUV": function getUUID() {
                    return G || (G = +new Date + (0,
                    U.AL)())
                }()
            }
        },
        "3072": function(v, E, k) {
            "use strict";
            k.d(E, {
                "V_": function() {
                    return URLPrefix
                },
                "Rz": function() {
                    return addProtocol
                },
                "vQ": function() {
                    return copyToClipboard
                },
                "GN": function() {
                    return downloadImage
                },
                "nV": function() {
                    return formatPoint
                },
                "mr": function() {
                    return formatTime
                },
                "AL": function() {
                    return generateRand
                },
                "_F": function() {
                    return getAuditStatus
                },
                "gu": function() {
                    return getFormatTime
                },
                "Wf": function() {
                    return getPvId
                },
                "An": function() {
                    return getQueryByName
                },
                "xu": function() {
                    return getRequestId
                },
                "SN": function() {
                    return getRequestQuery
                },
                "ah": function() {
                    return getSigReqData
                },
                "Jx": function() {
                    return handleJump
                },
                "s": function() {
                    return isIos
                },
                "pC": function() {
                    return isNoHistoryLengthBrowser
                },
                "SH": function() {
                    return isWxBrowser
                },
                "X0": function() {
                    return jumpTo
                },
                "Rl": function() {
                    return jumpToCompleteUrl
                },
                "sb": function() {
                    return jumpToWebview
                },
                "nZ": function() {
                    return objectToQueryString
                },
                "uM": function() {
                    return queryString
                },
                "OD": function() {
                    return queryStringByUrl
                },
                "P2": function() {
                    return throttle
                },
                "Pe": function() {
                    return transformFeatureCardJson
                },
                "eO": function() {
                    return updateQueryUrl
                },
                "JE": function() {
                    return useNativeDownloadBrowser
                },
                "Vj": function() {
                    return uuid
                }
            });
            var R = k(7762)
              , U = k(4165)
              , H = k(5861)
              , G = k(885)
              , W = k(7945)
              , Z = k(8595)
              , Y = k(5671)
              , J = k(3144)
              , K = function fixNumber(v) {
                return v.toString().length < 2 ? "0" + v : v.toString()
            }
              , X = function() {
                return (0,
                J.Z)((function Moment(v) {
                    (0,
                    Y.Z)(this, Moment),
                    this.time = new Date(v)
                }
                ), [{
                    "key": "fromNow",
                    "value": function fromNow() {
                        var v = new Date
                          , E = v.getTime() - this.time.getTime();
                        return E <= 6e5 ? "刚刚" : E <= 36e5 ? Math.round(E / 60 / 1e3) + "分钟前" : E <= 864e5 ? Math.round(E / 60 / 60 / 1e3) + "小时前" : v.getFullYear() == this.time.getFullYear() ? K(this.time.getMonth() + 1) + "-" + K(this.time.getDate()) + " " + K(this.time.getHours()) + ":" + K(this.time.getMinutes()) : this.time.getFullYear() + "-" + K(this.time.getMonth() + 1) + "-" + K(this.time.getDate())
                    }
                }, {
                    "key": "format",
                    "value": function format(v) {
                        return v.replace("yyyy", this.time.getFullYear().toString()).replace("MM", K(this.time.getMonth() + 1)).replace("dd", K(this.time.getDate())).replace("HH", K(this.time.getHours())).replace("mm", K(this.time.getMinutes())).replace("ss", K(this.time.getSeconds()))
                    }
                }, {
                    "key": "fixTime",
                    "value": function fixTime() {
                        var v = new Date;
                        if (v.getFullYear() == this.time.getFullYear()) {
                            var E = new Date(v.getFullYear(),v.getMonth(),v.getDate())
                              , k = new Date(this.time.getFullYear(),this.time.getMonth(),this.time.getDate());
                            return E.getTime() - k.getTime() == 0 ? "今天 " + K(this.time.getHours()) + ":" + K(this.time.getMinutes()) : E.getTime() - k.getTime() <= 864e5 ? "昨天 " + K(this.time.getHours()) + ":" + K(this.time.getMinutes()) : this.fromNow()
                        }
                        return this.fromNow()
                    }
                }, {
                    "key": "fixNewTime",
                    "value": function fixNewTime() {
                        var v = new Date - this.time;
                        return v < 0 || 0 == v || v < 6e4 ? "刚刚" : v < 36e5 ? Math.round(v / 6e4) + "分钟前" : v < 864e5 ? Math.round(v / 36e5) + "小时前" : v < 1728e5 ? "昨天" + this.format("HH:mm") : v < 2592e5 ? "前天" + this.format("HH:mm") : v < 6048e5 ? Math.round(v / 864e5) + "天前" : this.format("yyyy.MM.dd")
                    }
                }])
            }()
              , Q = k(5145)
              , ee = 0
              , te = 8;
            function md5_cmn(v, E, k, R, U, H) {
                return safe_add(function bit_rol(v, E) {
                    return v << E | v >>> 32 - E
                }(safe_add(safe_add(E, v), safe_add(R, H)), U), k)
            }
            function md5_ff(v, E, k, R, U, H, G) {
                return md5_cmn(E & k | ~E & R, v, E, U, H, G)
            }
            function md5_gg(v, E, k, R, U, H, G) {
                return md5_cmn(E & R | k & ~R, v, E, U, H, G)
            }
            function md5_hh(v, E, k, R, U, H, G) {
                return md5_cmn(E ^ k ^ R, v, E, U, H, G)
            }
            function md5_ii(v, E, k, R, U, H, G) {
                return md5_cmn(k ^ (E | ~R), v, E, U, H, G)
            }
            function safe_add(v, E) {
                var k = (65535 & v) + (65535 & E);
                return (v >> 16) + (E >> 16) + (k >> 16) << 16 | 65535 & k
            }
            var ne = function hex_md5(v) {
                return function binl2hex(v) {
                    for (var E = ee ? "0123456789ABCDEF" : "0123456789abcdef", k = "", R = 0; R < 4 * v.length; R++)
                        k += E.charAt(v[R >> 2] >> R % 4 * 8 + 4 & 15) + E.charAt(v[R >> 2] >> R % 4 * 8 & 15);
                    return k
                }(function core_md5(v, E) {
                    v[E >> 5] |= 128 << E % 32,
                    v[14 + (E + 64 >>> 9 << 4)] = E;
                    for (var k = 1732584193, R = -271733879, U = -1732584194, H = 271733878, G = 0; G < v.length; G += 16) {
                        var W = k
                          , Z = R
                          , Y = U
                          , J = H;
                        k = md5_ff(k, R, U, H, v[G + 0], 7, -680876936),
                        H = md5_ff(H, k, R, U, v[G + 1], 12, -389564586),
                        U = md5_ff(U, H, k, R, v[G + 2], 17, 606105819),
                        R = md5_ff(R, U, H, k, v[G + 3], 22, -1044525330),
                        k = md5_ff(k, R, U, H, v[G + 4], 7, -176418897),
                        H = md5_ff(H, k, R, U, v[G + 5], 12, 1200080426),
                        U = md5_ff(U, H, k, R, v[G + 6], 17, -1473231341),
                        R = md5_ff(R, U, H, k, v[G + 7], 22, -45705983),
                        k = md5_ff(k, R, U, H, v[G + 8], 7, 1770035416),
                        H = md5_ff(H, k, R, U, v[G + 9], 12, -1958414417),
                        U = md5_ff(U, H, k, R, v[G + 10], 17, -42063),
                        R = md5_ff(R, U, H, k, v[G + 11], 22, -1990404162),
                        k = md5_ff(k, R, U, H, v[G + 12], 7, 1804603682),
                        H = md5_ff(H, k, R, U, v[G + 13], 12, -40341101),
                        U = md5_ff(U, H, k, R, v[G + 14], 17, -1502002290),
                        k = md5_gg(k, R = md5_ff(R, U, H, k, v[G + 15], 22, 1236535329), U, H, v[G + 1], 5, -165796510),
                        H = md5_gg(H, k, R, U, v[G + 6], 9, -1069501632),
                        U = md5_gg(U, H, k, R, v[G + 11], 14, 643717713),
                        R = md5_gg(R, U, H, k, v[G + 0], 20, -373897302),
                        k = md5_gg(k, R, U, H, v[G + 5], 5, -701558691),
                        H = md5_gg(H, k, R, U, v[G + 10], 9, 38016083),
                        U = md5_gg(U, H, k, R, v[G + 15], 14, -660478335),
                        R = md5_gg(R, U, H, k, v[G + 4], 20, -405537848),
                        k = md5_gg(k, R, U, H, v[G + 9], 5, 568446438),
                        H = md5_gg(H, k, R, U, v[G + 14], 9, -1019803690),
                        U = md5_gg(U, H, k, R, v[G + 3], 14, -187363961),
                        R = md5_gg(R, U, H, k, v[G + 8], 20, 1163531501),
                        k = md5_gg(k, R, U, H, v[G + 13], 5, -1444681467),
                        H = md5_gg(H, k, R, U, v[G + 2], 9, -51403784),
                        U = md5_gg(U, H, k, R, v[G + 7], 14, 1735328473),
                        k = md5_hh(k, R = md5_gg(R, U, H, k, v[G + 12], 20, -1926607734), U, H, v[G + 5], 4, -378558),
                        H = md5_hh(H, k, R, U, v[G + 8], 11, -2022574463),
                        U = md5_hh(U, H, k, R, v[G + 11], 16, 1839030562),
                        R = md5_hh(R, U, H, k, v[G + 14], 23, -35309556),
                        k = md5_hh(k, R, U, H, v[G + 1], 4, -1530992060),
                        H = md5_hh(H, k, R, U, v[G + 4], 11, 1272893353),
                        U = md5_hh(U, H, k, R, v[G + 7], 16, -155497632),
                        R = md5_hh(R, U, H, k, v[G + 10], 23, -1094730640),
                        k = md5_hh(k, R, U, H, v[G + 13], 4, 681279174),
                        H = md5_hh(H, k, R, U, v[G + 0], 11, -358537222),
                        U = md5_hh(U, H, k, R, v[G + 3], 16, -722521979),
                        R = md5_hh(R, U, H, k, v[G + 6], 23, 76029189),
                        k = md5_hh(k, R, U, H, v[G + 9], 4, -640364487),
                        H = md5_hh(H, k, R, U, v[G + 12], 11, -421815835),
                        U = md5_hh(U, H, k, R, v[G + 15], 16, 530742520),
                        k = md5_ii(k, R = md5_hh(R, U, H, k, v[G + 2], 23, -995338651), U, H, v[G + 0], 6, -198630844),
                        H = md5_ii(H, k, R, U, v[G + 7], 10, 1126891415),
                        U = md5_ii(U, H, k, R, v[G + 14], 15, -1416354905),
                        R = md5_ii(R, U, H, k, v[G + 5], 21, -57434055),
                        k = md5_ii(k, R, U, H, v[G + 12], 6, 1700485571),
                        H = md5_ii(H, k, R, U, v[G + 3], 10, -1894986606),
                        U = md5_ii(U, H, k, R, v[G + 10], 15, -1051523),
                        R = md5_ii(R, U, H, k, v[G + 1], 21, -2054922799),
                        k = md5_ii(k, R, U, H, v[G + 8], 6, 1873313359),
                        H = md5_ii(H, k, R, U, v[G + 15], 10, -30611744),
                        U = md5_ii(U, H, k, R, v[G + 6], 15, -1560198380),
                        R = md5_ii(R, U, H, k, v[G + 13], 21, 1309151649),
                        k = md5_ii(k, R, U, H, v[G + 4], 6, -145523070),
                        H = md5_ii(H, k, R, U, v[G + 11], 10, -1120210379),
                        U = md5_ii(U, H, k, R, v[G + 2], 15, 718787259),
                        R = md5_ii(R, U, H, k, v[G + 9], 21, -343485551),
                        k = safe_add(k, W),
                        R = safe_add(R, Z),
                        U = safe_add(U, Y),
                        H = safe_add(H, J)
                    }
                    return Array(k, R, U, H)
                }(function str2binl(v) {
                    for (var E = Array(), k = (1 << te) - 1, R = 0; R < v.length * te; R += te)
                        E[R >> 5] |= (v.charCodeAt(R / te) & k) << R % 32;
                    return E
                }(v), v.length * te))
            }
              , re = k(640)
              , oe = k.n(re)
              , ie = k(1894)
              , ae = k(9168)
              , se = k(354);
            function uuid() {
                for (var v = [], E = 0; E < 32; E++)
                    v[E] = "0123456789abcdef".substr(Math.floor(16 * Math.random()), 1);
                return v.join("")
            }
            function getSigReqData(v, E) {
                var k = [];
                for (var R in v)
                    null != v[R] ? k.push(R + "=" + v[R]) : delete v[R];
                return k.sort(),
                ne(k.join("&") + E)
            }
            function generateRand() {
                var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 7
                  , E = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
                return Array.from(Array(v)).map((function() {
                    return E[parseInt((62 * Math.random()).toString())]
                }
                )).join("")
            }
            function URLPrefix(v) {
                if (!v)
                    return "";
                var E = /^\/\//.test(v) ? "https:" : "";
                return "".concat(E).concat(v)
            }
            function getQueryByName(v, E) {
                var k = new RegExp("[?&]" + E + "=([^&#]+)")
                  , R = v.match(k);
                return R ? R[1] : null
            }
            function getPvId() {
                var v, E, k = null === (v = window) || void 0 === v || null === (v = v.sessionStorage) || void 0 === v ? void 0 : v.getItem("ai_pvid");
                k || (k = getUuid(),
                null === (E = window) || void 0 === E || null === (E = E.sessionStorage) || void 0 === E || E.setItem("ai_pvid", k));
                return k
            }
            function getRequestId() {
                return getUuid()
            }
            function getUuid() {
                return (new Date).getTime() + function generateRand() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 7
                      , E = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
                    return Array.from(Array(v)).map((function() {
                        return E[parseInt((62 * Math.random()).toString())]
                    }
                    )).join("")
                }(7)
            }
            function jumpTo(v) {
                W.ZP.navigateTo({
                    "url": v
                })
            }
            function jumpToWebview(v) {
                var E = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                window.location.href = "https:" + (E ? "" : Q.bm) + v
            }
            function getAuditStatus() {
                return new Promise((function(v) {
                    ae.Z.getCISFeedData({
                        "spm": "".concat(se.Z.spmA, ".home.audit"),
                        "page": 1,
                        "size": 1
                    }).then((function(E) {
                        if (E) {
                            var k = E.content && E.content[0]
                              , R = 2 == k.status && se.Z.appVersion == k.version;
                            v(R)
                        } else
                            v(!1)
                    }
                    ))
                }
                ))
            }
            function jumpToCompleteUrl(v) {
                window.location.href = v
            }
            function getRequestQuery(v) {
                var E = v.split("?")[1];
                return E ? E.split("&").reduce((function(v, E) {
                    var k = E.split("=")
                      , R = (0,
                    G.Z)(k, 2)
                      , U = R[0]
                      , H = R[1];
                    return v[U] = decodeURIComponent(H.replace(/\+/g, " ")),
                    v
                }
                ), {}) : {}
            }
            function getFormatTime(v, E, k) {
                return Date.now() - v <= 864e5 && k ? new X(v).fromNow() : new X(v).format(E)
            }
            function formatTime(v) {
                if (v < 60)
                    return "".concat(Math.floor(v), "秒");
                var E = Math.floor(v / 60)
                  , k = v % 60;
                return k ? "".concat(E, "分钟").concat(k, "秒") : "".concat(E, "分钟")
            }
            function queryString() {
                for (var v, E = {}, k = (null === (v = window) || void 0 === v || null === (v = v.location) || void 0 === v || null === (v = v.search) || void 0 === v ? void 0 : v.substring(1)).split("&"), R = 0; R < k.length; R++) {
                    var U = k[R].split("=");
                    if (void 0 === E[U[0]])
                        E[U[0]] = decodeURIComponent(U[1]);
                    else if ("string" == typeof E[U[0]]) {
                        var H = [E[U[0]], decodeURIComponent(U[1])];
                        E[U[0]] = H
                    } else
                        E[U[0]].push(decodeURIComponent(U[1]))
                }
                return E
            }
            function queryStringByUrl() {
                for (var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "", E = {}, k = (v.split("?").length > 1 ? v.split("?")[1] : "").split("&"), R = 0; R < k.length; R++) {
                    var U = k[R].split("=");
                    if (void 0 === E[U[0]])
                        E[U[0]] = decodeURIComponent(U[1]);
                    else if ("string" == typeof E[U[0]]) {
                        var H = [E[U[0]], decodeURIComponent(U[1])];
                        E[U[0]] = H
                    } else
                        E[U[0]].push(decodeURIComponent(U[1]))
                }
                return E
            }
            function throttle(v, E) {
                var k = null;
                return function() {
                    for (var R = this, U = arguments.length, H = new Array(U), G = 0; G < U; G++)
                        H[G] = arguments[G];
                    k || (k = setTimeout((function() {
                        k = null,
                        v.apply(R, H)
                    }
                    ), E))
                }
            }
            function copyToClipboard(v) {
                var E = navigator.userAgent.match(/iPad|iPhone|iPod|Macintosh/i);
                return new Promise((function(k, R) {
                    try {
                        navigator.clipboard && E ? navigator.clipboard.writeText(v).then((function() {
                            k(!0)
                        }
                        )).catch((function() {
                            k(!1)
                        }
                        )) : k(oe()(v))
                    } catch (v) {
                        console.log("copyToClipboard", v),
                        R(v)
                    }
                }
                ))
            }
            function isIos() {
                return navigator.userAgent.match(/(iPad|iPhone|iPod)[\w\s]*;(?:[\w\s]+;)*[\w\s]+(?:iPad|iPhone|iPod)?\sOS\s([\d_.]+)/i)
            }
            function IsAndroid() {
                var v = navigator.userAgent;
                return v.indexOf("Android") > -1 || v.indexOf("adr") > -1 || v.indexOf("linux;") > -1
            }
            function isWxBrowser() {
                return navigator.userAgent.indexOf("MicroMessenger") > -1
            }
            function useNativeDownloadBrowser() {
                var v = navigator.userAgent;
                console.log(IsAndroid(), "33");
                var E = isIos();
                if (IsAndroid()) {
                    if (v.indexOf("MicroMessenger") > -1)
                        return !1;
                    if (v.indexOf("baiduboxapp") > -1)
                        return !1;
                    if (v.indexOf("MiuiBrowser") > -1)
                        return !0;
                    if (v.indexOf("samsungbrowser/") > -1)
                        return !0;
                    if (v.indexOf("UCBrowser") > -1)
                        return !1;
                    if (v.indexOf("TTWebView") > -1)
                        return !1;
                    if (v.indexOf("HuaweiBrowser") > -1)
                        return !0;
                    if (v.indexOf("VivoBrowser") > -1)
                        return !0;
                    if (v.indexOf("QBrowser") > -1)
                        return !0;
                    if (v.indexOf("Chrome") > -1)
                        return !0
                }
                if (E) {
                    if (navigator.standalone ? /WebKit\/[\d.]+/i.test(v) : /Safari/i.test(v) && !/CriOS/i.test(v) && !/MQQBrowser/i.test(v))
                        return !0;
                    if (v.indexOf("Chrome") > -1)
                        return !0
                }
                return !1
            }
            function dataURItoBlob(v) {
                for (var E = v.split(","), k = E[0].match(/:(.*?);/)[1], R = atob(E[1]), U = R.length, H = new Uint8Array(U); U--; )
                    H[U] = R.charCodeAt(U);
                return new Blob([H],{
                    "type": k
                })
            }
            function downloadImage(v) {
                var E = new Image
                  , k = function getImgName(v) {
                    var E = "/"
                      , k = v
                      , R = k.slice(v.lastIndexOf(E) + E.length);
                    return R
                }(v);
                E.setAttribute("crossOrigin", "anonymous"),
                E.src = v,
                E.onload = (0,
                H.Z)((0,
                U.Z)().mark((function _callee() {
                    var v, R, H, G, W, Y;
                    return (0,
                    U.Z)().wrap((function _callee$(U) {
                        for (; ; )
                            switch (U.prev = U.next) {
                            case 0:
                                return (v = document.createElement("canvas")).width = E.width,
                                v.height = E.height,
                                v.getContext("2d").drawImage(E, 0, 0, E.width, E.height),
                                R = v.toDataURL("image/png"),
                                H = dataURItoBlob(R),
                                console.log(H, URL.createObjectURL, "blobfile"),
                                U.prev = 8,
                                U.next = 11,
                                H.arrayBuffer();
                            case 11:
                                G = U.sent,
                                W = URL.createObjectURL(new Blob([G])),
                                (Y = document.createElement("a")).download = k,
                                Y.href = W,
                                Y.click(),
                                Y.remove(),
                                URL.revokeObjectURL(W),
                                U.next = 25;
                                break;
                            case 21:
                                U.prev = 21,
                                U.t0 = U.catch(8),
                                console.log("download error", U.t0),
                                (0,
                                Z.CF)({
                                    "duration": 3e3,
                                    "title": "请长按图片，进行保存",
                                    "icon": "none"
                                });
                            case 25:
                            case "end":
                                return U.stop()
                            }
                    }
                    ), _callee, null, [[8, 21]])
                }
                )))
            }
            function updateQueryUrl(v, E, k) {
                var R = new RegExp("([?&])" + E + "=.*?(&|$)","i")
                  , U = -1 !== v.indexOf("?") ? "&" : "?";
                return v.match(R) ? v.replace(R, "$1" + E + "=" + k + "$2") : v + U + E + "=" + k
            }
            function objectToQueryString(v) {
                return new URLSearchParams(v).toString()
            }
            function formatPoint(v) {
                if (v <= 0 || !v)
                    return "";
                if (v > 0 && v <= 999)
                    return v;
                if (v > 999 && v < 1e4) {
                    var E = v.toString().split("").slice(0, 2);
                    return E.splice(1, 0, "."),
                    E.join("") + "k"
                }
                var k = v.toString().split("").slice(0, -3);
                return k.splice(-1, 0, "."),
                k.join("") + "w"
            }
            function handleJump(v, E) {
                window.location.href = "/wap" + v
            }
            function addProtocol() {
                var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
                return v && v.indexOf && v.indexOf("http") < 0 ? "".concat("https:").concat(v) : v
            }
            function isNoHistoryLengthBrowser() {
                return ["HuaweiBrowser", "VivoBrowser", "HeyTapBrowser", "NewsArticle"].some((function(v) {
                    return navigator.userAgent.includes(v)
                }
                ))
            }
            function transformFeatureCardJson(v) {
                var E, k, U, H, G, W, Z, Y, J, K, X, Q, ee, te, ne, re, oe, ae, se, ce, le, ue, de, pe, fe, he, me, ge, _e, ve, ye, be, Se, we, Ee, Ce = {}, Te = v.selected ? null === (E = v) || void 0 === E ? void 0 : E.uuid : null;
                return v = null === (k = v) || void 0 === k ? void 0 : k.cardContent,
                Ce.toolSceneTitle = null === (U = v) || void 0 === U || null === (U = U.toolSceneTitle) || void 0 === U ? void 0 : U.toolSceneTitleValue,
                Ce.toolSceneName = null === (H = v) || void 0 === H || null === (H = H.toolScene) || void 0 === H ? void 0 : H.toolSceneName,
                Ce.toolSceneID = null === (G = v) || void 0 === G || null === (G = G.toolScene) || void 0 === G ? void 0 : G.toolSceneID,
                Ce.needPicDescribeValue = null === (W = v) || void 0 === W || null === (W = W.needPicDescribe) || void 0 === W ? void 0 : W.needPicDescribeValue,
                Ce.inputPicDescribeDefaultValue = null === (Z = v) || void 0 === Z || null === (Z = Z.inputPicDescribe) || void 0 === Z ? void 0 : Z.inputPicDescribeDefaultValue,
                Ce.inputPicDescribeTitle = null === (Y = v) || void 0 === Y || null === (Y = Y.inputPicDescribe) || void 0 === Y ? void 0 : Y.inputPicDescribeTitle,
                Ce.inputPicDescribeDesc = null === (J = v) || void 0 === J || null === (J = J.inputPicDescribe) || void 0 === J ? void 0 : J.inputPicDescribeDesc,
                Ce.inputPicDescribeSeq = null === (K = v) || void 0 === K || null === (K = K.inputPicDescribe) || void 0 === K ? void 0 : K.inputPicDescribeSeq,
                Ce.inputImageDescribeIndicateWord = null === (X = v) || void 0 === X || null === (X = X.inputImageDescribeIndicateWordList) || void 0 === X || null === (X = X.inputImageDescribeIndicateWord) || void 0 === X ? void 0 : X.map((function(v) {
                    return {
                        "keywords": null == v ? void 0 : v.inputImageDescribeIndicateWordKeyword,
                        "richKeywords": null == v ? void 0 : v.inputImageDescribeIndicateWordMultiKeyword
                    }
                }
                )),
                Ce.needChoosePicStyleValue = null === (Q = v) || void 0 === Q || null === (Q = Q.needChoosePicStyle) || void 0 === Q ? void 0 : Q.needChoosePicStyleValue,
                Ce.choosePicStyleDesc = null === (ee = v) || void 0 === ee || null === (ee = ee.choosePicStyle) || void 0 === ee ? void 0 : ee.choosePicStyleDesc,
                Ce.choosePicStyleSeq = null === (te = v) || void 0 === te || null === (te = te.choosePicStyle) || void 0 === te ? void 0 : te.choosePicStyleSeq,
                Ce.choosePicStyleTitle = null === (ne = v) || void 0 === ne || null === (ne = ne.choosePicStyle) || void 0 === ne ? void 0 : ne.choosePicStyleTitle,
                Ce.needBuildRadioValue = null === (re = v) || void 0 === re || null === (re = re.needBuildRadio) || void 0 === re ? void 0 : re.needBuildRadioValue,
                Ce.buildRadioBasicInfoTitle = null === (oe = v) || void 0 === oe || null === (oe = oe.buildRadioBasicInfo) || void 0 === oe ? void 0 : oe.buildRadioBasicInfoTitle,
                Ce.buildRadioBasicInfoSeq = null === (ae = v) || void 0 === ae || null === (ae = ae.buildRadioBasicInfo) || void 0 === ae ? void 0 : ae.buildRadioBasicInfoSeq,
                Ce.buildRadioBasicInfoDesc = null === (se = v) || void 0 === se || null === (se = se.buildRadioBasicInfo) || void 0 === se ? void 0 : se.buildRadioBasicInfoDesc,
                Ce.buildRadio = null === (ce = v) || void 0 === ce || null === (ce = ce.buildRadioList) || void 0 === ce || null === (ce = ce.buildRadio) || void 0 === ce ? void 0 : ce.map((function(v) {
                    var E, k = v.buildRadioLength, U = v.buildRadioWidth, H = "".concat(U, ":").concat(k), G = U / k, W = (0,
                    R.Z)(ie.CE);
                    try {
                        for (W.s(); !(E = W.n()).done; ) {
                            var Z = E.value;
                            if (Z.rate === G) {
                                H = Z.size;
                                break
                            }
                        }
                    } catch (v) {
                        W.e(v)
                    } finally {
                        W.f()
                    }
                    var Y = Number(H.split(":")[0])
                      , J = Number(H.split(":")[1])
                      , K = URLPrefix(null == v ? void 0 : v.buildRadioimageUrl);
                    return {
                        "size": H,
                        "high": k,
                        "width": U,
                        "label": null == v ? void 0 : v.buildRadioDesc,
                        "img": K,
                        "widthProp": Y,
                        "highProp": J,
                        "portraitSizeDesc": null == v ? void 0 : v.buildRadioName
                    }
                }
                )),
                Ce.type = null === (le = v) || void 0 === le ? void 0 : le.type,
                Ce.iconValue = null === (ue = v) || void 0 === ue || null === (ue = ue.operatePos) || void 0 === ue || null === (ue = ue.icon) || void 0 === ue ? void 0 : ue.iconValue,
                Ce.funcDescValue = null === (de = v) || void 0 === de || null === (de = de.operatePos) || void 0 === de || null === (de = de.funcDesc) || void 0 === de ? void 0 : de.funcDescValue,
                Ce.coverSmallUrlValue = null === (pe = v) || void 0 === pe || null === (pe = pe.operatePos) || void 0 === pe || null === (pe = pe.coverSmallUrl) || void 0 === pe ? void 0 : pe.coverSmallUrlValue,
                Ce.toolNameValue = null === (fe = v) || void 0 === fe || null === (fe = fe.operatePos) || void 0 === fe || null === (fe = fe.toolName) || void 0 === fe ? void 0 : fe.toolNameValue,
                Ce.coverBigUrlValue = null === (he = v) || void 0 === he || null === (he = he.operatePos) || void 0 === he || null === (he = he.coverBigUrl) || void 0 === he ? void 0 : he.coverBigUrlValue,
                Ce.styleClassificationValue = null === (me = v) || void 0 === me || null === (me = me.styleClassification) || void 0 === me ? void 0 : me.styleClassificationValue,
                Ce.needUploadSimpleImageValue = null === (ge = v) || void 0 === ge || null === (ge = ge.needUploadSimpleImage) || void 0 === ge ? void 0 : ge.needUploadSimpleImageValue,
                Ce.uploadSimpleImageSeq = null === (_e = v) || void 0 === _e || null === (_e = _e.uploadSimpleImage) || void 0 === _e ? void 0 : _e.uploadSimpleImageSeq,
                Ce.uploadSimpleImageTitle = null === (ve = v) || void 0 === ve || null === (ve = ve.uploadSimpleImage) || void 0 === ve ? void 0 : ve.uploadSimpleImageTitle,
                Ce.uploadSimpleImageDesc = null === (ye = v) || void 0 === ye || null === (ye = ye.uploadSimpleImage) || void 0 === ye ? void 0 : ye.uploadSimpleImageDesc,
                Ce.needAdSettingValue = null === (be = v) || void 0 === be || null === (be = be.needAdSetting) || void 0 === be ? void 0 : be.needAdSettingValue,
                Ce.adSetting = null === (Se = v) || void 0 === Se || null === (Se = Se.adSettingList) || void 0 === Se || null === (Se = Se.adSetting) || void 0 === Se ? void 0 : Se.map((function(v) {
                    var E, k, R, U, H;
                    return {
                        "adSettingSimpleImageSimilarityValue": null == v || null === (E = v.adSettingSimpleImageSimilarity) || void 0 === E ? void 0 : E.adSettingSimpleImageSimilarityValue,
                        "adSettingSimpleImageSimilarityTitle": null == v || null === (k = v.adSettingSimpleImageSimilarity) || void 0 === k ? void 0 : k.adSettingSimpleImageSimilarityTitle,
                        "adSettingInputPicDescTitle": null == v || null === (R = v.adSettingInputPicDesc) || void 0 === R ? void 0 : R.adSettingInputPicDescTitle,
                        "adSettingInputPicDescDefaultValue": null == v || null === (U = v.adSettingInputPicDesc) || void 0 === U ? void 0 : U.adSettingInputPicDescDefaultValue,
                        "adSettingInputPicDescDesc": null == v || null === (H = v.adSettingInputPicDesc) || void 0 === H ? void 0 : H.adSettingInputPicDescDesc
                    }
                }
                )),
                Ce.needUploadCommodityPortraitImage = null === (we = v) || void 0 === we || null === (we = we.needOriginalImage) || void 0 === we ? void 0 : we.needOriginalImageValue,
                Ce.uploadCommodityPortraitImageTitle = null === (Ee = v) || void 0 === Ee || null === (Ee = Ee.originalImage) || void 0 === Ee ? void 0 : Ee.originalImageTitle,
                Ce.uuid = Te,
                Ce
            }
        },
        "3173": function() {},
        "2495": function() {},
        "8241": function() {},
        "5547": function(v, E, k) {
            "use strict";
            k.d(E, {
                "Z": function() {
                    return Ue
                }
            });
            var R = k(989)
              , U = {
                "isLogin": !1,
                "userInfo": {
                    "username": "",
                    "avatar": "",
                    "userId": ""
                },
                "memberLevel": 0,
                "memberInfo": void 0,
                "isOnline": !0,
                "isWeixin": !1,
                "isBaidu": !1,
                "isToutiao": !1,
                "requestId": "",
                "pointInfo": {},
                "showDetailDialog": !1,
                "showNoPointDialog": !1,
                "isNotHasLastPage": !document.referrer || window.location.history <= 2,
                "statePageKey": 0,
                "memberAgreementType": "",
                "trailCount": 0,
                "systemCount": 1e3,
                "trailList": [],
                "isFirstTrail": !1
            }
              , H = k(1413)
              , G = k(2982)
              , W = k(2229)
              , Z = {
                "updateUserInfo": function updateUserInfo(v, E) {
                    v.userInfo = E
                },
                "updateMemberInfo": function updateMemberInfo(v, E) {
                    var k = E.memberLevel
                      , R = E.memberInfo;
                    v.memberLevel = k,
                    v.memberInfo = R
                },
                "updateLoginStatus": function updateLoginStatus(v, E) {
                    v.isLogin = E
                },
                "updateOnlineStatus": function updateOnlineStatus(v, E) {
                    v.isOnline = E
                },
                "updateRequestId": function updateRequestId(v, E) {
                    v.requestId = E,
                    W.Z.setItem("generateRequestId", E)
                },
                "updatePointInfo": function updatePointInfo(v, E) {
                    v.pointInfo = E
                },
                "updateShowDetailDialog": function updateShowDetailDialog(v, E) {
                    v.showDetailDialog = E
                },
                "getStoredRequestId": function getStoredRequestId(v) {
                    v.requestId || (v.requestId = W.Z.getItem("generateRequestId"))
                },
                "updateXCXEnv": function updateXCXEnv(v, E) {
                    "wx" == E && (v.isWeixin = !0),
                    "bd" == E && (v.isBaidu = !0),
                    "tt" == E && (v.isToutiao = !0)
                },
                "updateShowNoPointDialog": function updateShowNoPointDialog(v, E) {
                    v.showNoPointDialog = E
                },
                "updateIsNotHasLastPage": function updateIsNotHasLastPage(v, E) {
                    v.isNotHasLastPage = E
                },
                "updateStatePageKey": function updateStatePageKey(v, E) {
                    v.statePageKey = E
                },
                "updateMemberAgreementType": function updateMemberAgreementType(v, E) {
                    v.memberAgreementType = E,
                    W.Z.setItem("memberAgreementType", E)
                },
                "updateTrailCount": function updateTrailCount(v, E) {
                    v.trailCount = E
                },
                "updateSystemCount": function updateSystemCount(v, E) {
                    v.systemCount = E
                },
                "addTrailItem": function addTrailItem(v, E) {
                    var k = W.Z.getItem("trailList") || [];
                    E.picGroupId && (v.trailList = k.filter((function(v) {
                        return v.picGroupId !== E.picGroupId
                    }
                    ))),
                    E.smartId && (v.trailList = k),
                    v.trailList = [].concat((0,
                    G.Z)(v.trailList), [(0,
                    H.Z)({}, E)]),
                    W.Z.setItem("trailList", v.trailList)
                },
                "deleteTrailItem": function deleteTrailItem(v, E) {
                    var k = W.Z.getItem("trailList") || [];
                    v.trailList = k.filter((function(v) {
                        return !!v.smartId || v.picGroupId !== E
                    }
                    )),
                    console.log("deleteTrailItem", v.trailList),
                    W.Z.setItem("trailList", v.trailList)
                },
                "updateTrailStatus": function updateTrailStatus(v, E) {
                    v.isFirstTrail = E
                }
            }
              , Y = k(4165);
            function _objectDestructuringEmpty(v) {
                if (null == v)
                    throw new TypeError("Cannot destructure " + v)
            }
            var J = k(5861)
              , K = k(3)
              , X = k(5980)
              , Q = k(2088)
              , ee = k(6728)
              , te = k(8595)
              , ne = k(3570)
              , re = {
                "getUserPoint": function getUserPoint(v) {
                    var E = v.commit
                      , k = v.state;
                    if (k.isLogin) {
                        var R = {
                            "userId": k.userInfo.userId
                        };
                        return K.Z.getUserPoint(R).then((function(v) {
                            1 === v.code && E("updatePointInfo", v.data)
                        }
                        ))
                    }
                },
                "getUserInfo": function getUserInfo(v) {
                    var E = v.commit
                      , k = v.getters
                      , R = v.dispatch;
                    return X.Z.getUserInfo(k.xcxEnv).then((function(v) {
                        var k, U, H;
                        1 == v.code && v.data && (E("updateUserInfo", {
                            "username": null === (k = v.data) || void 0 === k ? void 0 : k.nickname,
                            "avatar": null === (U = v.data) || void 0 === U ? void 0 : U.avatar,
                            "userId": null === (H = v.data) || void 0 === H ? void 0 : H.userId
                        }),
                        E("updateLoginStatus", !0),
                        R("getUserPoint"))
                    }
                    ))
                },
                "checkIsSensitive": function checkIsSensitive(v, E) {
                    return (0,
                    J.Z)((0,
                    Y.Z)().mark((function _callee() {
                        var k;
                        return (0,
                        Y.Z)().wrap((function _callee$(R) {
                            for (; ; )
                                switch (R.prev = R.next) {
                                case 0:
                                    return _objectDestructuringEmpty(v),
                                    R.prev = 1,
                                    R.next = 4,
                                    Q.Z.sensitiveText(E);
                                case 4:
                                    if (1 !== (k = R.sent).code) {
                                        R.next = 9;
                                        break
                                    }
                                    return R.abrupt("return", k.data);
                                case 9:
                                    (0,
                                    te.CF)({
                                        "title": "网络出错，请重试",
                                        "icon": "none",
                                        "duration": 800
                                    });
                                case 10:
                                    R.next = 15;
                                    break;
                                case 12:
                                    R.prev = 12,
                                    R.t0 = R.catch(1),
                                    (0,
                                    te.CF)({
                                        "title": "网络出错，请重试",
                                        "icon": "none",
                                        "duration": 800
                                    });
                                case 15:
                                case "end":
                                    return R.stop()
                                }
                        }
                        ), _callee, null, [[1, 12]])
                    }
                    )))()
                },
                "getTrailCount": function getTrailCount(v) {
                    var E = v.commit
                      , k = v.getters;
                    if (!v.state.isLogin)
                        return X.Z.getTrailCount(k.xcxEnv).then((function(v) {
                            1 == v.code && v.data && (E("updateTrailCount", v.data.residualCountPerTourist),
                            E("updateSystemCount", v.data.residualCountPerDay),
                            E("updateTrailStatus", v.data.residualCountPerTourist === v.data.aiCountPerTourist))
                        }
                        ))
                },
                "mergeArt": function mergeArt(v, E) {
                    return (0,
                    J.Z)((0,
                    Y.Z)().mark((function _callee2() {
                        var k, R, U, H, Z;
                        return (0,
                        Y.Z)().wrap((function _callee2$(Y) {
                            for (; ; )
                                switch (Y.prev = Y.next) {
                                case 0:
                                    return k = v.dispatch,
                                    R = [],
                                    U = [],
                                    E.forEach((function(v) {
                                        v.picGroupId ? U.push(v) : R.push(v)
                                    }
                                    )),
                                    console.log("text", R, "pic", U),
                                    Y.next = 6,
                                    k("mergePicTrail", U);
                                case 6:
                                    return H = Y.sent,
                                    Y.next = 9,
                                    k("mergeTextTrail", R);
                                case 9:
                                    Z = Y.sent,
                                    console.log("residualText", Z, "residualPics", H),
                                    W.Z.setItem("trailList", [].concat((0,
                                    G.Z)(H), (0,
                                    G.Z)(Z)));
                                case 12:
                                case "end":
                                    return Y.stop()
                                }
                        }
                        ), _callee2)
                    }
                    )))()
                },
                "mergePicTrail": function mergePicTrail(v, E) {
                    return _objectDestructuringEmpty(v),
                    E.length <= 0 ? E : new Promise((function(v) {
                        X.Z.mergeTrailArt(E).then((function(k) {
                            if (1 === k.code) {
                                var R, U = new URLSearchParams(null === (R = window.location) || void 0 === R ? void 0 : R.search).get("taskId");
                                U && (console.log("updateTrailDetail", k.data[U]),
                                ne.Y.emit("updateTrailDetail", {
                                    "id": k.data[U]
                                })),
                                W.Z.setItem("picTrailRes", k.data),
                                ne.Y.emit("refresh"),
                                v([])
                            } else
                                console.error("merge art fail:", k),
                                v(E)
                        }
                        ))
                    }
                    ))
                },
                "mergeTextTrail": function mergeTextTrail(v, E) {
                    if (_objectDestructuringEmpty(v),
                    E.length <= 0)
                        return [];
                    var k = []
                      , R = E.map((function(v) {
                        var E, R = {
                            "category": 3,
                            "subCategory": 1,
                            "content": (null == v || null === (E = v.textRes) || void 0 === E ? void 0 : E.join("<br>")) || "",
                            "isDraft": !0,
                            "bizExtInfo": {
                                "mindTemplateId": v.smartId,
                                "mindTemplateMap": v.templateMap,
                                "uuid": v.uuid
                            }
                        };
                        return new Promise((function(E, U) {
                            ee.Z.publishArt(R).then((function(v) {
                                var k;
                                1 == v.code ? E(null === (k = v.data) || void 0 === k ? void 0 : k.artId) : U(v)
                            }
                            )).catch((function(E) {
                                U(E),
                                k.push(v)
                            }
                            ))
                        }
                        ))
                    }
                    ));
                    return new Promise((function(v) {
                        Promise.all(R).then((function(E) {
                            console.log(E, "textList"),
                            ne.Y.emit("saveTextTip"),
                            ne.Y.emit("updateBtnStatus", [{
                                "type": "save",
                                "status": !0
                            }]),
                            ne.Y.emit("refresh"),
                            v(k)
                        }
                        ), (function() {
                            v(k)
                        }
                        ))
                    }
                    ))
                }
            }
              , oe = {
                "namespaced": !0,
                "state": U,
                "getters": {
                    "isXCX": function isXCX(v) {
                        return v.isWeixin || v.isBaidu || v.isToutiao
                    },
                    "xcxEnv": function xcxEnv(v) {
                        return v.isWeixin ? "wx" : v.isBaidu ? "bd" : v.isToutiao ? "tt" : ""
                    }
                },
                "mutations": Z,
                "actions": re
            }
              , ie = (0,
            H.Z)({}, {
                "publishInfo": {
                    "show": !1,
                    "id": "",
                    "detail": null,
                    "bizExtInfo": {}
                },
                "historyList": [],
                "activeTab": "byText",
                "mainTypeInfo": {},
                "genFormInfo": {
                    "type": 0,
                    "templateType": "",
                    "templateTypeCode": 0,
                    "templateId": 1,
                    "imageCount": 2,
                    "promptCh": "",
                    "denoising": 0,
                    "backImgUrl": "",
                    "imageUrl": "",
                    "high": 512,
                    "width": 512,
                    "baseImageWidth": 0,
                    "baseImageHeight": 0,
                    "widthProp": null,
                    "highProp": null
                },
                "generateSame": "",
                "featureCardInfo": {}
            })
              , ae = {
                "getHistoryList": function getHistoryList(v) {
                    var E = v.commit
                      , k = v.state;
                    console.log(k.userInfo, "state");
                    var R = {
                        "userId": k.userInfo.userId,
                        "pageNo": 1,
                        "pageSize": 20
                    };
                    return Q.Z.getHistoryList(R).then((function(v) {
                        1 === v.code ? E("updateHistoryList", v.data) : ((0,
                        te.CF)({
                            "title": "获取历史记录失败",
                            "icon": "none",
                            "duration": 800
                        }),
                        console.log("get history err", v.msg))
                    }
                    ))
                }
            }
              , se = k(2495)
              , ce = {
                "namespaced": !0,
                "state": ie,
                "getters": k.n(se)(),
                "mutations": {
                    "updatePublishInfo": function updatePublishInfo(v, E) {
                        v.publishInfo = E
                    },
                    "updateHistoryList": function updateHistoryList(v, E) {
                        v.historyList = E
                    },
                    "updateActiveTab": function updateActiveTab(v, E) {
                        v.activeTab = E
                    },
                    "updateMainTypeInfo": function updateMainTypeInfo(v, E) {
                        v.mainTypeInfo = E
                    },
                    "updateGenFormInfo": function updateGenFormInfo(v, E) {
                        v.genFormInfo = E
                    },
                    "updateGenerateInfo": function updateGenerateInfo(v, E) {
                        var k = E.key
                          , R = E.value;
                        v[k] = R
                    },
                    "updateGenerateSame": function updateGenerateSame(v, E) {
                        v.generateSame = E
                    },
                    "updateFeatureCardInfo": function updateFeatureCardInfo(v, E) {
                        v.featureCardInfo = E
                    }
                },
                "actions": ae
            }
              , le = {
                "changeReplyCommentInfo": function changeReplyCommentInfo(v, E) {
                    v.replyCommentInfo = E
                },
                "receiveParamsFromGenerate": function receiveParamsFromGenerate(v, E) {
                    v.createInfo = {
                        "status": "loading",
                        "couldStop": !1,
                        "createParams": E.params,
                        "creator": E.creator,
                        "picGroupId": E.picGroupId
                    },
                    W.Z.setItem("createInfo", v.createInfo)
                },
                "resetCreateParams": function resetCreateParams(v, E) {
                    v.createInfo = (0,
                    H.Z)((0,
                    H.Z)({}, v.createInfo), E),
                    W.Z.setItem("createInfo", v.createInfo)
                },
                "updateCreateStatus": function updateCreateStatus(v, E) {
                    v.createInfo = (0,
                    H.Z)((0,
                    H.Z)({}, v.createInfo), {}, {
                        "status": E
                    }),
                    W.Z.setItem("createInfo", (0,
                    H.Z)((0,
                    H.Z)({}, v.createInfo), {}, {
                        "status": E
                    }))
                },
                "getCreateInfo": function getCreateInfo(v) {
                    v.createInfo.status || W.Z.getItem("createInfo") && (v.createInfo = W.Z.getItem("createInfo"))
                },
                "updateTimer": function updateTimer(v, E) {
                    v.timer = E
                },
                "updateRemainTime": function updateRemainTime(v, E) {
                    v.remainTime = E
                },
                "updateIsRead": function updateIsRead(v, E) {
                    v.isRead = E
                },
                "getCreateList": function getCreateList(v) {
                    return v.createList && v.createList.length ? v.createList : W.Z.getItem("createList")
                },
                "addCreateList": function addCreateList(v, E) {
                    v.createList = v.createList.filter((function(v) {
                        return v.picGroupId !== E.picGroupId
                    }
                    )),
                    v.createList = [].concat((0,
                    G.Z)(v.createList), [(0,
                    H.Z)((0,
                    H.Z)({}, E), {}, {
                        "spmReport": !1
                    })]),
                    W.Z.setItem("createList", v.createList)
                },
                "updateCreateList": function updateCreateList(v, E) {
                    Array.isArray(E) ? v.createList = E : -1 === v.createList.findIndex((function(v) {
                        return v.picGroupId === E.picGroupId
                    }
                    )) ? this.commit("artDetail/addCreateList", E) : v.createList = v.createList.map((function(v) {
                        return v.picGroupId === E.picGroupId ? (0,
                        H.Z)((0,
                        H.Z)({}, v), E) : v
                    }
                    ));
                    W.Z.setItem("createList", v.createList)
                }
            }
              , ue = k(8491)
              , de = k(5970)
              , pe = k(1894)
              , fe = k(1490)
              , he = k(354);
            function getGenerateMsgInfo(v, E, k) {
                var R, U = (null === (R = fe.dK.currentTracker) || void 0 === R ? void 0 : R.getTrackerData()) || "", H = U.spmA, G = U.spmB, W = U.spmE, Z = "".concat(H || he.Z.spmA, ".").concat(G || "home", ".0.0.").concat(W), Y = "/".concat(E.name, "?spm=").concat(Z, "&").concat(E.type ? E.type : "detailId", "=").concat(E.id);
                console.log("ssss", Y),
                "ERROR" !== v && "TIMEOUT" !== v || (Y = "/generate/".concat(E.name, "?spm=").concat(Z),
                Y = "".concat(Y, "&generateObj=").concat(E.genObj),
                console.log("fail", Y));
                var J = {
                    "title": pe.z2[v].title,
                    "label": pe.z2[v].label,
                    "icon": pe.z2[v].icon,
                    "jumpHref": Y,
                    "jumpName": pe.z2[v].jumpName,
                    "picGroupId": k
                };
                console.log("trigger showCreateMsg"),
                ne.Y.emit("showCreateMsg", {
                    "showMsg": !0,
                    "msgInfo": J
                })
            }
            var me = k(2050)
              , ge = k(1963)
              , _e = k(9380)
              , ve = {
                "getCreateList": function getCreateList(v) {
                    var E = v.state;
                    return E.createList && E.createList.length ? E.createList : W.Z.getItem("createList")
                },
                "intervalMsg": function intervalMsg(v, E) {
                    var k = v.commit
                      , R = v.state
                      , U = v.dispatch
                      , H = E.isFirstInterval
                      , G = void 0 === H || H
                      , W = E.clkParam
                      , Z = void 0 === W ? "" : W
                      , Y = R.createList
                      , J = null == Y ? void 0 : Y.map((function(v) {
                        return v.status
                    }
                    ));
                    null != J && J.includes("success") && setTimeout((function() {
                        U("generateSuccess")
                    }
                    ), 3e3),
                    null != J && J.includes("fail") && U("generateError", Z),
                    null != J && J.includes("stopped") && U("generateStopped"),
                    (null != J && J.includes("loading") || Y.filter((function(v) {
                        return !v.spmReport
                    }
                    )).length) && k("updateTimer", setTimeout((function() {
                        U("handleInterval")
                    }
                    ), G ? 0 : 3e3))
                },
                "handleInterval": function handleInterval(v) {
                    return (0,
                    J.Z)((0,
                    Y.Z)().mark((function _callee2() {
                        var E, k, R, U, H, G;
                        return (0,
                        Y.Z)().wrap((function _callee2$(W) {
                            for (; ; )
                                switch (W.prev = W.next) {
                                case 0:
                                    return E = v.commit,
                                    k = v.dispatch,
                                    R = v.state,
                                    W.prev = 1,
                                    W.next = 4,
                                    Q.Z.getGenerateMsgMulti();
                                case 4:
                                    if (1 !== (U = W.sent).code && fe.dK.trackAction(de.o.POINTS_DETAIL_NETWORK_FAILD, {
                                        "type": 1
                                    }),
                                    U.data) {
                                        W.next = 9;
                                        break
                                    }
                                    return E("resetCreateParams", {
                                        "status": null,
                                        "couldStop": !1,
                                        "createParams": {},
                                        "creator": {}
                                    }),
                                    W.abrupt("return");
                                case 9:
                                    if (H = [],
                                    0 !== U.data.length) {
                                        W.next = 15;
                                        break
                                    }
                                    return clearTimeout(R.timer),
                                    E("updateTimer", null),
                                    E("updateCreateList", H),
                                    W.abrupt("return");
                                case 15:
                                    return G = U.data.map(function() {
                                        var v = (0,
                                        J.Z)((0,
                                        Y.Z)().mark((function _callee(v, E) {
                                            return (0,
                                            Y.Z)().wrap((function _callee$(R) {
                                                for (; ; )
                                                    switch (R.prev = R.next) {
                                                    case 0:
                                                        return R.next = 2,
                                                        k("getCreateItem", {
                                                            "createItem": v,
                                                            "listIndex": E,
                                                            "couldStop": void 0 === (null == v ? void 0 : v.couldStop) || (null == v ? void 0 : v.couldStop)
                                                        });
                                                    case 2:
                                                    case "end":
                                                        return R.stop()
                                                    }
                                            }
                                            ), _callee)
                                        }
                                        )));
                                        return function(E, k) {
                                            return v.apply(this, arguments)
                                        }
                                    }()),
                                    W.next = 18,
                                    Promise.all(G);
                                case 18:
                                    k("intervalMsg", {
                                        "isFirstInterval": !1
                                    }),
                                    W.next = 24;
                                    break;
                                case 21:
                                    W.prev = 21,
                                    W.t0 = W.catch(1),
                                    fe.dK.trackAction(de.o.POINTS_DETAIL_NETWORK_FAILD, {
                                        "type": 2
                                    });
                                case 24:
                                case "end":
                                    return W.stop()
                                }
                        }
                        ), _callee2, null, [[1, 21]])
                    }
                    )))()
                },
                "getCreateItem": function getCreateItem(v, E) {
                    var k, R, U, G, Z, Y, J, K, X, Q, ee, te, ne, re, oe, ie = v.commit, ae = v.dispatch, se = v.rootState, ce = E.createItem, le = ce.code, ue = ce.data, de = ce.couldStop;
                    if (ue) {
                        var fe = {
                            "picGroupId": ue.picGroupId,
                            "remainTime": ue.remainTime,
                            "couldStop": de
                        };
                        switch (le) {
                        case pe.z2.SUCCESS.code:
                            var he, ge, _e;
                            if (null != ue && ue.artId)
                                fe.createParams = (0,
                                H.Z)((0,
                                H.Z)({}, ue.requestParam), {}, {
                                    "id": ue.artId,
                                    "imgList": ue.images.map((function(v) {
                                        return {
                                            "url": v,
                                            "coverImg": (0,
                                            me.Nc)(v, 800),
                                            "width": ue.requestParam.width,
                                            "height": ue.requestParam.high
                                        }
                                    }
                                    )),
                                    "templateName": ((null == ue || null === (he = ue.requestParam) || void 0 === he ? void 0 : he.templateType) || "默认") + "-" + ((null == ue || null === (ge = ue.requestParam) || void 0 === ge ? void 0 : ge.templateName) || "默认风格"),
                                    "templateLevel": (null == ue || null === (_e = ue.requestParam) || void 0 === _e ? void 0 : _e.templateLevel) || 0
                                }),
                                fe.creator = se.base.userInfo,
                                fe.status = "success",
                                fe.couldStop = !1;
                            else if (ue && !ue.artId) {
                                var ve, ye, be;
                                fe.createParams = (0,
                                H.Z)((0,
                                H.Z)({}, ue.requestParam), {}, {
                                    "templateName": ((null == ue || null === (ve = ue.requestParam) || void 0 === ve ? void 0 : ve.templateType) || "默认") + "-" + ((null == ue || null === (ye = ue.requestParam) || void 0 === ye ? void 0 : ye.templateName) || "默认风格"),
                                    "templateLevel": (null == ue || null === (be = ue.requestParam) || void 0 === be ? void 0 : be.templateLevel) || 0
                                }),
                                fe.creator = se.base.userInfo,
                                fe.status = "loading"
                            }
                            break;
                        case pe.z2.ERROR.code:
                            var Se = W.Z.getItem("featureCardUUid");
                            ae("updateErrorInfo", {
                                "clkParam": "templateId:".concat(null === (k = ue.requestParam) || void 0 === k ? void 0 : k.templateId, ";promptCh:").concat(encodeURIComponent(null === (R = ue.requestParam) || void 0 === R ? void 0 : R.promptCh), ";type:1;uuid:").concat(Se),
                                "createItem": ce
                            }),
                            fe = {
                                "picGroupId": (null == ce || null === (U = ce.data) || void 0 === U ? void 0 : U.picGroupId) || (null == ce ? void 0 : ce.picGroupId),
                                "createParams": (0,
                                H.Z)((0,
                                H.Z)({}, ue.requestParam), {}, {
                                    "templateName": ((null == ue || null === (G = ue.requestParam) || void 0 === G ? void 0 : G.templateType) || "默认") + "-" + ((null == ue || null === (Z = ue.requestParam) || void 0 === Z ? void 0 : Z.templateName) || "默认风格")
                                }) || (null == ce ? void 0 : ce.createParams),
                                "creator": se.base.userInfo,
                                "status": "fail"
                            };
                            break;
                        case pe.z2.STOPPED.code:
                            fe.createParams = (0,
                            H.Z)((0,
                            H.Z)({}, ue.requestParam), {}, {
                                "templateName": ((null == ue || null === (Y = ue.requestParam) || void 0 === Y ? void 0 : Y.templateType) || "默认") + "-" + ((null == ue || null === (J = ue.requestParam) || void 0 === J ? void 0 : J.templateName) || "默认风格")
                            }),
                            fe.creator = se.base.userInfo,
                            fe.status = "stopped";
                            break;
                        case pe.z2.TIMEOUT.code:
                            ae("updateErrorInfo", {
                                "clkParam": "type:3",
                                "createItem": ce
                            }),
                            fe = {
                                "picGroupId": (null == ce || null === (K = ce.data) || void 0 === K ? void 0 : K.picGroupId) || (null == ce ? void 0 : ce.picGroupId),
                                "createParams": (0,
                                H.Z)((0,
                                H.Z)({}, ue.requestParam), {}, {
                                    "templateName": ((null == ue || null === (X = ue.requestParam) || void 0 === X ? void 0 : X.templateType) || "默认") + "-" + ((null == ue || null === (Q = ue.requestParam) || void 0 === Q ? void 0 : Q.templateName) || "默认风格"),
                                    "templateLevel": (null == ue || null === (ee = ue.requestParam) || void 0 === ee ? void 0 : ee.templateLevel) || 0
                                }) || (null == ce ? void 0 : ce.createParams),
                                "creator": se.base.userInfo,
                                "status": "fail"
                            };
                            break;
                        default:
                            fe = {
                                "picGroupId": (null == ce || null === (te = ce.data) || void 0 === te ? void 0 : te.picGroupId) || (null == ce ? void 0 : ce.picGroupId),
                                "createParams": (0,
                                H.Z)((0,
                                H.Z)({}, ue.requestParam), {}, {
                                    "templateName": ((null == ue || null === (ne = ue.requestParam) || void 0 === ne ? void 0 : ne.templateType) || "默认") + "-" + ((null == ue || null === (re = ue.requestParam) || void 0 === re ? void 0 : re.templateName) || "默认风格"),
                                    "templateLevel": (null == ue || null === (oe = ue.requestParam) || void 0 === oe ? void 0 : oe.templateLevel) || 0
                                }) || (null == ce ? void 0 : ce.createParams),
                                "creator": se.base.userInfo,
                                "status": "fail"
                            }
                        }
                        ue.scoreInfo && ie("base/updatePointInfo", ue.scoreInfo, {
                            "root": !0
                        }),
                        ie("updateCreateList", fe)
                    }
                },
                "generateSuccess": function generateSuccess(v) {
                    var E, k = v.commit, R = v.state, U = v.dispatch;
                    k("getCreateList");
                    var H = null === (E = R.createList) || void 0 === E ? void 0 : E.filter((function(v) {
                        return "success" === v.status
                    }
                    ));
                    H.length && (null == H || H.forEach(function() {
                        var v = (0,
                        J.Z)((0,
                        Y.Z)().mark((function _callee3(v) {
                            var E, H, G, W, Z, J, K;
                            return (0,
                            Y.Z)().wrap((function _callee3$(Y) {
                                for (; ; )
                                    switch (Y.prev = Y.next) {
                                    case 0:
                                        return Y.next = 2,
                                        U("sendSpmACodes", {
                                            "createInfo": v
                                        });
                                    case 2:
                                        k("getCreateInfo"),
                                        R.createInfo.picGroupId === v.picGroupId && k("resetCreateParams", v),
                                        G = null === (E = (0,
                                        ge.FN)().router) || void 0 === E || null === (E = E.path) || void 0 === E ? void 0 : E.includes("/detail"),
                                        W = null === (H = (0,
                                        ge.FN)().router) || void 0 === H ? void 0 : H.params,
                                        G ? JSON.stringify(W).includes(null == v || null === (Z = v.createParams) || void 0 === Z ? void 0 : Z.id) ? U("readMsg", v.picGroupId) : getGenerateMsgInfo("SUCCESS", {
                                            "name": "detail",
                                            "id": null == v || null === (J = v.createParams) || void 0 === J ? void 0 : J.id
                                        }, v.picGroupId) : getGenerateMsgInfo("SUCCESS", {
                                            "name": "detail",
                                            "id": null == v || null === (K = v.createParams) || void 0 === K ? void 0 : K.id
                                        }, v.picGroupId);
                                    case 8:
                                    case "end":
                                        return Y.stop()
                                    }
                            }
                            ), _callee3)
                        }
                        )));
                        return function(E) {
                            return v.apply(this, arguments)
                        }
                    }()))
                },
                "generateStopped": function generateStopped(v) {
                    return (0,
                    J.Z)((0,
                    Y.Z)().mark((function _callee5() {
                        var E, k, R, U, H;
                        return (0,
                        Y.Z)().wrap((function _callee5$(G) {
                            for (; ; )
                                switch (G.prev = G.next) {
                                case 0:
                                    if (k = v.commit,
                                    R = v.state,
                                    U = v.dispatch,
                                    k("getCreateList"),
                                    (H = null === (E = R.createList) || void 0 === E ? void 0 : E.filter((function(v) {
                                        return ["stopScoreError", "stopped"].includes(v.status)
                                    }
                                    ))).length) {
                                        G.next = 5;
                                        break
                                    }
                                    return G.abrupt("return");
                                case 5:
                                    null == H || H.forEach(function() {
                                        var v = (0,
                                        J.Z)((0,
                                        Y.Z)().mark((function _callee4(v) {
                                            return (0,
                                            Y.Z)().wrap((function _callee4$(E) {
                                                for (; ; )
                                                    switch (E.prev = E.next) {
                                                    case 0:
                                                        k("getCreateInfo"),
                                                        R.createInfo.picGroupId === v.picGroupId && k("resetCreateParams", v),
                                                        U("readMsg", v.picGroupId);
                                                    case 4:
                                                    case "end":
                                                        return E.stop()
                                                    }
                                            }
                                            ), _callee4)
                                        }
                                        )));
                                        return function(E) {
                                            return v.apply(this, arguments)
                                        }
                                    }());
                                case 6:
                                case "end":
                                    return G.stop()
                                }
                        }
                        ), _callee5)
                    }
                    )))()
                },
                "generateError": function generateError(v) {
                    var E, k = v.state, R = v.dispatch, U = v.commit, G = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
                    U("getCreateList");
                    var W = null === (E = k.createList) || void 0 === E ? void 0 : E.filter((function(v) {
                        return "fail" === v.status
                    }
                    ));
                    W.length && (null == W || W.forEach(function() {
                        var v = (0,
                        J.Z)((0,
                        Y.Z)().mark((function _callee6(v) {
                            var E, W, Z, J, K, X, Q, ee;
                            return (0,
                            Y.Z)().wrap((function _callee6$(Y) {
                                for (; ; )
                                    switch (Y.prev = Y.next) {
                                    case 0:
                                        if (U("getCreateInfo"),
                                        (W = k.createInfo).picGroupId === v.picGroupId && U("resetCreateParams", v),
                                        !v.spmReport) {
                                            Y.next = 5;
                                            break
                                        }
                                        return Y.abrupt("return");
                                    case 5:
                                        Z = "ERROR",
                                        G.includes("type:1") ? Z = "ERROR" : G.includes("type:3") && (Z = "TIMEOUT"),
                                        (null === (E = (0,
                                        ge.FN)().router) || void 0 === E || null === (E = E.path) || void 0 === E ? void 0 : E.includes("/imgLoading")) ? W.picGroupId === v.picGroupId && (ne.Y.emit("getCreateDetail"),
                                        !G.includes("type:2") && R("readMsg", v.picGroupId)) : (K = v.createParams,
                                        X = "byText",
                                        2 === K.type && (X = "200" === K.templateTypeCode ? "byCommodity" : "202" === K.templateTypeCode ? "byPersonBg" : "byPortrait"),
                                        5 === K.type && (X = "byHDZoom"),
                                        1 === K.type && (X = "byImg"),
                                        Q = encodeURIComponent(JSON.stringify((0,
                                        H.Z)((0,
                                        H.Z)({}, K), {}, {
                                            "imgUrl": K.imageUrl
                                        }))),
                                        ee = null === (J = pe.eA.find((function(v) {
                                            return v.id === X
                                        }
                                        ))) || void 0 === J ? void 0 : J.newPath,
                                        getGenerateMsgInfo(Z, {
                                            "name": ee,
                                            "genObj": Q
                                        }, v.picGroupId)),
                                        U("updateCreateList", (0,
                                        H.Z)((0,
                                        H.Z)({}, v), {}, {
                                            "spmReport": !0
                                        }));
                                    case 10:
                                    case "end":
                                        return Y.stop()
                                    }
                            }
                            ), _callee6)
                        }
                        )));
                        return function(E) {
                            return v.apply(this, arguments)
                        }
                    }()))
                },
                "readMsg": function readMsg(v, E) {
                    return (0,
                    J.Z)((0,
                    Y.Z)().mark((function _callee7() {
                        var k, R, U, H;
                        return (0,
                        Y.Z)().wrap((function _callee7$(G) {
                            for (; ; )
                                switch (G.prev = G.next) {
                                case 0:
                                    return k = v.commit,
                                    R = v.state,
                                    G.prev = 1,
                                    G.next = 4,
                                    Q.Z.readGenerateMsg({
                                        "picGroupIds": [E]
                                    });
                                case 4:
                                    1 === (U = G.sent).code ? (console.log("消息已读成功"),
                                    k("getCreateList"),
                                    H = R.createList.filter((function(v) {
                                        return v.picGroupId !== E
                                    }
                                    )),
                                    k("updateCreateList", H)) : console.log("消息已读失败", null == U ? void 0 : U.msg),
                                    G.next = 11;
                                    break;
                                case 8:
                                    G.prev = 8,
                                    G.t0 = G.catch(1),
                                    console.log("消息已读接口异常", G.t0);
                                case 11:
                                case "end":
                                    return G.stop()
                                }
                        }
                        ), _callee7, null, [[1, 8]])
                    }
                    )))()
                },
                "updateErrorInfo": function updateErrorInfo(v, E) {
                    var k, R = E.clkParam, U = E.createItem;
                    console.log(R, "error clk"),
                    W.Z.removeItem("art_".concat(null == U || null === (k = U.data) || void 0 === k ? void 0 : k.picGroupId, "_startTime")),
                    (0,
                    _e.vX)({
                        "acode": de.o.GENERATE_ERROR,
                        "clkParam": R
                    })
                },
                "getDetail": function getDetail(v, E) {
                    return (0,
                    J.Z)((0,
                    Y.Z)().mark((function _callee8() {
                        var k, R, U, G;
                        return (0,
                        Y.Z)().wrap((function _callee8$(W) {
                            for (; ; )
                                switch (W.prev = W.next) {
                                case 0:
                                    return k = v.commit,
                                    R = v.rootState,
                                    W.prev = 1,
                                    W.next = 4,
                                    ue.Z.getArtDetail({
                                        "blogId": null == E ? void 0 : E.artId
                                    });
                                case 4:
                                    1 == (null == (U = W.sent) ? void 0 : U.code) ? k("resetCreateParams", {
                                        "status": "success",
                                        "createParams": (0,
                                        H.Z)((0,
                                        H.Z)({}, null == E ? void 0 : E.requestParam), {}, {
                                            "id": null == E ? void 0 : E.artId,
                                            "imgList": null === (G = U.data) || void 0 === G || null === (G = G.ext) || void 0 === G || null === (G = G.pics) || void 0 === G ? void 0 : G.map((function(v) {
                                                return v.coverImg = (0,
                                                me.Nc)(v.url, 800),
                                                v
                                            }
                                            ))
                                        }),
                                        "creator": R.base.userInfo,
                                        "picGroupId": E.picGroupId
                                    }) : console.log("查询详情失败", U),
                                    W.next = 11;
                                    break;
                                case 8:
                                    W.prev = 8,
                                    W.t0 = W.catch(1),
                                    console.log("查询详情接口异常", W.t0);
                                case 11:
                                case "end":
                                    return W.stop()
                                }
                        }
                        ), _callee8, null, [[1, 8]])
                    }
                    )))()
                },
                "sendSpmACodes": function sendSpmACodes(v, E) {
                    var k, R, U, G, Z, Y, J, K, X, Q, ee, te, ne, re, oe = v.commit, ie = v.state, ae = E.createInfo;
                    if (!ae.spmReport && !0 !== location.href.includes("imgLoading")) {
                        console.log("createList", ae, ie.createList),
                        oe("updateCreateList", (0,
                        H.Z)((0,
                        H.Z)({}, ae), {}, {
                            "spmReport": !0
                        }));
                        var se = W.Z.getItem("art_".concat(ae.picGroupId, "_startTime"))
                          , ce = 2;
                        if (1 === (null == ae || null === (k = ae.createParams) || void 0 === k ? void 0 : k.type))
                            ce = 1;
                        else if (2 === (null == ae || null === (R = ae.createParams) || void 0 === R ? void 0 : R.type)) {
                            var le, ue, pe;
                            "200" === (null == ae || null === (le = ae.createParams) || void 0 === le ? void 0 : le.templateTypeCode) ? ce = 3 : "201" === (null == ae || null === (ue = ae.createParams) || void 0 === ue ? void 0 : ue.templateTypeCode) ? ce = 4 : "202" == (null == ae || null === (pe = ae.createParams) || void 0 === pe ? void 0 : pe.templateTypeCode) && (ce = 9)
                        } else
                            5 == (null == ae || null === (U = ae.createParams) || void 0 === U ? void 0 : U.type) && (ce = 8);
                        var fe, he = W.Z.getItem("featureCardUUid"), me = ae.createParams.templateLevel > 0 ? 1 : 2, ge = (null == ae || null === (G = ae.createParams) || void 0 === G ? void 0 : G.imageUrl) || "null", ve = (null == ae || null === (Z = ae.createParams) || void 0 === Z ? void 0 : Z.backImgUrl) || "null", ye = (null == ae || null === (Y = ae.createParams) || void 0 === Y ? void 0 : Y.subType) || 1;
                        if (ge = ge.replace(/^https?:\/\//, ""),
                        ve = ve.replace(/^https?:\/\//, ""),
                        fe = "templateId:".concat(null == ae ? void 0 : ae.createParams.templateId, ";templateType:").concat(null == ae || null === (J = ae.createParams) || void 0 === J ? void 0 : J.templateType, ";imageCount:").concat(null == ae || null === (K = ae.createParams) || void 0 === K ? void 0 : K.imageCount, ";") + "scale:".concat(null == ae || null === (X = ae.createParams) || void 0 === X ? void 0 : X.widthProp, ":").concat(null == ae || null === (Q = ae.createParams) || void 0 === Q ? void 0 : Q.highProp, ";") + "high:".concat(null == ae || null === (ee = ae.createParams) || void 0 === ee ? void 0 : ee.high, ";width:").concat(null == ae || null === (te = ae.createParams) || void 0 === te ? void 0 : te.width, ";promptCh:").concat(encodeURIComponent((null == ae || null === (ne = ae.createParams) || void 0 === ne ? void 0 : ne.promptCh) || "null"), ";userId:").concat((null == ae || null === (re = ae.creator) || void 0 === re ? void 0 : re.userId) || "null", ";generateType:").concat(ce, ";vip:").concat(me, ";imageUrl:").concat(ge, ";backImgUrl:").concat(ve, ";uuid:").concat(he, ";kind:").concat(ye),
                        1 === ce || 2 === ce ? (0,
                        _e.vX)({
                            "acode": de.o.GENERATE_SUCCESS,
                            "clkParam": fe
                        }) : 3 !== ce && 4 !== ce && 8 != ce && 9 != ce || (0,
                        _e.vX)({
                            "acode": de.o.CREATE_Commodity_Portrait_SUCCESS,
                            "clkParam": fe
                        }),
                        (0,
                        _e.vX)({
                            "acode": 10976,
                            "clkParam": "requestId:".concat(null == se ? void 0 : se.requestId, ";timeDiff:").concat((new Date).getTime() - +(null == se ? void 0 : se.time), ";").concat(fe)
                        }),
                        W.Z.removeItem("art_".concat(ae.picGroupId, "_startTime")),
                        "" !== W.Z.getItem("newSizeMap")) {
                            var be, Se, we, Ee = JSON.parse(W.Z.getItem("newSizeMap")), Ce = (null == ae || null === (be = ae.createParams) || void 0 === be ? void 0 : be.widthProp) + ":" + (null == ae || null === (Se = ae.createParams) || void 0 === Se ? void 0 : Se.highProp), Te = -1 !== Ee.findIndex((function(v) {
                                return v.size === Ce && "原图比例" === v.label
                            }
                            ));
                            (null == ae || null === (we = ae.createParams) || void 0 === we ? void 0 : we.imageUrl) && Te && (0,
                            _e.vX)({
                                "acode": de.o.USE_ORIGIN_SIZE
                            })
                        }
                        W.Z.getItem("isGenerateSame") && (W.Z.removeItem("isGenerateSame"),
                        (0,
                        _e.vX)({
                            "acode": de.o.GENERATE_SAME
                        }))
                    }
                }
            }
              , ye = k(3173)
              , be = {
                "namespaced": !0,
                "state": {
                    "replyCommentInfo": {
                        "replyInfo": {
                            "level": 1,
                            "commentInfo": null
                        },
                        "vm": null
                    },
                    "createInfo": {
                        "status": null,
                        "createParams": {},
                        "creator": {},
                        "picGroupId": ""
                    },
                    "createList": [],
                    "timer": null,
                    "remainTime": 0,
                    "isRead": !1
                },
                "getters": k.n(ye)(),
                "mutations": le,
                "actions": ve
            }
              , Se = k(8241)
              , we = {
                "namespaced": !0,
                "state": {
                    "searchPrompt": "",
                    "searchSimilarId": ""
                },
                "getters": {
                    "getSearchPrompt": function getSearchPrompt(v) {
                        return v.searchPrompt
                    }
                },
                "mutations": {
                    "setSearchPrompt": function setSearchPrompt(v, E) {
                        v.searchPrompt = E
                    },
                    "updateSearchSimilarId": function updateSearchSimilarId(v, E) {
                        v.searchSimilarId = E
                    }
                },
                "actions": k.n(Se)()
            }
              , Ee = {
                "updateSmartId": function updateSmartId(v, E) {
                    v.smartId = E,
                    W.Z.setItem("smartId", v.smartId)
                },
                "updateUUid": function updateUUid(v, E) {
                    v.uuid = E,
                    W.Z.setItem("uuid", v.uuid)
                },
                "updateSmartInfo": function updateSmartInfo(v, E) {
                    v.smartInfo = E,
                    W.Z.setItem("smartInfo", v.smartInfo)
                },
                "updateMindTemplateMap": function updateMindTemplateMap(v, E) {
                    v.mindTemplateMap["key".concat(E.index + 1)] = E.inputContent,
                    W.Z.setItem("mindTemplateMap", v.mindTemplateMap)
                },
                "clearMindTemplateMap": function clearMindTemplateMap(v) {
                    v.mindTemplateMap = {},
                    W.Z.removeItem("mindTemplateMap")
                },
                "updateTextInfo": function updateTextInfo(v, E) {
                    v.textInfo = E,
                    W.Z.setItem("textInfo", v.textInfo)
                }
            }
              , Ce = k(3072)
              , Te = {
                "getSmartInfo": function getSmartInfo(v) {
                    var E = v.commit
                      , k = v.state
                      , R = v.dispatch;
                    try {
                        ee.Z.getSmartDetail({
                            "smartId": k.smartId
                        }).then((function(v) {
                            if (1 === v.code) {
                                var k, U = null === (k = v.data) || void 0 === k ? void 0 : k.inner.filter((function(v) {
                                    return 1 == v.type
                                }
                                ));
                                v.data.inner = U,
                                E("updateSmartInfo", v.data)
                            } else
                                console.log("get smart info error", v.msg),
                                R("jumpError")
                        }
                        )).catch((function(v) {
                            console.log("handle smart info error", v),
                            R("jumpError")
                        }
                        ))
                    } catch (v) {
                        console.log("handle smart info error", v),
                        R("jumpError")
                    }
                },
                "getSmartInfoByUUid": function getSmartInfoByUUid(v) {
                    var E = v.commit
                      , k = v.state
                      , R = v.dispatch;
                    try {
                        ee.Z.getSmartDetailByUUid({
                            "uuids": k.uuid
                        }).then((function(v) {
                            if (1 === v.code) {
                                var k, U, H, G, W, Z, Y, J, K, X, Q, ee = null == v || null === (k = v.data) || void 0 === k || null === (k = k[0]) || void 0 === k || null === (k = k.xmlJson) || void 0 === k ? void 0 : k.xml, te = {
                                    "id": null == ee || null === (U = ee.outSide) || void 0 === U || null === (U = U.toolID) || void 0 === U ? void 0 : U.toolIDValue,
                                    "typeId": null == ee || null === (H = ee.outSide) || void 0 === H || null === (H = H.toolScene) || void 0 === H ? void 0 : H.toolSceneID,
                                    "uuid": null == v || null === (G = v.data) || void 0 === G || null === (G = G[0]) || void 0 === G ? void 0 : G.uuid,
                                    "title": null == ee || null === (W = ee.outSide) || void 0 === W || null === (W = W.toolTitle) || void 0 === W ? void 0 : W.toolTitleValue,
                                    "content": null == ee || null === (Z = ee.outSide) || void 0 === Z || null === (Z = Z.toolDesc) || void 0 === Z ? void 0 : Z.toolDescValue,
                                    "avatar": null == ee || null === (Y = ee.outSide) || void 0 === Y || null === (Y = Y.userId) || void 0 === Y ? void 0 : Y.authorCover,
                                    "picture": null == ee || null === (J = ee.outSide) || void 0 === J || null === (J = J.toolBackUrl) || void 0 === J ? void 0 : J.toolBackUrlValue,
                                    "nickName": null == ee || null === (K = ee.outSide) || void 0 === K || null === (K = K.userId) || void 0 === K ? void 0 : K.authorName
                                }, ne = null == ee || null === (X = ee.inner) || void 0 === X || null === (X = X.userInputStepList) || void 0 === X || null === (X = X.userInputStep) || void 0 === X ? void 0 : X.map((function(v) {
                                    return {
                                        "type": v.inputBoxType,
                                        "value": v.inputBoxTitle,
                                        "content": v.inputBoxDefaultValue
                                    }
                                }
                                )).filter((function(v) {
                                    return 1 == v.type
                                }
                                ));
                                te.inner = ne;
                                var re = null == ee || null === (Q = ee.inner) || void 0 === Q || null === (Q = Q.userInputSugList) || void 0 === Q ? void 0 : Q.userInputSug.filter((function(v) {
                                    return !!v.tagName
                                }
                                )).map((function(v) {
                                    return {
                                        "tagName": v.tagName,
                                        "hints": v.caseWord.split(";")
                                    }
                                }
                                ));
                                te.suggestions = re,
                                console.log(te, "smartInfo"),
                                E("updateSmartInfo", te)
                            } else
                                console.log("get smart info error", v.msg),
                                R("jumpError")
                        }
                        )).catch((function(v) {
                            console.log("handle smart info error", v),
                            R("jumpError")
                        }
                        ))
                    } catch (v) {
                        console.log("handle smart info error", v),
                        R("jumpError")
                    }
                },
                "recordTemplateMap": function recordTemplateMap(v, E) {
                    var k = v.commit
                      , R = v.state;
                    k("updateMindTemplateMap", E);
                    var U = R.mindTemplateMap;
                    U.smartId = E.smartId,
                    W.Z.setItem("generateTemplateMap", U)
                },
                "jumpError": function jumpError() {
                    var v = this.isH5 ? "/error" : "/pages/404/index";
                    (0,
                    Ce.Jx)(v)
                }
            }
              , xe = k(9171)
              , Ae = {
                "namespaced": !0,
                "state": {
                    "smartId": "",
                    "uuid": "",
                    "smartInfo": {},
                    "mindTemplateMap": {},
                    "textInfo": {
                        "status": "",
                        "artId": "",
                        "textRes": []
                    }
                },
                "getters": k.n(xe)(),
                "mutations": Ee,
                "actions": Te
            }
              , Ie = {
                "updateActivityId": function updateActivityId(v, E) {
                    v.activityId = E
                },
                "updateGenerateParams": function updateGenerateParams(v, E) {
                    v.generateParams = E
                },
                "updateStaticsParams": function updateStaticsParams(v, E) {
                    v.staticsParams = E
                },
                "updateMaterialImg": function updateMaterialImg(v, E) {
                    v.materialImg = E
                },
                "updateMaterialByImg": function updateMaterialByImg(v, E) {
                    v.materialByImg = E
                },
                "updateMaterialByNormal": function updateMaterialByNormal(v, E) {
                    v.materialByNormal = E
                },
                "updateMaterialBgInfo": function updateMaterialBgInfo(v, E) {
                    var k, R, U;
                    (v.materialBgInfo = E,
                    console.log(v.materialBgInfo, "mm"),
                    null !== (k = v.materialBgInfo) && void 0 !== k && k.imgUrl) && this.commit("eCard/updateMaterialInfo", {
                        "imgUrl": v.materialBgInfo.imgUrl,
                        "blessings": null === (R = v.materialInfo) || void 0 === R ? void 0 : R.blessings,
                        "receiver": null === (U = v.materialInfo) || void 0 === U ? void 0 : U.receiver
                    })
                },
                "updateTimer": function updateTimer(v, E) {
                    v.timer = E
                },
                "updateIsRead": function updateIsRead(v, E) {
                    v.isRead = E
                },
                "updateMaterialInfo": function updateMaterialInfo(v, E) {
                    v.materialInfo = E
                },
                "updateCount": function updateCount(v, E) {
                    v.count = E
                },
                "updateIsStopInterval": function updateIsStopInterval(v, E) {
                    v.isStopInterval = E
                }
            }
              , ke = k(5145)
              , Oe = k(2935)
              , Pe = {
                "addProduceCount": function addProduceCount() {
                    return Oe.Z.get({
                        "url": "".concat(ke.Jl, "/activity/card/pic/produce/count")
                    })
                }
            }
              , Re = 10745
              , Me = {
                "type": 1,
                "templateId": 56,
                "templateTypeCode": "2",
                "promptCh": "Best quality, masterpiece,bright Eyes,(ultra-detailed face),8k,<lora:add_detail:1>, <lora:LCM_LoRA_Weights_SD15:1> , <lora:weight_slider-LECO-v1:-3>,<lora:S-shape body:-1>",
                "denoising": 7,
                "imageCount": 1,
                "widthProp": 2,
                "highProp": 3,
                "baseImageWidth": 512,
                "baseImageHeight": 768,
                "width": 512,
                "high": 768
            }
              , Ne = {
                "stepOneImg": "//q3.itc.cn/images/20240306/d1de0ef99181479699e399dff8a7cd4f.png",
                "stepTwoImg": "//q4.itc.cn/images/20240306/3c7a684fee94472eb0297ddd1450f098.png",
                "toWhomPlaceholder": "想鼓励谁瘦身？",
                "contentPlaceholder": "你可以从下方选择瘦身flag，或手动输入哦",
                "genBtnText": "一键合成瘦身海报",
                "banner": "//q2.itc.cn/images/20240306/1d6b4edff00c4425bda3e3bbb680025f.png",
                "qrCodeUrl": "//q3.itc.cn/images/20240308/4667eb3f35de4175b00549807408b0a4.png"
            }
              , De = {
                "intervalMsg": function intervalMsg(v, E) {
                    var k = v.commit
                      , R = v.state
                      , U = v.dispatch
                      , H = E.isFirstInterval
                      , G = void 0 === H || H;
                    if (!R.isStopInterval) {
                        var W = R.materialBgInfo;
                        switch (null == W ? void 0 : W.status) {
                        case "success":
                        case "fail":
                            U("readMsg");
                            break;
                        default:
                            k("updateTimer", setTimeout((function() {
                                U("handleInterval")
                            }
                            ), G ? 0 : 3e3))
                        }
                    }
                },
                "handleInterval": function handleInterval(v) {
                    return (0,
                    J.Z)((0,
                    Y.Z)().mark((function _callee() {
                        var E, k, R, U, H;
                        return (0,
                        Y.Z)().wrap((function _callee$(G) {
                            for (; ; )
                                switch (G.prev = G.next) {
                                case 0:
                                    return E = v.commit,
                                    k = v.dispatch,
                                    G.prev = 1,
                                    G.next = 4,
                                    Q.Z.getGenerateMsg();
                                case 4:
                                    R = G.sent,
                                    U = R.code,
                                    H = R.data,
                                    G.t0 = U,
                                    G.next = 1 === G.t0 ? 9 : G.t0 === pe.z2.ERROR.code ? 14 : G.t0 === pe.z2.TIMEOUT.code ? 16 : 200003 === G.t0 ? 18 : 20;
                                    break;
                                case 9:
                                    if (null == H || !H.artId) {
                                        G.next = 12;
                                        break
                                    }
                                    return G.next = 12,
                                    k("getDetail", H);
                                case 12:
                                    return H && k("intervalMsg", {
                                        "isFirstInterval": !1
                                    }),
                                    G.abrupt("break", 21);
                                case 14:
                                case 16:
                                    return k("genMaterialBgError"),
                                    G.abrupt("break", 21);
                                case 18:
                                    return E("updateMaterialBgInfo", {
                                        "status": "fail",
                                        "imgUrl": ""
                                    }),
                                    G.abrupt("break", 21);
                                case 20:
                                    k("genMaterialBgError");
                                case 21:
                                    E("updateIsRead", !1),
                                    G.next = 27;
                                    break;
                                case 24:
                                    G.prev = 24,
                                    G.t1 = G.catch(1),
                                    k("genMaterialBgError");
                                case 27:
                                case "end":
                                    return G.stop()
                                }
                        }
                        ), _callee, null, [[1, 24]])
                    }
                    )))()
                },
                "readMsg": function readMsg(v) {
                    return (0,
                    J.Z)((0,
                    Y.Z)().mark((function _callee2() {
                        var E, k;
                        return (0,
                        Y.Z)().wrap((function _callee2$(R) {
                            for (; ; )
                                switch (R.prev = R.next) {
                                case 0:
                                    return E = v.commit,
                                    R.prev = 1,
                                    R.next = 4,
                                    Q.Z.readGenerateMsg();
                                case 4:
                                    1 === (k = R.sent).code ? (E("updateIsRead", !0),
                                    console.log("消息已读成功")) : console.log("消息已读失败", null == k ? void 0 : k.msg),
                                    R.next = 11;
                                    break;
                                case 8:
                                    R.prev = 8,
                                    R.t0 = R.catch(1),
                                    console.log("消息已读接口异常", R.t0);
                                case 11:
                                case "end":
                                    return R.stop()
                                }
                        }
                        ), _callee2, null, [[1, 8]])
                    }
                    )))()
                },
                "getDetail": function getDetail(v, E) {
                    return (0,
                    J.Z)((0,
                    Y.Z)().mark((function _callee3() {
                        var k, R, U, H, G;
                        return (0,
                        Y.Z)().wrap((function _callee3$(W) {
                            for (; ; )
                                switch (W.prev = W.next) {
                                case 0:
                                    return k = v.commit,
                                    R = v.state,
                                    U = v.dispatch,
                                    W.prev = 1,
                                    W.next = 4,
                                    ue.Z.getArtDetail({
                                        "blogId": null == E ? void 0 : E.artId
                                    });
                                case 4:
                                    if (1 != (null == (H = W.sent) ? void 0 : H.code)) {
                                        W.next = 12;
                                        break
                                    }
                                    return k("updateMaterialBgInfo", {
                                        "imgUrl": null === (G = H.data) || void 0 === G || null === (G = G.ext) || void 0 === G || null === (G = G.pics[0]) || void 0 === G ? void 0 : G.url,
                                        "status": "success"
                                    }),
                                    W.next = 9,
                                    U("getCount");
                                case 9:
                                    fe.dK.trackAction(Re, {
                                        "activityId": R.activityId
                                    }),
                                    W.next = 13;
                                    break;
                                case 12:
                                    console.log("查询详情失败", H);
                                case 13:
                                    W.next = 18;
                                    break;
                                case 15:
                                    W.prev = 15,
                                    W.t0 = W.catch(1),
                                    console.log("查询详情接口异常", W.t0);
                                case 18:
                                case "end":
                                    return W.stop()
                                }
                        }
                        ), _callee3, null, [[1, 15]])
                    }
                    )))()
                },
                "updateECardInfo": function updateECardInfo(v, E) {
                    return (0,
                    J.Z)((0,
                    Y.Z)().mark((function _callee4() {
                        var k, R, U, H, G;
                        return (0,
                        Y.Z)().wrap((function _callee4$(W) {
                            for (; ; )
                                switch (W.prev = W.next) {
                                case 0:
                                    if (k = v.commit,
                                    R = v.state,
                                    U = v.dispatch,
                                    H = E.code,
                                    G = E.data,
                                    1 !== H) {
                                        W.next = 11;
                                        break
                                    }
                                    if (W.t0 = null == G ? void 0 : G.artId,
                                    !W.t0) {
                                        W.next = 7;
                                        break
                                    }
                                    return W.next = 7,
                                    U("getDetail", G);
                                case 7:
                                    clearTimeout(R.timer),
                                    k("updateTimer", null),
                                    W.next = 12;
                                    break;
                                case 11:
                                    clearTimeout(R.timer);
                                case 12:
                                    G && U("intervalMsg", {
                                        "isFirstInterval": !1
                                    });
                                case 13:
                                case "end":
                                    return W.stop()
                                }
                        }
                        ), _callee4)
                    }
                    )))()
                },
                "genMaterialBgError": function genMaterialBgError(v) {
                    return (0,
                    J.Z)((0,
                    Y.Z)().mark((function _callee5() {
                        var E, k;
                        return (0,
                        Y.Z)().wrap((function _callee5$(R) {
                            for (; ; )
                                switch (R.prev = R.next) {
                                case 0:
                                    return E = v.commit,
                                    k = v.dispatch,
                                    R.next = 3,
                                    k("readMsg");
                                case 3:
                                    return R.next = 5,
                                    k("getCount");
                                case 5:
                                    E("updateMaterialBgInfo", {
                                        "imgUrl": "",
                                        "status": "fail"
                                    });
                                case 6:
                                case "end":
                                    return R.stop()
                                }
                        }
                        ), _callee5)
                    }
                    )))()
                },
                "getCount": function getCount(v) {
                    return (0,
                    J.Z)((0,
                    Y.Z)().mark((function _callee6() {
                        var E, k, R, U;
                        return (0,
                        Y.Z)().wrap((function _callee6$(H) {
                            for (; ; )
                                switch (H.prev = H.next) {
                                case 0:
                                    return E = v.commit,
                                    k = v.rootState,
                                    H.prev = 1,
                                    R = {
                                        "userId": k.base.userInfo.userId
                                    },
                                    H.next = 5,
                                    Q.Z.getTodayCount(R);
                                case 5:
                                    1 === (U = H.sent).code ? E("updateCount", U.data || 0) : console.log(U.msg, "获取次数失败"),
                                    H.next = 12;
                                    break;
                                case 9:
                                    H.prev = 9,
                                    H.t0 = H.catch(1),
                                    console.log(H.t0, "获取次数失败");
                                case 12:
                                case "end":
                                    return H.stop()
                                }
                        }
                        ), _callee6, null, [[1, 9]])
                    }
                    )))()
                },
                "getActivityInfo": function getActivityInfo(v) {
                    return (0,
                    J.Z)((0,
                    Y.Z)().mark((function _callee7() {
                        var E, k, R, U, H;
                        return (0,
                        Y.Z)().wrap((function _callee7$(G) {
                            for (; ; )
                                switch (G.prev = G.next) {
                                case 0:
                                    return E = v.commit,
                                    k = v.state,
                                    G.prev = 1,
                                    G.next = 4,
                                    Pe.getActivityInfo({
                                        "activityId": k.activityId
                                    });
                                case 4:
                                    1 == (R = G.sent).code ? (E("updateGenerateParams", null === (U = R.data) || void 0 === U ? void 0 : U.generateParams),
                                    E("updateStaticsParams", null === (H = R.data) || void 0 === H ? void 0 : H.staticsParams)) : 100004 === R.code ? (console.log(R.msg, "活动id不存在"),
                                    (0,
                                    Ce.Jx)("/error")) : (console.log(R.msg, "获取活动配置信息失败"),
                                    E("updateGenerateParams", Me),
                                    E("updateStaticsParams", Ne)),
                                    G.next = 12;
                                    break;
                                case 8:
                                    G.prev = 8,
                                    G.t0 = G.catch(1),
                                    console.log(G.t0, "获取活动配置信息失败"),
                                    (0,
                                    Ce.Jx)("/error");
                                case 12:
                                case "end":
                                    return G.stop()
                                }
                        }
                        ), _callee7, null, [[1, 8]])
                    }
                    )))()
                }
            }
              , $e = {
                "namespaced": !0,
                "state": {
                    "activityId": "",
                    "generateParams": {},
                    "staticsParams": {},
                    "materialImg": "",
                    "materialInfo": {},
                    "materialByImg": {},
                    "materialByNormal": {},
                    "materialBgInfo": {
                        "imgUrl": "",
                        "status": "init"
                    },
                    "timer": null,
                    "isRead": !1,
                    "count": 10,
                    "isStopInterval": !1
                },
                "getters": {
                    "isXCX": function isXCX(v) {
                        return v.isWeixin || v.isBaidu || v.isToutiao
                    },
                    "xcxEnv": function xcxEnv(v) {
                        return v.isWeixin ? "wx" : v.isBaidu ? "bd" : v.isToutiao ? "tt" : ""
                    }
                },
                "mutations": Ie,
                "actions": De
            }
              , Le = {
                "changeReplyCommentInfo": function changeReplyCommentInfo(v, E) {
                    v.replyCommentInfo = E
                },
                "receiveParamsFromGenerate": function receiveParamsFromGenerate(v, E) {
                    v.createInfo = {
                        "status": "loading",
                        "couldStop": !1,
                        "createParams": E.params,
                        "creator": E.creator,
                        "picGroupId": E.picGroupId
                    },
                    this.commit("artDetail/receiveParamsFromGenerate", E)
                },
                "resetCreateParams": function resetCreateParams(v, E) {
                    v.createInfo = (0,
                    H.Z)((0,
                    H.Z)({}, v.createInfo), E),
                    console.log("resetCreateParams trail", v.createInfo),
                    this.commit("artDetail/resetCreateParams", v.createInfo)
                },
                "updateCreateStatus": function updateCreateStatus(v, E) {
                    v.createInfo = (0,
                    H.Z)((0,
                    H.Z)({}, v.createInfo), {}, {
                        "status": E
                    }),
                    this.commit("artDetail/updateCreateStatus", E)
                },
                "getCreateInfo": function getCreateInfo(v) {
                    v.createInfo.status || W.Z.getItem("createInfo") && (v.createInfo = W.Z.getItem("createInfo"))
                },
                "updateTimer": function updateTimer(v, E) {
                    v.timer = E
                },
                "updateRemainTime": function updateRemainTime(v, E) {
                    v.remainTime = E
                },
                "updateIsRead": function updateIsRead(v, E) {
                    v.isRead = E
                },
                "getCreateList": function getCreateList(v) {
                    return v.trailCreateList && v.trailCreateList.length ? v.trailCreateList : W.Z.getItem("createList")
                },
                "addCreateList": function addCreateList(v, E) {
                    v.trailCreateList = v.trailCreateList.filter((function(v) {
                        return v.picGroupId !== E.picGroupId
                    }
                    )),
                    v.trailCreateList = [].concat((0,
                    G.Z)(v.trailCreateList), [(0,
                    H.Z)((0,
                    H.Z)({}, E), {}, {
                        "spmReport": !1
                    })]),
                    W.Z.setItem("createList", v.trailCreateList)
                },
                "updateCreateList": function updateCreateList(v, E) {
                    Array.isArray(E) ? v.trailCreateList = E : -1 === v.trailCreateList.findIndex((function(v) {
                        return v.picGroupId === E.picGroupId
                    }
                    )) ? this.commit("trailDetail/addCreateList", E) : v.trailCreateList = v.trailCreateList.map((function(v) {
                        return v.picGroupId === E.picGroupId ? (0,
                        H.Z)((0,
                        H.Z)({}, v), E) : v
                    }
                    ));
                    this.commit("artDetail/updateCreateList", E)
                }
            }
              , Fe = {
                "getCreateList": function getCreateList(v) {
                    var E = v.state;
                    return E.trailCreateList && E.trailCreateList.length ? E.trailCreateList : W.Z.getItem("createList")
                },
                "intervalMsg": function intervalMsg(v, E) {
                    var k = v.commit
                      , R = v.state
                      , U = v.dispatch
                      , H = E.isFirstInterval
                      , G = void 0 === H || H
                      , W = E.clkParam
                      , Z = void 0 === W ? "" : W
                      , Y = R.trailCreateList
                      , J = null == Y ? void 0 : Y.map((function(v) {
                        return v.status
                    }
                    ));
                    null != J && J.includes("success") && setTimeout((function() {
                        U("generateSuccess")
                    }
                    ), 3e3),
                    null != J && J.includes("fail") && U("generateError", Z),
                    null != J && J.includes("stopped") && U("generateStopped"),
                    (null != J && J.includes("loading") || Y.filter((function(v) {
                        return !v.spmReport
                    }
                    )).length) && (console.log("call handleTrailInterval in vuex"),
                    k("updateTimer", setTimeout((function() {
                        U("handleTrailInterval")
                    }
                    ), G ? 0 : 3e3)))
                },
                "handleTrailInterval": function handleTrailInterval(v) {
                    return (0,
                    J.Z)((0,
                    Y.Z)().mark((function _callee2() {
                        var E, k, R, U, H, G;
                        return (0,
                        Y.Z)().wrap((function _callee2$(W) {
                            for (; ; )
                                switch (W.prev = W.next) {
                                case 0:
                                    return E = v.commit,
                                    k = v.dispatch,
                                    R = v.state,
                                    W.prev = 1,
                                    W.next = 4,
                                    Q.Z.getTrailGenerateMsgMulti();
                                case 4:
                                    if (1 !== (U = W.sent).code && fe.dK.trackAction(de.o.POINTS_DETAIL_NETWORK_FAILD, {
                                        "type": 1
                                    }),
                                    U.data) {
                                        W.next = 9;
                                        break
                                    }
                                    return E("resetCreateParams", {
                                        "status": null,
                                        "couldStop": !1,
                                        "createParams": {},
                                        "creator": {}
                                    }),
                                    W.abrupt("return");
                                case 9:
                                    if (H = [],
                                    0 !== U.data.length) {
                                        W.next = 15;
                                        break
                                    }
                                    return clearTimeout(R.timer),
                                    E("updateTimer", null),
                                    E("updateCreateList", H),
                                    W.abrupt("return");
                                case 15:
                                    return G = U.data.map(function() {
                                        var v = (0,
                                        J.Z)((0,
                                        Y.Z)().mark((function _callee(v, E) {
                                            return (0,
                                            Y.Z)().wrap((function _callee$(R) {
                                                for (; ; )
                                                    switch (R.prev = R.next) {
                                                    case 0:
                                                        return R.next = 2,
                                                        k("getCreateItem", {
                                                            "createItem": v,
                                                            "listIndex": E,
                                                            "couldStop": void 0 === (null == v ? void 0 : v.couldStop) || (null == v ? void 0 : v.couldStop)
                                                        });
                                                    case 2:
                                                    case "end":
                                                        return R.stop()
                                                    }
                                            }
                                            ), _callee)
                                        }
                                        )));
                                        return function(E, k) {
                                            return v.apply(this, arguments)
                                        }
                                    }()),
                                    W.next = 18,
                                    Promise.all(G);
                                case 18:
                                    k("intervalMsg", {
                                        "isFirstInterval": !1
                                    }),
                                    W.next = 24;
                                    break;
                                case 21:
                                    W.prev = 21,
                                    W.t0 = W.catch(1),
                                    fe.dK.trackAction(de.o.POINTS_DETAIL_NETWORK_FAILD, {
                                        "type": 2
                                    });
                                case 24:
                                case "end":
                                    return W.stop()
                                }
                        }
                        ), _callee2, null, [[1, 21]])
                    }
                    )))()
                },
                "getCreateItem": function getCreateItem(v, E) {
                    var k, R, U, G, Z, Y, J, K, X, Q, ee, te, ne, re, oe, ie = v.commit, ae = v.dispatch, se = v.rootState, ce = E.createItem, le = ce.code, ue = ce.data, de = ce.couldStop;
                    if (ue) {
                        var fe = ue.picGroupId
                          , he = ue.remainTime
                          , ge = ue.aiProduceResp
                          , _e = {
                            "picGroupId": fe,
                            "remainTime": he,
                            "couldStop": de
                        };
                        switch (le) {
                        case pe.z2.SUCCESS.code:
                            var ve, ye, be;
                            if (null != ue && ue.taskId)
                                _e.createParams = (0,
                                H.Z)((0,
                                H.Z)({}, ue.requestParam), {}, {
                                    "id": ue.picGroupId,
                                    "imgList": ue.images.map((function(v) {
                                        return {
                                            "url": v,
                                            "coverImg": (0,
                                            me.Nc)(v, 800),
                                            "width": ue.requestParam.width,
                                            "height": ue.requestParam.high
                                        }
                                    }
                                    )),
                                    "templateName": ((null == ue || null === (ve = ue.requestParam) || void 0 === ve ? void 0 : ve.templateType) || "默认") + "-" + ((null == ue || null === (ye = ue.requestParam) || void 0 === ye ? void 0 : ye.templateName) || "默认风格"),
                                    "templateLevel": (null == ue || null === (be = ue.requestParam) || void 0 === be ? void 0 : be.templateLevel) || 0
                                }),
                                _e.creator = se.base.userInfo,
                                _e.status = "success",
                                _e.couldStop = !1,
                                ie("base/addTrailItem", (0,
                                H.Z)((0,
                                H.Z)({}, ge), {}, {
                                    "taskId": ue.taskId,
                                    "picGroupId": ue.picGroupId,
                                    "publishTime": (new Date).getTime()
                                }), {
                                    "root": !0
                                });
                            else if (ue && !ue.taskId) {
                                var Se, we, Ee;
                                _e.createParams = (0,
                                H.Z)((0,
                                H.Z)({}, ue.requestParam), {}, {
                                    "templateName": ((null == ue || null === (Se = ue.requestParam) || void 0 === Se ? void 0 : Se.templateType) || "默认") + "-" + ((null == ue || null === (we = ue.requestParam) || void 0 === we ? void 0 : we.templateName) || "默认风格"),
                                    "templateLevel": (null == ue || null === (Ee = ue.requestParam) || void 0 === Ee ? void 0 : Ee.templateLevel) || 0
                                }),
                                _e.creator = se.base.userInfo,
                                _e.status = "loading"
                            }
                            break;
                        case pe.z2.ERROR.code:
                            var Ce = W.Z.getItem("featureCardUUid");
                            ae("updateErrorInfo", {
                                "clkParam": "templateId:".concat(null === (k = ue.requestParam) || void 0 === k ? void 0 : k.templateId, ";promptCh:").concat(encodeURIComponent(null === (R = ue.requestParam) || void 0 === R ? void 0 : R.promptCh), ";type:1;uuid:").concat(Ce),
                                "createItem": ce
                            }),
                            _e = {
                                "picGroupId": (null == ce || null === (U = ce.data) || void 0 === U ? void 0 : U.picGroupId) || (null == ce ? void 0 : ce.picGroupId),
                                "createParams": (0,
                                H.Z)((0,
                                H.Z)({}, ue.requestParam), {}, {
                                    "templateName": ((null == ue || null === (G = ue.requestParam) || void 0 === G ? void 0 : G.templateType) || "默认") + "-" + ((null == ue || null === (Z = ue.requestParam) || void 0 === Z ? void 0 : Z.templateName) || "默认风格")
                                }) || (null == ce ? void 0 : ce.createParams),
                                "creator": se.base.userInfo,
                                "status": "fail"
                            };
                            break;
                        case pe.z2.STOPPED.code:
                            _e.createParams = (0,
                            H.Z)((0,
                            H.Z)({}, ue.requestParam), {}, {
                                "templateName": ((null == ue || null === (Y = ue.requestParam) || void 0 === Y ? void 0 : Y.templateType) || "默认") + "-" + ((null == ue || null === (J = ue.requestParam) || void 0 === J ? void 0 : J.templateName) || "默认风格")
                            }),
                            _e.creator = se.base.userInfo,
                            _e.status = "stopped";
                            break;
                        case pe.z2.TIMEOUT.code:
                            ae("updateErrorInfo", {
                                "clkParam": "type:3",
                                "createItem": ce
                            }),
                            _e = {
                                "picGroupId": (null == ce || null === (K = ce.data) || void 0 === K ? void 0 : K.picGroupId) || (null == ce ? void 0 : ce.picGroupId),
                                "createParams": (0,
                                H.Z)((0,
                                H.Z)({}, ue.requestParam), {}, {
                                    "templateName": ((null == ue || null === (X = ue.requestParam) || void 0 === X ? void 0 : X.templateType) || "默认") + "-" + ((null == ue || null === (Q = ue.requestParam) || void 0 === Q ? void 0 : Q.templateName) || "默认风格"),
                                    "templateLevel": (null == ue || null === (ee = ue.requestParam) || void 0 === ee ? void 0 : ee.templateLevel) || 0
                                }) || (null == ce ? void 0 : ce.createParams),
                                "creator": se.base.userInfo,
                                "status": "fail"
                            };
                            break;
                        default:
                            _e = {
                                "picGroupId": (null == ce || null === (te = ce.data) || void 0 === te ? void 0 : te.picGroupId) || (null == ce ? void 0 : ce.picGroupId),
                                "createParams": (0,
                                H.Z)((0,
                                H.Z)({}, ue.requestParam), {}, {
                                    "templateName": ((null == ue || null === (ne = ue.requestParam) || void 0 === ne ? void 0 : ne.templateType) || "默认") + "-" + ((null == ue || null === (re = ue.requestParam) || void 0 === re ? void 0 : re.templateName) || "默认风格"),
                                    "templateLevel": (null == ue || null === (oe = ue.requestParam) || void 0 === oe ? void 0 : oe.templateLevel) || 0
                                }) || (null == ce ? void 0 : ce.createParams),
                                "creator": se.base.userInfo,
                                "status": "fail"
                            }
                        }
                        ie("updateCreateList", _e)
                    }
                },
                "generateSuccess": function generateSuccess(v) {
                    var E, k = v.commit, R = v.state, U = v.dispatch;
                    k("getCreateList");
                    var H = null === (E = R.trailCreateList) || void 0 === E ? void 0 : E.filter((function(v) {
                        return "success" === v.status
                    }
                    ));
                    H.length && (null == H || H.forEach(function() {
                        var v = (0,
                        J.Z)((0,
                        Y.Z)().mark((function _callee3(v) {
                            var E, H, G, W, Z, J, K, X;
                            return (0,
                            Y.Z)().wrap((function _callee3$(Y) {
                                for (; ; )
                                    switch (Y.prev = Y.next) {
                                    case 0:
                                        return Y.next = 2,
                                        U("sendSpmACodes", {
                                            "createInfo": v
                                        });
                                    case 2:
                                        k("getCreateInfo"),
                                        G = R.createInfo,
                                        console.log(G, "createInfo"),
                                        G.picGroupId === v.picGroupId && k("resetCreateParams", v),
                                        W = null === (E = (0,
                                        ge.FN)().router) || void 0 === E || null === (E = E.path) || void 0 === E ? void 0 : E.includes("/detail"),
                                        Z = null === (H = (0,
                                        ge.FN)().router) || void 0 === H ? void 0 : H.params,
                                        W ? JSON.stringify(Z).includes(null == v || null === (J = v.createParams) || void 0 === J ? void 0 : J.id) ? U("readMsg", v.picGroupId) : getGenerateMsgInfo("SUCCESS", {
                                            "name": "detail",
                                            "id": null == v || null === (K = v.createParams) || void 0 === K ? void 0 : K.id,
                                            "type": "taskId"
                                        }, v.picGroupId) : getGenerateMsgInfo("SUCCESS", {
                                            "name": "detail",
                                            "id": null == v || null === (X = v.createParams) || void 0 === X ? void 0 : X.id,
                                            "type": "taskId"
                                        }, v.picGroupId);
                                    case 9:
                                    case "end":
                                        return Y.stop()
                                    }
                            }
                            ), _callee3)
                        }
                        )));
                        return function(E) {
                            return v.apply(this, arguments)
                        }
                    }()))
                },
                "generateStopped": function generateStopped(v) {
                    return (0,
                    J.Z)((0,
                    Y.Z)().mark((function _callee5() {
                        var E, k, R, U, H;
                        return (0,
                        Y.Z)().wrap((function _callee5$(G) {
                            for (; ; )
                                switch (G.prev = G.next) {
                                case 0:
                                    if (k = v.commit,
                                    R = v.state,
                                    U = v.dispatch,
                                    k("getCreateList"),
                                    (H = null === (E = R.trailCreateList) || void 0 === E ? void 0 : E.filter((function(v) {
                                        return ["stopScoreError", "stopped"].includes(v.status)
                                    }
                                    ))).length) {
                                        G.next = 5;
                                        break
                                    }
                                    return G.abrupt("return");
                                case 5:
                                    null == H || H.forEach(function() {
                                        var v = (0,
                                        J.Z)((0,
                                        Y.Z)().mark((function _callee4(v) {
                                            return (0,
                                            Y.Z)().wrap((function _callee4$(E) {
                                                for (; ; )
                                                    switch (E.prev = E.next) {
                                                    case 0:
                                                        k("getCreateInfo"),
                                                        R.createInfo.picGroupId === v.picGroupId && k("resetCreateParams", v),
                                                        U("readMsg", v.picGroupId);
                                                    case 4:
                                                    case "end":
                                                        return E.stop()
                                                    }
                                            }
                                            ), _callee4)
                                        }
                                        )));
                                        return function(E) {
                                            return v.apply(this, arguments)
                                        }
                                    }());
                                case 6:
                                case "end":
                                    return G.stop()
                                }
                        }
                        ), _callee5)
                    }
                    )))()
                },
                "generateError": function generateError(v) {
                    var E, k = v.state, R = v.dispatch, U = v.commit, G = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
                    U("getCreateList");
                    var W = null === (E = k.trailCreateList) || void 0 === E ? void 0 : E.filter((function(v) {
                        return "fail" === v.status
                    }
                    ));
                    W.length && (null == W || W.forEach(function() {
                        var v = (0,
                        J.Z)((0,
                        Y.Z)().mark((function _callee6(v) {
                            var E, W, Z, J, K, X, Q, ee;
                            return (0,
                            Y.Z)().wrap((function _callee6$(Y) {
                                for (; ; )
                                    switch (Y.prev = Y.next) {
                                    case 0:
                                        if (U("getCreateInfo"),
                                        (W = k.createInfo).picGroupId === v.picGroupId && U("resetCreateParams", v),
                                        !v.spmReport) {
                                            Y.next = 5;
                                            break
                                        }
                                        return Y.abrupt("return");
                                    case 5:
                                        Z = "ERROR",
                                        G.includes("type:1") ? Z = "ERROR" : G.includes("type:3") && (Z = "TIMEOUT"),
                                        (null === (E = (0,
                                        ge.FN)().router) || void 0 === E || null === (E = E.path) || void 0 === E ? void 0 : E.includes("/imgLoading")) ? W.picGroupId === v.picGroupId && (ne.Y.emit("getCreateDetail"),
                                        !G.includes("type:2") && R("readMsg", v.picGroupId)) : (K = v.createParams,
                                        X = "byText",
                                        2 === K.type && (X = "200" === K.templateTypeCode ? "byCommodity" : "202" === K.templateTypeCode ? "byPersonBg" : "byPortrait"),
                                        5 === K.type && (X = "byHDZoom"),
                                        1 === K.type && (X = "byImg"),
                                        Q = encodeURIComponent(JSON.stringify((0,
                                        H.Z)((0,
                                        H.Z)({}, K), {}, {
                                            "genType": X,
                                            "imgUrl": K.imageUrl
                                        }))),
                                        ee = null === (J = pe.eA.find((function(v) {
                                            return v.id === X
                                        }
                                        ))) || void 0 === J ? void 0 : J.newPath,
                                        getGenerateMsgInfo(Z, {
                                            "name": ee,
                                            "genObj": Q
                                        }, v.picGroupId)),
                                        U("updateCreateList", (0,
                                        H.Z)((0,
                                        H.Z)({}, v), {}, {
                                            "spmReport": !0
                                        }));
                                    case 10:
                                    case "end":
                                        return Y.stop()
                                    }
                            }
                            ), _callee6)
                        }
                        )));
                        return function(E) {
                            return v.apply(this, arguments)
                        }
                    }()))
                },
                "readMsg": function readMsg(v, E) {
                    return (0,
                    J.Z)((0,
                    Y.Z)().mark((function _callee7() {
                        var k, R, U, H;
                        return (0,
                        Y.Z)().wrap((function _callee7$(G) {
                            for (; ; )
                                switch (G.prev = G.next) {
                                case 0:
                                    return k = v.commit,
                                    R = v.state,
                                    G.prev = 1,
                                    G.next = 4,
                                    Q.Z.readGenerateMsg({
                                        "picGroupIds": [E]
                                    });
                                case 4:
                                    1 === (U = G.sent).code ? (console.log("消息已读成功"),
                                    k("getCreateList"),
                                    H = R.trailCreateList.filter((function(v) {
                                        return v.picGroupId !== E
                                    }
                                    )),
                                    k("updateCreateList", H)) : console.log("消息已读失败", null == U ? void 0 : U.msg),
                                    G.next = 11;
                                    break;
                                case 8:
                                    G.prev = 8,
                                    G.t0 = G.catch(1),
                                    console.log("消息已读接口异常", G.t0);
                                case 11:
                                case "end":
                                    return G.stop()
                                }
                        }
                        ), _callee7, null, [[1, 8]])
                    }
                    )))()
                },
                "updateErrorInfo": function updateErrorInfo(v, E) {
                    var k, R = v.dispatch, U = E.clkParam, H = E.createItem;
                    W.Z.removeItem("art_".concat(null == H || null === (k = H.data) || void 0 === k ? void 0 : k.picGroupId, "_startTime")),
                    R("base/getTrailCount", {}, {
                        "root": !0
                    }),
                    (0,
                    _e.vX)({
                        "acode": de.o.GENERATE_ERROR,
                        "clkParam": U
                    })
                },
                "sendSpmACodes": function sendSpmACodes(v, E) {
                    var k, R, U, G, Z, Y, J, K, X, Q, ee, te, ne, re, oe, ie, ae, se = v.commit, ce = v.rootState, le = v.dispatch, ue = E.createInfo;
                    if (!ue.spmReport && !0 !== location.href.includes("imgLoading")) {
                        ce.base.isLogin && (console.log("merge trail when login", W.Z.getItem("trailList")),
                        le("base/mergeArt", W.Z.getItem("trailList"), {
                            "root": !0
                        })),
                        se("updateCreateList", (0,
                        H.Z)((0,
                        H.Z)({}, ue), {}, {
                            "spmReport": !0
                        }));
                        var pe = W.Z.getItem("art_".concat(ue.picGroupId, "_startTime"))
                          , fe = 2;
                        if (1 === (null == ue || null === (k = ue.createParams) || void 0 === k ? void 0 : k.type))
                            fe = 1;
                        else if (2 === (null == ue || null === (R = ue.createParams) || void 0 === R ? void 0 : R.type)) {
                            var he, me, ge;
                            "200" === (null == ue || null === (he = ue.createParams) || void 0 === he ? void 0 : he.templateTypeCode) ? fe = 3 : "201" === (null == ue || null === (me = ue.createParams) || void 0 === me ? void 0 : me.templateTypeCode) ? fe = 4 : "202" == (null == ue || null === (ge = ue.createParams) || void 0 === ge ? void 0 : ge.templateTypeCode) && (fe = 9)
                        } else
                            5 == (null == ue || null === (U = ue.createParams) || void 0 === U ? void 0 : U.type) && (fe = 8);
                        var ve, ye = W.Z.getItem("featureCardUUid"), be = ue.createParams.templateLevel > 0 ? 1 : 2, Se = (null == ue || null === (G = ue.createParams) || void 0 === G ? void 0 : G.imageUrl) || "null", we = (null == ue || null === (Z = ue.createParams) || void 0 === Z ? void 0 : Z.backImgUrl) || "null", Ee = (null == ue || null === (Y = ue.createParams) || void 0 === Y ? void 0 : Y.subType) || 1;
                        Se = Se.replace(/^https?:\/\//, ""),
                        we = we.replace(/^https?:\/\//, ""),
                        ve = "templateId:".concat(null == ue ? void 0 : ue.createParams.templateId, ";templateType:").concat(null == ue || null === (J = ue.createParams) || void 0 === J ? void 0 : J.templateType, ";imageCount:").concat(null == ue || null === (K = ue.createParams) || void 0 === K ? void 0 : K.imageCount, ";") + "scale:".concat(null == ue || null === (X = ue.createParams) || void 0 === X ? void 0 : X.widthProp, ":").concat(null == ue || null === (Q = ue.createParams) || void 0 === Q ? void 0 : Q.highProp, ";") + "high:".concat(null == ue || null === (ee = ue.createParams) || void 0 === ee ? void 0 : ee.high, ";width:").concat(null == ue || null === (te = ue.createParams) || void 0 === te ? void 0 : te.width, ";promptCh:").concat(encodeURIComponent((null == ue || null === (ne = ue.createParams) || void 0 === ne ? void 0 : ne.promptCh) || "null"), ";userId:").concat((null == ue || null === (re = ue.creator) || void 0 === re ? void 0 : re.userId) || "null", ";generateType:").concat(fe, ";vip:").concat(be, ";imageUrl:").concat(Se, ";backImgUrl:").concat(we, ";uuid:").concat(ye, ";kind:").concat(Ee),
                        1 === fe || 2 === fe ? (0,
                        _e.vX)({
                            "acode": de.o.GENERATE_SUCCESS,
                            "clkParam": ve
                        }) : 3 !== fe && 4 !== fe && 8 != fe && 9 != fe || (0,
                        _e.vX)({
                            "acode": de.o.CREATE_Commodity_Portrait_SUCCESS,
                            "clkParam": ve
                        }),
                        (0,
                        _e.vX)({
                            "acode": 10976,
                            "clkParam": "requestId:".concat(null == pe ? void 0 : pe.requestId, ";timeDiff:").concat((new Date).getTime() - +(null == pe ? void 0 : pe.time), ";").concat(ve)
                        }),
                        W.Z.removeItem("art_".concat(ue.picGroupId, "_startTime"));
                        var Ce = JSON.parse(W.Z.getItem("newSizeMap"))
                          , Te = (null == ue || null === (oe = ue.createParams) || void 0 === oe ? void 0 : oe.widthProp) + ":" + (null == ue || null === (ie = ue.createParams) || void 0 === ie ? void 0 : ie.highProp)
                          , xe = -1 !== Ce.findIndex((function(v) {
                            return v.size === Te && "原图比例" === v.label
                        }
                        ));
                        (null == ue || null === (ae = ue.createParams) || void 0 === ae ? void 0 : ae.imageUrl) && xe && (0,
                        _e.vX)({
                            "acode": de.o.USE_ORIGIN_SIZE
                        }),
                        W.Z.getItem("isGenerateSame") && (W.Z.removeItem("isGenerateSame"),
                        (0,
                        _e.vX)({
                            "acode": de.o.GENERATE_SAME
                        }))
                    }
                }
            }
              , je = k(4796)
              , Be = {
                "namespaced": !0,
                "state": {
                    "replyCommentInfo": {
                        "replyInfo": {
                            "level": 1,
                            "commentInfo": null
                        },
                        "vm": null
                    },
                    "createInfo": {
                        "status": null,
                        "createParams": {},
                        "creator": {},
                        "picGroupId": ""
                    },
                    "trailCreateList": [],
                    "timer": null,
                    "remainTime": 0,
                    "isRead": !1
                },
                "getters": k.n(je)(),
                "mutations": Le,
                "actions": Fe
            }
              , Ue = (0,
            R.MT)({
                "modules": {
                    "base": oe,
                    "artDetail": be,
                    "trailDetail": Be,
                    "generate": ce,
                    "homeSearch": we,
                    "textGenerate": Ae,
                    "eCard": $e
                }
            })
        },
        "9171": function() {},
        "4796": function() {},
        "9742": function(v, E) {
            "use strict";
            E.b$ = function toByteArray(v) {
                var E, k, H = getLens(v), G = H[0], W = H[1], Z = new U(function _byteLength(v, E, k) {
                    return 3 * (E + k) / 4 - k
                }(0, G, W)), Y = 0, J = W > 0 ? G - 4 : G;
                for (k = 0; k < J; k += 4)
                    E = R[v.charCodeAt(k)] << 18 | R[v.charCodeAt(k + 1)] << 12 | R[v.charCodeAt(k + 2)] << 6 | R[v.charCodeAt(k + 3)],
                    Z[Y++] = E >> 16 & 255,
                    Z[Y++] = E >> 8 & 255,
                    Z[Y++] = 255 & E;
                2 === W && (E = R[v.charCodeAt(k)] << 2 | R[v.charCodeAt(k + 1)] >> 4,
                Z[Y++] = 255 & E);
                1 === W && (E = R[v.charCodeAt(k)] << 10 | R[v.charCodeAt(k + 1)] << 4 | R[v.charCodeAt(k + 2)] >> 2,
                Z[Y++] = E >> 8 & 255,
                Z[Y++] = 255 & E);
                return Z
            }
            ,
            E.JQ = function fromByteArray(v) {
                for (var E, R = v.length, U = R % 3, H = [], G = 16383, W = 0, Z = R - U; W < Z; W += G)
                    H.push(encodeChunk(v, W, W + G > Z ? Z : W + G));
                1 === U ? (E = v[R - 1],
                H.push(k[E >> 2] + k[E << 4 & 63] + "==")) : 2 === U && (E = (v[R - 2] << 8) + v[R - 1],
                H.push(k[E >> 10] + k[E >> 4 & 63] + k[E << 2 & 63] + "="));
                return H.join("")
            }
            ;
            for (var k = [], R = [], U = "undefined" != typeof Uint8Array ? Uint8Array : Array, H = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", G = 0; G < 64; ++G)
                k[G] = H[G],
                R[H.charCodeAt(G)] = G;
            function getLens(v) {
                var E = v.length;
                if (E % 4 > 0)
                    throw new Error("Invalid string. Length must be a multiple of 4");
                var k = v.indexOf("=");
                return -1 === k && (k = E),
                [k, k === E ? 0 : 4 - k % 4]
            }
            function encodeChunk(v, E, R) {
                for (var U, H, G = [], W = E; W < R; W += 3)
                    U = (v[W] << 16 & 16711680) + (v[W + 1] << 8 & 65280) + (255 & v[W + 2]),
                    G.push(k[(H = U) >> 18 & 63] + k[H >> 12 & 63] + k[H >> 6 & 63] + k[63 & H]);
                return G.join("")
            }
            R["-".charCodeAt(0)] = 62,
            R["_".charCodeAt(0)] = 63
        },
        "640": function(v, E, k) {
            "use strict";
            var R = k(1742)
              , U = {
                "text/plain": "Text",
                "text/html": "Url",
                "default": "Text"
            };
            v.exports = function copy(v, E) {
                var k, H, G, W, Z, Y, J = !1;
                E || (E = {}),
                k = E.debug || !1;
                try {
                    if (G = R(),
                    W = document.createRange(),
                    Z = document.getSelection(),
                    (Y = document.createElement("span")).textContent = v,
                    Y.ariaHidden = "true",
                    Y.style.all = "unset",
                    Y.style.position = "fixed",
                    Y.style.top = 0,
                    Y.style.clip = "rect(0, 0, 0, 0)",
                    Y.style.whiteSpace = "pre",
                    Y.style.webkitUserSelect = "text",
                    Y.style.MozUserSelect = "text",
                    Y.style.msUserSelect = "text",
                    Y.style.userSelect = "text",
                    Y.addEventListener("copy", (function(R) {
                        if (R.stopPropagation(),
                        E.format)
                            if (R.preventDefault(),
                            void 0 === R.clipboardData) {
                                k && console.warn("unable to use e.clipboardData"),
                                k && console.warn("trying IE specific stuff"),
                                window.clipboardData.clearData();
                                var H = U[E.format] || U.default;
                                window.clipboardData.setData(H, v)
                            } else
                                R.clipboardData.clearData(),
                                R.clipboardData.setData(E.format, v);
                        E.onCopy && (R.preventDefault(),
                        E.onCopy(R.clipboardData))
                    }
                    )),
                    document.body.appendChild(Y),
                    W.selectNodeContents(Y),
                    Z.addRange(W),
                    !document.execCommand("copy"))
                        throw new Error("copy command was unsuccessful");
                    J = !0
                } catch (R) {
                    k && console.error("unable to copy using execCommand: ", R),
                    k && console.warn("trying IE specific stuff");
                    try {
                        window.clipboardData.setData(E.format || "text", v),
                        E.onCopy && E.onCopy(window.clipboardData),
                        J = !0
                    } catch (R) {
                        k && console.error("unable to copy using clipboardData: ", R),
                        k && console.error("falling back to prompt"),
                        H = function format(v) {
                            var E = (/mac os x/i.test(navigator.userAgent) ? "⌘" : "Ctrl") + "+C";
                            return v.replace(/#{\s*key\s*}/g, E)
                        }("message"in E ? E.message : "Copy to clipboard: #{key}, Enter"),
                        window.prompt(H, v)
                    }
                } finally {
                    Z && ("function" == typeof Z.removeRange ? Z.removeRange(W) : Z.removeAllRanges()),
                    Y && document.body.removeChild(Y),
                    G()
                }
                return J
            }
        },
        "4020": function(v) {
            "use strict";
            var E = "%[a-f0-9]{2}"
              , k = new RegExp("(" + E + ")|([^%]+?)","gi")
              , R = new RegExp("(" + E + ")+","gi");
            function decodeComponents(v, E) {
                try {
                    return [decodeURIComponent(v.join(""))]
                } catch (v) {}
                if (1 === v.length)
                    return v;
                E = E || 1;
                var k = v.slice(0, E)
                  , R = v.slice(E);
                return Array.prototype.concat.call([], decodeComponents(k), decodeComponents(R))
            }
            function decode(v) {
                try {
                    return decodeURIComponent(v)
                } catch (U) {
                    for (var E = v.match(k) || [], R = 1; R < E.length; R++)
                        E = (v = decodeComponents(E, R).join("")).match(k) || [];
                    return v
                }
            }
            v.exports = function(v) {
                if ("string" != typeof v)
                    throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof v + "`");
                try {
                    return v = v.replace(/\+/g, " "),
                    decodeURIComponent(v)
                } catch (E) {
                    return function customDecodeURIComponent(v) {
                        for (var E = {
                            "%FE%FF": "��",
                            "%FF%FE": "��"
                        }, k = R.exec(v); k; ) {
                            try {
                                E[k[0]] = decodeURIComponent(k[0])
                            } catch (v) {
                                var U = decode(k[0]);
                                U !== k[0] && (E[k[0]] = U)
                            }
                            k = R.exec(v)
                        }
                        E["%C2"] = "�";
                        for (var H = Object.keys(E), G = 0; G < H.length; G++) {
                            var W = H[G];
                            v = v.replace(new RegExp(W,"g"), E[W])
                        }
                        return v
                    }(v)
                }
            }
        },
        "2806": function(v) {
            "use strict";
            v.exports = function(v, E) {
                for (var k = {}, R = Object.keys(v), U = Array.isArray(E), H = 0; H < R.length; H++) {
                    var G = R[H]
                      , W = v[G];
                    (U ? -1 !== E.indexOf(G) : E(G, W, v)) && (k[G] = W)
                }
                return k
            }
        },
        "840": function(v, E, k) {
            var R;
            !function(U, H, G, W) {
                "use strict";
                var Z, Y = ["", "webkit", "Moz", "MS", "ms", "o"], J = H.createElement("div"), K = "function", X = Math.round, Q = Math.abs, ee = Date.now;
                function setTimeoutContext(v, E, k) {
                    return setTimeout(bindFn(v, k), E)
                }
                function invokeArrayArg(v, E, k) {
                    return !!Array.isArray(v) && (each(v, k[E], k),
                    !0)
                }
                function each(v, E, k) {
                    var R;
                    if (v)
                        if (v.forEach)
                            v.forEach(E, k);
                        else if (v.length !== W)
                            for (R = 0; R < v.length; )
                                E.call(k, v[R], R, v),
                                R++;
                        else
                            for (R in v)
                                v.hasOwnProperty(R) && E.call(k, v[R], R, v)
                }
                function deprecate(v, E, k) {
                    var R = "DEPRECATED METHOD: " + E + "\n" + k + " AT \n";
                    return function() {
                        var E = new Error("get-stack-trace")
                          , k = E && E.stack ? E.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace"
                          , H = U.console && (U.console.warn || U.console.log);
                        return H && H.call(U.console, R, k),
                        v.apply(this, arguments)
                    }
                }
                Z = "function" != typeof Object.assign ? function assign(v) {
                    if (v === W || null === v)
                        throw new TypeError("Cannot convert undefined or null to object");
                    for (var E = Object(v), k = 1; k < arguments.length; k++) {
                        var R = arguments[k];
                        if (R !== W && null !== R)
                            for (var U in R)
                                R.hasOwnProperty(U) && (E[U] = R[U])
                    }
                    return E
                }
                : Object.assign;
                var te = deprecate((function extend(v, E, k) {
                    for (var R = Object.keys(E), U = 0; U < R.length; )
                        (!k || k && v[R[U]] === W) && (v[R[U]] = E[R[U]]),
                        U++;
                    return v
                }
                ), "extend", "Use `assign`.")
                  , ne = deprecate((function merge(v, E) {
                    return te(v, E, !0)
                }
                ), "merge", "Use `assign`.");
                function inherit(v, E, k) {
                    var R, U = E.prototype;
                    (R = v.prototype = Object.create(U)).constructor = v,
                    R._super = U,
                    k && Z(R, k)
                }
                function bindFn(v, E) {
                    return function boundFn() {
                        return v.apply(E, arguments)
                    }
                }
                function boolOrFn(v, E) {
                    return typeof v == K ? v.apply(E && E[0] || W, E) : v
                }
                function ifUndefined(v, E) {
                    return v === W ? E : v
                }
                function addEventListeners(v, E, k) {
                    each(splitStr(E), (function(E) {
                        v.addEventListener(E, k, !1)
                    }
                    ))
                }
                function removeEventListeners(v, E, k) {
                    each(splitStr(E), (function(E) {
                        v.removeEventListener(E, k, !1)
                    }
                    ))
                }
                function hasParent(v, E) {
                    for (; v; ) {
                        if (v == E)
                            return !0;
                        v = v.parentNode
                    }
                    return !1
                }
                function inStr(v, E) {
                    return v.indexOf(E) > -1
                }
                function splitStr(v) {
                    return v.trim().split(/\s+/g)
                }
                function inArray(v, E, k) {
                    if (v.indexOf && !k)
                        return v.indexOf(E);
                    for (var R = 0; R < v.length; ) {
                        if (k && v[R][k] == E || !k && v[R] === E)
                            return R;
                        R++
                    }
                    return -1
                }
                function toArray(v) {
                    return Array.prototype.slice.call(v, 0)
                }
                function uniqueArray(v, E, k) {
                    for (var R = [], U = [], H = 0; H < v.length; ) {
                        var G = E ? v[H][E] : v[H];
                        inArray(U, G) < 0 && R.push(v[H]),
                        U[H] = G,
                        H++
                    }
                    return k && (R = E ? R.sort((function sortUniqueArray(v, k) {
                        return v[E] > k[E]
                    }
                    )) : R.sort()),
                    R
                }
                function prefixed(v, E) {
                    for (var k, R, U = E[0].toUpperCase() + E.slice(1), H = 0; H < Y.length; ) {
                        if ((R = (k = Y[H]) ? k + U : E)in v)
                            return R;
                        H++
                    }
                    return W
                }
                var re = 1;
                function getWindowForElement(v) {
                    var E = v.ownerDocument || v;
                    return E.defaultView || E.parentWindow || U
                }
                var oe = "ontouchstart"in U
                  , ie = prefixed(U, "PointerEvent") !== W
                  , ae = oe && /mobile|tablet|ip(ad|hone|od)|android/i.test(navigator.userAgent)
                  , se = "touch"
                  , ce = "mouse"
                  , le = 25
                  , ue = 1
                  , de = 4
                  , pe = 8
                  , fe = 1
                  , he = 2
                  , me = 4
                  , ge = 8
                  , _e = 16
                  , ve = he | me
                  , ye = ge | _e
                  , be = ve | ye
                  , Se = ["x", "y"]
                  , we = ["clientX", "clientY"];
                function Input(v, E) {
                    var k = this;
                    this.manager = v,
                    this.callback = E,
                    this.element = v.element,
                    this.target = v.options.inputTarget,
                    this.domHandler = function(E) {
                        boolOrFn(v.options.enable, [v]) && k.handler(E)
                    }
                    ,
                    this.init()
                }
                function inputHandler(v, E, k) {
                    var R = k.pointers.length
                      , U = k.changedPointers.length
                      , H = E & ue && R - U == 0
                      , G = E & (de | pe) && R - U == 0;
                    k.isFirst = !!H,
                    k.isFinal = !!G,
                    H && (v.session = {}),
                    k.eventType = E,
                    function computeInputData(v, E) {
                        var k = v.session
                          , R = E.pointers
                          , U = R.length;
                        k.firstInput || (k.firstInput = simpleCloneInputData(E));
                        U > 1 && !k.firstMultiple ? k.firstMultiple = simpleCloneInputData(E) : 1 === U && (k.firstMultiple = !1);
                        var H = k.firstInput
                          , G = k.firstMultiple
                          , Z = G ? G.center : H.center
                          , Y = E.center = getCenter(R);
                        E.timeStamp = ee(),
                        E.deltaTime = E.timeStamp - H.timeStamp,
                        E.angle = getAngle(Z, Y),
                        E.distance = getDistance(Z, Y),
                        function computeDeltaXY(v, E) {
                            var k = E.center
                              , R = v.offsetDelta || {}
                              , U = v.prevDelta || {}
                              , H = v.prevInput || {};
                            E.eventType !== ue && H.eventType !== de || (U = v.prevDelta = {
                                "x": H.deltaX || 0,
                                "y": H.deltaY || 0
                            },
                            R = v.offsetDelta = {
                                "x": k.x,
                                "y": k.y
                            });
                            E.deltaX = U.x + (k.x - R.x),
                            E.deltaY = U.y + (k.y - R.y)
                        }(k, E),
                        E.offsetDirection = getDirection(E.deltaX, E.deltaY);
                        var J = getVelocity(E.deltaTime, E.deltaX, E.deltaY);
                        E.overallVelocityX = J.x,
                        E.overallVelocityY = J.y,
                        E.overallVelocity = Q(J.x) > Q(J.y) ? J.x : J.y,
                        E.scale = G ? function getScale(v, E) {
                            return getDistance(E[0], E[1], we) / getDistance(v[0], v[1], we)
                        }(G.pointers, R) : 1,
                        E.rotation = G ? function getRotation(v, E) {
                            return getAngle(E[1], E[0], we) + getAngle(v[1], v[0], we)
                        }(G.pointers, R) : 0,
                        E.maxPointers = k.prevInput ? E.pointers.length > k.prevInput.maxPointers ? E.pointers.length : k.prevInput.maxPointers : E.pointers.length,
                        function computeIntervalInputData(v, E) {
                            var k, R, U, H, G = v.lastInterval || E, Z = E.timeStamp - G.timeStamp;
                            if (E.eventType != pe && (Z > le || G.velocity === W)) {
                                var Y = E.deltaX - G.deltaX
                                  , J = E.deltaY - G.deltaY
                                  , K = getVelocity(Z, Y, J);
                                R = K.x,
                                U = K.y,
                                k = Q(K.x) > Q(K.y) ? K.x : K.y,
                                H = getDirection(Y, J),
                                v.lastInterval = E
                            } else
                                k = G.velocity,
                                R = G.velocityX,
                                U = G.velocityY,
                                H = G.direction;
                            E.velocity = k,
                            E.velocityX = R,
                            E.velocityY = U,
                            E.direction = H
                        }(k, E);
                        var K = v.element;
                        hasParent(E.srcEvent.target, K) && (K = E.srcEvent.target);
                        E.target = K
                    }(v, k),
                    v.emit("hammer.input", k),
                    v.recognize(k),
                    v.session.prevInput = k
                }
                function simpleCloneInputData(v) {
                    for (var E = [], k = 0; k < v.pointers.length; )
                        E[k] = {
                            "clientX": X(v.pointers[k].clientX),
                            "clientY": X(v.pointers[k].clientY)
                        },
                        k++;
                    return {
                        "timeStamp": ee(),
                        "pointers": E,
                        "center": getCenter(E),
                        "deltaX": v.deltaX,
                        "deltaY": v.deltaY
                    }
                }
                function getCenter(v) {
                    var E = v.length;
                    if (1 === E)
                        return {
                            "x": X(v[0].clientX),
                            "y": X(v[0].clientY)
                        };
                    for (var k = 0, R = 0, U = 0; U < E; )
                        k += v[U].clientX,
                        R += v[U].clientY,
                        U++;
                    return {
                        "x": X(k / E),
                        "y": X(R / E)
                    }
                }
                function getVelocity(v, E, k) {
                    return {
                        "x": E / v || 0,
                        "y": k / v || 0
                    }
                }
                function getDirection(v, E) {
                    return v === E ? fe : Q(v) >= Q(E) ? v < 0 ? he : me : E < 0 ? ge : _e
                }
                function getDistance(v, E, k) {
                    k || (k = Se);
                    var R = E[k[0]] - v[k[0]]
                      , U = E[k[1]] - v[k[1]];
                    return Math.sqrt(R * R + U * U)
                }
                function getAngle(v, E, k) {
                    k || (k = Se);
                    var R = E[k[0]] - v[k[0]]
                      , U = E[k[1]] - v[k[1]];
                    return 180 * Math.atan2(U, R) / Math.PI
                }
                Input.prototype = {
                    "handler": function() {},
                    "init": function() {
                        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler),
                        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler),
                        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler)
                    },
                    "destroy": function() {
                        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler),
                        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler),
                        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler)
                    }
                };
                var Ee = {
                    "mousedown": ue,
                    "mousemove": 2,
                    "mouseup": de
                }
                  , Ce = "mousedown"
                  , Te = "mousemove mouseup";
                function MouseInput() {
                    this.evEl = Ce,
                    this.evWin = Te,
                    this.pressed = !1,
                    Input.apply(this, arguments)
                }
                inherit(MouseInput, Input, {
                    "handler": function MEhandler(v) {
                        var E = Ee[v.type];
                        E & ue && 0 === v.button && (this.pressed = !0),
                        2 & E && 1 !== v.which && (E = de),
                        this.pressed && (E & de && (this.pressed = !1),
                        this.callback(this.manager, E, {
                            "pointers": [v],
                            "changedPointers": [v],
                            "pointerType": ce,
                            "srcEvent": v
                        }))
                    }
                });
                var xe = {
                    "pointerdown": ue,
                    "pointermove": 2,
                    "pointerup": de,
                    "pointercancel": pe,
                    "pointerout": pe
                }
                  , Ae = {
                    "2": se,
                    "3": "pen",
                    "4": ce,
                    "5": "kinect"
                }
                  , Ie = "pointerdown"
                  , ke = "pointermove pointerup pointercancel";
                function PointerEventInput() {
                    this.evEl = Ie,
                    this.evWin = ke,
                    Input.apply(this, arguments),
                    this.store = this.manager.session.pointerEvents = []
                }
                U.MSPointerEvent && !U.PointerEvent && (Ie = "MSPointerDown",
                ke = "MSPointerMove MSPointerUp MSPointerCancel"),
                inherit(PointerEventInput, Input, {
                    "handler": function PEhandler(v) {
                        var E = this.store
                          , k = !1
                          , R = v.type.toLowerCase().replace("ms", "")
                          , U = xe[R]
                          , H = Ae[v.pointerType] || v.pointerType
                          , G = H == se
                          , W = inArray(E, v.pointerId, "pointerId");
                        U & ue && (0 === v.button || G) ? W < 0 && (E.push(v),
                        W = E.length - 1) : U & (de | pe) && (k = !0),
                        W < 0 || (E[W] = v,
                        this.callback(this.manager, U, {
                            "pointers": E,
                            "changedPointers": [v],
                            "pointerType": H,
                            "srcEvent": v
                        }),
                        k && E.splice(W, 1))
                    }
                });
                var Oe = {
                    "touchstart": ue,
                    "touchmove": 2,
                    "touchend": de,
                    "touchcancel": pe
                };
                function SingleTouchInput() {
                    this.evTarget = "touchstart",
                    this.evWin = "touchstart touchmove touchend touchcancel",
                    this.started = !1,
                    Input.apply(this, arguments)
                }
                function normalizeSingleTouches(v, E) {
                    var k = toArray(v.touches)
                      , R = toArray(v.changedTouches);
                    return E & (de | pe) && (k = uniqueArray(k.concat(R), "identifier", !0)),
                    [k, R]
                }
                inherit(SingleTouchInput, Input, {
                    "handler": function TEhandler(v) {
                        var E = Oe[v.type];
                        if (E === ue && (this.started = !0),
                        this.started) {
                            var k = normalizeSingleTouches.call(this, v, E);
                            E & (de | pe) && k[0].length - k[1].length == 0 && (this.started = !1),
                            this.callback(this.manager, E, {
                                "pointers": k[0],
                                "changedPointers": k[1],
                                "pointerType": se,
                                "srcEvent": v
                            })
                        }
                    }
                });
                var Pe = {
                    "touchstart": ue,
                    "touchmove": 2,
                    "touchend": de,
                    "touchcancel": pe
                }
                  , Re = "touchstart touchmove touchend touchcancel";
                function TouchInput() {
                    this.evTarget = Re,
                    this.targetIds = {},
                    Input.apply(this, arguments)
                }
                function getTouches(v, E) {
                    var k = toArray(v.touches)
                      , R = this.targetIds;
                    if (E & (2 | ue) && 1 === k.length)
                        return R[k[0].identifier] = !0,
                        [k, k];
                    var U, H, G = toArray(v.changedTouches), W = [], Z = this.target;
                    if (H = k.filter((function(v) {
                        return hasParent(v.target, Z)
                    }
                    )),
                    E === ue)
                        for (U = 0; U < H.length; )
                            R[H[U].identifier] = !0,
                            U++;
                    for (U = 0; U < G.length; )
                        R[G[U].identifier] && W.push(G[U]),
                        E & (de | pe) && delete R[G[U].identifier],
                        U++;
                    return W.length ? [uniqueArray(H.concat(W), "identifier", !0), W] : void 0
                }
                inherit(TouchInput, Input, {
                    "handler": function MTEhandler(v) {
                        var E = Pe[v.type]
                          , k = getTouches.call(this, v, E);
                        k && this.callback(this.manager, E, {
                            "pointers": k[0],
                            "changedPointers": k[1],
                            "pointerType": se,
                            "srcEvent": v
                        })
                    }
                });
                var Me = 2500;
                function TouchMouseInput() {
                    Input.apply(this, arguments);
                    var v = bindFn(this.handler, this);
                    this.touch = new TouchInput(this.manager,v),
                    this.mouse = new MouseInput(this.manager,v),
                    this.primaryTouch = null,
                    this.lastTouches = []
                }
                function recordTouches(v, E) {
                    v & ue ? (this.primaryTouch = E.changedPointers[0].identifier,
                    setLastTouch.call(this, E)) : v & (de | pe) && setLastTouch.call(this, E)
                }
                function setLastTouch(v) {
                    var E = v.changedPointers[0];
                    if (E.identifier === this.primaryTouch) {
                        var k = {
                            "x": E.clientX,
                            "y": E.clientY
                        };
                        this.lastTouches.push(k);
                        var R = this.lastTouches;
                        setTimeout((function() {
                            var v = R.indexOf(k);
                            v > -1 && R.splice(v, 1)
                        }
                        ), Me)
                    }
                }
                function isSyntheticEvent(v) {
                    for (var E = v.srcEvent.clientX, k = v.srcEvent.clientY, R = 0; R < this.lastTouches.length; R++) {
                        var U = this.lastTouches[R]
                          , H = Math.abs(E - U.x)
                          , G = Math.abs(k - U.y);
                        if (H <= 25 && G <= 25)
                            return !0
                    }
                    return !1
                }
                inherit(TouchMouseInput, Input, {
                    "handler": function TMEhandler(v, E, k) {
                        var R = k.pointerType == se
                          , U = k.pointerType == ce;
                        if (!(U && k.sourceCapabilities && k.sourceCapabilities.firesTouchEvents)) {
                            if (R)
                                recordTouches.call(this, E, k);
                            else if (U && isSyntheticEvent.call(this, k))
                                return;
                            this.callback(v, E, k)
                        }
                    },
                    "destroy": function destroy() {
                        this.touch.destroy(),
                        this.mouse.destroy()
                    }
                });
                var Ne = prefixed(J.style, "touchAction")
                  , De = Ne !== W
                  , $e = "compute"
                  , Le = "auto"
                  , Fe = "manipulation"
                  , je = "none"
                  , Be = "pan-x"
                  , Ue = "pan-y"
                  , He = function getTouchActionProps() {
                    if (!De)
                        return !1;
                    var v = {}
                      , E = U.CSS && U.CSS.supports;
                    return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach((function(k) {
                        v[k] = !E || U.CSS.supports("touch-action", k)
                    }
                    )),
                    v
                }();
                function TouchAction(v, E) {
                    this.manager = v,
                    this.set(E)
                }
                TouchAction.prototype = {
                    "set": function(v) {
                        v == $e && (v = this.compute()),
                        De && this.manager.element.style && He[v] && (this.manager.element.style[Ne] = v),
                        this.actions = v.toLowerCase().trim()
                    },
                    "update": function() {
                        this.set(this.manager.options.touchAction)
                    },
                    "compute": function() {
                        var v = [];
                        return each(this.manager.recognizers, (function(E) {
                            boolOrFn(E.options.enable, [E]) && (v = v.concat(E.getTouchAction()))
                        }
                        )),
                        function cleanTouchActions(v) {
                            if (inStr(v, je))
                                return je;
                            var E = inStr(v, Be)
                              , k = inStr(v, Ue);
                            if (E && k)
                                return je;
                            if (E || k)
                                return E ? Be : Ue;
                            if (inStr(v, Fe))
                                return Fe;
                            return Le
                        }(v.join(" "))
                    },
                    "preventDefaults": function(v) {
                        var E = v.srcEvent
                          , k = v.offsetDirection;
                        if (this.manager.session.prevented)
                            E.preventDefault();
                        else {
                            var R = this.actions
                              , U = inStr(R, je) && !He[je]
                              , H = inStr(R, Ue) && !He[Ue]
                              , G = inStr(R, Be) && !He[Be];
                            if (U) {
                                var W = 1 === v.pointers.length
                                  , Z = v.distance < 2
                                  , Y = v.deltaTime < 250;
                                if (W && Z && Y)
                                    return
                            }
                            if (!G || !H)
                                return U || H && k & ve || G && k & ye ? this.preventSrc(E) : void 0
                        }
                    },
                    "preventSrc": function(v) {
                        this.manager.session.prevented = !0,
                        v.preventDefault()
                    }
                };
                var ze = 1
                  , qe = 32;
                function Recognizer(v) {
                    this.options = Z({}, this.defaults, v || {}),
                    this.id = function uniqueId() {
                        return re++
                    }(),
                    this.manager = null,
                    this.options.enable = ifUndefined(this.options.enable, !0),
                    this.state = ze,
                    this.simultaneous = {},
                    this.requireFail = []
                }
                function stateStr(v) {
                    return 16 & v ? "cancel" : 8 & v ? "end" : 4 & v ? "move" : 2 & v ? "start" : ""
                }
                function directionStr(v) {
                    return v == _e ? "down" : v == ge ? "up" : v == he ? "left" : v == me ? "right" : ""
                }
                function getRecognizerByNameIfManager(v, E) {
                    var k = E.manager;
                    return k ? k.get(v) : v
                }
                function AttrRecognizer() {
                    Recognizer.apply(this, arguments)
                }
                function PanRecognizer() {
                    AttrRecognizer.apply(this, arguments),
                    this.pX = null,
                    this.pY = null
                }
                function PinchRecognizer() {
                    AttrRecognizer.apply(this, arguments)
                }
                function PressRecognizer() {
                    Recognizer.apply(this, arguments),
                    this._timer = null,
                    this._input = null
                }
                function RotateRecognizer() {
                    AttrRecognizer.apply(this, arguments)
                }
                function SwipeRecognizer() {
                    AttrRecognizer.apply(this, arguments)
                }
                function TapRecognizer() {
                    Recognizer.apply(this, arguments),
                    this.pTime = !1,
                    this.pCenter = !1,
                    this._timer = null,
                    this._input = null,
                    this.count = 0
                }
                function Hammer(v, E) {
                    return (E = E || {}).recognizers = ifUndefined(E.recognizers, Hammer.defaults.preset),
                    new Manager(v,E)
                }
                Recognizer.prototype = {
                    "defaults": {},
                    "set": function(v) {
                        return Z(this.options, v),
                        this.manager && this.manager.touchAction.update(),
                        this
                    },
                    "recognizeWith": function(v) {
                        if (invokeArrayArg(v, "recognizeWith", this))
                            return this;
                        var E = this.simultaneous;
                        return E[(v = getRecognizerByNameIfManager(v, this)).id] || (E[v.id] = v,
                        v.recognizeWith(this)),
                        this
                    },
                    "dropRecognizeWith": function(v) {
                        return invokeArrayArg(v, "dropRecognizeWith", this) || (v = getRecognizerByNameIfManager(v, this),
                        delete this.simultaneous[v.id]),
                        this
                    },
                    "requireFailure": function(v) {
                        if (invokeArrayArg(v, "requireFailure", this))
                            return this;
                        var E = this.requireFail;
                        return -1 === inArray(E, v = getRecognizerByNameIfManager(v, this)) && (E.push(v),
                        v.requireFailure(this)),
                        this
                    },
                    "dropRequireFailure": function(v) {
                        if (invokeArrayArg(v, "dropRequireFailure", this))
                            return this;
                        v = getRecognizerByNameIfManager(v, this);
                        var E = inArray(this.requireFail, v);
                        return E > -1 && this.requireFail.splice(E, 1),
                        this
                    },
                    "hasRequireFailures": function() {
                        return this.requireFail.length > 0
                    },
                    "canRecognizeWith": function(v) {
                        return !!this.simultaneous[v.id]
                    },
                    "emit": function(v) {
                        var E = this
                          , k = this.state;
                        function emit(k) {
                            E.manager.emit(k, v)
                        }
                        k < 8 && emit(E.options.event + stateStr(k)),
                        emit(E.options.event),
                        v.additionalEvent && emit(v.additionalEvent),
                        k >= 8 && emit(E.options.event + stateStr(k))
                    },
                    "tryEmit": function(v) {
                        if (this.canEmit())
                            return this.emit(v);
                        this.state = qe
                    },
                    "canEmit": function() {
                        for (var v = 0; v < this.requireFail.length; ) {
                            if (!(this.requireFail[v].state & (qe | ze)))
                                return !1;
                            v++
                        }
                        return !0
                    },
                    "recognize": function(v) {
                        var E = Z({}, v);
                        if (!boolOrFn(this.options.enable, [this, E]))
                            return this.reset(),
                            void (this.state = qe);
                        56 & this.state && (this.state = ze),
                        this.state = this.process(E),
                        30 & this.state && this.tryEmit(E)
                    },
                    "process": function(v) {},
                    "getTouchAction": function() {},
                    "reset": function() {}
                },
                inherit(AttrRecognizer, Recognizer, {
                    "defaults": {
                        "pointers": 1
                    },
                    "attrTest": function(v) {
                        var E = this.options.pointers;
                        return 0 === E || v.pointers.length === E
                    },
                    "process": function(v) {
                        var E = this.state
                          , k = v.eventType
                          , R = 6 & E
                          , U = this.attrTest(v);
                        return R && (k & pe || !U) ? 16 | E : R || U ? k & de ? 8 | E : 2 & E ? 4 | E : 2 : qe
                    }
                }),
                inherit(PanRecognizer, AttrRecognizer, {
                    "defaults": {
                        "event": "pan",
                        "threshold": 10,
                        "pointers": 1,
                        "direction": be
                    },
                    "getTouchAction": function() {
                        var v = this.options.direction
                          , E = [];
                        return v & ve && E.push(Ue),
                        v & ye && E.push(Be),
                        E
                    },
                    "directionTest": function(v) {
                        var E = this.options
                          , k = !0
                          , R = v.distance
                          , U = v.direction
                          , H = v.deltaX
                          , G = v.deltaY;
                        return U & E.direction || (E.direction & ve ? (U = 0 === H ? fe : H < 0 ? he : me,
                        k = H != this.pX,
                        R = Math.abs(v.deltaX)) : (U = 0 === G ? fe : G < 0 ? ge : _e,
                        k = G != this.pY,
                        R = Math.abs(v.deltaY))),
                        v.direction = U,
                        k && R > E.threshold && U & E.direction
                    },
                    "attrTest": function(v) {
                        return AttrRecognizer.prototype.attrTest.call(this, v) && (2 & this.state || !(2 & this.state) && this.directionTest(v))
                    },
                    "emit": function(v) {
                        this.pX = v.deltaX,
                        this.pY = v.deltaY;
                        var E = directionStr(v.direction);
                        E && (v.additionalEvent = this.options.event + E),
                        this._super.emit.call(this, v)
                    }
                }),
                inherit(PinchRecognizer, AttrRecognizer, {
                    "defaults": {
                        "event": "pinch",
                        "threshold": 0,
                        "pointers": 2
                    },
                    "getTouchAction": function() {
                        return [je]
                    },
                    "attrTest": function(v) {
                        return this._super.attrTest.call(this, v) && (Math.abs(v.scale - 1) > this.options.threshold || 2 & this.state)
                    },
                    "emit": function(v) {
                        if (1 !== v.scale) {
                            var E = v.scale < 1 ? "in" : "out";
                            v.additionalEvent = this.options.event + E
                        }
                        this._super.emit.call(this, v)
                    }
                }),
                inherit(PressRecognizer, Recognizer, {
                    "defaults": {
                        "event": "press",
                        "pointers": 1,
                        "time": 251,
                        "threshold": 9
                    },
                    "getTouchAction": function() {
                        return [Le]
                    },
                    "process": function(v) {
                        var E = this.options
                          , k = v.pointers.length === E.pointers
                          , R = v.distance < E.threshold
                          , U = v.deltaTime > E.time;
                        if (this._input = v,
                        !R || !k || v.eventType & (de | pe) && !U)
                            this.reset();
                        else if (v.eventType & ue)
                            this.reset(),
                            this._timer = setTimeoutContext((function() {
                                this.state = 8,
                                this.tryEmit()
                            }
                            ), E.time, this);
                        else if (v.eventType & de)
                            return 8;
                        return qe
                    },
                    "reset": function() {
                        clearTimeout(this._timer)
                    },
                    "emit": function(v) {
                        8 === this.state && (v && v.eventType & de ? this.manager.emit(this.options.event + "up", v) : (this._input.timeStamp = ee(),
                        this.manager.emit(this.options.event, this._input)))
                    }
                }),
                inherit(RotateRecognizer, AttrRecognizer, {
                    "defaults": {
                        "event": "rotate",
                        "threshold": 0,
                        "pointers": 2
                    },
                    "getTouchAction": function() {
                        return [je]
                    },
                    "attrTest": function(v) {
                        return this._super.attrTest.call(this, v) && (Math.abs(v.rotation) > this.options.threshold || 2 & this.state)
                    }
                }),
                inherit(SwipeRecognizer, AttrRecognizer, {
                    "defaults": {
                        "event": "swipe",
                        "threshold": 10,
                        "velocity": .3,
                        "direction": ve | ye,
                        "pointers": 1
                    },
                    "getTouchAction": function() {
                        return PanRecognizer.prototype.getTouchAction.call(this)
                    },
                    "attrTest": function(v) {
                        var E, k = this.options.direction;
                        return k & (ve | ye) ? E = v.overallVelocity : k & ve ? E = v.overallVelocityX : k & ye && (E = v.overallVelocityY),
                        this._super.attrTest.call(this, v) && k & v.offsetDirection && v.distance > this.options.threshold && v.maxPointers == this.options.pointers && Q(E) > this.options.velocity && v.eventType & de
                    },
                    "emit": function(v) {
                        var E = directionStr(v.offsetDirection);
                        E && this.manager.emit(this.options.event + E, v),
                        this.manager.emit(this.options.event, v)
                    }
                }),
                inherit(TapRecognizer, Recognizer, {
                    "defaults": {
                        "event": "tap",
                        "pointers": 1,
                        "taps": 1,
                        "interval": 300,
                        "time": 250,
                        "threshold": 9,
                        "posThreshold": 10
                    },
                    "getTouchAction": function() {
                        return [Fe]
                    },
                    "process": function(v) {
                        var E = this.options
                          , k = v.pointers.length === E.pointers
                          , R = v.distance < E.threshold
                          , U = v.deltaTime < E.time;
                        if (this.reset(),
                        v.eventType & ue && 0 === this.count)
                            return this.failTimeout();
                        if (R && U && k) {
                            if (v.eventType != de)
                                return this.failTimeout();
                            var H = !this.pTime || v.timeStamp - this.pTime < E.interval
                              , G = !this.pCenter || getDistance(this.pCenter, v.center) < E.posThreshold;
                            if (this.pTime = v.timeStamp,
                            this.pCenter = v.center,
                            G && H ? this.count += 1 : this.count = 1,
                            this._input = v,
                            0 === this.count % E.taps)
                                return this.hasRequireFailures() ? (this._timer = setTimeoutContext((function() {
                                    this.state = 8,
                                    this.tryEmit()
                                }
                                ), E.interval, this),
                                2) : 8
                        }
                        return qe
                    },
                    "failTimeout": function() {
                        return this._timer = setTimeoutContext((function() {
                            this.state = qe
                        }
                        ), this.options.interval, this),
                        qe
                    },
                    "reset": function() {
                        clearTimeout(this._timer)
                    },
                    "emit": function() {
                        8 == this.state && (this._input.tapCount = this.count,
                        this.manager.emit(this.options.event, this._input))
                    }
                }),
                Hammer.VERSION = "2.0.7",
                Hammer.defaults = {
                    "domEvents": !1,
                    "touchAction": $e,
                    "enable": !0,
                    "inputTarget": null,
                    "inputClass": null,
                    "preset": [[RotateRecognizer, {
                        "enable": !1
                    }], [PinchRecognizer, {
                        "enable": !1
                    }, ["rotate"]], [SwipeRecognizer, {
                        "direction": ve
                    }], [PanRecognizer, {
                        "direction": ve
                    }, ["swipe"]], [TapRecognizer], [TapRecognizer, {
                        "event": "doubletap",
                        "taps": 2
                    }, ["tap"]], [PressRecognizer]],
                    "cssProps": {
                        "userSelect": "none",
                        "touchSelect": "none",
                        "touchCallout": "none",
                        "contentZooming": "none",
                        "userDrag": "none",
                        "tapHighlightColor": "rgba(0,0,0,0)"
                    }
                };
                function Manager(v, E) {
                    this.options = Z({}, Hammer.defaults, E || {}),
                    this.options.inputTarget = this.options.inputTarget || v,
                    this.handlers = {},
                    this.session = {},
                    this.recognizers = [],
                    this.oldCssProps = {},
                    this.element = v,
                    this.input = function createInputInstance(v) {
                        return new (v.options.inputClass || (ie ? PointerEventInput : ae ? TouchInput : oe ? TouchMouseInput : MouseInput))(v,inputHandler)
                    }(this),
                    this.touchAction = new TouchAction(this,this.options.touchAction),
                    toggleCssProps(this, !0),
                    each(this.options.recognizers, (function(v) {
                        var E = this.add(new v[0](v[1]));
                        v[2] && E.recognizeWith(v[2]),
                        v[3] && E.requireFailure(v[3])
                    }
                    ), this)
                }
                function toggleCssProps(v, E) {
                    var k, R = v.element;
                    R.style && (each(v.options.cssProps, (function(U, H) {
                        k = prefixed(R.style, H),
                        E ? (v.oldCssProps[k] = R.style[k],
                        R.style[k] = U) : R.style[k] = v.oldCssProps[k] || ""
                    }
                    )),
                    E || (v.oldCssProps = {}))
                }
                Manager.prototype = {
                    "set": function(v) {
                        return Z(this.options, v),
                        v.touchAction && this.touchAction.update(),
                        v.inputTarget && (this.input.destroy(),
                        this.input.target = v.inputTarget,
                        this.input.init()),
                        this
                    },
                    "stop": function(v) {
                        this.session.stopped = v ? 2 : 1
                    },
                    "recognize": function(v) {
                        var E = this.session;
                        if (!E.stopped) {
                            var k;
                            this.touchAction.preventDefaults(v);
                            var R = this.recognizers
                              , U = E.curRecognizer;
                            (!U || U && 8 & U.state) && (U = E.curRecognizer = null);
                            for (var H = 0; H < R.length; )
                                k = R[H],
                                2 === E.stopped || U && k != U && !k.canRecognizeWith(U) ? k.reset() : k.recognize(v),
                                !U && 14 & k.state && (U = E.curRecognizer = k),
                                H++
                        }
                    },
                    "get": function(v) {
                        if (v instanceof Recognizer)
                            return v;
                        for (var E = this.recognizers, k = 0; k < E.length; k++)
                            if (E[k].options.event == v)
                                return E[k];
                        return null
                    },
                    "add": function(v) {
                        if (invokeArrayArg(v, "add", this))
                            return this;
                        var E = this.get(v.options.event);
                        return E && this.remove(E),
                        this.recognizers.push(v),
                        v.manager = this,
                        this.touchAction.update(),
                        v
                    },
                    "remove": function(v) {
                        if (invokeArrayArg(v, "remove", this))
                            return this;
                        if (v = this.get(v)) {
                            var E = this.recognizers
                              , k = inArray(E, v);
                            -1 !== k && (E.splice(k, 1),
                            this.touchAction.update())
                        }
                        return this
                    },
                    "on": function(v, E) {
                        if (v !== W && E !== W) {
                            var k = this.handlers;
                            return each(splitStr(v), (function(v) {
                                k[v] = k[v] || [],
                                k[v].push(E)
                            }
                            )),
                            this
                        }
                    },
                    "off": function(v, E) {
                        if (v !== W) {
                            var k = this.handlers;
                            return each(splitStr(v), (function(v) {
                                E ? k[v] && k[v].splice(inArray(k[v], E), 1) : delete k[v]
                            }
                            )),
                            this
                        }
                    },
                    "emit": function(v, E) {
                        this.options.domEvents && function triggerDomEvent(v, E) {
                            var k = H.createEvent("Event");
                            k.initEvent(v, !0, !0),
                            k.gesture = E,
                            E.target.dispatchEvent(k)
                        }(v, E);
                        var k = this.handlers[v] && this.handlers[v].slice();
                        if (k && k.length) {
                            E.type = v,
                            E.preventDefault = function() {
                                E.srcEvent.preventDefault()
                            }
                            ;
                            for (var R = 0; R < k.length; )
                                k[R](E),
                                R++
                        }
                    },
                    "destroy": function() {
                        this.element && toggleCssProps(this, !1),
                        this.handlers = {},
                        this.session = {},
                        this.input.destroy(),
                        this.element = null
                    }
                },
                Z(Hammer, {
                    "INPUT_START": ue,
                    "INPUT_MOVE": 2,
                    "INPUT_END": de,
                    "INPUT_CANCEL": pe,
                    "STATE_POSSIBLE": ze,
                    "STATE_BEGAN": 2,
                    "STATE_CHANGED": 4,
                    "STATE_ENDED": 8,
                    "STATE_RECOGNIZED": 8,
                    "STATE_CANCELLED": 16,
                    "STATE_FAILED": qe,
                    "DIRECTION_NONE": fe,
                    "DIRECTION_LEFT": he,
                    "DIRECTION_RIGHT": me,
                    "DIRECTION_UP": ge,
                    "DIRECTION_DOWN": _e,
                    "DIRECTION_HORIZONTAL": ve,
                    "DIRECTION_VERTICAL": ye,
                    "DIRECTION_ALL": be,
                    "Manager": Manager,
                    "Input": Input,
                    "TouchAction": TouchAction,
                    "TouchInput": TouchInput,
                    "MouseInput": MouseInput,
                    "PointerEventInput": PointerEventInput,
                    "TouchMouseInput": TouchMouseInput,
                    "SingleTouchInput": SingleTouchInput,
                    "Recognizer": Recognizer,
                    "AttrRecognizer": AttrRecognizer,
                    "Tap": TapRecognizer,
                    "Pan": PanRecognizer,
                    "Swipe": SwipeRecognizer,
                    "Pinch": PinchRecognizer,
                    "Rotate": RotateRecognizer,
                    "Press": PressRecognizer,
                    "on": addEventListeners,
                    "off": removeEventListeners,
                    "each": each,
                    "merge": ne,
                    "extend": te,
                    "assign": Z,
                    "inherit": inherit,
                    "bindFn": bindFn,
                    "prefixed": prefixed
                }),
                (void 0 !== U ? U : "undefined" != typeof self ? self : {}).Hammer = Hammer,
                (R = function() {
                    return Hammer
                }
                .call(E, k, E, v)) === W || (v.exports = R)
            }(window, document)
        },
        "1682": function(v, E, k) {
            "use strict";
            function extends_extends() {
                return extends_extends = Object.assign ? Object.assign.bind() : function(v) {
                    for (var E = 1; E < arguments.length; E++) {
                        var k = arguments[E];
                        for (var R in k)
                            ({}).hasOwnProperty.call(k, R) && (v[R] = k[R])
                    }
                    return v
                }
                ,
                extends_extends.apply(null, arguments)
            }
            var R;
            k.d(E, {
                "aU": function() {
                    return R
                },
                "lX": function() {
                    return createBrowserHistory
                },
                "cP": function() {
                    return parsePath
                }
            }),
            function(v) {
                v.Pop = "POP",
                v.Push = "PUSH",
                v.Replace = "REPLACE"
            }(R || (R = {}));
            var readOnly = function(v) {
                return v
            };
            var U = "beforeunload"
              , H = "popstate";
            function createBrowserHistory(v) {
                void 0 === v && (v = {});
                var E = v.window
                  , k = void 0 === E ? document.defaultView : E
                  , G = k.history;
                function getIndexAndLocation() {
                    var v = k.location
                      , E = v.pathname
                      , R = v.search
                      , U = v.hash
                      , H = G.state || {};
                    return [H.idx, readOnly({
                        "pathname": E,
                        "search": R,
                        "hash": U,
                        "state": H.usr || null,
                        "key": H.key || "default"
                    })]
                }
                var W = null;
                k.addEventListener(H, (function handlePop() {
                    if (W)
                        Q.call(W),
                        W = null;
                    else {
                        var v = R.Pop
                          , E = getIndexAndLocation()
                          , k = E[0]
                          , U = E[1];
                        if (Q.length) {
                            if (null != k) {
                                var H = J - k;
                                H && (W = {
                                    "action": v,
                                    "location": U,
                                    "retry": function retry() {
                                        go(-1 * H)
                                    }
                                },
                                go(H))
                            }
                        } else
                            applyTx(v)
                    }
                }
                ));
                var Z = R.Pop
                  , Y = getIndexAndLocation()
                  , J = Y[0]
                  , K = Y[1]
                  , X = createEvents()
                  , Q = createEvents();
                function createHref(v) {
                    return "string" == typeof v ? v : createPath(v)
                }
                function getNextLocation(v, E) {
                    return void 0 === E && (E = null),
                    readOnly(extends_extends({
                        "pathname": K.pathname,
                        "hash": "",
                        "search": ""
                    }, "string" == typeof v ? parsePath(v) : v, {
                        "state": E,
                        "key": createKey()
                    }))
                }
                function getHistoryStateAndUrl(v, E) {
                    return [{
                        "usr": v.state,
                        "key": v.key,
                        "idx": E
                    }, createHref(v)]
                }
                function allowTx(v, E, k) {
                    return !Q.length || (Q.call({
                        "action": v,
                        "location": E,
                        "retry": k
                    }),
                    !1)
                }
                function applyTx(v) {
                    Z = v;
                    var E = getIndexAndLocation();
                    J = E[0],
                    K = E[1],
                    X.call({
                        "action": Z,
                        "location": K
                    })
                }
                function go(v) {
                    G.go(v)
                }
                null == J && (J = 0,
                G.replaceState(extends_extends({}, G.state, {
                    "idx": J
                }), ""));
                var ee = {
                    get "action"() {
                        return Z
                    },
                    get "location"() {
                        return K
                    },
                    "createHref": createHref,
                    "push": function push(v, E) {
                        var U = R.Push
                          , H = getNextLocation(v, E);
                        if (allowTx(U, H, (function retry() {
                            push(v, E)
                        }
                        ))) {
                            var W = getHistoryStateAndUrl(H, J + 1)
                              , Z = W[0]
                              , Y = W[1];
                            try {
                                G.pushState(Z, "", Y)
                            } catch (v) {
                                k.location.assign(Y)
                            }
                            applyTx(U)
                        }
                    },
                    "replace": function replace(v, E) {
                        var k = R.Replace
                          , U = getNextLocation(v, E);
                        if (allowTx(k, U, (function retry() {
                            replace(v, E)
                        }
                        ))) {
                            var H = getHistoryStateAndUrl(U, J)
                              , W = H[0]
                              , Z = H[1];
                            G.replaceState(W, "", Z),
                            applyTx(k)
                        }
                    },
                    "go": go,
                    "back": function back() {
                        go(-1)
                    },
                    "forward": function forward() {
                        go(1)
                    },
                    "listen": function listen(v) {
                        return X.push(v)
                    },
                    "block": function block(v) {
                        var E = Q.push(v);
                        return 1 === Q.length && k.addEventListener(U, promptBeforeUnload),
                        function() {
                            E(),
                            Q.length || k.removeEventListener(U, promptBeforeUnload)
                        }
                    }
                };
                return ee
            }
            function promptBeforeUnload(v) {
                v.preventDefault(),
                v.returnValue = ""
            }
            function createEvents() {
                var v = [];
                return {
                    get "length"() {
                        return v.length
                    },
                    "push": function push(E) {
                        return v.push(E),
                        function() {
                            v = v.filter((function(v) {
                                return v !== E
                            }
                            ))
                        }
                    },
                    "call": function call(E) {
                        v.forEach((function(v) {
                            return v && v(E)
                        }
                        ))
                    }
                }
            }
            function createKey() {
                return Math.random().toString(36).substr(2, 8)
            }
            function createPath(v) {
                var E = v.pathname
                  , k = void 0 === E ? "/" : E
                  , R = v.search
                  , U = void 0 === R ? "" : R
                  , H = v.hash
                  , G = void 0 === H ? "" : H;
                return U && "?" !== U && (k += "?" === U.charAt(0) ? U : "?" + U),
                G && "#" !== G && (k += "#" === G.charAt(0) ? G : "#" + G),
                k
            }
            function parsePath(v) {
                var E = {};
                if (v) {
                    var k = v.indexOf("#");
                    k >= 0 && (E.hash = v.substr(k),
                    v = v.substr(0, k));
                    var R = v.indexOf("?");
                    R >= 0 && (E.search = v.substr(R),
                    v = v.substr(0, R)),
                    v && (E.pathname = v)
                }
                return E
            }
        },
        "4370": function(v, E, k) {
            "use strict";
            Object.defineProperty(E, "__esModule", {
                "value": !0
            }),
            E.headerDefaults = E.eventDefaults = void 0;
            var R = k(4296);
            E.headerDefaults = function headerDefaults() {
                return {
                    "productId": "adamgibbons/ics",
                    "method": "PUBLISH"
                }
            }
            ,
            E.eventDefaults = function eventDefaults() {
                return {
                    "title": "Untitled event",
                    "uid": (0,
                    R.nanoid)(),
                    "timestamp": Date.now()
                }
            }
        },
        "4276": function(v, E, k) {
            "use strict";
            E.yM = function createEvent(v, E) {
                return createEvents([v], E)
            }
            ;
            var R = k(3165);
            function _typeof(v) {
                return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(v) {
                    return typeof v
                }
                : function(v) {
                    return v && "function" == typeof Symbol && v.constructor === Symbol && v !== Symbol.prototype ? "symbol" : typeof v
                }
                ,
                _typeof(v)
            }
            function ownKeys(v, E) {
                var k = Object.keys(v);
                if (Object.getOwnPropertySymbols) {
                    var R = Object.getOwnPropertySymbols(v);
                    E && (R = R.filter((function(E) {
                        return Object.getOwnPropertyDescriptor(v, E).enumerable
                    }
                    ))),
                    k.push.apply(k, R)
                }
                return k
            }
            function _objectSpread(v) {
                for (var E = 1; E < arguments.length; E++) {
                    var k = null != arguments[E] ? arguments[E] : {};
                    E % 2 ? ownKeys(Object(k), !0).forEach((function(E) {
                        _defineProperty(v, E, k[E])
                    }
                    )) : Object.getOwnPropertyDescriptors ? Object.defineProperties(v, Object.getOwnPropertyDescriptors(k)) : ownKeys(Object(k)).forEach((function(E) {
                        Object.defineProperty(v, E, Object.getOwnPropertyDescriptor(k, E))
                    }
                    ))
                }
                return v
            }
            function _defineProperty(v, E, k) {
                return (E = function _toPropertyKey(v) {
                    var E = function _toPrimitive(v, E) {
                        if ("object" !== _typeof(v) || null === v)
                            return v;
                        var k = v[Symbol.toPrimitive];
                        if (void 0 !== k) {
                            var R = k.call(v, E || "default");
                            if ("object" !== _typeof(R))
                                return R;
                            throw new TypeError("@@toPrimitive must return a primitive value.")
                        }
                        return ("string" === E ? String : Number)(v)
                    }(v, "string");
                    return "symbol" === _typeof(E) ? E : String(E)
                }(E))in v ? Object.defineProperty(v, E, {
                    "value": k,
                    "enumerable": !0,
                    "configurable": !0,
                    "writable": !0
                }) : v[E] = k,
                v
            }
            function buildHeaderAndEventAndValidate(v) {
                return (0,
                R.validateHeaderAndEvent)(_objectSpread(_objectSpread({}, (0,
                R.buildHeader)(v)), (0,
                R.buildEvent)(v)))
            }
            function createEvents(v, E, k) {
                var U, H = "object" === _typeof(E) ? E : {}, G = 3 === arguments.length ? k : "function" == typeof E ? E : null;
                try {
                    U = function run() {
                        if (!v)
                            return {
                                "error": new Error("one argument is required"),
                                "value": null
                            };
                        var E = 0 === v.length ? function buildHeaderAndValidate(v) {
                            return (0,
                            R.validateHeader)((0,
                            R.buildHeader)(v))
                        }(H) : buildHeaderAndEventAndValidate(_objectSpread(_objectSpread({}, v[0]), H))
                          , k = E.error
                          , U = E.value;
                        if (k)
                            return {
                                "error": k,
                                "value": null
                            };
                        var G = "";
                        G += (0,
                        R.formatHeader)(U);
                        for (var W = 0; W < v.length; W++) {
                            var Z = buildHeaderAndEventAndValidate(v[W])
                              , Y = Z.error
                              , J = Z.value;
                            if (Y)
                                return {
                                    "error": Y,
                                    "value": null
                                };
                            G += (0,
                            R.formatEvent)(J)
                        }
                        return {
                            "error": null,
                            "value": G += (0,
                            R.formatFooter)()
                        }
                    }()
                } catch (v) {
                    U = {
                        "error": v,
                        "value": null
                    }
                }
                return G ? G(U.error, U.value) : U
            }
        },
        "3269": function(v, E, k) {
            "use strict";
            Object.defineProperty(E, "__esModule", {
                "value": !0
            }),
            E.buildEvent = function buildEvent() {
                var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                return removeUndefined(Object.assign({}, (0,
                R.eventDefaults)(), v))
            }
            ,
            E.buildHeader = function buildHeader() {
                var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                return removeUndefined(Object.assign({}, (0,
                R.headerDefaults)(), v))
            }
            ;
            var R = k(4370);
            function _typeof(v) {
                return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(v) {
                    return typeof v
                }
                : function(v) {
                    return v && "function" == typeof Symbol && v.constructor === Symbol && v !== Symbol.prototype ? "symbol" : typeof v
                }
                ,
                _typeof(v)
            }
            function _defineProperty(v, E, k) {
                return (E = function _toPropertyKey(v) {
                    var E = function _toPrimitive(v, E) {
                        if ("object" !== _typeof(v) || null === v)
                            return v;
                        var k = v[Symbol.toPrimitive];
                        if (void 0 !== k) {
                            var R = k.call(v, E || "default");
                            if ("object" !== _typeof(R))
                                return R;
                            throw new TypeError("@@toPrimitive must return a primitive value.")
                        }
                        return ("string" === E ? String : Number)(v)
                    }(v, "string");
                    return "symbol" === _typeof(E) ? E : String(E)
                }(E))in v ? Object.defineProperty(v, E, {
                    "value": k,
                    "enumerable": !0,
                    "configurable": !0,
                    "writable": !0
                }) : v[E] = k,
                v
            }
            function removeUndefined(v) {
                return Object.entries(v).reduce((function(v, E) {
                    return void 0 !== E[1] ? Object.assign(v, _defineProperty({}, E[0], E[1])) : v
                }
                ), {})
            }
        },
        "6167": function(v, E, k) {
            "use strict";
            Object.defineProperty(E, "__esModule", {
                "value": !0
            }),
            E.formatEvent = function formatEvent() {
                var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                  , E = v.title
                  , k = v.uid
                  , H = v.sequence
                  , G = v.timestamp
                  , W = v.start
                  , Z = v.startType
                  , Y = v.startInputType
                  , J = v.startOutputType
                  , K = v.duration
                  , X = v.end
                  , Q = v.endInputType
                  , ee = v.endOutputType
                  , te = v.description
                  , ne = v.url
                  , re = v.geo
                  , oe = v.location
                  , ie = v.status
                  , ae = v.categories
                  , se = v.organizer
                  , ce = v.attendees
                  , le = v.alarms
                  , ue = v.recurrenceRule
                  , de = v.exclusionDates
                  , pe = v.busyStatus
                  , fe = v.transp
                  , he = v.classification
                  , me = v.created
                  , ge = v.lastModified
                  , _e = v.htmlContent
                  , ve = "";
                ve += "BEGIN:VEVENT\r\n",
                ve += (0,
                R.foldLine)("UID:".concat((0,
                U.default)(k))) + "\r\n",
                ve += E ? (0,
                R.foldLine)("SUMMARY:".concat((0,
                U.default)((0,
                R.setSummary)(E)))) + "\r\n" : "",
                ve += (0,
                R.foldLine)("DTSTAMP:".concat((0,
                U.default)((0,
                R.formatDate)(G)))) + "\r\n",
                ve += (0,
                R.foldLine)("DTSTART".concat(W && 3 == W.length ? ";VALUE=DATE" : "", ":").concat((0,
                U.default)((0,
                R.formatDate)(W, J || Z, Y)))) + "\r\n",
                (!X || 3 !== X.length || W.length !== X.length || W.some((function(v, E) {
                    return v !== X[E]
                }
                ))) && X && (ve += (0,
                R.foldLine)("DTEND".concat(3 === X.length ? ";VALUE=DATE" : "", ":").concat((0,
                U.default)((0,
                R.formatDate)(X, ee || J || Z, Q || Y)))) + "\r\n");
                ve += void 0 !== H ? "SEQUENCE:".concat(H, "\r\n") : "",
                ve += te ? (0,
                R.foldLine)("DESCRIPTION:".concat((0,
                U.default)((0,
                R.setDescription)(te)))) + "\r\n" : "",
                ve += ne ? (0,
                R.foldLine)("URL:".concat((0,
                U.default)(ne))) + "\r\n" : "",
                ve += re ? (0,
                R.foldLine)("GEO:".concat((0,
                R.setGeolocation)(re))) + "\r\n" : "",
                ve += oe ? (0,
                R.foldLine)("LOCATION:".concat((0,
                U.default)((0,
                R.setLocation)(oe)))) + "\r\n" : "",
                ve += ie ? (0,
                R.foldLine)("STATUS:".concat((0,
                U.default)(ie))) + "\r\n" : "",
                ve += ae ? (0,
                R.foldLine)("CATEGORIES:".concat((0,
                U.default)(ae.join(",")))) + "\r\n" : "",
                ve += se ? (0,
                R.foldLine)("ORGANIZER;".concat((0,
                R.setOrganizer)(se))) + "\r\n" : "",
                ve += pe ? (0,
                R.foldLine)("X-MICROSOFT-CDO-BUSYSTATUS:".concat((0,
                U.default)(pe))) + "\r\n" : "",
                ve += fe ? (0,
                R.foldLine)("TRANSP:".concat((0,
                U.default)(fe))) + "\r\n" : "",
                ve += he ? (0,
                R.foldLine)("CLASS:".concat((0,
                U.default)(he))) + "\r\n" : "",
                ve += me ? "CREATED:" + (0,
                U.default)((0,
                R.formatDate)(me)) + "\r\n" : "",
                ve += ge ? "LAST-MODIFIED:" + (0,
                U.default)((0,
                R.formatDate)(ge)) + "\r\n" : "",
                ve += _e ? (0,
                R.foldLine)("X-ALT-DESC;FMTTYPE=text/html:".concat((0,
                U.default)(_e))) + "\r\n" : "",
                ce && ce.forEach((function(v) {
                    ve += (0,
                    R.foldLine)("ATTENDEE;".concat((0,
                    U.default)((0,
                    R.setContact)(v)))) + "\r\n"
                }
                ));
                ve += ue ? (0,
                R.foldLine)("RRULE:".concat((0,
                U.default)(ue))) + "\r\n" : "",
                ve += de ? (0,
                R.foldLine)("EXDATE:".concat((0,
                U.default)(de.map((function(v) {
                    return (0,
                    R.formatDate)(v)
                }
                )).join(",")))) + "\r\n" : "",
                ve += K ? (0,
                R.foldLine)("DURATION:".concat((0,
                R.formatDuration)(K))) + "\r\n" : "",
                le && le.forEach((function(v) {
                    ve += (0,
                    R.setAlarm)(v)
                }
                ));
                return ve += "END:VEVENT\r\n"
            }
            ,
            E.formatFooter = function formatFooter() {
                return "END:VCALENDAR\r\n"
            }
            ,
            E.formatHeader = function formatHeader() {
                var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                  , E = v.productId
                  , k = v.method
                  , H = v.calName
                  , G = "";
                return G += "BEGIN:VCALENDAR\r\n",
                G += "VERSION:2.0\r\n",
                G += "CALSCALE:GREGORIAN\r\n",
                G += (0,
                R.foldLine)("PRODID:".concat((0,
                U.default)(E))) + "\r\n",
                G += (0,
                R.foldLine)("METHOD:".concat((0,
                U.default)(k))) + "\r\n",
                G += H ? (0,
                R.foldLine)("X-WR-CALNAME:".concat((0,
                U.default)(H))) + "\r\n" : "",
                G += "X-PUBLISHED-TTL:PT1H\r\n"
            }
            ;
            var R = k(6851)
              , U = function _interopRequireDefault(v) {
                return v && v.__esModule ? v : {
                    "default": v
                }
            }(k(9364))
        },
        "3165": function(v, E, k) {
            "use strict";
            Object.defineProperty(E, "__esModule", {
                "value": !0
            }),
            Object.defineProperty(E, "buildEvent", {
                "enumerable": !0,
                "get": function get() {
                    return R.buildEvent
                }
            }),
            Object.defineProperty(E, "buildHeader", {
                "enumerable": !0,
                "get": function get() {
                    return R.buildHeader
                }
            }),
            Object.defineProperty(E, "formatEvent", {
                "enumerable": !0,
                "get": function get() {
                    return U.formatEvent
                }
            }),
            Object.defineProperty(E, "formatFooter", {
                "enumerable": !0,
                "get": function get() {
                    return U.formatFooter
                }
            }),
            Object.defineProperty(E, "formatHeader", {
                "enumerable": !0,
                "get": function get() {
                    return U.formatHeader
                }
            }),
            Object.defineProperty(E, "validateHeader", {
                "enumerable": !0,
                "get": function get() {
                    return H.validateHeader
                }
            }),
            Object.defineProperty(E, "validateHeaderAndEvent", {
                "enumerable": !0,
                "get": function get() {
                    return H.validateHeaderAndEvent
                }
            });
            var R = k(3269)
              , U = k(6167)
              , H = k(36)
        },
        "36": function(v, E, k) {
            "use strict";
            Object.defineProperty(E, "__esModule", {
                "value": !0
            });
            var R = k(7468);
            Object.keys(R).forEach((function(v) {
                "default" !== v && "__esModule" !== v && (v in E && E[v] === R[v] || Object.defineProperty(E, v, {
                    "enumerable": !0,
                    "get": function get() {
                        return R[v]
                    }
                }))
            }
            ))
        },
        "7468": function(v, E, k) {
            "use strict";
            Object.defineProperty(E, "__esModule", {
                "value": !0
            }),
            E.validateHeader = function validateHeader(v) {
                try {
                    return {
                        "error": null,
                        "value": K.validateSync(v, {
                            "abortEarly": !1,
                            "strict": !0
                        })
                    }
                } catch (v) {
                    return {
                        "error": Object.assign({}, v),
                        "value": void 0
                    }
                }
            }
            ,
            E.validateHeaderAndEvent = function validateHeaderAndEvent(v) {
                try {
                    return {
                        "error": null,
                        "value": Q.validateSync(v, {
                            "abortEarly": !1,
                            "strict": !0
                        })
                    }
                } catch (v) {
                    return {
                        "error": Object.assign({}, v),
                        "value": void 0
                    }
                }
            }
            ;
            var R = function _interopRequireWildcard(v, E) {
                if (!E && v && v.__esModule)
                    return v;
                if (null === v || "object" !== _typeof(v) && "function" != typeof v)
                    return {
                        "default": v
                    };
                var k = _getRequireWildcardCache(E);
                if (k && k.has(v))
                    return k.get(v);
                var R = {}
                  , U = Object.defineProperty && Object.getOwnPropertyDescriptor;
                for (var H in v)
                    if ("default" !== H && Object.prototype.hasOwnProperty.call(v, H)) {
                        var G = U ? Object.getOwnPropertyDescriptor(v, H) : null;
                        G && (G.get || G.set) ? Object.defineProperty(R, H, G) : R[H] = v[H]
                    }
                R.default = v,
                k && k.set(v, R);
                return R
            }(k(6310));
            function _getRequireWildcardCache(v) {
                if ("function" != typeof WeakMap)
                    return null;
                var E = new WeakMap
                  , k = new WeakMap;
                return (_getRequireWildcardCache = function _getRequireWildcardCache(v) {
                    return v ? k : E
                }
                )(v)
            }
            function _typeof(v) {
                return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(v) {
                    return typeof v
                }
                : function(v) {
                    return v && "function" == typeof Symbol && v.constructor === Symbol && v !== Symbol.prototype ? "symbol" : typeof v
                }
                ,
                _typeof(v)
            }
            function ownKeys(v, E) {
                var k = Object.keys(v);
                if (Object.getOwnPropertySymbols) {
                    var R = Object.getOwnPropertySymbols(v);
                    E && (R = R.filter((function(E) {
                        return Object.getOwnPropertyDescriptor(v, E).enumerable
                    }
                    ))),
                    k.push.apply(k, R)
                }
                return k
            }
            function _objectSpread(v) {
                for (var E = 1; E < arguments.length; E++) {
                    var k = null != arguments[E] ? arguments[E] : {};
                    E % 2 ? ownKeys(Object(k), !0).forEach((function(E) {
                        _defineProperty(v, E, k[E])
                    }
                    )) : Object.getOwnPropertyDescriptors ? Object.defineProperties(v, Object.getOwnPropertyDescriptors(k)) : ownKeys(Object(k)).forEach((function(E) {
                        Object.defineProperty(v, E, Object.getOwnPropertyDescriptor(k, E))
                    }
                    ))
                }
                return v
            }
            function _defineProperty(v, E, k) {
                return (E = function _toPropertyKey(v) {
                    var E = function _toPrimitive(v, E) {
                        if ("object" !== _typeof(v) || null === v)
                            return v;
                        var k = v[Symbol.toPrimitive];
                        if (void 0 !== k) {
                            var R = k.call(v, E || "default");
                            if ("object" !== _typeof(R))
                                return R;
                            throw new TypeError("@@toPrimitive must return a primitive value.")
                        }
                        return ("string" === E ? String : Number)(v)
                    }(v, "string");
                    return "symbol" === _typeof(E) ? E : String(E)
                }(E))in v ? Object.defineProperty(v, E, {
                    "value": k,
                    "enumerable": !0,
                    "configurable": !0,
                    "writable": !0
                }) : v[E] = k,
                v
            }
            var U = /^(?:([a-z0-9+.-]+):\/\/)(?:\S+(?::\S*)?@)?(?:(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*\.?)(?::\d{2,5})?(?:[/?#]\S*)?$/
              , H = function dateTimeSchema(v) {
                var E = v.required;
                return R.lazy((function(v) {
                    return "number" == typeof v ? R.number().integer().min(0) : "string" == typeof v ? R.string().required() : E || void 0 !== v ? R.array().required().min(3).max(7).of(R.lazy((function(v, E) {
                        var k = E.parent.indexOf(E.value);
                        return [R.number().integer(), R.number().integer().min(1).max(12), R.number().integer().min(1).max(31), R.number().integer().min(0).max(23), R.number().integer().min(0).max(60), R.number().integer().min(0).max(60)][k]
                    }
                    ))) : R.mixed().oneOf([void 0])
                }
                ))
            }
              , G = R.object().shape({
                "before": R.boolean(),
                "weeks": R.number(),
                "days": R.number(),
                "hours": R.number(),
                "minutes": R.number(),
                "seconds": R.number()
            }).noUnknown()
              , W = R.object().shape({
                "name": R.string(),
                "email": R.string().email(),
                "rsvp": R.boolean(),
                "dir": R.string().matches(U),
                "partstat": R.string(),
                "role": R.string(),
                "cutype": R.string(),
                "xNumGuests": R.number()
            }).noUnknown()
              , Z = R.object().shape({
                "name": R.string(),
                "email": R.string().email(),
                "dir": R.string(),
                "sentBy": R.string()
            }).noUnknown()
              , Y = R.object().shape({
                "action": R.string().matches(/^(audio|display|email)$/).required(),
                "trigger": R.mixed().required(),
                "description": R.string(),
                "duration": G,
                "repeat": R.number(),
                "attach": R.string(),
                "attachType": R.string(),
                "summary": R.string(),
                "attendee": W,
                "x-prop": R.mixed(),
                "iana-prop": R.mixed()
            }).noUnknown()
              , J = {
                "productId": R.string(),
                "method": R.string(),
                "calName": R.string()
            }
              , K = R.object().shape(J).noUnknown()
              , X = {
                "summary": R.string(),
                "timestamp": H({
                    "required": !1
                }),
                "title": R.string(),
                "uid": R.string(),
                "sequence": R.number().integer().max(2147483647),
                "start": H({
                    "required": !0
                }),
                "duration": G,
                "startType": R.string().matches(/^(utc|local)$/),
                "startInputType": R.string().matches(/^(utc|local)$/),
                "startOutputType": R.string().matches(/^(utc|local)$/),
                "end": H({
                    "required": !1
                }),
                "endInputType": R.string().matches(/^(utc|local)$/),
                "endOutputType": R.string().matches(/^(utc|local)$/),
                "description": R.string(),
                "url": R.string().matches(U),
                "geo": R.object().shape({
                    "lat": R.number(),
                    "lon": R.number()
                }),
                "location": R.string(),
                "status": R.string().matches(/^(TENTATIVE|CANCELLED|CONFIRMED)$/i),
                "categories": R.array().of(R.string()),
                "organizer": Z,
                "attendees": R.array().of(W),
                "alarms": R.array().of(Y),
                "recurrenceRule": R.string(),
                "busyStatus": R.string().matches(/^(TENTATIVE|FREE|BUSY|OOF)$/i),
                "transp": R.string().matches(/^(TRANSPARENT|OPAQUE)$/i),
                "classification": R.string(),
                "created": H({
                    "required": !1
                }),
                "lastModified": H({
                    "required": !1
                }),
                "exclusionDates": R.array().of(H({
                    "required": !0
                })),
                "htmlContent": R.string()
            }
              , Q = R.object().shape(_objectSpread(_objectSpread({}, J), X)).test("xor", "object should have end or duration (but not both)", (function(v) {
                var E = !!v.end
                  , k = !!v.duration;
                return E && !k || !E && k || !E && !k
            }
            )).noUnknown()
        },
        "9364": function(v, E) {
            "use strict";
            Object.defineProperty(E, "__esModule", {
                "value": !0
            }),
            E.default = function encodeNewLines(v) {
                return v.replace(/\r?\n/gm, "\\n")
            }
        },
        "6444": function(v, E) {
            "use strict";
            Object.defineProperty(E, "__esModule", {
                "value": !0
            }),
            E.default = function encodeParamValue(v) {
                return '"'.concat(v.replaceAll('"', '\\"'), '"')
            }
        },
        "4561": function(v, E, k) {
            "use strict";
            Object.defineProperty(E, "__esModule", {
                "value": !0
            }),
            E.default = function foldLine(v) {
                var E = []
                  , k = 75;
                for (; (0,
                R.runes)(v).length > k; )
                    E.push((0,
                    R.substring)(v, 0, k)),
                    v = (0,
                    R.substring)(v, k),
                    k = 74;
                return E.push(v),
                E.join("\r\n\t")
            }
            ;
            var R = k(4285)
        },
        "1966": function(v, E) {
            "use strict";
            function _slicedToArray(v, E) {
                return function _arrayWithHoles(v) {
                    if (Array.isArray(v))
                        return v
                }(v) || function _iterableToArrayLimit(v, E) {
                    var k = null == v ? null : "undefined" != typeof Symbol && v[Symbol.iterator] || v["@@iterator"];
                    if (null != k) {
                        var R, U, H, G, W = [], Z = !0, Y = !1;
                        try {
                            if (H = (k = k.call(v)).next,
                            0 === E) {
                                if (Object(k) !== k)
                                    return;
                                Z = !1
                            } else
                                for (; !(Z = (R = H.call(k)).done) && (W.push(R.value),
                                W.length !== E); Z = !0)
                                    ;
                        } catch (v) {
                            Y = !0,
                            U = v
                        } finally {
                            try {
                                if (!Z && null != k.return && (G = k.return(),
                                Object(G) !== G))
                                    return
                            } finally {
                                if (Y)
                                    throw U
                            }
                        }
                        return W
                    }
                }(v, E) || function _unsupportedIterableToArray(v, E) {
                    if (!v)
                        return;
                    if ("string" == typeof v)
                        return _arrayLikeToArray(v, E);
                    var k = Object.prototype.toString.call(v).slice(8, -1);
                    "Object" === k && v.constructor && (k = v.constructor.name);
                    if ("Map" === k || "Set" === k)
                        return Array.from(v);
                    if ("Arguments" === k || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(k))
                        return _arrayLikeToArray(v, E)
                }(v, E) || function _nonIterableRest() {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }()
            }
            function _arrayLikeToArray(v, E) {
                (null == E || E > v.length) && (E = v.length);
                for (var k = 0, R = new Array(E); k < E; k++)
                    R[k] = v[k];
                return R
            }
            Object.defineProperty(E, "__esModule", {
                "value": !0
            }),
            E.default = function formatDate() {
                var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
                  , E = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "utc"
                  , R = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "local";
                if ("string" == typeof v)
                    return v;
                if (Array.isArray(v) && 3 === v.length) {
                    var U = _slicedToArray(v, 3)
                      , H = U[0]
                      , G = U[1]
                      , W = U[2];
                    return "".concat(H).concat(k(G)).concat(k(W))
                }
                var Z = new Date;
                if (Array.isArray(v) && v.length > 0 && v[0]) {
                    var Y = _slicedToArray(v, 6)
                      , J = Y[0]
                      , K = Y[1]
                      , X = Y[2]
                      , Q = Y[3]
                      , ee = void 0 === Q ? 0 : Q
                      , te = Y[4]
                      , ne = void 0 === te ? 0 : te
                      , re = Y[5]
                      , oe = void 0 === re ? 0 : re;
                    Z = "local" === R ? new Date(J,K - 1,X,ee,ne,oe) : new Date(Date.UTC(J, K - 1, X, ee, ne, oe))
                } else
                    Array.isArray(v) || (Z = new Date(v));
                if ("local" === E)
                    return [Z.getFullYear(), k(Z.getMonth() + 1), k(Z.getDate()), "T", k(Z.getHours()), k(Z.getMinutes()), k(Z.getSeconds())].join("");
                return [Z.getUTCFullYear(), k(Z.getUTCMonth() + 1), k(Z.getUTCDate()), "T", k(Z.getUTCHours()), k(Z.getUTCMinutes()), k(Z.getUTCSeconds()), "Z"].join("")
            }
            ;
            var k = function pad(v) {
                return v < 10 ? "0".concat(v) : "".concat(v)
            }
        },
        "4671": function(v, E) {
            "use strict";
            Object.defineProperty(E, "__esModule", {
                "value": !0
            }),
            E.default = function formatDuration() {
                var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                  , E = v.weeks
                  , k = v.days
                  , R = v.hours
                  , U = v.minutes
                  , H = v.seconds
                  , G = "P";
                return G += E ? "".concat(E, "W") : "",
                G += k ? "".concat(k, "D") : "",
                G += "T",
                G += R ? "".concat(R, "H") : "",
                G += U ? "".concat(U, "M") : "",
                G += H ? "".concat(H, "S") : ""
            }
        },
        "2257": function(v, E) {
            "use strict";
            Object.defineProperty(E, "__esModule", {
                "value": !0
            }),
            E.default = function formatText(v) {
                return v.replace(/\\/gm, "\\\\").replace(/\r?\n/gm, "\\n").replace(/;/gm, "\\;").replace(/,/gm, "\\,")
            }
        },
        "6851": function(v, E, k) {
            "use strict";
            Object.defineProperty(E, "__esModule", {
                "value": !0
            }),
            Object.defineProperty(E, "encodeParamValue", {
                "enumerable": !0,
                "get": function get() {
                    return Q.default
                }
            }),
            Object.defineProperty(E, "foldLine", {
                "enumerable": !0,
                "get": function get() {
                    return K.default
                }
            }),
            Object.defineProperty(E, "formatDate", {
                "enumerable": !0,
                "get": function get() {
                    return R.default
                }
            }),
            Object.defineProperty(E, "formatDuration", {
                "enumerable": !0,
                "get": function get() {
                    return J.default
                }
            }),
            Object.defineProperty(E, "setAlarm", {
                "enumerable": !0,
                "get": function get() {
                    return W.default
                }
            }),
            Object.defineProperty(E, "setContact", {
                "enumerable": !0,
                "get": function get() {
                    return H.default
                }
            }),
            Object.defineProperty(E, "setDescription", {
                "enumerable": !0,
                "get": function get() {
                    return Z.default
                }
            }),
            Object.defineProperty(E, "setGeolocation", {
                "enumerable": !0,
                "get": function get() {
                    return U.default
                }
            }),
            Object.defineProperty(E, "setLocation", {
                "enumerable": !0,
                "get": function get() {
                    return X.default
                }
            }),
            Object.defineProperty(E, "setOrganizer", {
                "enumerable": !0,
                "get": function get() {
                    return G.default
                }
            }),
            Object.defineProperty(E, "setSummary", {
                "enumerable": !0,
                "get": function get() {
                    return Y.default
                }
            });
            var R = _interopRequireDefault(k(1966))
              , U = _interopRequireDefault(k(5735))
              , H = _interopRequireDefault(k(6382))
              , G = _interopRequireDefault(k(4884))
              , W = _interopRequireDefault(k(8433))
              , Z = _interopRequireDefault(k(4209))
              , Y = _interopRequireDefault(k(4521))
              , J = _interopRequireDefault(k(4671))
              , K = _interopRequireDefault(k(4561))
              , X = _interopRequireDefault(k(9017))
              , Q = _interopRequireDefault(k(6444));
            function _interopRequireDefault(v) {
                return v && v.__esModule ? v : {
                    "default": v
                }
            }
        },
        "8433": function(v, E, k) {
            "use strict";
            Object.defineProperty(E, "__esModule", {
                "value": !0
            }),
            E.default = function setAlarm() {
                var v = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                  , E = v.action
                  , k = v.repeat
                  , G = v.description
                  , W = v.duration
                  , Z = v.attach
                  , Y = v.attachType
                  , J = v.trigger
                  , K = v.summary
                  , X = "BEGIN:VALARM\r\n";
                X += (0,
                U.default)("ACTION:".concat((0,
                H.default)(function setAction(v) {
                    return v.toUpperCase()
                }(E)))) + "\r\n",
                X += k ? (0,
                U.default)("REPEAT:".concat(k)) + "\r\n" : "",
                X += G ? (0,
                U.default)("DESCRIPTION:".concat((0,
                H.default)(G))) + "\r\n" : "",
                X += W ? (0,
                U.default)("DURATION:".concat(setDuration(W))) + "\r\n" : "";
                var Q = Y || "FMTTYPE=audio/basic";
                return X += Z ? (0,
                U.default)((0,
                H.default)("ATTACH;".concat(Q, ":").concat(Z))) + "\r\n" : "",
                X += J ? function setTrigger(v) {
                    var E = "";
                    if (Array.isArray(v) || "number" == typeof v || "string" == typeof v)
                        E = "TRIGGER;VALUE=DATE-TIME:".concat((0,
                        H.default)((0,
                        R.default)(v)), "\r\n");
                    else {
                        var k = v.before ? "-" : "";
                        E = "TRIGGER:".concat((0,
                        H.default)(k + setDuration(v)), "\r\n")
                    }
                    return E
                }(J) : "",
                X += K ? (0,
                U.default)("SUMMARY:".concat((0,
                H.default)(K))) + "\r\n" : "",
                X += "END:VALARM\r\n"
            }
            ;
            var R = _interopRequireDefault(k(1966))
              , U = _interopRequireDefault(k(4561))
              , H = _interopRequireDefault(k(9364));
            function _interopRequireDefault(v) {
                return v && v.__esModule ? v : {
                    "default": v
                }
            }
            function setDuration(v) {
                var E = v.weeks
                  , k = v.days
                  , R = v.hours
                  , U = v.minutes
                  , H = v.seconds
                  , G = "P";
                return G += E ? "".concat(E, "W") : "",
                G += k ? "".concat(k, "D") : "",
                G += "T",
                G += R ? "".concat(R, "H") : "",
                G += U ? "".concat(U, "M") : "",
                G += H ? "".concat(H, "S") : ""
            }
        },
        "6382": function(v, E, k) {
            "use strict";
            Object.defineProperty(E, "__esModule", {
                "value": !0
            }),
            E.default = function setContact(v) {
                var E = v.name
                  , k = v.email
                  , U = v.rsvp
                  , H = v.dir
                  , G = v.partstat
                  , W = v.role
                  , Z = v.cutype
                  , Y = v.xNumGuests
                  , J = [];
                void 0 !== U && J.push(U ? "RSVP=TRUE" : "RSVP=FALSE");
                Z && J.push("CUTYPE=".concat((0,
                R.default)(Z)));
                void 0 !== Y && J.push("X-NUM-GUESTS=".concat(Y));
                W && J.push("ROLE=".concat((0,
                R.default)(W)));
                G && J.push("PARTSTAT=".concat((0,
                R.default)(G)));
                H && J.push("DIR=".concat((0,
                R.default)(H)));
                return J.push("CN=".concat((0,
                R.default)(E || "Unnamed attendee"))),
                J.join(";").concat(k ? ":mailto:".concat(k) : "")
            }
            ;
            var R = function _interopRequireDefault(v) {
                return v && v.__esModule ? v : {
                    "default": v
                }
            }(k(6444))
        },
        "4209": function(v, E, k) {
            "use strict";
            Object.defineProperty(E, "__esModule", {
                "value": !0
            }),
            E.default = function setDescription(v) {
                return (0,
                R.default)(v)
            }
            ;
            var R = function _interopRequireDefault(v) {
                return v && v.__esModule ? v : {
                    "default": v
                }
            }(k(2257))
        },
        "5735": function(v, E) {
            "use strict";
            Object.defineProperty(E, "__esModule", {
                "value": !0
            }),
            E.default = function setGeolocation(v) {
                var E = v.lat
                  , k = v.lon;
                return "".concat(E, ";").concat(k)
            }
        },
        "9017": function(v, E, k) {
            "use strict";
            Object.defineProperty(E, "__esModule", {
                "value": !0
            }),
            E.default = function setLocation(v) {
                return (0,
                R.default)(v)
            }
            ;
            var R = function _interopRequireDefault(v) {
                return v && v.__esModule ? v : {
                    "default": v
                }
            }(k(2257))
        },
        "4884": function(v, E, k) {
            "use strict";
            Object.defineProperty(E, "__esModule", {
                "value": !0
            }),
            E.default = function setOrganizer(v) {
                var E = v.name
                  , k = v.email
                  , U = v.dir
                  , H = v.sentBy
                  , G = "";
                return G += U ? "DIR=".concat((0,
                R.default)(U), ";") : "",
                G += H ? "SENT-BY=".concat((0,
                R.default)("MAILTO:".concat(H)), ";") : "",
                G += "CN=",
                G += (0,
                R.default)(E || "Organizer"),
                G += k ? ":MAILTO:".concat(k) : ""
            }
            ;
            var R = function _interopRequireDefault(v) {
                return v && v.__esModule ? v : {
                    "default": v
                }
            }(k(6444))
        },
        "4521": function(v, E, k) {
            "use strict";
            Object.defineProperty(E, "__esModule", {
                "value": !0
            }),
            E.default = function setSummary(v) {
                return (0,
                R.default)(v)
            }
            ;
            var R = function _interopRequireDefault(v) {
                return v && v.__esModule ? v : {
                    "default": v
                }
            }(k(2257))
        },
        "3805": function(v) {
            "use strict";
            v.exports = isMobile,
            v.exports.isMobile = isMobile,
            v.exports.default = isMobile;
            const E = /(android|bb\d+|meego).+mobile|armv7l|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series[46]0|samsungbrowser.*mobile|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i
              , k = /CrOS/
              , R = /android|ipad|playbook|silk/i;
            function isMobile(v) {
                v || (v = {});
                let U = v.ua;
                if (U || "undefined" == typeof navigator || (U = navigator.userAgent),
                U && U.headers && "string" == typeof U.headers["user-agent"] && (U = U.headers["user-agent"]),
                "string" != typeof U)
                    return !1;
                let H = E.test(U) && !k.test(U) || !!v.tablet && R.test(U);
                return !H && v.tablet && v.featureDetect && navigator && navigator.maxTouchPoints > 1 && -1 !== U.indexOf("Macintosh") && -1 !== U.indexOf("Safari") && (H = !0),
                H
            }
        },
        "6829": function(v, E, k) {
            "use strict";
            var R = Object.getOwnPropertySymbols
              , U = Object.prototype.hasOwnProperty
              , H = Object.prototype.propertyIsEnumerable;
            var G = function shouldUseNative() {
                try {
                    if (!Object.assign)
                        return !1;
                    var v = new String("abc");
                    if (v[5] = "de",
                    "5" === Object.getOwnPropertyNames(v)[0])
                        return !1;
                    for (var E = {}, k = 0; k < 10; k++)
                        E["_" + String.fromCharCode(k)] = k;
                    if ("0123456789" !== Object.getOwnPropertyNames(E).map((function(v) {
                        return E[v]
                    }
                    )).join(""))
                        return !1;
                    var R = {};
                    return "abcdefghijklmnopqrst".split("").forEach((function(v) {
                        R[v] = v
                    }
                    )),
                    "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, R)).join("")
                } catch (v) {
                    return !1
                }
            }() ? Object.assign : function(v, E) {
                for (var k, G, W = function toObject(v) {
                    if (null == v)
                        throw new TypeError("Object.assign cannot be called with null or undefined");
                    return Object(v)
                }(v), Z = 1; Z < arguments.length; Z++) {
                    for (var Y in k = Object(arguments[Z]))
                        U.call(k, Y) && (W[Y] = k[Y]);
                    if (R) {
                        G = R(k);
                        for (var J = 0; J < G.length; J++)
                            H.call(k, G[J]) && (W[G[J]] = k[G[J]])
                    }
                }
                return W
            }
              , W = encodeURIComponent;
            function isFunction(v) {
                return "function" == typeof v
            }
            var Z = ("undefined" != typeof window ? window : k.g).localStorage
              , Y = {
                "disabled": !1,
                "set": function set(v, E) {
                    return void 0 === E ? Y.remove(v) : (Z.setItem(v, Y.serialize(E)),
                    E)
                },
                "get": function get(v, E) {
                    var k = Y.deserialize(Z.getItem(v));
                    return void 0 === k ? E : k
                },
                "remove": function remove(v) {
                    Z.removeItem(v)
                },
                "clear": function clear() {
                    Z.clear()
                },
                "has": function has(v) {
                    return void 0 !== Y.get(v)
                },
                "forEach": function forEach(v) {
                    for (var E = 0; E < Z.length; E++) {
                        var k = Z.key(E);
                        v(k, Y.get(k))
                    }
                },
                "getAll": function getAll() {
                    var v = {};
                    return Y.forEach((function(E, k) {
                        v[E] = k
                    }
                    )),
                    v
                },
                "serialize": function serialize(v) {
                    return JSON.stringify(v)
                },
                "deserialize": function deserialize(v) {
                    if ("string" == typeof v)
                        try {
                            return JSON.parse(v)
                        } catch (E) {
                            return v || void 0
                        }
                }
            };
            try {
                var J = "__store__";
                Y.set(J, J),
                Y.get(J) !== J && (Y.disabled = !0),
                Y.remove(J)
            } catch (v) {
                Y.disabled = !0
            }
            Y.enabled = !Y.disabled;
            var K = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(v) {
                return typeof v
            }
            : function(v) {
                return v && "function" == typeof Symbol && v.constructor === Symbol && v !== Symbol.prototype ? "symbol" : typeof v
            }
              , X = "undefined" != typeof window ? window : k.g
              , Q = "Promise"in X && K(isFunction(Promise))
              , ee = function noop() {}
              , te = encodeURIComponent
              , ne = X.document
              , re = ne ? ne.head || ne.getElementsByTagName("head")[0] : null
              , oe = 2e3
              , ie = {
                "timeout": oe,
                "retryTimes": 2,
                "backup": null,
                "params": {},
                "jsonp": "callback",
                "name": null,
                "cache": !1,
                "useStore": !1,
                "storeCheck": null,
                "storeSign": null,
                "storeCheckKey": null,
                "dataCheck": null,
                "charset": "UTF-8"
            }
              , ae = (new Date).getTime();
            function generateJsonpUrlWithParams(v, E) {
                return E = "string" == typeof E ? E : function serializeParams(v) {
                    return v ? Object.keys(v).map((function(E) {
                        return E + "=" + W(v[E])
                    }
                    )).join("&") : ""
                }(E),
                v = (v += (~v.indexOf("?") ? "&" : "?") + E).replace("?&", "?")
            }
            function fetchData(v, E, k) {
                var R = E.originalUrl
                  , U = E.charset
                  , H = function getUrlQueryParamByName(v, E) {
                    v || (v = window.location.href),
                    E = E.replace(/[[]]/g, "\\$&");
                    var k = new RegExp("[?&]" + E + "(=([^&#]*)|&|#|$)").exec(v);
                    return k ? k[2] ? decodeURIComponent(k[2].replace(/\+/g, " ")) : "" : null
                }(v, E.jsonp)
                  , G = "?" !== H && H || E.name || "__jsonp" + ae++
                  , W = arguments[3] || null;
                H ? "?" === H && (v = function updateQueryStringParamByName(v, E, k) {
                    var R = new RegExp("([?&])" + E + "=.*?(&|$)","i")
                      , U = -1 !== v.indexOf("?") ? "&" : "?";
                    return v.match(R) ? v.replace(R, "$1" + E + "=" + k + "$2") : v + U + E + "=" + k
                }(v, E.jsonp, te(G))) : v += ("&" === v.split("").pop() ? "" : "&") + E.jsonp + "=" + te(G),
                E.cache || (v += ("&" === v.split("").pop() ? "" : "&") + "_=" + (new Date).getTime()),
                clearTimeout(X["timer_" + G]);
                var Z = X[G];
                X[G] = function(v) {
                    if (Z && Z(v),
                    cleanup(G),
                    W && (v.__$$backupCall = W),
                    E.dataCheck) {
                        if (!1 !== E.dataCheck(v))
                            return setDataToStore({
                                "useStore": E.useStore,
                                "storeKey": R,
                                "data": v
                            }),
                            k(null, v);
                        !1 === fallback(R, E, k) && k(new Error("Data check error, and no fallback"))
                    } else
                        setDataToStore({
                            "useStore": E.useStore,
                            "storeKey": R,
                            "data": v
                        }),
                        k(null, v)
                }
                ;
                var Y = function appendScriptTagToHead(v) {
                    var E = v.url
                      , k = v.charset;
                    if (!ne)
                        return;
                    var R = ne.createElement("script");
                    R.type = "text/javascript",
                    k && (R.charset = k);
                    return R.src = E,
                    re.appendChild(R),
                    R
                }({
                    "url": v,
                    "charset": U
                })
                  , J = null != E.timeout ? E.timeout : oe;
                function cleanup(v) {
                    Y.parentNode && Y.parentNode.removeChild(Y),
                    X[v] = ee,
                    clearTimeout(X["timer_" + v])
                }
                X["timer_" + G] = setTimeout((function() {
                    return cleanup(G),
                    "number" == typeof E.retryTimes && E.retryTimes > 0 ? (E.retryTimes--,
                    fetchData(R, E, k)) : !1 === fallback(R, E, k) ? k(new Error("Timeout and no data return")) : void 0
                }
                ), J)
            }
            function storeCheckFn(v, E, k) {
                return !!(v && E && k) && (v[E] && v[E] === k)
            }
            function setDataToStore(v) {
                var E = v.useStore
                  , k = v.storeKey
                  , R = v.data;
                (E = !!E && Y.enabled) && Y.set(k, R)
            }
            function fallback(v, E, k) {
                var R = E.backup;
                if (R) {
                    if ("string" == typeof R)
                        return delete E.backup,
                        fetchData(generateJsonpUrlWithParams(R, E.params), E, k, {
                            "backup": R
                        });
                    if (Array.isArray(R) && R.length) {
                        var U = R.shift();
                        return fetchData(generateJsonpUrlWithParams(U, E.params), E, k, {
                            "backup": U
                        })
                    }
                }
                var H = function getDataFromStoreWithoutCheck(v) {
                    var E = v.useStore
                      , k = v.storeKey
                      , R = v.dataCheck;
                    if (E = !!E && Y.enabled) {
                        var U = Y.get(k);
                        if (!R || U && R && !1 !== R(U))
                            return U
                    }
                    return null
                }({
                    "useStore": E.useStore,
                    "storeKey": v,
                    "dataCheck": E.dataCheck
                });
                return !!H && (k(null, H),
                !0)
            }
            E.Z = function jsonp$1(v, E, k) {
                if (isFunction(v) ? (k = v,
                E = {}) : v && "object" === (void 0 === v ? "undefined" : K(v)) && (k = E,
                v = (E = v || {}).url),
                isFunction(E) && (k = E,
                E = {}),
                E || (E = {}),
                E = G({}, ie, E),
                v = v || E.url,
                k = k || ee,
                !v || "string" != typeof v)
                    return k(new Error("Param url is needed!")),
                    !jsonp$1.promiseClose && Q ? new Promise((function(v, E) {
                        return E(new Error("Param url is needed!"))
                    }
                    )) : void 0;
                var R = generateJsonpUrlWithParams(v, E.params)
                  , U = function getDataFromStore(v) {
                    var E = v.useStore
                      , k = v.storeKey
                      , R = v.storeCheck
                      , U = v.storeCheckKey
                      , H = v.storeSign
                      , G = v.dataCheck;
                    if (E = !!E && Y.enabled) {
                        var W = Y.get(k);
                        if ((R = R || storeCheckFn)(W, U, H) && (!G || W && G && !1 !== G(W)))
                            return W
                    }
                    return null
                }({
                    "useStore": E.useStore,
                    "storeKey": R,
                    "storeCheck": E.storeCheck,
                    "storeCheckKey": E.storeCheckKey,
                    "storeSign": E.storeSign,
                    "dataCheck": E.dataCheck
                });
                return U ? (k(null, U),
                !jsonp$1.promiseClose && Q ? new Promise((function(v) {
                    return v(U)
                }
                )) : void 0) : (E.originalUrl = R,
                !jsonp$1.promiseClose && Q ? new Promise((function(v, U) {
                    fetchData(R, E, (function(E, R) {
                        if (E)
                            return k(E),
                            U(E);
                        k(null, R),
                        v(R)
                    }
                    ))
                }
                )) : void fetchData(R, E, k))
            }
        },
        "9942": function(v, E) {
            "use strict";
            Object.defineProperty(E, "__esModule", {
                "value": !0
            }),
            E.GetAPI = E.APIReady = E.setupAPI = void 0;
            var k = void 0
              , R = [];
            E.setupAPI = function(v) {
                k = v,
                R.forEach((function(v) {
                    v()
                }
                )),
                R = []
            }
            ;
            E.APIReady = function(v) {
                R.push(v)
            }
            ;
            E.GetAPI = function() {
                return k
            }
        },
        "4287": function(v, E, k) {
            "use strict";
            Object.defineProperty(E, "__esModule", {
                "value": !0
            }),
            E.GetVstUserId = E.GetUserId = E.GetDeviceInfo = E.getSUV = void 0;
            var R = k(9942)
              , U = k(2665);
            E.getSUV = function() {
                var v, E, k, H, G = (null === (v = (0,
                R.GetAPI)()) || void 0 === v ? void 0 : v.getStorageSync) && (null === (E = (0,
                R.GetAPI)()) || void 0 === E ? void 0 : E.getStorageSync("SUV"));
                return G || (G = (0,
                U.CreateUUID)(),
                (null === (k = (0,
                R.GetAPI)()) || void 0 === k ? void 0 : k.setStorageSync) && (null === (H = (0,
                R.GetAPI)()) || void 0 === H || H.setStorageSync("SUV", G))),
                G
            }
            ;
            var getDefaultDeviceInfo = function() {
                var v, k, U = (null === (v = (0,
                R.GetAPI)()) || void 0 === v ? void 0 : v.getSystemInfoSync) && (null === (k = (0,
                R.GetAPI)()) || void 0 === k ? void 0 : k.getSystemInfoSync());
                return {
                    "os_type": (null == U ? void 0 : U.system.split(" ")[0]) || "",
                    "os_version": (null == U ? void 0 : U.system.split(" ")[1]) || "",
                    "device_type": (null == U ? void 0 : U.platform) || "",
                    "device_brand": (null == U ? void 0 : U.brand) || "",
                    "device_model": (null == U ? void 0 : U.model) || "",
                    "device_res": (null == U ? void 0 : U.screenWidth) + "*" + (null == U ? void 0 : U.screenHeight),
                    "device_pixrat": (null == U ? void 0 : U.pixelRatio) || 0,
                    "SUV": (0,
                    E.getSUV)()
                }
            };
            E.GetDeviceInfo = function(v) {
                return v ? Object.assign(getDefaultDeviceInfo(), v) : getDefaultDeviceInfo()
            }
            ;
            var H = "";
            "undefined" != typeof __root && __root.getUserId && __root.getUserId((function(v) {
                H = v
            }
            ), "userId");
            E.GetUserId = function() {
                var v, E;
                return H || (H = (null === (v = (0,
                R.GetAPI)()) || void 0 === v ? void 0 : v.setStorageSync) && (null === (E = (0,
                R.GetAPI)()) || void 0 === E ? void 0 : E.getStorageSync("userId"))),
                H
            }
            ;
            E.GetVstUserId = function() {
                var v, E, k = (null === (v = (0,
                R.GetAPI)()) || void 0 === v ? void 0 : v.getStorageSync) && (null === (E = (0,
                R.GetAPI)()) || void 0 === E ? void 0 : E.getStorageSync("userInfo"));
                return k && k.userId ? k.userId : ""
            }
        },
        "1490": function(v, E, k) {
            "use strict";
            E.dK = void 0;
            var R = new (k(3978).TrackerManager);
            E.dK = R;
            var U = k(3566);
            var H = k(4287)
        },
        "3978": function(v, E, k) {
            "use strict";
            Object.defineProperty(E, "__esModule", {
                "value": !0
            }),
            E.TrackerManager = void 0;
            var R = k(2665)
              , U = k(3566)
              , H = k(794)
              , G = k(9907)
              , W = k(9942)
              , Z = function() {
                function TrackerManager() {
                    var v = this;
                    this.maxEVGroupCount = 20,
                    this.sessionId = (0,
                    R.CreateSessionId)(),
                    this.backFromBackground = !1,
                    this.EVQueue = [],
                    this.SendEVWithThrottle = (0,
                    R.throttle)((function() {
                        v.sendEVReport()
                    }
                    ), 1e3)
                }
                return Object.defineProperty(TrackerManager.prototype, "currentTracker", {
                    "get": function() {
                        return this._currentTracker
                    },
                    "enumerable": !1,
                    "configurable": !0
                }),
                Object.defineProperty(TrackerManager.prototype, "configration", {
                    "get": function() {
                        return this._configration || {
                            "appName": "",
                            "appId": "",
                            "appVersion": "",
                            "spmA": "0",
                            "vst_user_id": ""
                        }
                    },
                    "enumerable": !1,
                    "configurable": !0
                }),
                TrackerManager.prototype.setupConfigration = function(v) {
                    var E = this.configration;
                    v.appName && (E.appName = v.appName),
                    v.appId && (E.appId = v.appId),
                    v.appVersion && (E.appVersion = v.appVersion),
                    v.spmA && (E.spmA = v.spmA),
                    v.vst_user_id && (E.vst_user_id = v.vst_user_id),
                    v.ext && (E.ext = v.ext),
                    v.requestOptions && (E.requestOptions = v.requestOptions),
                    v.isWeb && (E.isWeb = v.isWeb),
                    this._configration = E,
                    v.api && (0,
                    W.setupAPI)(v.api)
                }
                ,
                TrackerManager.prototype.trackStart = function(v, E) {
                    v.becomeCurrent(E),
                    this.updateTrackerLink(v)
                }
                ,
                TrackerManager.prototype.onAppHide = function() {
                    var v;
                    this.trackPVEnd(),
                    this.updateTrackerLink(null === (v = this.currentTracker) || void 0 === v ? void 0 : v.copy()),
                    this.backFromBackground = !0
                }
                ,
                TrackerManager.prototype.onAppShow = function() {}
                ,
                TrackerManager.prototype.resetBackFromStatus = function() {
                    this.backFromBackground = !1
                }
                ,
                TrackerManager.prototype.updateTrackerLink = function(v) {
                    var E;
                    this.previousTracker = null === (E = this.currentTracker) || void 0 === E ? void 0 : E.previousStatus,
                    this._currentTracker = v
                }
                ,
                TrackerManager.prototype.createPageTracker = function(v, E, k, R) {
                    return new U.PageTracker(String(this.configration.spmA),v,E,k,R)
                }
                ,
                TrackerManager.prototype.trackPV = function() {
                    this.needTrackPVEnd() ? this.trackPVEnd() : this.resetBackFromStatus()
                }
                ,
                TrackerManager.prototype.trackPVEnd = function() {
                    this.currentTracker && this.sendPVReport()
                }
                ,
                TrackerManager.prototype.sendPVReport = function() {
                    if (this.currentTracker) {
                        var v = (0,
                        H.CreateTrackModel)(this.configration)
                          , E = (0,
                        H.CreatePVModel)(this.sessionId, this.currentTracker, this.previousTracker);
                        this.configration.isWeb && (E.refer_page_info = (null === document || void 0 === document ? void 0 : document.referrer) || ""),
                        (0,
                        G.SendPV)(Object.assign(v, {
                            "pv_modules": [E]
                        }), this.configration.requestOptions)
                    }
                }
                ,
                TrackerManager.prototype.needTrackPVEnd = function() {
                    return !this.backFromBackground
                }
                ,
                TrackerManager.prototype.trackEV = function(v, E, k, R, U) {
                    if (void 0 === v && (v = "0"),
                    void 0 === E && (E = "0"),
                    void 0 === k && (k = ""),
                    this.currentTracker) {
                        var G = this.currentTracker.createExposeTracker(v, E, k, R, U)
                          , W = (0,
                        H.CreateEVModel)(this.sessionId, G, this.previousTracker);
                        this.configration.isWeb && (W.refer_page_info = (null === document || void 0 === document ? void 0 : document.referrer) || ""),
                        this.EVQueue.push(W),
                        this.SendEVWithThrottle()
                    }
                }
                ,
                TrackerManager.prototype.sendEVReport = function() {
                    var v = this;
                    if (0 != this.EVQueue.length) {
                        var E = (0,
                        H.CreateTrackModel)(this.configration)
                          , k = this.EVQueue.splice(0, this.maxEVGroupCount);
                        (0,
                        G.SendEV)(Object.assign(E, {
                            "exp_info": k
                        }), this.configration.requestOptions).then((function() {
                            v.SendEVWithThrottle()
                        }
                        )).catch((function() {
                            v.EVQueue = k.concat(v.EVQueue)
                        }
                        ))
                    }
                }
                ,
                TrackerManager.prototype.trackAction = function() {
                    if (this.currentTracker) {
                        var v = arguments[0]
                          , E = arguments[arguments.length - 1]
                          , k = "object" == typeof E ? E : void 0
                          , R = this.currentTracker.createActionTracker(v, k)
                          , U = arguments[1];
                        R.spmC = "string" == typeof U ? U : "0";
                        var H = arguments[2];
                        R.spmD = "string" == typeof H ? H : "0",
                        this.sendActionReport(R)
                    }
                }
                ,
                TrackerManager.prototype.sendActionReport = function(v) {
                    var E = (0,
                    H.CreateTrackModel)(this.configration)
                      , k = (0,
                    H.CreateActionModel)(this.sessionId, v, this.previousTracker);
                    this.configration.isWeb && (k.refer_page_info = (null === document || void 0 === document ? void 0 : document.referrer) || ""),
                    (0,
                    G.SendAction)(Object.assign(E, {
                        "action_info": [k]
                    }), this.configration.requestOptions)
                }
                ,
                TrackerManager
            }();
            E.TrackerManager = Z
        },
        "7911": function(v, E, k) {
            "use strict";
            Object.defineProperty(E, "__esModule", {
                "value": !0
            }),
            E.GetNetworkType = void 0;
            var R = k(9942)
              , U = "unknown";
            (0,
            R.APIReady)((function() {
                var v, E, k, H;
                (null === (v = (0,
                R.GetAPI)()) || void 0 === v ? void 0 : v.onNetworkStatusChange) && (null === (E = (0,
                R.GetAPI)()) || void 0 === E || E.onNetworkStatusChange((function(v) {
                    U = v.networkType
                }
                ))),
                (null === (k = (0,
                R.GetAPI)()) || void 0 === k ? void 0 : k.getNetworkType) && (null === (H = (0,
                R.GetAPI)()) || void 0 === H || H.getNetworkType({
                    "success": function(v) {
                        U = v.networkType
                    }
                }))
            }
            ));
            E.GetNetworkType = function() {
                return U
            }
        },
        "9907": function(v, E, k) {
            "use strict";
            var R = this && this.__assign || function() {
                return R = Object.assign || function(v) {
                    for (var E, k = 1, R = arguments.length; k < R; k++)
                        for (var U in E = arguments[k])
                            Object.prototype.hasOwnProperty.call(E, U) && (v[U] = E[U]);
                    return v
                }
                ,
                R.apply(this, arguments)
            }
            ;
            Object.defineProperty(E, "__esModule", {
                "value": !0
            }),
            E.SendAction = E.SendEV = E.SendPV = void 0;
            var U = k(9942)
              , H = "https://track.sohu.com/"
              , G = H + "sv"
              , W = H + "se"
              , Z = H + "sa"
              , SendRequest = function(v, E, k) {
                return void 0 === k && (k = {}),
                new Promise((function(H, G) {
                    var W;
                    null === (W = (0,
                    U.GetAPI)()) || void 0 === W || W.request(R({
                        "url": v,
                        "data": E,
                        "method": "POST",
                        "success": function(v) {
                            H(v)
                        },
                        "fail": function(v) {
                            G(v)
                        }
                    }, k))
                }
                ))
            };
            E.SendPV = function(v, E) {
                return SendRequest(G, v, E)
            }
            ;
            E.SendEV = function(v, E) {
                return SendRequest(W, v, E)
            }
            ;
            E.SendAction = function(v, E) {
                return SendRequest(Z, v, E)
            }
        },
        "794": function(v, E, k) {
            "use strict";
            var R = this && this.__assign || function() {
                return R = Object.assign || function(v) {
                    for (var E, k = 1, R = arguments.length; k < R; k++)
                        for (var U in E = arguments[k])
                            Object.prototype.hasOwnProperty.call(E, U) && (v[U] = E[U]);
                    return v
                }
                ,
                R.apply(this, arguments)
            }
            ;
            Object.defineProperty(E, "__esModule", {
                "value": !0
            }),
            E.CreateActionModel = E.CreateEVModel = E.CreatePVModel = E.CreateTrackModel = void 0;
            var U = k(4287)
              , H = k(7911);
            E.CreateTrackModel = function(v) {
                return {
                    "report_time": +new Date,
                    "app_name": (null == v ? void 0 : v.appName) || "",
                    "app_id": (null == v ? void 0 : v.appId) || "",
                    "app_version": (null == v ? void 0 : v.appVersion) || "",
                    "device_info": (0,
                    U.GetDeviceInfo)(),
                    "vst_user_id": (null == v ? void 0 : v.vst_user_id) || (0,
                    U.GetVstUserId)(),
                    "ext": R({
                        "userId": (0,
                        U.GetUserId)()
                    }, null == v ? void 0 : v.ext)
                }
            }
            ;
            var CreateEventModel = function(v, E, k) {
                return {
                    "timestamp": E.startTimestamp,
                    "log_time": +new Date,
                    "session_id": v,
                    "net": (0,
                    H.GetNetworkType)(),
                    "spm_cnt": E.spmCode,
                    "spm_pre": null == k ? void 0 : k.spmCode,
                    "page_info": E.pageInfo,
                    "ev_page_info": E.evPageInfo,
                    "refer_page_info": null == k ? void 0 : k.pageInfo,
                    "pv_id": E.pvId,
                    "pvid_pre": null == k ? void 0 : k.pvId
                }
            };
            E.CreatePVModel = function(v, E, k) {
                return Object.assign(CreateEventModel(v, E, k), {
                    "scm_pre": null == k ? void 0 : k.scm
                })
            }
            ;
            E.CreateEVModel = function(v, E, k) {
                return Object.assign(CreateEventModel(v, E, k), {
                    "scm_cnt": E.scm,
                    "ext": E.ext
                })
            }
            ;
            E.CreateActionModel = function(v, E, k) {
                return Object.assign(CreateEventModel(v, E, k), {
                    "acode": E.acode,
                    "aext": E.aext
                })
            }
        },
        "3566": function(v, E, k) {
            "use strict";
            var R, U = this && this.__extends || (R = function(v, E) {
                return R = Object.setPrototypeOf || {
                    "__proto__": []
                }instanceof Array && function(v, E) {
                    v.__proto__ = E
                }
                || function(v, E) {
                    for (var k in E)
                        Object.prototype.hasOwnProperty.call(E, k) && (v[k] = E[k])
                }
                ,
                R(v, E)
            }
            ,
            function(v, E) {
                if ("function" != typeof E && null !== E)
                    throw new TypeError("Class extends value " + String(E) + " is not a constructor or null");
                function __() {
                    this.constructor = v
                }
                R(v, E),
                v.prototype = null === E ? Object.create(E) : (__.prototype = E.prototype,
                new __)
            }
            );
            Object.defineProperty(E, "__esModule", {
                "value": !0
            }),
            E.ActionTracker = E.ExposeTracker = E.PageTracker = void 0;
            var H = k(2665)
              , G = function(v) {
                function PageTracker(E, k, R, U, G) {
                    var W = v.call(this) || this;
                    return W._pvId = (0,
                    H.CreatePvId)(),
                    W.spmA = E,
                    W.spmB = k,
                    W.pageInfo = R,
                    U && (W._pvId = U),
                    G && W.updateECode(G),
                    W._startTimestamp = +new Date,
                    W
                }
                return U(PageTracker, v),
                Object.defineProperty(PageTracker.prototype, "pvId", {
                    "get": function() {
                        return this._pvId
                    },
                    "enumerable": !1,
                    "configurable": !0
                }),
                Object.defineProperty(PageTracker.prototype, "startTimestamp", {
                    "get": function() {
                        return this._startTimestamp
                    },
                    "enumerable": !1,
                    "configurable": !0
                }),
                Object.defineProperty(PageTracker.prototype, "previousStatus", {
                    "get": function() {
                        return this._previousStatus || this.copy()
                    },
                    "enumerable": !1,
                    "configurable": !0
                }),
                PageTracker.prototype.becomePrevious = function(v, E, k) {
                    void 0 === v && (v = "0"),
                    void 0 === E && (E = "0");
                    var R = this.copy();
                    R.spmC = v,
                    R.spmD = E,
                    R.scm = k,
                    this._previousStatus = R
                }
                ,
                PageTracker.prototype.becomeCurrent = function(v) {
                    !v && this.updateECode(),
                    this._previousStatus = void 0,
                    this._startTimestamp = +new Date
                }
                ,
                PageTracker.prototype.createActionTracker = function(v, E) {
                    var k = new Z(this.spmA,this.spmB,v,this.pageInfo,E,this.pvId);
                    return k.updateECode(this.spmE),
                    k
                }
                ,
                PageTracker.prototype.createExposeTracker = function(v, E, k, R, U) {
                    void 0 === v && (v = "0"),
                    void 0 === E && (E = "0"),
                    void 0 === k && (k = ""),
                    U || (U = {});
                    var H = this.pageInfo
                      , G = new W(this.spmA,this.spmB,H,this.pvId);
                    return G.spmC = v,
                    G.spmD = E,
                    G.scm = k,
                    G.evPageInfo = U,
                    R && (G.ext = R),
                    G.updateECode(this.spmE),
                    G
                }
                ,
                PageTracker.prototype.copy = function() {
                    var v = new PageTracker(this.spmA,this.spmB,this.pageInfo);
                    return v._startTimestamp = this.startTimestamp,
                    v._pvId = this.pvId,
                    v.updateECode(this.spmE),
                    v
                }
                ,
                PageTracker.prototype.getTrackerData = function() {
                    return {
                        "spmA": this.spmA,
                        "spmB": this.spmB,
                        "spmC": this.spmC,
                        "spmD": this.spmD,
                        "spmE": this.spmE,
                        "pvId": this.pvId
                    }
                }
                ,
                PageTracker
            }(function() {
                function SPMCode() {
                    this.spmC = "0",
                    this.spmD = "0",
                    this._spmE = (0,
                    H.CreateSpmECode)()
                }
                return Object.defineProperty(SPMCode.prototype, "spmE", {
                    "get": function() {
                        return this._spmE
                    },
                    "enumerable": !1,
                    "configurable": !0
                }),
                Object.defineProperty(SPMCode.prototype, "spmCode", {
                    "get": function() {
                        return "".concat(this.spmA, ".").concat(this.spmB, ".").concat(this.spmC, ".").concat(this.spmD, ".").concat(this.spmE)
                    },
                    "enumerable": !1,
                    "configurable": !0
                }),
                SPMCode.prototype.updateECode = function(v) {
                    this._spmE = v || (0,
                    H.CreateSpmECode)()
                }
                ,
                SPMCode
            }());
            E.PageTracker = G;
            var W = function(v) {
                function ExposeTracker() {
                    return null !== v && v.apply(this, arguments) || this
                }
                return U(ExposeTracker, v),
                ExposeTracker
            }(G);
            E.ExposeTracker = W;
            var Z = function(v) {
                function ActionTracker(E, k, R, U, H, G) {
                    var W = v.call(this, E, k, U, G) || this;
                    return W.acode = R,
                    W.aext = H,
                    W
                }
                return U(ActionTracker, v),
                ActionTracker
            }(G);
            E.ActionTracker = Z
        },
        "2665": function(v, E) {
            "use strict";
            Object.defineProperty(E, "__esModule", {
                "value": !0
            }),
            E.throttle = E.CreateUUID = E.CreateSpmECode = E.CreatePvId = E.CreateSessionId = E.RandomString = void 0;
            E.RandomString = function(v) {
                var E = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
                return Array.from(Array(v)).map((function(v) {
                    return E[parseInt((62 * Math.random()).toString())]
                }
                )).join("")
            }
            ;
            E.CreateSessionId = function() {
                return (new Date).getTime() + (0,
                E.RandomString)(7)
            }
            ;
            E.CreatePvId = function() {
                return (new Date).getTime() + (0,
                E.RandomString)(7)
            }
            ;
            E.CreateSpmECode = function() {
                return (new Date).getTime() + (0,
                E.RandomString)(7)
            }
            ;
            E.CreateUUID = function() {
                return (new Date).getTime() + (0,
                E.RandomString)(7)
            }
            ,
            E.throttle = function throttle(v, E) {
                var k = -1;
                return function() {
                    for (var R = this, U = [], H = 0; H < arguments.length; H++)
                        U[H] = arguments[H];
                    clearTimeout(k),
                    k = setTimeout((function() {
                        v.apply(R, U)
                    }
                    ), E)
                }
            }
        },
        "6711": function(v) {
            window,
            v.exports = function(v) {
                var E = {};
                function o(k) {
                    if (E[k])
                        return E[k].exports;
                    var R = E[k] = {
                        "i": k,
                        "l": !1,
                        "exports": {}
                    };
                    return v[k].call(R.exports, R, R.exports, o),
                    R.l = !0,
                    R.exports
                }
                return o.m = v,
                o.c = E,
                o.d = function(v, E, k) {
                    o.o(v, E) || Object.defineProperty(v, E, {
                        "enumerable": !0,
                        "get": k
                    })
                }
                ,
                o.r = function(v) {
                    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(v, Symbol.toStringTag, {
                        "value": "Module"
                    }),
                    Object.defineProperty(v, "__esModule", {
                        "value": !0
                    })
                }
                ,
                o.t = function(v, E) {
                    if (1 & E && (v = o(v)),
                    8 & E)
                        return v;
                    if (4 & E && "object" == typeof v && v && v.__esModule)
                        return v;
                    var k = Object.create(null);
                    if (o.r(k),
                    Object.defineProperty(k, "default", {
                        "enumerable": !0,
                        "value": v
                    }),
                    2 & E && "string" != typeof v)
                        for (var R in v)
                            o.d(k, R, function(E) {
                                return v[E]
                            }
                            .bind(null, R));
                    return k
                }
                ,
                o.n = function(v) {
                    var E = v && v.__esModule ? function() {
                        return v.default
                    }
                    : function() {
                        return v
                    }
                    ;
                    return o.d(E, "a", E),
                    E
                }
                ,
                o.o = function(v, E) {
                    return Object.prototype.hasOwnProperty.call(v, E)
                }
                ,
                o.p = "",
                o(o.s = 31)
            }([function(v, E, k) {
                "use strict";
                var R = k(2)
                  , U = Object.prototype.toString;
                function i(v) {
                    return "[object Array]" === U.call(v)
                }
                function a(v) {
                    return void 0 === v
                }
                function s(v) {
                    return null !== v && "object" == typeof v
                }
                function c(v) {
                    return "[object Function]" === U.call(v)
                }
                function u(v, E) {
                    if (null != v)
                        if ("object" != typeof v && (v = [v]),
                        i(v))
                            for (var k = 0, R = v.length; k < R; k++)
                                E.call(null, v[k], k, v);
                        else
                            for (var U in v)
                                Object.prototype.hasOwnProperty.call(v, U) && E.call(null, v[U], U, v)
                }
                v.exports = {
                    "isArray": i,
                    "isArrayBuffer": function(v) {
                        return "[object ArrayBuffer]" === U.call(v)
                    },
                    "isBuffer": function(v) {
                        return null !== v && !a(v) && null !== v.constructor && !a(v.constructor) && "function" == typeof v.constructor.isBuffer && v.constructor.isBuffer(v)
                    },
                    "isFormData": function(v) {
                        return "undefined" != typeof FormData && v instanceof FormData
                    },
                    "isArrayBufferView": function(v) {
                        return "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(v) : v && v.buffer && v.buffer instanceof ArrayBuffer
                    },
                    "isString": function(v) {
                        return "string" == typeof v
                    },
                    "isNumber": function(v) {
                        return "number" == typeof v
                    },
                    "isObject": s,
                    "isUndefined": a,
                    "isDate": function(v) {
                        return "[object Date]" === U.call(v)
                    },
                    "isFile": function(v) {
                        return "[object File]" === U.call(v)
                    },
                    "isBlob": function(v) {
                        return "[object Blob]" === U.call(v)
                    },
                    "isFunction": c,
                    "isStream": function(v) {
                        return s(v) && c(v.pipe)
                    },
                    "isURLSearchParams": function(v) {
                        return "undefined" != typeof URLSearchParams && v instanceof URLSearchParams
                    },
                    "isStandardBrowserEnv": function() {
                        return ("undefined" == typeof navigator || "ReactNative" !== navigator.product && "NativeScript" !== navigator.product && "NS" !== navigator.product) && "undefined" != typeof window && "undefined" != typeof document
                    },
                    "forEach": u,
                    "merge": function e() {
                        var v = {};
                        function o(E, k) {
                            "object" == typeof v[k] && "object" == typeof E ? v[k] = e(v[k], E) : v[k] = E
                        }
                        for (var E = 0, k = arguments.length; E < k; E++)
                            u(arguments[E], o);
                        return v
                    },
                    "deepMerge": function e() {
                        var v = {};
                        function o(E, k) {
                            "object" == typeof v[k] && "object" == typeof E ? v[k] = e(v[k], E) : v[k] = "object" == typeof E ? e({}, E) : E
                        }
                        for (var E = 0, k = arguments.length; E < k; E++)
                            u(arguments[E], o);
                        return v
                    },
                    "extend": function(v, E, k) {
                        return u(E, (function(E, U) {
                            v[U] = k && "function" == typeof E ? R(E, k) : E
                        }
                        )),
                        v
                    },
                    "trim": function(v) {
                        return v.replace(/^\s*/, "").replace(/\s*$/, "")
                    }
                }
            }
            , function(v, E, k) {
                v.exports = k(14)
            }
            , function(v, E, k) {
                "use strict";
                v.exports = function(v, E) {
                    return function() {
                        for (var k = new Array(arguments.length), R = 0; R < k.length; R++)
                            k[R] = arguments[R];
                        return v.apply(E, k)
                    }
                }
            }
            , function(v, E, k) {
                "use strict";
                var R = k(0);
                function r(v) {
                    return encodeURIComponent(v).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
                }
                v.exports = function(v, E, k) {
                    if (!E)
                        return v;
                    var U;
                    if (k)
                        U = k(E);
                    else if (R.isURLSearchParams(E))
                        U = E.toString();
                    else {
                        var H = [];
                        R.forEach(E, (function(v, E) {
                            null != v && (R.isArray(v) ? E += "[]" : v = [v],
                            R.forEach(v, (function(v) {
                                R.isDate(v) ? v = v.toISOString() : R.isObject(v) && (v = JSON.stringify(v)),
                                H.push(r(E) + "=" + r(v))
                            }
                            )))
                        }
                        )),
                        U = H.join("&")
                    }
                    if (U) {
                        var G = v.indexOf("#");
                        -1 !== G && (v = v.slice(0, G)),
                        v += (-1 === v.indexOf("?") ? "?" : "&") + U
                    }
                    return v
                }
            }
            , function(v, E, k) {
                "use strict";
                v.exports = function(v) {
                    return !(!v || !v.__CANCEL__)
                }
            }
            , function(v, E, k) {
                "use strict";
                (function(E) {
                    var R = k(0)
                      , U = k(20)
                      , H = {
                        "Content-Type": "application/x-www-form-urlencoded"
                    };
                    function a(v, E) {
                        !R.isUndefined(v) && R.isUndefined(v["Content-Type"]) && (v["Content-Type"] = E)
                    }
                    var G, W = {
                        "adapter": (("undefined" != typeof XMLHttpRequest || void 0 !== E && "[object process]" === Object.prototype.toString.call(E)) && (G = k(6)),
                        G),
                        "transformRequest": [function(v, E) {
                            return U(E, "Accept"),
                            U(E, "Content-Type"),
                            R.isFormData(v) || R.isArrayBuffer(v) || R.isBuffer(v) || R.isStream(v) || R.isFile(v) || R.isBlob(v) ? v : R.isArrayBufferView(v) ? v.buffer : R.isURLSearchParams(v) ? (a(E, "application/x-www-form-urlencoded;charset=utf-8"),
                            v.toString()) : R.isObject(v) ? (a(E, "application/json;charset=utf-8"),
                            JSON.stringify(v)) : v
                        }
                        ],
                        "transformResponse": [function(v) {
                            if ("string" == typeof v)
                                try {
                                    v = JSON.parse(v)
                                } catch (v) {}
                            return v
                        }
                        ],
                        "timeout": 0,
                        "xsrfCookieName": "XSRF-TOKEN",
                        "xsrfHeaderName": "X-XSRF-TOKEN",
                        "maxContentLength": -1,
                        "validateStatus": function(v) {
                            return v >= 200 && v < 300
                        },
                        "headers": {
                            "common": {
                                "Accept": "application/json, text/plain, */*"
                            }
                        }
                    };
                    R.forEach(["delete", "get", "head"], (function(v) {
                        W.headers[v] = {}
                    }
                    )),
                    R.forEach(["post", "put", "patch"], (function(v) {
                        W.headers[v] = R.merge(H)
                    }
                    )),
                    v.exports = W
                }
                ).call(this, k(19))
            }
            , function(v, E, k) {
                "use strict";
                var R = k(0)
                  , U = k(21)
                  , H = k(3)
                  , G = k(23)
                  , W = k(26)
                  , Z = k(27)
                  , Y = k(7);
                v.exports = function(v) {
                    return new Promise((function(E, J) {
                        var K = v.data
                          , X = v.headers;
                        R.isFormData(K) && delete X["Content-Type"];
                        var Q = new XMLHttpRequest;
                        if (v.auth) {
                            var ee = v.auth.username || ""
                              , te = v.auth.password || "";
                            X.Authorization = "Basic " + btoa(ee + ":" + te)
                        }
                        var ne = G(v.baseURL, v.url);
                        if (Q.open(v.method.toUpperCase(), H(ne, v.params, v.paramsSerializer), !0),
                        Q.timeout = v.timeout,
                        Q.onreadystatechange = function() {
                            if (Q && 4 === Q.readyState && (0 !== Q.status || Q.responseURL && 0 === Q.responseURL.indexOf("file:"))) {
                                var k = "getAllResponseHeaders"in Q ? W(Q.getAllResponseHeaders()) : null
                                  , R = {
                                    "data": v.responseType && "text" !== v.responseType ? Q.response : Q.responseText,
                                    "status": Q.status,
                                    "statusText": Q.statusText,
                                    "headers": k,
                                    "config": v,
                                    "request": Q
                                };
                                U(E, J, R),
                                Q = null
                            }
                        }
                        ,
                        Q.onabort = function() {
                            Q && (J(Y("Request aborted", v, "ECONNABORTED", Q)),
                            Q = null)
                        }
                        ,
                        Q.onerror = function() {
                            J(Y("Network Error", v, null, Q)),
                            Q = null
                        }
                        ,
                        Q.ontimeout = function() {
                            var E = "timeout of " + v.timeout + "ms exceeded";
                            v.timeoutErrorMessage && (E = v.timeoutErrorMessage),
                            J(Y(E, v, "ECONNABORTED", Q)),
                            Q = null
                        }
                        ,
                        R.isStandardBrowserEnv()) {
                            var re = k(28)
                              , oe = (v.withCredentials || Z(ne)) && v.xsrfCookieName ? re.read(v.xsrfCookieName) : void 0;
                            oe && (X[v.xsrfHeaderName] = oe)
                        }
                        if ("setRequestHeader"in Q && R.forEach(X, (function(v, E) {
                            void 0 === K && "content-type" === E.toLowerCase() ? delete X[E] : Q.setRequestHeader(E, v)
                        }
                        )),
                        R.isUndefined(v.withCredentials) || (Q.withCredentials = !!v.withCredentials),
                        v.responseType)
                            try {
                                Q.responseType = v.responseType
                            } catch (E) {
                                if ("json" !== v.responseType)
                                    throw E
                            }
                        "function" == typeof v.onDownloadProgress && Q.addEventListener("progress", v.onDownloadProgress),
                        "function" == typeof v.onUploadProgress && Q.upload && Q.upload.addEventListener("progress", v.onUploadProgress),
                        v.cancelToken && v.cancelToken.promise.then((function(v) {
                            Q && (Q.abort(),
                            J(v),
                            Q = null)
                        }
                        )),
                        void 0 === K && (K = null),
                        Q.send(K)
                    }
                    ))
                }
            }
            , function(v, E, k) {
                "use strict";
                var R = k(22);
                v.exports = function(v, E, k, U, H) {
                    var G = new Error(v);
                    return R(G, E, k, U, H)
                }
            }
            , function(v, E, k) {
                "use strict";
                var R = k(0);
                v.exports = function(v, E) {
                    E = E || {};
                    var k = {}
                      , U = ["url", "method", "params", "data"]
                      , H = ["headers", "auth", "proxy"]
                      , G = ["baseURL", "url", "transformRequest", "transformResponse", "paramsSerializer", "timeout", "withCredentials", "adapter", "responseType", "xsrfCookieName", "xsrfHeaderName", "onUploadProgress", "onDownloadProgress", "maxContentLength", "validateStatus", "maxRedirects", "httpAgent", "httpsAgent", "cancelToken", "socketPath"];
                    R.forEach(U, (function(v) {
                        void 0 !== E[v] && (k[v] = E[v])
                    }
                    )),
                    R.forEach(H, (function(U) {
                        R.isObject(E[U]) ? k[U] = R.deepMerge(v[U], E[U]) : void 0 !== E[U] ? k[U] = E[U] : R.isObject(v[U]) ? k[U] = R.deepMerge(v[U]) : void 0 !== v[U] && (k[U] = v[U])
                    }
                    )),
                    R.forEach(G, (function(R) {
                        void 0 !== E[R] ? k[R] = E[R] : void 0 !== v[R] && (k[R] = v[R])
                    }
                    ));
                    var W = U.concat(H).concat(G)
                      , Z = Object.keys(E).filter((function(v) {
                        return -1 === W.indexOf(v)
                    }
                    ));
                    return R.forEach(Z, (function(R) {
                        void 0 !== E[R] ? k[R] = E[R] : void 0 !== v[R] && (k[R] = v[R])
                    }
                    )),
                    k
                }
            }
            , function(v, E, k) {
                "use strict";
                function n(v) {
                    this.message = v
                }
                n.prototype.toString = function() {
                    return "Cancel" + (this.message ? ": " + this.message : "")
                }
                ,
                n.prototype.__CANCEL__ = !0,
                v.exports = n
            }
            , function(v, E, k) {
                var R, U, H;
                U = window,
                H = function(v) {
                    function t(v) {
                        var E = this;
                        v.onekeyId && (K.autoLoadScript("https://passportv4-web.bjcnc.scs.sohucs.com/crypto-js.min.js", (function(v) {
                            E.cryptoLoaded = v
                        }
                        )),
                        K.autoLoadScript("https://www.cmpassport.com/h5/js/jssdk_auth/jssdk-1.0.0.min.js", (function(v) {
                            E.ydrzLoaded = v
                        }
                        ))),
                        this.options = K.extend({}, J, v || {}),
                        this._id = "passport" + U.replace(/\D/g, ""),
                        this.version = U,
                        this.appid = this.options.appid,
                        this.options.gidinf && this.options.serialno && (l("gidinf", this.options.gidinf),
                        l("srn", this.options.serialno)),
                        G ? l("t", H) : l("t", H, W),
                        this.setCommonCookie()
                    }
                    var E, k, R = (k = (E = v).opera ? opera.version().replace(/\d$/, "") - 0 : parseFloat((/(?:IE |fox\/|ome\/|ion\/)(\d+\.\d)/.exec(navigator.userAgent) || [, 0])[1]),
                    {
                        "ie": !!E.VBArray && Math.max(document.documentMode || 0, k),
                        "firefox": !!E.netscape && k,
                        "opera": !!E.opera && k,
                        "chrome": !!E.chrome && k,
                        "safari": /apple/i.test(navigator.vendor) && k
                    }), U = "4.0.14", H = (new Date).getTime(), G = /\.sohu.com/.test(location.host), W = 2 == document.domain.split(".").length ? document.domain : document.domain.split(".").slice(document.domain.split(".").length - 2).join("."), Z = R.ie && R.ie < 9 ? "https://v4.passport.sohu.com/i/".replace("https", "http") : G ? "https://v4.passport.sohu.com/i/" : "https://v4-passport.56.com/i/", Y = "https://m.passport.sohu.com", J = {
                        "appid": "",
                        "url": {
                            "commonCookie": Z + "cookie/common",
                            "challenge": Z + "jf/code",
                            "loginByUserId": Z + "login",
                            "loginRequireCaptcha": Z + "login/require/captcha",
                            "mobileLogin": Z + "login/mobile",
                            "quickLogin": Z + "login/quick",
                            "passportLogin": Z + "login/passport",
                            "scanCodeLogin": Z + "login/token",
                            "pictureCaptcha": Z + "captcha/picture",
                            "signInCaptcha": Z + "smcode/mobile/signin",
                            "registerCaptcha": Z + "smcode/mobile/signup",
                            "newRegisterCaptcha": Z + "smcode/mobile/esignup",
                            "bindPhoneCaptcha": Z + "smcode/mobile/sblmobile",
                            "logout": Z + "logout",
                            "register": Z + "register",
                            "registerUp": Z + "register/v2",
                            "bindPhone": Z + "login/bind/mobile",
                            "checkPhone": Z + "verify/mobile/bind",
                            "checkUserPhoneBind": Z + "verify/user/mobile",
                            "getPhoneCode": Z + "mobile/phonecode",
                            "getMobileCaptcha": Z + "smcode/mobile/v2",
                            "verifyMobileCaptcha": Z + "verify/smcode/mobile",
                            "getSecmobileCaptcha": Z + "smcode/secmobile",
                            "verifySecmobileCaptcha": Z + "verify/smcode/secmobile",
                            "queryCertificateStaus": Z + "certificate/query/passport",
                            "userCertificate": Z + "certificate/create",
                            "getAICaptcha": Z + "captcha/npicture",
                            "verifyAICaptcha": Z + "captcha/nvalid",
                            "resetPassword": Z + "password/reset2",
                            "updatePassword": Z + "password/update2",
                            "verifySecmobCaptcha": Z + "login/security/secmob"
                        }
                    }, K = {
                        "extend": function() {
                            var v, E, k, R, U = arguments[0] || {}, H = arguments.length;
                            for (v = 1; v < H; v++)
                                if (null !== (k = arguments[v]))
                                    for (E in k)
                                        void 0 !== (R = k[E]) && (U[E] = R);
                            return U
                        },
                        "inArray": function(v, E) {
                            for (var k = 0; k < E.length; k++)
                                if (E[k] === v)
                                    return k;
                            return -1
                        },
                        "isString": function(v) {
                            return "string" == typeof v
                        },
                        "isFunction": function(v) {
                            return "function" == typeof v
                        },
                        "isBool": function(v) {
                            return "boolean" == typeof v
                        },
                        "bind": function(v, E) {
                            return function() {
                                v.apply(E, arguments)
                            }
                        },
                        "trim": function(v) {
                            return this.isString(v) ? v.replace(/^\s+/, "").replace(/\s+$/, "") : v
                        },
                        "param": function(v) {
                            var E = [];
                            for (var k in v)
                                E.push(k + "=" + v[k]);
                            return E.join("&")
                        },
                        "url": function(v, E) {
                            return v + (/\?/.test(v) ? "&" : "?") + this.param(E)
                        },
                        "md5": function(v) {
                            function t(v, E, k, R, U, H) {
                                return a((G = a(a(E, v), a(R, H))) << (W = U) | G >>> 32 - W, k);
                                var G, W
                            }
                            function o(v, E, k, R, U, H, G) {
                                return t(E & k | ~E & R, v, E, U, H, G)
                            }
                            function n(v, E, k, R, U, H, G) {
                                return t(E & R | k & ~R, v, E, U, H, G)
                            }
                            function r(v, E, k, R, U, H, G) {
                                return t(E ^ k ^ R, v, E, U, H, G)
                            }
                            function i(v, E, k, R, U, H, G) {
                                return t(k ^ (E | ~R), v, E, U, H, G)
                            }
                            function a(v, E) {
                                var k = (65535 & v) + (65535 & E);
                                return (v >> 16) + (E >> 16) + (k >> 16) << 16 | 65535 & k
                            }
                            var E, k = 0, R = 8;
                            return function(v) {
                                for (var E = k ? "0123456789ABCDEF" : "0123456789abcdef", R = "", U = 0; U < 4 * v.length; U++)
                                    R += E.charAt(v[U >> 2] >> U % 4 * 8 + 4 & 15) + E.charAt(v[U >> 2] >> U % 4 * 8 & 15);
                                return R
                            }(function(v, E) {
                                v[E >> 5] |= 128 << E % 32,
                                v[14 + (E + 64 >>> 9 << 4)] = E;
                                for (var k = 1732584193, R = -271733879, U = -1732584194, H = 271733878, G = 0; G < v.length; G += 16) {
                                    var W = k
                                      , Z = R
                                      , Y = U
                                      , J = H;
                                    k = o(k, R, U, H, v[G + 0], 7, -680876936),
                                    H = o(H, k, R, U, v[G + 1], 12, -389564586),
                                    U = o(U, H, k, R, v[G + 2], 17, 606105819),
                                    R = o(R, U, H, k, v[G + 3], 22, -1044525330),
                                    k = o(k, R, U, H, v[G + 4], 7, -176418897),
                                    H = o(H, k, R, U, v[G + 5], 12, 1200080426),
                                    U = o(U, H, k, R, v[G + 6], 17, -1473231341),
                                    R = o(R, U, H, k, v[G + 7], 22, -45705983),
                                    k = o(k, R, U, H, v[G + 8], 7, 1770035416),
                                    H = o(H, k, R, U, v[G + 9], 12, -1958414417),
                                    U = o(U, H, k, R, v[G + 10], 17, -42063),
                                    R = o(R, U, H, k, v[G + 11], 22, -1990404162),
                                    k = o(k, R, U, H, v[G + 12], 7, 1804603682),
                                    H = o(H, k, R, U, v[G + 13], 12, -40341101),
                                    U = o(U, H, k, R, v[G + 14], 17, -1502002290),
                                    k = n(k, R = o(R, U, H, k, v[G + 15], 22, 1236535329), U, H, v[G + 1], 5, -165796510),
                                    H = n(H, k, R, U, v[G + 6], 9, -1069501632),
                                    U = n(U, H, k, R, v[G + 11], 14, 643717713),
                                    R = n(R, U, H, k, v[G + 0], 20, -373897302),
                                    k = n(k, R, U, H, v[G + 5], 5, -701558691),
                                    H = n(H, k, R, U, v[G + 10], 9, 38016083),
                                    U = n(U, H, k, R, v[G + 15], 14, -660478335),
                                    R = n(R, U, H, k, v[G + 4], 20, -405537848),
                                    k = n(k, R, U, H, v[G + 9], 5, 568446438),
                                    H = n(H, k, R, U, v[G + 14], 9, -1019803690),
                                    U = n(U, H, k, R, v[G + 3], 14, -187363961),
                                    R = n(R, U, H, k, v[G + 8], 20, 1163531501),
                                    k = n(k, R, U, H, v[G + 13], 5, -1444681467),
                                    H = n(H, k, R, U, v[G + 2], 9, -51403784),
                                    U = n(U, H, k, R, v[G + 7], 14, 1735328473),
                                    k = r(k, R = n(R, U, H, k, v[G + 12], 20, -1926607734), U, H, v[G + 5], 4, -378558),
                                    H = r(H, k, R, U, v[G + 8], 11, -2022574463),
                                    U = r(U, H, k, R, v[G + 11], 16, 1839030562),
                                    R = r(R, U, H, k, v[G + 14], 23, -35309556),
                                    k = r(k, R, U, H, v[G + 1], 4, -1530992060),
                                    H = r(H, k, R, U, v[G + 4], 11, 1272893353),
                                    U = r(U, H, k, R, v[G + 7], 16, -155497632),
                                    R = r(R, U, H, k, v[G + 10], 23, -1094730640),
                                    k = r(k, R, U, H, v[G + 13], 4, 681279174),
                                    H = r(H, k, R, U, v[G + 0], 11, -358537222),
                                    U = r(U, H, k, R, v[G + 3], 16, -722521979),
                                    R = r(R, U, H, k, v[G + 6], 23, 76029189),
                                    k = r(k, R, U, H, v[G + 9], 4, -640364487),
                                    H = r(H, k, R, U, v[G + 12], 11, -421815835),
                                    U = r(U, H, k, R, v[G + 15], 16, 530742520),
                                    k = i(k, R = r(R, U, H, k, v[G + 2], 23, -995338651), U, H, v[G + 0], 6, -198630844),
                                    H = i(H, k, R, U, v[G + 7], 10, 1126891415),
                                    U = i(U, H, k, R, v[G + 14], 15, -1416354905),
                                    R = i(R, U, H, k, v[G + 5], 21, -57434055),
                                    k = i(k, R, U, H, v[G + 12], 6, 1700485571),
                                    H = i(H, k, R, U, v[G + 3], 10, -1894986606),
                                    U = i(U, H, k, R, v[G + 10], 15, -1051523),
                                    R = i(R, U, H, k, v[G + 1], 21, -2054922799),
                                    k = i(k, R, U, H, v[G + 8], 6, 1873313359),
                                    H = i(H, k, R, U, v[G + 15], 10, -30611744),
                                    U = i(U, H, k, R, v[G + 6], 15, -1560198380),
                                    R = i(R, U, H, k, v[G + 13], 21, 1309151649),
                                    k = i(k, R, U, H, v[G + 4], 6, -145523070),
                                    H = i(H, k, R, U, v[G + 11], 10, -1120210379),
                                    U = i(U, H, k, R, v[G + 2], 15, 718787259),
                                    R = i(R, U, H, k, v[G + 9], 21, -343485551),
                                    k = a(k, W),
                                    R = a(R, Z),
                                    U = a(U, Y),
                                    H = a(H, J)
                                }
                                return Array(k, R, U, H)
                            }(function(v) {
                                for (var E = Array(), k = (1 << R) - 1, U = 0; U < v.length * R; U += R)
                                    E[U >> 5] |= (v.charCodeAt(U / R) & k) << U % 32;
                                return E
                            }(E = v), E.length * R))
                        },
                        "autoLoadScript": function(v, E) {
                            var k = document.createElement("script")
                              , R = document.getElementsByTagName("head")[0];
                            k.charset = "UTF-8",
                            k.async = !0,
                            k.onerror = function() {
                                E && E(!1)
                            }
                            ;
                            var U = !1;
                            k.onload = k.onreadystatechange = function() {
                                U || k.readyState && "loaded" !== k.readyState && "complete" !== k.readyState || (U = !0,
                                E && E(!0))
                            }
                            ,
                            k.src = v,
                            R.appendChild(k)
                        }
                    }, h = function(v) {
                        var E, k = new RegExp("(^| )" + v + "=([^;]*)(;|$)");
                        return (E = document.cookie.match(k)) ? unescape(E[2]) : null
                    }, l = function(v, E, k) {
                        var R = new Date;
                        R.setTime(R.getTime() + 2592e6),
                        document.cookie = k ? v + "=" + escape(E) + ";domain=" + k + ";path=/;expires=" + R.toGMTString() : v + "=" + escape(E) + ";domain=sohu.com;path=/;expires=" + R.toGMTString()
                    }, X = H + 1, Q = H + 2, ee = H + 3;
                    return t.prototype = {
                        "onekeyLogin": function(v) {
                            function t(v, E) {
                                var k, R, U = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""), H = [];
                                if (E = E || U.length,
                                v)
                                    for (k = 0; k < v; k++)
                                        H[k] = U[0 | Math.random() * E];
                                else
                                    for (H[8] = H[13] = H[18] = H[23] = "-",
                                    H[14] = "4",
                                    k = 0; k < 36; k++)
                                        H[k] || (R = 0 | 16 * Math.random(),
                                        H[k] = U[19 == k ? 3 & R | 8 : R]);
                                return H.join("")
                            }
                            function o(v, E) {
                                for (var k = String(v), R = E - k.length; R > 0; R--)
                                    k = "0" + k;
                                return k
                            }
                            function n(E) {
                                var U = {
                                    "appid": k,
                                    "token": E.token,
                                    "traceid": t(32, 32),
                                    "userInformation": E.userInformation
                                };
                                R.quickLogin({
                                    "success": function(E, k) {
                                        v.success && v.success(E, k)
                                    },
                                    "error": function(E) {
                                        v.error && v.error(E)
                                    },
                                    "params": U
                                })
                            }
                            function r(E) {
                                v.getTokenError && v.getTokenError(E)
                            }
                            var E, k = this.appid, R = this, U = {
                                "version": "2.0",
                                "timestamp": (E = new Date,
                                o(E.getFullYear(), 4) + o(E.getMonth() + 1, 2) + o(E.getDate(), 2) + o(E.getHours(), 2) + o(E.getMinutes(), 2) + o(E.getSeconds(), 2) + o(E.getMilliseconds(), 3)),
                                "appId": this.options.onekeyId,
                                "appkey": this.options.onekeyKey,
                                "onekeySwitchBackUrl": this.options.onekeySwitchBackUrl,
                                "onekeySwitchBackInfo": this.options.onekeySwitchBackInfo,
                                "businessType": "8",
                                "openType": 1,
                                "traceId": t(32, 32),
                                "expandParams": "",
                                "isTest": "",
                                "authPageType": 3
                            }, H = 0;
                            !function e() {
                                if (R.cryptoLoaded && R.ydrzLoaded && CryptoJS && CryptoJS.MD5) {
                                    var v = CryptoJS.MD5(U.appId + U.businessType + U.traceId + U.timestamp + U.traceId + U.version + U.appkey).toString();
                                    return U.onekeySwitchBackUrl && YDRZAuthLogin.authPageInit({
                                        "customControlStyle": {
                                            "ifShow": !0,
                                            "width": "50%",
                                            "height": "32px",
                                            "high": "85%",
                                            "left": "25%",
                                            "url": U.onekeySwitchBackUrl,
                                            "name": U.onekeySwitchBackInfo
                                        },
                                        "returnBtnStyle": {
                                            "width": "0.8rem",
                                            "height": "1rem"
                                        }
                                    }),
                                    void YDRZAuthLogin.getTokenInfo({
                                        "data": {
                                            "version": U.version,
                                            "appId": U.appId,
                                            "sign": v,
                                            "traceId": U.traceId,
                                            "timestamp": U.timestamp,
                                            "openType": U.openType,
                                            "expandParams": U.expandParams,
                                            "isTest": U.isTest,
                                            "authPageType": U.authPageType
                                        },
                                        "success": n,
                                        "error": r
                                    })
                                }
                                ++H < 30 && setTimeout(e, 100)
                            }()
                        },
                        "getNetType": function(v, E) {
                            var k = this
                              , R = 0;
                            !function r() {
                                if (k.cryptoLoaded && k.ydrzLoaded) {
                                    var U = YDRZAuthLogin.getConnection(v);
                                    E && E({
                                        "netType": U.netType,
                                        "platform": navigator.platform,
                                        "userAgent": navigator.userAgent
                                    })
                                } else
                                    ++R < 30 && setTimeout(r, 100)
                            }()
                        },
                        "setCommonCookie": function(v) {
                            if (G ? l("t", H) : l("t", H, W),
                            h("gidinf") && h("reqtype"))
                                v && v();
                            else {
                                var E = this.options.url.commonCookie
                                  , k = {
                                    "callback": "?"
                                };
                                G || (k.domain = W),
                                E = K.url(E, k),
                                this.getJSONP(E, v)
                            }
                        },
                        "bridging": function(v) {
                            var E = {
                                "error": v.error,
                                "success": v.success
                            }
                              , k = v.params || {};
                            return v.params && v.params.appid || (k.appid = this.options.appid),
                            k.callback = function(v) {
                                if (v) {
                                    var k = v.body;
                                    200 === Number(v.status) || 201 === Number(v.status) || 206 === Number(v.status) ? E.success && E.success(k, v.status) : E.error && E.error(v)
                                } else
                                    E.error && E.error(v)
                            }
                            ,
                            k
                        },
                        "randomName": function(v) {
                            return this._id + "_" + v + H++
                        },
                        "getJSONP": function(E, k, R) {
                            var U, H = this.randomName("cb"), G = document.getElementsByTagName("head")[0], W = document.createElement("script"), Z = (new Date).getTime();
                            U = (E = E.replace(/(=)\?(?=&|$)|\?\?/, "$1" + H)).replace(/([?&])_=[^&]*/, "$1_=" + Z),
                            E = U + (U === E ? (/\?/.test(E) ? "&" : "?") + "_=" + Z : ""),
                            v[H] = function(E) {
                                K.isFunction(k) && k(E),
                                setTimeout((function() {
                                    v[H] = void 0,
                                    G.removeChild(W)
                                }
                                ), 1)
                            }
                            ,
                            W.type = "text/javascript",
                            W.charset = R || "UTF-8",
                            W.src = E,
                            W.onerror = function(E) {
                                console.log("error"),
                                v[H]({
                                    "status": 500
                                })
                            }
                            ,
                            G.appendChild(W)
                        },
                        "getMethod": function(v, E) {
                            var k = this.bridging(v)
                              , R = k.callback;
                            k.callback = "?",
                            E = K.url(E, k),
                            this.getJSONP(E, R)
                        },
                        "getChallenge": function(E, k) {
                            G ? l("t", H) : l("t", H, W);
                            var R = this;
                            this.setCommonCookie((function() {
                                var U = {
                                    "callback": "?",
                                    "type": G ? 0 : 1
                                }
                                  , H = K.url(R.options.url.challenge, U);
                                R.getJSONP(H, (function(R) {
                                    v.eval(R),
                                    k.params = k.params || {},
                                    !G && document._jv && (k.params._jv = document._jv),
                                    E && E(k)
                                }
                                ))
                            }
                            ))
                        },
                        "getChallengeWithoutCookieSet": function(E, k) {
                            var R = {
                                "callback": "?",
                                "type": G ? 0 : 1
                            }
                              , U = K.url(this.options.url.challenge, R);
                            this.getJSONP(U, (function(R) {
                                v.eval(R),
                                k.params = k.params || {},
                                !G && document._jv && (k.params._jv = document._jv),
                                E && E(k)
                            }
                            ))
                        },
                        "createIFrame": function(v) {
                            var E;
                            return v = v || this.randomName("passportIframe"),
                            R.ie && R.ie < 9 ? E = document.createElement('<iframe src="about:blank" name="' + v + '"></iframe>') : (E = document.createElement("iframe")).setAttribute("name", v),
                            E.style.display = "none",
                            document.body.appendChild(E),
                            E
                        },
                        "createForm": function(v, E) {
                            var k, R, U, H = document.createElement("form");
                            for (R in v)
                                U = v[R],
                                (k = document.createElement("input")).type = "hidden",
                                k.name = R,
                                k.value = U,
                                H.appendChild(k);
                            return H.style.display = "none",
                            E ? E.appendChild(H) : document.body.appendChild(H),
                            H
                        },
                        "formData": function(v, E) {
                            var k = {};
                            for (var R in v)
                                v[R] && ("password" === R ? k.password = K.trim(v.password) : k[R] = K.trim(v[R]));
                            return k
                        },
                        "ajax_post": function(E, k, R) {
                            var U = function(v) {
                                var E = [];
                                for (var k in v)
                                    E.push(encodeURIComponent(k) + "=" + encodeURIComponent(v[k]));
                                return E.join("&")
                            }(k);
                            if (v.XMLHttpRequest)
                                var H = new XMLHttpRequest;
                            else
                                H = new ActiveXObject("Microsoft.XMLHTTP");
                            H.onreadystatechange = function() {
                                4 == H.readyState && R && R(JSON.parse(H.responseText))
                            }
                            ,
                            H.open("POST", E, !0),
                            H.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"),
                            H.withCredentials = !0,
                            H.send(U)
                        },
                        "formToIFrame": function(v, E) {
                            var k;
                            v.nf = 1,
                            v.callback && (k = K.bind(v.callback, this)),
                            delete v.callback,
                            this.ajax_post(E, this.formData(v), k)
                        },
                        "createIFrameQRCode": function(v) {
                            var E;
                            return v = v || this.randomName("passportIframe"),
                            R.ie && R.ie < 9 ? E = document.createElement('<iframe src="about:blank" name="' + v + '" width="150px" height="150px"></iframe>') : ((E = document.createElement("iframe")).setAttribute("name", v),
                            E.height = "150px",
                            E.width = "150px",
                            E.setAttribute("frameBorder", 0)),
                            E
                        },
                        "getQRCode": function(v) {
                            var E = this
                              , k = {
                                "success": function(k) {
                                    k.qrurl = "https://usr.mb.hd.sohu.com/pc/getqr.json?qrtoken=cab088c91e9647599dd5dd5eca0bec1c&code=283ffbf7792f1565cbf5a3d927e48822",
                                    k.qrtoken = "cab088c91e9647599dd5dd5eca0bec1c";
                                    var R = E.createIFrameQRCode();
                                    R.src = k.qrurl,
                                    document.getElementById(v.params.id).appendChild(R),
                                    E.queryQRCodeStatus()
                                },
                                "error": function(v) {
                                    console.log("error", v)
                                },
                                "params": {
                                    "pagetoken": (new Date).getTime()
                                }
                            };
                            this.createQRCode(k)
                        },
                        "createQRCode": function(v) {
                            this.getMethod(v, this.options.url.getAICaptcha)
                        },
                        "queryQRCodeStatus": function(v) {
                            this.getMethod(v, this.options.url.getAICaptcha)
                        },
                        "verifySecmobCaptcha": function(v) {
                            var E = this
                              , k = E.options.url.verifySecmobCaptcha + "/" + (v.params.appid || E.options.appid);
                            E.getChallenge((function(v) {
                                E.formToIFrame(E.bridging(v), k)
                            }
                            ), v)
                        },
                        "resetPassword": function(v) {
                            if (h("exp")) {
                                var E = this.options.url.resetPassword;
                                this.formToIFrame(this.bridging(v), E)
                            }
                        },
                        "updatePassword": function(v) {
                            var E = this.options.url.updatePassword;
                            this.formToIFrame(this.bridging(v), E)
                        },
                        "login": function(v) {
                            var E = this
                              , k = E.options.url.loginByUserId + "/" + (v.params.appid || E.options.appid);
                            v.params.password = K.md5(v.params.password),
                            v.params.captcha && (v.params.pagetoken = X),
                            E.getChallenge((function(v) {
                                E.formToIFrame(E.bridging(v), k)
                            }
                            ), v)
                        },
                        "loginRequireCaptcha": function(v) {
                            this.getMethod(v, this.options.url.loginRequireCaptcha)
                        },
                        "mobileLogin": function(v) {
                            var E = this
                              , k = E.options.url.mobileLogin + "/" + E.options.appid;
                            E.getChallenge((function(v) {
                                E.formToIFrame(E.bridging(v), k)
                            }
                            ), v)
                        },
                        "quickLogin": function(v) {
                            var E = this
                              , k = E.options.url.quickLogin + "/" + E.options.appid;
                            E.getChallenge((function(v) {
                                E.formToIFrame(E.bridging(v), k)
                            }
                            ), v)
                        },
                        "getThirdLoginUrl": function(v) {
                            if ("weChat" === v.provider) {
                                var E = "";
                                return v.wxParams && (E = "&selfRedirect=" + (v.wxParams.self_redirect || "") + "&style=" + (v.wxParams.style || "") + "&href=" + (v.wxParams.href || "")),
                                "https://plus.sohu.com/spassport/bind/" + this.options.appid + "/wechat?ru=" + v.ru + (G ? "" : "&pua=true") + E
                            }
                            return "//passport.sohu.com/openlogin/request.action?provider=" + v.provider + "&appid=" + this.options.appid + "&ru=" + v.ru + (G ? "" : "&pua=true")
                        },
                        "getWechatMPLoginUrl": function(v) {
                            return Z.substring(0, Z.length - 2) + "/oauth/loginurl?appid=" + this.options.appid + "&openkey=" + v.openkey + "&platform=wechat&ru=" + v.ru
                        },
                        "logout": function(v) {
                            var E = this
                              , k = E.options.url.logout + "/" + E.options.appid;
                            E.getChallengeWithoutCookieSet((function(v) {
                                E.formToIFrame(E.bridging(v), k)
                            }
                            ), v)
                        },
                        "getLoginPicture": function() {
                            return this.options.url.pictureCaptcha + "?pagetoken=" + X + "&random=" + this.randomName("sdk")
                        },
                        "getPhonePicture": function() {
                            return this.options.url.pictureCaptcha + "?pagetoken=" + Q + "&random=" + this.randomName("sdk")
                        },
                        "getRegisterPicture": function() {
                            return this.options.url.pictureCaptcha + "?pagetoken=" + ee + "&random=" + this.randomName("sdk")
                        },
                        "getSignInCaptcha": function(v) {
                            v.params.pagetoken = Q,
                            this.getMethod(v, this.options.url.signInCaptcha)
                        },
                        "getRegisterCaptcha": function(v) {
                            v.params.pagetoken = ee,
                            this.getMethod(v, this.options.url.registerCaptcha)
                        },
                        "getNewRegisterCaptcha": function(v) {
                            v.params.pagetoken = ee,
                            this.getMethod(v, this.options.url.newRegisterCaptcha)
                        },
                        "getBindPhoneCaptcha": function(v) {
                            this.getMethod(v, this.options.url.bindPhoneCaptcha)
                        },
                        "register": function(v) {
                            var E = this
                              , k = E.options.url.register + "/" + E.options.appid;
                            E.getChallenge((function(v) {
                                E.formToIFrame(E.bridging(v), k)
                            }
                            ), v)
                        },
                        "registerUp": function(v) {
                            var E = this
                              , k = E.options.url.registerUp + "/" + E.options.appid;
                            E.getChallenge((function(v) {
                                E.formToIFrame(E.bridging(v), k)
                            }
                            ), v)
                        },
                        "bindPhone": function(v) {
                            var E = this
                              , k = E.options.url.bindPhone + "/" + E.options.appid;
                            E.getChallenge((function(v) {
                                E.formToIFrame(E.bridging(v), k)
                            }
                            ), v)
                        },
                        "checkPhone": function(v) {
                            this.getMethod(v, this.options.url.checkPhone)
                        },
                        "checkUserPhoneBind": function(v) {
                            var E = this.options.url.checkUserPhoneBind + "/" + this.options.appid;
                            this.getMethod(v, E)
                        },
                        "passportLogin": function(v) {
                            var E = this
                              , k = E.options.url.passportLogin + "/" + E.options.appid;
                            v.params.password = K.md5(v.params.password),
                            E.getChallenge((function(v) {
                                E.formToIFrame(E.bridging(v), k)
                            }
                            ), v)
                        },
                        "scanCodeLogin": function(v) {
                            var E = this
                              , k = E.options.url.scanCodeLogin + "/" + E.options.appid;
                            v.params.password = K.md5(v.params.password),
                            E.getChallenge((function(v) {
                                E.formToIFrame(E.bridging(v), k)
                            }
                            ), v)
                        },
                        "getPhoneCode": function(v) {
                            document.domain && "https://" + document.domain === Y ? this.getMethod(v, Y + "/i/mobile/phonecode") : this.getMethod(v, this.options.url.getPhoneCode)
                        },
                        "getMobileCaptcha": function(v) {
                            v.params.pagetoken = Q;
                            var E = this.options.url.getMobileCaptcha + "/" + v.params.captchaType;
                            this.getMethod(v, E)
                        },
                        "verifyMobileCaptcha": function(v) {
                            var E = this.options.url.verifyMobileCaptcha;
                            this.getMethod(v, E)
                        },
                        "getSecmobileCaptcha": function(v) {
                            var E = this.options.url.getSecmobileCaptcha + "/" + v.params.captchaType;
                            this.getMethod(v, E)
                        },
                        "verifySecmobileCaptcha": function(v) {
                            var E = this.options.url.verifySecmobileCaptcha + "/" + v.params.captchaType;
                            this.getMethod(v, E)
                        },
                        "queryCertificateStaus": function(v) {
                            this.getMethod(v, this.options.url.queryCertificateStaus)
                        },
                        "userCertificate": function(v) {
                            this.getMethod(v, this.options.url.userCertificate)
                        },
                        "getAICaptcha": function(v) {
                            this.getMethod(v, this.options.url.getAICaptcha)
                        },
                        "verifyAICaptcha": function(v) {
                            var E = this
                              , k = E.options.url.verifyAICaptcha;
                            E.getChallenge((function(v) {
                                E.formToIFrame(E.bridging(v), k)
                            }
                            ), v)
                        }
                    },
                    v.SohuPassport = t,
                    t
                }
                ,
                v.exports ? v.exports = H(U) : void 0 === (R = function() {
                    return H(U)
                }
                .call(E, k, E, v)) || (v.exports = R)
            }
            , function(v, E, k) {
                var R, U, H;
                U = window,
                H = function(v) {
                    function t(v) {
                        var E = this;
                        v.onekeyId && (K.autoLoadScript("https://passportv4-web.bjcnc.scs.sohucs.com/crypto-js.min.js", (function(v) {
                            E.cryptoLoaded = v
                        }
                        )),
                        K.autoLoadScript("https://www.cmpassport.com/h5/js/jssdk_auth/jssdk.min.js", (function(v) {
                            E.ydrzLoaded = v
                        }
                        ))),
                        this.options = K.extend({}, J, v || {}),
                        this._id = "passport" + U.replace(/\D/g, ""),
                        this.version = U,
                        this.appid = this.options.appid,
                        this.options.gidinf && this.options.serialno && (l("gidinf", this.options.gidinf),
                        l("srn", this.options.serialno)),
                        G ? l("t", H) : l("t", H, W),
                        this.setCommonCookie()
                    }
                    var E, k, R = (k = (E = v).opera ? opera.version().replace(/\d$/, "") - 0 : parseFloat((/(?:IE |fox\/|ome\/|ion\/)(\d+\.\d)/.exec(navigator.userAgent) || [, 0])[1]),
                    {
                        "ie": !!E.VBArray && Math.max(document.documentMode || 0, k),
                        "firefox": !!E.netscape && k,
                        "opera": !!E.opera && k,
                        "chrome": !!E.chrome && k,
                        "safari": /apple/i.test(navigator.vendor) && k
                    }), U = "test", H = (new Date).getTime(), G = /\.sohu.com/.test(location.host), W = 2 == document.domain.split(".").length ? document.domain : document.domain.split(".").slice(document.domain.split(".").length - 2).join("."), Z = R.ie && R.ie < 9 ? "https://tstm.passport.sohu.com/i/".replace("https", "http") : G ? "https://tstm.passport.sohu.com/i/" : "https://v4-passport.56.com/i/", Y = "https://tstm.passport.sohu.com", J = {
                        "appid": "",
                        "url": {
                            "commonCookie": Z + "cookie/common",
                            "challenge": Z + "jf/code",
                            "loginByUserId": Z + "login",
                            "loginRequireCaptcha": Z + "login/require/captcha",
                            "mobileLogin": Z + "login/mobile",
                            "quickLogin": Z + "login/quick",
                            "passportLogin": Z + "login/passport",
                            "scanCodeLogin": Z + "login/token",
                            "pictureCaptcha": Z + "captcha/picture",
                            "signInCaptcha": Z + "smcode/mobile/signin",
                            "registerCaptcha": Z + "smcode/mobile/signup",
                            "newRegisterCaptcha": Z + "smcode/mobile/esignup",
                            "bindPhoneCaptcha": Z + "smcode/mobile/sblmobile",
                            "logout": Z + "logout",
                            "register": Z + "register",
                            "registerUp": Z + "register/v2",
                            "bindPhone": Z + "login/bind/mobile",
                            "checkPhone": Z + "verify/mobile/bind",
                            "checkUserPhoneBind": Z + "verify/user/mobile",
                            "getPhoneCode": Z + "mobile/phonecode",
                            "getMobileCaptcha": Z + "smcode/mobile/v2",
                            "verifyMobileCaptcha": Z + "verify/smcode/mobile",
                            "getSecmobileCaptcha": Z + "smcode/secmobile",
                            "verifySecmobileCaptcha": Z + "verify/smcode/secmobile",
                            "queryCertificateStaus": Z + "certificate/query/passport",
                            "userCertificate": Z + "certificate/create",
                            "getAICaptcha": Z + "captcha/npicture",
                            "verifyAICaptcha": Z + "captcha/nvalid",
                            "resetPassword": Z + "password/reset2",
                            "updatePassword": Z + "password/update2",
                            "verifySecmobCaptcha": Z + "login/security/secmob"
                        }
                    }, K = {
                        "extend": function() {
                            var v, E, k, R, U = arguments[0] || {}, H = arguments.length;
                            for (v = 1; v < H; v++)
                                if (null !== (k = arguments[v]))
                                    for (E in k)
                                        void 0 !== (R = k[E]) && (U[E] = R);
                            return U
                        },
                        "inArray": function(v, E) {
                            for (var k = 0; k < E.length; k++)
                                if (E[k] === v)
                                    return k;
                            return -1
                        },
                        "isString": function(v) {
                            return "string" == typeof v
                        },
                        "isFunction": function(v) {
                            return "function" == typeof v
                        },
                        "isBool": function(v) {
                            return "boolean" == typeof v
                        },
                        "bind": function(v, E) {
                            return function() {
                                v.apply(E, arguments)
                            }
                        },
                        "trim": function(v) {
                            return this.isString(v) ? v.replace(/^\s+/, "").replace(/\s+$/, "") : v
                        },
                        "param": function(v) {
                            var E = [];
                            for (var k in v)
                                E.push(k + "=" + v[k]);
                            return E.join("&")
                        },
                        "url": function(v, E) {
                            return v + (/\?/.test(v) ? "&" : "?") + this.param(E)
                        },
                        "md5": function(v) {
                            function t(v, E, k, R, U, H) {
                                return a((G = a(a(E, v), a(R, H))) << (W = U) | G >>> 32 - W, k);
                                var G, W
                            }
                            function o(v, E, k, R, U, H, G) {
                                return t(E & k | ~E & R, v, E, U, H, G)
                            }
                            function n(v, E, k, R, U, H, G) {
                                return t(E & R | k & ~R, v, E, U, H, G)
                            }
                            function r(v, E, k, R, U, H, G) {
                                return t(E ^ k ^ R, v, E, U, H, G)
                            }
                            function i(v, E, k, R, U, H, G) {
                                return t(k ^ (E | ~R), v, E, U, H, G)
                            }
                            function a(v, E) {
                                var k = (65535 & v) + (65535 & E);
                                return (v >> 16) + (E >> 16) + (k >> 16) << 16 | 65535 & k
                            }
                            var E, k = 0, R = 8;
                            return function(v) {
                                for (var E = k ? "0123456789ABCDEF" : "0123456789abcdef", R = "", U = 0; U < 4 * v.length; U++)
                                    R += E.charAt(v[U >> 2] >> U % 4 * 8 + 4 & 15) + E.charAt(v[U >> 2] >> U % 4 * 8 & 15);
                                return R
                            }(function(v, E) {
                                v[E >> 5] |= 128 << E % 32,
                                v[14 + (E + 64 >>> 9 << 4)] = E;
                                for (var k = 1732584193, R = -271733879, U = -1732584194, H = 271733878, G = 0; G < v.length; G += 16) {
                                    var W = k
                                      , Z = R
                                      , Y = U
                                      , J = H;
                                    k = o(k, R, U, H, v[G + 0], 7, -680876936),
                                    H = o(H, k, R, U, v[G + 1], 12, -389564586),
                                    U = o(U, H, k, R, v[G + 2], 17, 606105819),
                                    R = o(R, U, H, k, v[G + 3], 22, -1044525330),
                                    k = o(k, R, U, H, v[G + 4], 7, -176418897),
                                    H = o(H, k, R, U, v[G + 5], 12, 1200080426),
                                    U = o(U, H, k, R, v[G + 6], 17, -1473231341),
                                    R = o(R, U, H, k, v[G + 7], 22, -45705983),
                                    k = o(k, R, U, H, v[G + 8], 7, 1770035416),
                                    H = o(H, k, R, U, v[G + 9], 12, -1958414417),
                                    U = o(U, H, k, R, v[G + 10], 17, -42063),
                                    R = o(R, U, H, k, v[G + 11], 22, -1990404162),
                                    k = o(k, R, U, H, v[G + 12], 7, 1804603682),
                                    H = o(H, k, R, U, v[G + 13], 12, -40341101),
                                    U = o(U, H, k, R, v[G + 14], 17, -1502002290),
                                    k = n(k, R = o(R, U, H, k, v[G + 15], 22, 1236535329), U, H, v[G + 1], 5, -165796510),
                                    H = n(H, k, R, U, v[G + 6], 9, -1069501632),
                                    U = n(U, H, k, R, v[G + 11], 14, 643717713),
                                    R = n(R, U, H, k, v[G + 0], 20, -373897302),
                                    k = n(k, R, U, H, v[G + 5], 5, -701558691),
                                    H = n(H, k, R, U, v[G + 10], 9, 38016083),
                                    U = n(U, H, k, R, v[G + 15], 14, -660478335),
                                    R = n(R, U, H, k, v[G + 4], 20, -405537848),
                                    k = n(k, R, U, H, v[G + 9], 5, 568446438),
                                    H = n(H, k, R, U, v[G + 14], 9, -1019803690),
                                    U = n(U, H, k, R, v[G + 3], 14, -187363961),
                                    R = n(R, U, H, k, v[G + 8], 20, 1163531501),
                                    k = n(k, R, U, H, v[G + 13], 5, -1444681467),
                                    H = n(H, k, R, U, v[G + 2], 9, -51403784),
                                    U = n(U, H, k, R, v[G + 7], 14, 1735328473),
                                    k = r(k, R = n(R, U, H, k, v[G + 12], 20, -1926607734), U, H, v[G + 5], 4, -378558),
                                    H = r(H, k, R, U, v[G + 8], 11, -2022574463),
                                    U = r(U, H, k, R, v[G + 11], 16, 1839030562),
                                    R = r(R, U, H, k, v[G + 14], 23, -35309556),
                                    k = r(k, R, U, H, v[G + 1], 4, -1530992060),
                                    H = r(H, k, R, U, v[G + 4], 11, 1272893353),
                                    U = r(U, H, k, R, v[G + 7], 16, -155497632),
                                    R = r(R, U, H, k, v[G + 10], 23, -1094730640),
                                    k = r(k, R, U, H, v[G + 13], 4, 681279174),
                                    H = r(H, k, R, U, v[G + 0], 11, -358537222),
                                    U = r(U, H, k, R, v[G + 3], 16, -722521979),
                                    R = r(R, U, H, k, v[G + 6], 23, 76029189),
                                    k = r(k, R, U, H, v[G + 9], 4, -640364487),
                                    H = r(H, k, R, U, v[G + 12], 11, -421815835),
                                    U = r(U, H, k, R, v[G + 15], 16, 530742520),
                                    k = i(k, R = r(R, U, H, k, v[G + 2], 23, -995338651), U, H, v[G + 0], 6, -198630844),
                                    H = i(H, k, R, U, v[G + 7], 10, 1126891415),
                                    U = i(U, H, k, R, v[G + 14], 15, -1416354905),
                                    R = i(R, U, H, k, v[G + 5], 21, -57434055),
                                    k = i(k, R, U, H, v[G + 12], 6, 1700485571),
                                    H = i(H, k, R, U, v[G + 3], 10, -1894986606),
                                    U = i(U, H, k, R, v[G + 10], 15, -1051523),
                                    R = i(R, U, H, k, v[G + 1], 21, -2054922799),
                                    k = i(k, R, U, H, v[G + 8], 6, 1873313359),
                                    H = i(H, k, R, U, v[G + 15], 10, -30611744),
                                    U = i(U, H, k, R, v[G + 6], 15, -1560198380),
                                    R = i(R, U, H, k, v[G + 13], 21, 1309151649),
                                    k = i(k, R, U, H, v[G + 4], 6, -145523070),
                                    H = i(H, k, R, U, v[G + 11], 10, -1120210379),
                                    U = i(U, H, k, R, v[G + 2], 15, 718787259),
                                    R = i(R, U, H, k, v[G + 9], 21, -343485551),
                                    k = a(k, W),
                                    R = a(R, Z),
                                    U = a(U, Y),
                                    H = a(H, J)
                                }
                                return Array(k, R, U, H)
                            }(function(v) {
                                for (var E = Array(), k = (1 << R) - 1, U = 0; U < v.length * R; U += R)
                                    E[U >> 5] |= (v.charCodeAt(U / R) & k) << U % 32;
                                return E
                            }(E = v), E.length * R))
                        },
                        "autoLoadScript": function(v, E) {
                            var k = document.createElement("script")
                              , R = document.getElementsByTagName("head")[0];
                            k.charset = "UTF-8",
                            k.async = !0,
                            k.onerror = function() {
                                E && E(!1)
                            }
                            ;
                            var U = !1;
                            k.onload = k.onreadystatechange = function() {
                                U || k.readyState && "loaded" !== k.readyState && "complete" !== k.readyState || (U = !0,
                                E && E(!0))
                            }
                            ,
                            k.src = v,
                            R.appendChild(k)
                        }
                    }, h = function(v) {
                        var E, k = new RegExp("(^| )" + v + "=([^;]*)(;|$)");
                        return (E = document.cookie.match(k)) ? unescape(E[2]) : null
                    }, l = function(v, E, k) {
                        var R = new Date;
                        R.setTime(R.getTime() + 2592e6),
                        document.cookie = k ? v + "=" + escape(E) + ";domain=" + k + ";path=/;expires=" + R.toGMTString() : v + "=" + escape(E) + ";domain=sohu.com;path=/;expires=" + R.toGMTString()
                    };
                    return pageTokenLogin = H + 1,
                    pageTokenPhone = H + 2,
                    pageTokenRegister = H + 3,
                    t.prototype = {
                        "onekeyLogin": function(v) {
                            function t(v, E) {
                                var k, R, U = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""), H = [];
                                if (E = E || U.length,
                                v)
                                    for (k = 0; k < v; k++)
                                        H[k] = U[0 | Math.random() * E];
                                else
                                    for (H[8] = H[13] = H[18] = H[23] = "-",
                                    H[14] = "4",
                                    k = 0; k < 36; k++)
                                        H[k] || (R = 0 | 16 * Math.random(),
                                        H[k] = U[19 == k ? 3 & R | 8 : R]);
                                return H.join("")
                            }
                            function o(v, E) {
                                for (var k = String(v), R = E - k.length; R > 0; R--)
                                    k = "0" + k;
                                return k
                            }
                            function n(E) {
                                var U = {
                                    "appid": k,
                                    "token": E.token,
                                    "traceid": t(32, 32),
                                    "userInformation": E.userInformation
                                };
                                R.quickLogin({
                                    "success": function(E, k) {
                                        v.success && v.success(E, k)
                                    },
                                    "error": function(E) {
                                        v.error && v.error(E)
                                    },
                                    "params": U
                                })
                            }
                            function r(E) {
                                v.getTokenError && v.getTokenError(E)
                            }
                            var E, k = this.appid, R = this, U = {
                                "version": "2.0",
                                "timestamp": (E = new Date,
                                o(E.getFullYear(), 4) + o(E.getMonth() + 1, 2) + o(E.getDate(), 2) + o(E.getHours(), 2) + o(E.getMinutes(), 2) + o(E.getSeconds(), 2) + o(E.getMilliseconds(), 3)),
                                "appId": this.options.onekeyId,
                                "appkey": this.options.onekeyKey,
                                "businessType": "8",
                                "openType": 1,
                                "traceId": t(32, 32),
                                "expandParams": "",
                                "isTest": ""
                            }, H = 0;
                            !function e() {
                                if (R.cryptoLoaded && R.ydrzLoaded && CryptoJS && CryptoJS.MD5) {
                                    var v = CryptoJS.MD5(U.appId + U.businessType + U.traceId + U.timestamp + U.traceId + U.version + U.appkey).toString();
                                    YDRZ.getTokenInfo({
                                        "data": {
                                            "version": U.version,
                                            "appId": U.appId,
                                            "sign": v,
                                            "traceId": U.traceId,
                                            "timestamp": U.timestamp,
                                            "openType": U.openType,
                                            "expandParams": U.expandParams,
                                            "isTest": U.isTest
                                        },
                                        "success": n,
                                        "error": r
                                    })
                                } else
                                    ++H < 30 && setTimeout(e, 100)
                            }()
                        },
                        "getNetType": function(v, E) {
                            var k = this
                              , R = 0;
                            !function r() {
                                if (k.cryptoLoaded && k.ydrzLoaded) {
                                    var U = YDRZ.getConnection(v);
                                    E && E({
                                        "netType": U.netType,
                                        "platform": navigator.platform,
                                        "userAgent": navigator.userAgent
                                    })
                                } else
                                    ++R < 30 && setTimeout(r, 100)
                            }()
                        },
                        "setCommonCookie": function(v) {
                            if (G ? l("t", H) : l("t", H, W),
                            h("gidinf") && h("reqtype"))
                                v && v();
                            else {
                                var E = this.options.url.commonCookie
                                  , k = {
                                    "callback": "?"
                                };
                                G || (k.domain = W),
                                E = K.url(E, k),
                                this.getJSONP(E, v)
                            }
                        },
                        "bridging": function(v) {
                            var E = {
                                "error": v.error,
                                "success": v.success
                            }
                              , k = v.params || {};
                            return v.params && v.params.appid || (k.appid = this.options.appid),
                            k.callback = function(v) {
                                if (v) {
                                    var k = v.body;
                                    200 === Number(v.status) || 201 === Number(v.status) || 206 === Number(v.status) ? E.success && E.success(k, v.status) : E.error && E.error(v)
                                } else
                                    E.error && E.error(v)
                            }
                            ,
                            k
                        },
                        "randomName": function(v) {
                            return this._id + "_" + v + H++
                        },
                        "getJSONP": function(E, k, R) {
                            var U, H = this.randomName("cb"), G = document.getElementsByTagName("head")[0], W = document.createElement("script"), Z = (new Date).getTime();
                            U = (E = E.replace(/(=)\?(?=&|$)|\?\?/, "$1" + H)).replace(/([?&])_=[^&]*/, "$1_=" + Z),
                            E = U + (U === E ? (/\?/.test(E) ? "&" : "?") + "_=" + Z : ""),
                            v[H] = function(E) {
                                K.isFunction(k) && k(E),
                                setTimeout((function() {
                                    v[H] = void 0,
                                    G.removeChild(W)
                                }
                                ), 1)
                            }
                            ,
                            W.type = "text/javascript",
                            W.charset = R || "UTF-8",
                            W.src = E,
                            W.onerror = function(E) {
                                console.log("error"),
                                v[H]({
                                    "status": 500
                                })
                            }
                            ,
                            G.appendChild(W)
                        },
                        "getMethod": function(v, E) {
                            var k = this.bridging(v)
                              , R = k.callback;
                            k.callback = "?",
                            E = K.url(E, k),
                            this.getJSONP(E, R)
                        },
                        "getChallenge": function(E, k) {
                            G ? l("t", H) : l("t", H, W);
                            var R = this;
                            this.setCommonCookie((function() {
                                var U = {
                                    "callback": "?",
                                    "type": G ? 0 : 1
                                }
                                  , H = K.url(R.options.url.challenge, U);
                                R.getJSONP(H, (function(R) {
                                    v.eval(R),
                                    k.params = k.params || {},
                                    !G && document._jv && (k.params._jv = document._jv),
                                    E && E(k)
                                }
                                ))
                            }
                            ))
                        },
                        "getChallengeWithoutCookieSet": function(E, k) {
                            var R = {
                                "callback": "?",
                                "type": G ? 0 : 1
                            }
                              , U = K.url(this.options.url.challenge, R);
                            this.getJSONP(U, (function(R) {
                                v.eval(R),
                                k.params = k.params || {},
                                !G && document._jv && (k.params._jv = document._jv),
                                E && E(k)
                            }
                            ))
                        },
                        "createIFrame": function(v) {
                            var E;
                            return v = v || this.randomName("passportIframe"),
                            R.ie && R.ie < 9 ? E = document.createElement('<iframe src="about:blank" name="' + v + '"></iframe>') : (E = document.createElement("iframe")).setAttribute("name", v),
                            E.style.display = "none",
                            document.body.appendChild(E),
                            E
                        },
                        "createForm": function(v, E) {
                            var k, R, U, H = document.createElement("form");
                            for (R in v)
                                U = v[R],
                                (k = document.createElement("input")).type = "hidden",
                                k.name = R,
                                k.value = U,
                                H.appendChild(k);
                            return H.style.display = "none",
                            E ? (console.log("node", E),
                            E.appendChild(H)) : document.body.appendChild(H),
                            H
                        },
                        "formData": function(v, E) {
                            var k = {};
                            for (var R in v)
                                v[R] && ("password" === R ? k.password = K.trim(v.password) : k[R] = K.trim(v[R]));
                            return k
                        },
                        "ajax_post": function(E, k, R) {
                            var U = function(v) {
                                var E = [];
                                for (var k in v)
                                    E.push(encodeURIComponent(k) + "=" + encodeURIComponent(v[k]));
                                return E.join("&")
                            }(k);
                            if (v.XMLHttpRequest)
                                var H = new XMLHttpRequest;
                            else
                                H = new ActiveXObject("Microsoft.XMLHTTP");
                            H.onreadystatechange = function() {
                                4 == H.readyState && R && R(JSON.parse(H.responseText))
                            }
                            ,
                            H.open("POST", E, !0),
                            H.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"),
                            H.withCredentials = !0,
                            H.send(U)
                        },
                        "formToIFrame": function(v, E) {
                            var k;
                            v.nf = 1,
                            v.callback && (k = K.bind(v.callback, this)),
                            delete v.callback,
                            this.ajax_post(E, this.formData(v), k)
                        },
                        "createIFrameQRCode": function(v) {
                            var E;
                            return v = v || this.randomName("passportIframe"),
                            R.ie && R.ie < 9 ? E = document.createElement('<iframe src="about:blank" name="' + v + '" width="150px" height="150px"></iframe>') : ((E = document.createElement("iframe")).setAttribute("name", v),
                            E.height = "150px",
                            E.width = "150px",
                            E.setAttribute("frameBorder", 0)),
                            E
                        },
                        "getQRCode": function(v) {
                            var E = this
                              , k = {
                                "success": function(k) {
                                    console.log("success", k),
                                    k.qrurl = "https://usr.mb.hd.sohu.com/pc/getqr.json?qrtoken=cab088c91e9647599dd5dd5eca0bec1c&code=283ffbf7792f1565cbf5a3d927e48822",
                                    k.qrtoken = "cab088c91e9647599dd5dd5eca0bec1c";
                                    var R = E.createIFrameQRCode();
                                    R.src = k.qrurl,
                                    document.getElementById(v.params.id).appendChild(R),
                                    E.queryQRCodeStatus()
                                },
                                "error": function(v) {
                                    console.log("error", v)
                                },
                                "params": {
                                    "pagetoken": (new Date).getTime()
                                }
                            };
                            this.createQRCode(k)
                        },
                        "createQRCode": function(v) {
                            this.getMethod(v, this.options.url.getAICaptcha)
                        },
                        "queryQRCodeStatus": function(v) {
                            this.getMethod(v, this.options.url.getAICaptcha)
                        },
                        "verifySecmobCaptcha": function(v) {
                            var E = this
                              , k = E.options.url.verifySecmobCaptcha + "/" + (v.params.appid || E.options.appid);
                            E.getChallenge((function(v) {
                                E.formToIFrame(E.bridging(v), k)
                            }
                            ), v)
                        },
                        "resetPassword": function(v) {
                            if (h("exp")) {
                                var E = this.options.url.resetPassword;
                                this.formToIFrame(this.bridging(v), E)
                            }
                        },
                        "updatePassword": function(v) {
                            var E = this.options.url.updatePassword;
                            this.formToIFrame(this.bridging(v), E)
                        },
                        "login": function(v) {
                            var E = this
                              , k = E.options.url.loginByUserId + "/" + (v.params.appid || E.options.appid);
                            v.params.password = K.md5(v.params.password),
                            v.params.captcha && (v.params.pagetoken = pageTokenLogin),
                            E.getChallenge((function(v) {
                                E.formToIFrame(E.bridging(v), k)
                            }
                            ), v)
                        },
                        "loginRequireCaptcha": function(v) {
                            this.getMethod(v, this.options.url.loginRequireCaptcha)
                        },
                        "mobileLogin": function(v) {
                            var E = this
                              , k = E.options.url.mobileLogin + "/" + E.options.appid;
                            E.getChallenge((function(v) {
                                E.formToIFrame(E.bridging(v), k)
                            }
                            ), v)
                        },
                        "quickLogin": function(v) {
                            var E = this
                              , k = E.options.url.quickLogin + "/" + E.options.appid;
                            E.getChallenge((function(v) {
                                E.formToIFrame(E.bridging(v), k)
                            }
                            ), v)
                        },
                        "getThirdLoginUrl": function(v) {
                            if ("weChat" === v.provider) {
                                var E = "";
                                return v.wxParams && (E = "&selfRedirect=" + (v.wxParams.self_redirect || "") + "&style=" + (v.wxParams.style || "") + "&href=" + (v.wxParams.href || "")),
                                "https://plus.sohu.com/spassport/bind/" + this.options.appid + "/wechat?ru=" + v.ru + (G ? "" : "&pua=true") + E
                            }
                            return "//passport.sohu.com/openlogin/request.action?provider=" + v.provider + "&appid=" + this.options.appid + "&ru=" + v.ru + (G ? "" : "&pua=true")
                        },
                        "getWechatMPLoginUrl": function(v) {
                            return Z.substring(0, Z.length - 2) + "/oauth/loginurl?appid=" + this.options.appid + "&openkey=" + v.openkey + "&platform=wechat&ru=" + v.ru
                        },
                        "logout": function(v) {
                            var E = this
                              , k = E.options.url.logout + "/" + E.options.appid;
                            E.getChallengeWithoutCookieSet((function(v) {
                                E.formToIFrame(E.bridging(v), k)
                            }
                            ), v)
                        },
                        "getLoginPicture": function() {
                            return this.options.url.pictureCaptcha + "?pagetoken=" + pageTokenLogin + "&random=" + this.randomName("sdk")
                        },
                        "getPhonePicture": function() {
                            return this.options.url.pictureCaptcha + "?pagetoken=" + pageTokenPhone + "&random=" + this.randomName("sdk")
                        },
                        "getRegisterPicture": function() {
                            return this.options.url.pictureCaptcha + "?pagetoken=" + pageTokenRegister + "&random=" + this.randomName("sdk")
                        },
                        "getSignInCaptcha": function(v) {
                            v.params.pagetoken = pageTokenPhone,
                            this.getMethod(v, this.options.url.signInCaptcha)
                        },
                        "getRegisterCaptcha": function(v) {
                            v.params.pagetoken = pageTokenRegister,
                            this.getMethod(v, this.options.url.registerCaptcha)
                        },
                        "getNewRegisterCaptcha": function(v) {
                            v.params.pagetoken = pageTokenRegister,
                            this.getMethod(v, this.options.url.newRegisterCaptcha)
                        },
                        "getBindPhoneCaptcha": function(v) {
                            this.getMethod(v, this.options.url.bindPhoneCaptcha)
                        },
                        "register": function(v) {
                            var E = this
                              , k = E.options.url.register + "/" + E.options.appid;
                            E.getChallenge((function(v) {
                                E.formToIFrame(E.bridging(v), k)
                            }
                            ), v)
                        },
                        "registerUp": function(v) {
                            var E = this
                              , k = E.options.url.registerUp + "/" + E.options.appid;
                            E.getChallenge((function(v) {
                                E.formToIFrame(E.bridging(v), k)
                            }
                            ), v)
                        },
                        "bindPhone": function(v) {
                            var E = this
                              , k = E.options.url.bindPhone + "/" + E.options.appid;
                            E.getChallenge((function(v) {
                                E.formToIFrame(E.bridging(v), k)
                            }
                            ), v)
                        },
                        "checkPhone": function(v) {
                            this.getMethod(v, this.options.url.checkPhone)
                        },
                        "checkUserPhoneBind": function(v) {
                            var E = this.options.url.checkUserPhoneBind + "/" + this.options.appid;
                            this.getMethod(v, E)
                        },
                        "passportLogin": function(v) {
                            var E = this
                              , k = E.options.url.passportLogin + "/" + E.options.appid;
                            v.params.password = K.md5(v.params.password),
                            E.getChallenge((function(v) {
                                E.formToIFrame(E.bridging(v), k)
                            }
                            ), v)
                        },
                        "scanCodeLogin": function(v) {
                            var E = this
                              , k = E.options.url.scanCodeLogin + "/" + E.options.appid;
                            v.params.password = K.md5(v.params.password),
                            E.getChallenge((function(v) {
                                E.formToIFrame(E.bridging(v), k)
                            }
                            ), v)
                        },
                        "getPhoneCode": function(v) {
                            document.domain && "https://" + document.domain === Y ? this.getMethod(v, Y + "/i/mobile/phonecode") : this.getMethod(v, this.options.url.getPhoneCode)
                        },
                        "getMobileCaptcha": function(v) {
                            v.params.pagetoken = pageTokenPhone;
                            var E = this.options.url.getMobileCaptcha + "/" + v.params.captchaType;
                            this.getMethod(v, E)
                        },
                        "verifyMobileCaptcha": function(v) {
                            var E = this.options.url.verifyMobileCaptcha;
                            this.getMethod(v, E)
                        },
                        "getSecmobileCaptcha": function(v) {
                            var E = this.options.url.getSecmobileCaptcha + "/" + v.params.captchaType;
                            this.getMethod(v, E)
                        },
                        "verifySecmobileCaptcha": function(v) {
                            var E = this.options.url.verifySecmobileCaptcha + "/" + v.params.captchaType;
                            this.getMethod(v, E)
                        },
                        "queryCertificateStaus": function(v) {
                            this.getMethod(v, this.options.url.queryCertificateStaus)
                        },
                        "userCertificate": function(v) {
                            this.getMethod(v, this.options.url.userCertificate)
                        },
                        "getAICaptcha": function(v) {
                            this.getMethod(v, this.options.url.getAICaptcha)
                        },
                        "verifyAICaptcha": function(v) {
                            var E = this
                              , k = E.options.url.verifyAICaptcha;
                            E.getChallenge((function(v) {
                                E.formToIFrame(E.bridging(v), k)
                            }
                            ), v)
                        }
                    },
                    v.SohuPassport = t,
                    t
                }
                ,
                v.exports ? v.exports = H(U) : void 0 === (R = function() {
                    return H(U)
                }
                .call(E, k, E, v)) || (v.exports = R)
            }
            , function(v, E) {
                function o(v) {
                    this._store = {},
                    this.StorageName = v + "Storage"
                }
                o.prototype = {
                    "constructor": o,
                    "setItem": function(v, E, k) {
                        this.removeItem(v);
                        var R = (new Date).getTime()
                          , U = {
                            "_value": E
                        };
                        return k && (U._expire = R + k),
                        this.isSupportStorage ? (window[this.StorageName].setItem(v, JSON.stringify(U)),
                        this._store[v] = JSON.stringify(U)) : this._store[v] = JSON.stringify(U),
                        U
                    },
                    "getItem": function(v) {
                        var E = this.isSupportStorage ? JSON.parse(window[this.StorageName].getItem(v)) : this._store[v] && JSON.parse(this._store[v])
                          , k = (new Date).getTime();
                        return E ? E._expire && k > E._expire ? null : E._value : null
                    },
                    "removeItem": function(v) {
                        window[this.StorageName].removeItem(v)
                    },
                    "isSupportStorage": function() {
                        var v, E = "isSupportStorage";
                        try {
                            v = window[this.StorageName]
                        } catch (E) {
                            return v = null,
                            console.log(E),
                            !1
                        }
                        if (v)
                            try {
                                return v.setItem(E, E),
                                v.removeItem(E),
                                !0
                            } catch (v) {
                                return !1
                            }
                        return !1
                    }
                };
                var k = new o("local");
                v.exports = {
                    "localStorageUtil": k
                }
            }
            , function(v, E) {
                var k = {
                    "get": function(v) {
                        var E = new RegExp("\\b" + v + "=([^;]*)\\b").exec(document.cookie);
                        return E ? decodeURIComponent(E[1]) : null
                    },
                    "set": function(v, E, k, R, U, H) {
                        var G = k || null
                          , W = R || "/"
                          , Z = U || null
                          , Y = H || !1
                          , J = new Date;
                        "number" == typeof G && (J.setTime(J.getTime() + Number(G)),
                        G = J),
                        document.cookie = v + "=" + encodeURIComponent(E) + (null === G ? "" : "; expires=" + G.toGMTString()) + (null === W ? "" : "; path=" + W) + (null === Z ? "" : "; domain=" + Z) + (!0 === Y ? "; secure" : "")
                    },
                    "remove": function(v, E, k) {
                        this.get(v) && (E = E || "/",
                        document.cookie = v + "=; expires=Thu, 01-Jan-70 00:00:01 GMT; path=" + E + (k ? "; domain=" + k : ""))
                    }
                };
                v.exports = k
            }
            , function(v, E, k) {
                "use strict";
                var R = k(0)
                  , U = k(2)
                  , H = k(15)
                  , G = k(8);
                function s(v) {
                    var E = new H(v)
                      , k = U(H.prototype.request, E);
                    return R.extend(k, H.prototype, E),
                    R.extend(k, E),
                    k
                }
                var W = s(k(5));
                W.Axios = H,
                W.create = function(v) {
                    return s(G(W.defaults, v))
                }
                ,
                W.Cancel = k(9),
                W.CancelToken = k(29),
                W.isCancel = k(4),
                W.all = function(v) {
                    return Promise.all(v)
                }
                ,
                W.spread = k(30),
                v.exports = W,
                v.exports.default = W
            }
            , function(v, E, k) {
                "use strict";
                var R = k(0)
                  , U = k(3)
                  , H = k(16)
                  , G = k(17)
                  , W = k(8);
                function c(v) {
                    this.defaults = v,
                    this.interceptors = {
                        "request": new H,
                        "response": new H
                    }
                }
                c.prototype.request = function(v) {
                    "string" == typeof v ? (v = arguments[1] || {}).url = arguments[0] : v = v || {},
                    (v = W(this.defaults, v)).method ? v.method = v.method.toLowerCase() : this.defaults.method ? v.method = this.defaults.method.toLowerCase() : v.method = "get";
                    var E = [G, void 0]
                      , k = Promise.resolve(v);
                    for (this.interceptors.request.forEach((function(v) {
                        E.unshift(v.fulfilled, v.rejected)
                    }
                    )),
                    this.interceptors.response.forEach((function(v) {
                        E.push(v.fulfilled, v.rejected)
                    }
                    )); E.length; )
                        k = k.then(E.shift(), E.shift());
                    return k
                }
                ,
                c.prototype.getUri = function(v) {
                    return v = W(this.defaults, v),
                    U(v.url, v.params, v.paramsSerializer).replace(/^\?/, "")
                }
                ,
                R.forEach(["delete", "get", "head", "options"], (function(v) {
                    c.prototype[v] = function(E, k) {
                        return this.request(R.merge(k || {}, {
                            "method": v,
                            "url": E
                        }))
                    }
                }
                )),
                R.forEach(["post", "put", "patch"], (function(v) {
                    c.prototype[v] = function(E, k, U) {
                        return this.request(R.merge(U || {}, {
                            "method": v,
                            "url": E,
                            "data": k
                        }))
                    }
                }
                )),
                v.exports = c
            }
            , function(v, E, k) {
                "use strict";
                var R = k(0);
                function r() {
                    this.handlers = []
                }
                r.prototype.use = function(v, E) {
                    return this.handlers.push({
                        "fulfilled": v,
                        "rejected": E
                    }),
                    this.handlers.length - 1
                }
                ,
                r.prototype.eject = function(v) {
                    this.handlers[v] && (this.handlers[v] = null)
                }
                ,
                r.prototype.forEach = function(v) {
                    R.forEach(this.handlers, (function(E) {
                        null !== E && v(E)
                    }
                    ))
                }
                ,
                v.exports = r
            }
            , function(v, E, k) {
                "use strict";
                var R = k(0)
                  , U = k(18)
                  , H = k(4)
                  , G = k(5);
                function s(v) {
                    v.cancelToken && v.cancelToken.throwIfRequested()
                }
                v.exports = function(v) {
                    return s(v),
                    v.headers = v.headers || {},
                    v.data = U(v.data, v.headers, v.transformRequest),
                    v.headers = R.merge(v.headers.common || {}, v.headers[v.method] || {}, v.headers),
                    R.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (function(E) {
                        delete v.headers[E]
                    }
                    )),
                    (v.adapter || G.adapter)(v).then((function(E) {
                        return s(v),
                        E.data = U(E.data, E.headers, v.transformResponse),
                        E
                    }
                    ), (function(E) {
                        return H(E) || (s(v),
                        E && E.response && (E.response.data = U(E.response.data, E.response.headers, v.transformResponse))),
                        Promise.reject(E)
                    }
                    ))
                }
            }
            , function(v, E, k) {
                "use strict";
                var R = k(0);
                v.exports = function(v, E, k) {
                    return R.forEach(k, (function(k) {
                        v = k(v, E)
                    }
                    )),
                    v
                }
            }
            , function(v, E) {
                var k, R, U = v.exports = {};
                function i() {
                    throw new Error("setTimeout has not been defined")
                }
                function a() {
                    throw new Error("clearTimeout has not been defined")
                }
                function s(v) {
                    if (k === setTimeout)
                        return setTimeout(v, 0);
                    if ((k === i || !k) && setTimeout)
                        return k = setTimeout,
                        setTimeout(v, 0);
                    try {
                        return k(v, 0)
                    } catch (E) {
                        try {
                            return k.call(null, v, 0)
                        } catch (E) {
                            return k.call(this, v, 0)
                        }
                    }
                }
                !function() {
                    try {
                        k = "function" == typeof setTimeout ? setTimeout : i
                    } catch (v) {
                        k = i
                    }
                    try {
                        R = "function" == typeof clearTimeout ? clearTimeout : a
                    } catch (v) {
                        R = a
                    }
                }();
                var H, G = [], W = !1, Z = -1;
                function d() {
                    W && H && (W = !1,
                    H.length ? G = H.concat(G) : Z = -1,
                    G.length && h())
                }
                function h() {
                    if (!W) {
                        var v = s(d);
                        W = !0;
                        for (var E = G.length; E; ) {
                            for (H = G,
                            G = []; ++Z < E; )
                                H && H[Z].run();
                            Z = -1,
                            E = G.length
                        }
                        H = null,
                        W = !1,
                        function(v) {
                            if (R === clearTimeout)
                                return clearTimeout(v);
                            if ((R === a || !R) && clearTimeout)
                                return R = clearTimeout,
                                clearTimeout(v);
                            try {
                                R(v)
                            } catch (E) {
                                try {
                                    return R.call(null, v)
                                } catch (E) {
                                    return R.call(this, v)
                                }
                            }
                        }(v)
                    }
                }
                function l(v, E) {
                    this.fun = v,
                    this.array = E
                }
                function m() {}
                U.nextTick = function(v) {
                    var E = new Array(arguments.length - 1);
                    if (arguments.length > 1)
                        for (var k = 1; k < arguments.length; k++)
                            E[k - 1] = arguments[k];
                    G.push(new l(v,E)),
                    1 !== G.length || W || s(h)
                }
                ,
                l.prototype.run = function() {
                    this.fun.apply(null, this.array)
                }
                ,
                U.title = "browser",
                U.browser = !0,
                U.env = {},
                U.argv = [],
                U.version = "",
                U.versions = {},
                U.on = m,
                U.addListener = m,
                U.once = m,
                U.off = m,
                U.removeListener = m,
                U.removeAllListeners = m,
                U.emit = m,
                U.prependListener = m,
                U.prependOnceListener = m,
                U.listeners = function(v) {
                    return []
                }
                ,
                U.binding = function(v) {
                    throw new Error("process.binding is not supported")
                }
                ,
                U.cwd = function() {
                    return "/"
                }
                ,
                U.chdir = function(v) {
                    throw new Error("process.chdir is not supported")
                }
                ,
                U.umask = function() {
                    return 0
                }
            }
            , function(v, E, k) {
                "use strict";
                var R = k(0);
                v.exports = function(v, E) {
                    R.forEach(v, (function(k, R) {
                        R !== E && R.toUpperCase() === E.toUpperCase() && (v[E] = k,
                        delete v[R])
                    }
                    ))
                }
            }
            , function(v, E, k) {
                "use strict";
                var R = k(7);
                v.exports = function(v, E, k) {
                    var U = k.config.validateStatus;
                    !U || U(k.status) ? v(k) : E(R("Request failed with status code " + k.status, k.config, null, k.request, k))
                }
            }
            , function(v, E, k) {
                "use strict";
                v.exports = function(v, E, k, R, U) {
                    return v.config = E,
                    k && (v.code = k),
                    v.request = R,
                    v.response = U,
                    v.isAxiosError = !0,
                    v.toJSON = function() {
                        return {
                            "message": this.message,
                            "name": this.name,
                            "description": this.description,
                            "number": this.number,
                            "fileName": this.fileName,
                            "lineNumber": this.lineNumber,
                            "columnNumber": this.columnNumber,
                            "stack": this.stack,
                            "config": this.config,
                            "code": this.code
                        }
                    }
                    ,
                    v
                }
            }
            , function(v, E, k) {
                "use strict";
                var R = k(24)
                  , U = k(25);
                v.exports = function(v, E) {
                    return v && !R(E) ? U(v, E) : E
                }
            }
            , function(v, E, k) {
                "use strict";
                v.exports = function(v) {
                    return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(v)
                }
            }
            , function(v, E, k) {
                "use strict";
                v.exports = function(v, E) {
                    return E ? v.replace(/\/+$/, "") + "/" + E.replace(/^\/+/, "") : v
                }
            }
            , function(v, E, k) {
                "use strict";
                var R = k(0)
                  , U = ["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"];
                v.exports = function(v) {
                    var E, k, H, G = {};
                    return v ? (R.forEach(v.split("\n"), (function(v) {
                        if (H = v.indexOf(":"),
                        E = R.trim(v.substr(0, H)).toLowerCase(),
                        k = R.trim(v.substr(H + 1)),
                        E) {
                            if (G[E] && U.indexOf(E) >= 0)
                                return;
                            G[E] = "set-cookie" === E ? (G[E] ? G[E] : []).concat([k]) : G[E] ? G[E] + ", " + k : k
                        }
                    }
                    )),
                    G) : G
                }
            }
            , function(v, E, k) {
                "use strict";
                var R = k(0);
                v.exports = R.isStandardBrowserEnv() ? function() {
                    var v, E = /(msie|trident)/i.test(navigator.userAgent), k = document.createElement("a");
                    function r(v) {
                        var R = v;
                        return E && (k.setAttribute("href", R),
                        R = k.href),
                        k.setAttribute("href", R),
                        {
                            "href": k.href,
                            "protocol": k.protocol ? k.protocol.replace(/:$/, "") : "",
                            "host": k.host,
                            "search": k.search ? k.search.replace(/^\?/, "") : "",
                            "hash": k.hash ? k.hash.replace(/^#/, "") : "",
                            "hostname": k.hostname,
                            "port": k.port,
                            "pathname": "/" === k.pathname.charAt(0) ? k.pathname : "/" + k.pathname
                        }
                    }
                    return v = r(window.location.href),
                    function(E) {
                        var k = R.isString(E) ? r(E) : E;
                        return k.protocol === v.protocol && k.host === v.host
                    }
                }() : function() {
                    return !0
                }
            }
            , function(v, E, k) {
                "use strict";
                var R = k(0);
                v.exports = R.isStandardBrowserEnv() ? {
                    "write": function(v, E, k, U, H, G) {
                        var W = [];
                        W.push(v + "=" + encodeURIComponent(E)),
                        R.isNumber(k) && W.push("expires=" + new Date(k).toGMTString()),
                        R.isString(U) && W.push("path=" + U),
                        R.isString(H) && W.push("domain=" + H),
                        !0 === G && W.push("secure"),
                        document.cookie = W.join("; ")
                    },
                    "read": function(v) {
                        var E = document.cookie.match(new RegExp("(^|;\\s*)(" + v + ")=([^;]*)"));
                        return E ? decodeURIComponent(E[3]) : null
                    },
                    "remove": function(v) {
                        this.write(v, "", Date.now() - 864e5)
                    }
                } : {
                    "write": function() {},
                    "read": function() {
                        return null
                    },
                    "remove": function() {}
                }
            }
            , function(v, E, k) {
                "use strict";
                var R = k(9);
                function r(v) {
                    if ("function" != typeof v)
                        throw new TypeError("executor must be a function.");
                    var E;
                    this.promise = new Promise((function(v) {
                        E = v
                    }
                    ));
                    var k = this;
                    v((function(v) {
                        k.reason || (k.reason = new R(v),
                        E(k.reason))
                    }
                    ))
                }
                r.prototype.throwIfRequested = function() {
                    if (this.reason)
                        throw this.reason
                }
                ,
                r.source = function() {
                    var v;
                    return {
                        "token": new r((function(E) {
                            v = E
                        }
                        )),
                        "cancel": v
                    }
                }
                ,
                v.exports = r
            }
            , function(v, E, k) {
                "use strict";
                v.exports = function(v) {
                    return function(E) {
                        return v.apply(null, E)
                    }
                }
            }
            , function(v, E, k) {
                "use strict";
                k.r(E);
                var R = k(10)
                  , U = k.n(R)
                  , H = k(11)
                  , G = k.n(H)
                  , W = function() {
                    var v = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]
                      , E = v ? "PROD" : "prod"
                      , k = window.location.host;
                    return /^(t3\.m|n\.m|feed\.m|m|pre\.beta\.www|www)\.sohu(\.com)?/.test(k) || (E = v ? "TEST" : "test"),
                    /^(t3\.m|pre\.beta\.www)\.sohu(\.com)?/.test(k) && (E = v ? "PRE" : "pre"),
                    E
                }()
                  , Z = {
                    "appid": "116006"
                }
                  , u = function(v) {
                    return new ("prod" === (v.env || W) ? U.a : G.a)(v.passportConfig || Z)
                }
                  , Y = {
                    "dev": "//test-uis.mp.sohu.com/v3/uc",
                    "test": "//test-uis.mp.sohu.com/v3/uc",
                    "pre": "//pre-uis.mp.sohu.com/v3/uc",
                    "prod": "//uis.mp.sohu.com/v3/uc"
                }
                  , J = {
                    "appkey": "4003",
                    "secret": "395e615ffa1fdc85dd072387d6b75ba4",
                    "loginUrl": Y[W],
                    "loginUrlMap": Y
                }
                  , K = k(1)
                  , X = k.n(K)
                  , l = function(v) {
                    var E = v.env || W
                      , k = v && v.successFun || function() {}
                      , R = v && v.failureFun || function() {}
                      , U = v && v.device || "MPTCFEMOBILEUSER"
                      , H = v && v.appId || 100016
                      , G = J.loginUrlMap[E] || J.loginUrlMap.prod;
                    X()({
                        "url": G + "/user/info?appId=".concat(H, "&device=").concat(U),
                        "method": "GET",
                        "withCredentials": !0
                    }).then((function(v) {
                        try {
                            v && v.data && 1 == v.data.code ? k(v.data) : v && v.data && (200001 == v.data.code || 200002 == v.data.code || 200003 == v.data.code || 200006 == v.data.code || 200007 == v.data.code) ? X()({
                                "url": G + "/refresh/token?appId=".concat(H, "&device=").concat(U),
                                "method": "GET",
                                "withCredentials": !0
                            }).then((function(v) {
                                try {
                                    v && v.data && 1 == v.data.code ? k(v.data) : R(v.data)
                                } catch (v) {
                                    console.log(err),
                                    R(err)
                                }
                            }
                            )).catch((function(v) {
                                console.log(v),
                                R(v)
                            }
                            )) : R(v.data)
                        } catch (v) {
                            console.log(v),
                            R(v)
                        }
                    }
                    )).catch((function(v) {
                        console.log(v),
                        R(v)
                    }
                    ))
                }
                  , m = function(v) {
                    var E = v.env || W
                      , k = v && v.successFun || function() {}
                      , R = v && v.failureFun || function() {}
                      , U = v && v.device || "MPTCFEMOBILEUSER"
                      , H = v && v.appId || 100016
                      , G = v && v.loginSide || 4;
                    X()({
                        "url": J.loginUrlMap[E] + "/login",
                        "method": "POST",
                        "data": {
                            "appId": H,
                            "device": U,
                            "loginSide": G
                        },
                        "withCredentials": !0
                    }).then((function(v) {
                        try {
                            v && v.data && 1 == v.data.code ? k(v.data) : R(v.data)
                        } catch (v) {
                            console.log(v),
                            R(v)
                        }
                    }
                    )).catch((function(v) {
                        console.log(v),
                        R(v)
                    }
                    ))
                }
                  , Q = k(12)
                  , ee = k.n(Q)
                  , te = k(13);
                function b(v) {
                    return (b = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(v) {
                        return typeof v
                    }
                    : function(v) {
                        return v && "function" == typeof Symbol && v.constructor === Symbol && v !== Symbol.prototype ? "symbol" : typeof v
                    }
                    )(v)
                }
                function C(v, E) {
                    for (var k = 0; k < E.length; k++) {
                        var R = E[k];
                        R.enumerable = R.enumerable || !1,
                        R.configurable = !0,
                        "value"in R && (R.writable = !0),
                        Object.defineProperty(v, w(R.key), R)
                    }
                }
                function w(v) {
                    var E = function(v, E) {
                        if ("object" != b(v) || !v)
                            return v;
                        var k = v[Symbol.toPrimitive];
                        if (void 0 !== k) {
                            var R = k.call(v, E || "default");
                            if ("object" != b(R))
                                return R;
                            throw new TypeError("@@toPrimitive must return a primitive value.")
                        }
                        return ("string" === E ? String : Number)(v)
                    }(v, "string");
                    return "symbol" == b(E) ? E : E + ""
                }
                var ne = k.n(te).a
                  , re = ee.a.localStorageUtil
                  , S = function(v) {
                    return {
                        "success": v && v.successFun || v.success || function() {}
                        ,
                        "error": function() {}
                        ,
                        "params": v && v.params || {}
                    }
                }
                  , oe = function() {
                    return v = function e(v) {
                        !function(v, E) {
                            if (!(v instanceof E))
                                throw new TypeError("Cannot call a class as a function")
                        }(this, e),
                        this.passport = u(v || {})
                    }
                    ,
                    (E = [{
                        "key": "login",
                        "value": function(v) {
                            m(v)
                        }
                    }, {
                        "key": "checkLogin",
                        "value": function(v) {
                            l(v)
                        }
                    }, {
                        "key": "accountLogin",
                        "value": function(v) {
                            this.passport.login(S(v))
                        }
                    }, {
                        "key": "getPhonePicture",
                        "value": function() {
                            return this.passport.getPhonePicture()
                        }
                    }, {
                        "key": "getLoginPicture",
                        "value": function() {
                            return this.passport.getLoginPicture()
                        }
                    }, {
                        "key": "getSignInCaptcha",
                        "value": function(v) {
                            this.passport.getSignInCaptcha(S(v))
                        }
                    }, {
                        "key": "getMobileCaptcha",
                        "value": function(v) {
                            this.passport.getMobileCaptcha(S(v))
                        }
                    }, {
                        "key": "logout",
                        "value": function(v) {
                            this.passport.logout({
                                "success": function(E, k) {
                                    (v && v.successFun || v.success || function() {}
                                    )(E, k),
                                    ne.remove("user_id", "/", ".sohu.com"),
                                    ne.remove("umab_access_token", "/", ".sohu.com"),
                                    ne.remove("umab_refresh_token", "/", ".sohu.com"),
                                    re.removeItem("userinfo"),
                                    re.removeItem("userProfile")
                                },
                                "error": function() {}
                                ,
                                "params": v && v.params || {}
                            })
                        }
                    }, {
                        "key": "mobileLogin",
                        "value": function(v) {
                            this.passport.mobileLogin(S(v))
                        }
                    }, {
                        "key": "thirdLogin",
                        "value": function(v) {
                            return this.passport.getThirdLoginUrl({
                                "provider": v && v.provider || "qq",
                                "ru": v && v.ru || encodeURIComponent("https://m.sohu.com")
                            })
                        }
                    }, {
                        "key": "getWechatMPLoginUrl",
                        "value": function(v) {
                            var E = {
                                "openkey": v.openkey || "wxb5f6e60eb862aab9",
                                "ru": v && v.ru || encodeURIComponent("https://m.sohu.com")
                            };
                            return passport.getWechatMPLoginUrl(E)
                        }
                    }, {
                        "key": "onekeyLogin",
                        "value": function(v) {
                            var E = S(v);
                            E.getTokenError = v.getTokenError,
                            this.passport.onekeyLogin(E)
                        }
                    }, {
                        "key": "getNetType",
                        "value": function(v) {
                            this.passport.getNetType(this.passport.options.onekeyId, v)
                        }
                    }]) && C(v.prototype, E),
                    k && C(v, k),
                    Object.defineProperty(v, "prototype", {
                        "writable": !1
                    }),
                    v;
                    var v, E, k
                }();
                E.default = oe
            }
            ])
        },
        "1795": function(v, E, k) {
            var R;
            v = k.nmd(v),
            function() {
                "use strict";
                var U = {
                    "function": !0,
                    "object": !0
                }
                  , H = U[typeof window] && window || this
                  , G = U[typeof E] && E
                  , W = U.object && v && !v.nodeType && v
                  , Z = G && W && "object" == typeof k.g && k.g;
                !Z || Z.global !== Z && Z.window !== Z && Z.self !== Z || (H = Z);
                var Y = Math.pow(2, 53) - 1
                  , J = /\bOpera/
                  , K = Object.prototype
                  , X = K.hasOwnProperty
                  , Q = K.toString;
                function capitalize(v) {
                    return (v = String(v)).charAt(0).toUpperCase() + v.slice(1)
                }
                function format(v) {
                    return v = trim(v),
                    /^(?:webOS|i(?:OS|P))/.test(v) ? v : capitalize(v)
                }
                function forOwn(v, E) {
                    for (var k in v)
                        X.call(v, k) && E(v[k], k, v)
                }
                function getClassOf(v) {
                    return null == v ? capitalize(v) : Q.call(v).slice(8, -1)
                }
                function qualify(v) {
                    return String(v).replace(/([ -])(?!$)/g, "$1?")
                }
                function reduce(v, E) {
                    var k = null;
                    return function each(v, E) {
                        var k = -1
                          , R = v ? v.length : 0;
                        if ("number" == typeof R && R > -1 && R <= Y)
                            for (; ++k < R; )
                                E(v[k], k, v);
                        else
                            forOwn(v, E)
                    }(v, (function(R, U) {
                        k = E(k, R, U, v)
                    }
                    )),
                    k
                }
                function trim(v) {
                    return String(v).replace(/^ +| +$/g, "")
                }
                var ee = function parse(v) {
                    var E = H
                      , k = v && "object" == typeof v && "String" != getClassOf(v);
                    k && (E = v,
                    v = null);
                    var R = E.navigator || {}
                      , U = R.userAgent || "";
                    v || (v = U);
                    var G, W, Z = k ? !!R.likeChrome : /\bChrome\b/.test(v) && !/internal|\n/i.test(Q.toString()), Y = "Object", K = k ? Y : "ScriptBridgingProxyObject", X = k ? Y : "Environment", ee = k && E.java ? "JavaPackage" : getClassOf(E.java), te = k ? Y : "RuntimeObject", ne = /\bJava/.test(ee) && E.java, re = ne && getClassOf(E.environment) == X, oe = ne ? "a" : "α", ie = ne ? "b" : "β", ae = E.document || {}, se = E.operamini || E.opera, ce = J.test(ce = k && se ? se["[[Class]]"] : getClassOf(se)) ? ce : se = null, le = v, ue = [], de = null, pe = v == U, fe = pe && se && "function" == typeof se.version && se.version(), he = function getLayout(E) {
                        return reduce(E, (function(E, k) {
                            return E || RegExp("\\b" + (k.pattern || qualify(k)) + "\\b", "i").exec(v) && (k.label || k)
                        }
                        ))
                    }([{
                        "label": "EdgeHTML",
                        "pattern": "Edge"
                    }, "Trident", {
                        "label": "WebKit",
                        "pattern": "AppleWebKit"
                    }, "iCab", "Presto", "NetFront", "Tasman", "KHTML", "Gecko"]), me = function getName(E) {
                        return reduce(E, (function(E, k) {
                            return E || RegExp("\\b" + (k.pattern || qualify(k)) + "\\b", "i").exec(v) && (k.label || k)
                        }
                        ))
                    }(["Adobe AIR", "Arora", "Avant Browser", "Breach", "Camino", "Electron", "Epiphany", "Fennec", "Flock", "Galeon", "GreenBrowser", "iCab", "Iceweasel", "K-Meleon", "Konqueror", "Lunascape", "Maxthon", {
                        "label": "Microsoft Edge",
                        "pattern": "(?:Edge|Edg|EdgA|EdgiOS)"
                    }, "Midori", "Nook Browser", "PaleMoon", "PhantomJS", "Raven", "Rekonq", "RockMelt", {
                        "label": "Samsung Internet",
                        "pattern": "SamsungBrowser"
                    }, "SeaMonkey", {
                        "label": "Silk",
                        "pattern": "(?:Cloud9|Silk-Accelerated)"
                    }, "Sleipnir", "SlimBrowser", {
                        "label": "SRWare Iron",
                        "pattern": "Iron"
                    }, "Sunrise", "Swiftfox", "Vivaldi", "Waterfox", "WebPositive", {
                        "label": "Yandex Browser",
                        "pattern": "YaBrowser"
                    }, {
                        "label": "UC Browser",
                        "pattern": "UCBrowser"
                    }, "Opera Mini", {
                        "label": "Opera Mini",
                        "pattern": "OPiOS"
                    }, "Opera", {
                        "label": "Opera",
                        "pattern": "OPR"
                    }, "Chromium", "Chrome", {
                        "label": "Chrome",
                        "pattern": "(?:HeadlessChrome)"
                    }, {
                        "label": "Chrome Mobile",
                        "pattern": "(?:CriOS|CrMo)"
                    }, {
                        "label": "Firefox",
                        "pattern": "(?:Firefox|Minefield)"
                    }, {
                        "label": "Firefox for iOS",
                        "pattern": "FxiOS"
                    }, {
                        "label": "IE",
                        "pattern": "IEMobile"
                    }, {
                        "label": "IE",
                        "pattern": "MSIE"
                    }, "Safari"]), ge = getProduct([{
                        "label": "BlackBerry",
                        "pattern": "BB10"
                    }, "BlackBerry", {
                        "label": "Galaxy S",
                        "pattern": "GT-I9000"
                    }, {
                        "label": "Galaxy S2",
                        "pattern": "GT-I9100"
                    }, {
                        "label": "Galaxy S3",
                        "pattern": "GT-I9300"
                    }, {
                        "label": "Galaxy S4",
                        "pattern": "GT-I9500"
                    }, {
                        "label": "Galaxy S5",
                        "pattern": "SM-G900"
                    }, {
                        "label": "Galaxy S6",
                        "pattern": "SM-G920"
                    }, {
                        "label": "Galaxy S6 Edge",
                        "pattern": "SM-G925"
                    }, {
                        "label": "Galaxy S7",
                        "pattern": "SM-G930"
                    }, {
                        "label": "Galaxy S7 Edge",
                        "pattern": "SM-G935"
                    }, "Google TV", "Lumia", "iPad", "iPod", "iPhone", "Kindle", {
                        "label": "Kindle Fire",
                        "pattern": "(?:Cloud9|Silk-Accelerated)"
                    }, "Nexus", "Nook", "PlayBook", "PlayStation Vita", "PlayStation", "TouchPad", "Transformer", {
                        "label": "Wii U",
                        "pattern": "WiiU"
                    }, "Wii", "Xbox One", {
                        "label": "Xbox 360",
                        "pattern": "Xbox"
                    }, "Xoom"]), _e = function getManufacturer(E) {
                        return reduce(E, (function(E, k, R) {
                            return E || (k[ge] || k[/^[a-z]+(?: +[a-z]+\b)*/i.exec(ge)] || RegExp("\\b" + qualify(R) + "(?:\\b|\\w*\\d)", "i").exec(v)) && R
                        }
                        ))
                    }({
                        "Apple": {
                            "iPad": 1,
                            "iPhone": 1,
                            "iPod": 1
                        },
                        "Alcatel": {},
                        "Archos": {},
                        "Amazon": {
                            "Kindle": 1,
                            "Kindle Fire": 1
                        },
                        "Asus": {
                            "Transformer": 1
                        },
                        "Barnes & Noble": {
                            "Nook": 1
                        },
                        "BlackBerry": {
                            "PlayBook": 1
                        },
                        "Google": {
                            "Google TV": 1,
                            "Nexus": 1
                        },
                        "HP": {
                            "TouchPad": 1
                        },
                        "HTC": {},
                        "Huawei": {},
                        "Lenovo": {},
                        "LG": {},
                        "Microsoft": {
                            "Xbox": 1,
                            "Xbox One": 1
                        },
                        "Motorola": {
                            "Xoom": 1
                        },
                        "Nintendo": {
                            "Wii U": 1,
                            "Wii": 1
                        },
                        "Nokia": {
                            "Lumia": 1
                        },
                        "Oppo": {},
                        "Samsung": {
                            "Galaxy S": 1,
                            "Galaxy S2": 1,
                            "Galaxy S3": 1,
                            "Galaxy S4": 1
                        },
                        "Sony": {
                            "PlayStation": 1,
                            "PlayStation Vita": 1
                        },
                        "Xiaomi": {
                            "Mi": 1,
                            "Redmi": 1
                        }
                    }), ve = function getOS(E) {
                        return reduce(E, (function(E, k) {
                            var R = k.pattern || qualify(k);
                            return !E && (E = RegExp("\\b" + R + "(?:/[\\d.]+|[ \\w.]*)", "i").exec(v)) && (E = function cleanupOS(v, E, k) {
                                var R = {
                                    "10.0": "10",
                                    "6.4": "10 Technical Preview",
                                    "6.3": "8.1",
                                    "6.2": "8",
                                    "6.1": "Server 2008 R2 / 7",
                                    "6.0": "Server 2008 / Vista",
                                    "5.2": "Server 2003 / XP 64-bit",
                                    "5.1": "XP",
                                    "5.01": "2000 SP1",
                                    "5.0": "2000",
                                    "4.0": "NT",
                                    "4.90": "ME"
                                };
                                return E && k && /^Win/i.test(v) && !/^Windows Phone /i.test(v) && (R = R[/[\d.]+$/.exec(v)]) && (v = "Windows " + R),
                                v = String(v),
                                E && k && (v = v.replace(RegExp(E, "i"), k)),
                                format(v.replace(/ ce$/i, " CE").replace(/\bhpw/i, "web").replace(/\bMacintosh\b/, "Mac OS").replace(/_PowerPC\b/i, " OS").replace(/\b(OS X) [^ \d]+/i, "$1").replace(/\bMac (OS X)\b/, "$1").replace(/\/(\d)/, " $1").replace(/_/g, ".").replace(/(?: BePC|[ .]*fc[ \d.]+)$/i, "").replace(/\bx86\.64\b/gi, "x86_64").replace(/\b(Windows Phone) OS\b/, "$1").replace(/\b(Chrome OS \w+) [\d.]+\b/, "$1").split(" on ")[0])
                            }(E, R, k.label || k)),
                            E
                        }
                        ))
                    }(["Windows Phone", "KaiOS", "Android", "CentOS", {
                        "label": "Chrome OS",
                        "pattern": "CrOS"
                    }, "Debian", {
                        "label": "DragonFly BSD",
                        "pattern": "DragonFly"
                    }, "Fedora", "FreeBSD", "Gentoo", "Haiku", "Kubuntu", "Linux Mint", "OpenBSD", "Red Hat", "SuSE", "Ubuntu", "Xubuntu", "Cygwin", "Symbian OS", "hpwOS", "webOS ", "webOS", "Tablet OS", "Tizen", "Linux", "Mac OS X", "Macintosh", "Mac", "Windows 98;", "Windows "]);
                    function getProduct(E) {
                        return reduce(E, (function(E, k) {
                            var R = k.pattern || qualify(k);
                            return !E && (E = RegExp("\\b" + R + " *\\d+[.\\w_]*", "i").exec(v) || RegExp("\\b" + R + " *\\w+-[\\w]*", "i").exec(v) || RegExp("\\b" + R + "(?:; *(?:[a-z]+[_-])?[a-z]+\\d+|[^ ();-]*)", "i").exec(v)) && ((E = String(k.label && !RegExp(R, "i").test(k.label) ? k.label : E).split("/"))[1] && !/[\d.]+/.test(E[0]) && (E[0] += " " + E[1]),
                            k = k.label || k,
                            E = format(E[0].replace(RegExp(R, "i"), k).replace(RegExp("; *(?:" + k + "[_-])?", "i"), " ").replace(RegExp("(" + k + ")[-_.]?(\\w)", "i"), "$1 $2"))),
                            E
                        }
                        ))
                    }
                    function getVersion(E) {
                        return reduce(E, (function(E, k) {
                            return E || (RegExp(k + "(?:-[\\d.]+/|(?: for [\\w-]+)?[ /-])([\\d.]+[^ ();/_-]*)", "i").exec(v) || 0)[1] || null
                        }
                        ))
                    }
                    if (he && (he = [he]),
                    /\bAndroid\b/.test(ve) && !ge && (G = /\bAndroid[^;]*;(.*?)(?:Build|\) AppleWebKit)\b/i.exec(v)) && (ge = trim(G[1]).replace(/^[a-z]{2}-[a-z]{2};\s*/i, "") || null),
                    _e && !ge ? ge = getProduct([_e]) : _e && ge && (ge = ge.replace(RegExp("^(" + qualify(_e) + ")[-_.\\s]", "i"), _e + " ").replace(RegExp("^(" + qualify(_e) + ")[-_.]?(\\w)", "i"), _e + " $2")),
                    (G = /\bGoogle TV\b/.exec(ge)) && (ge = G[0]),
                    /\bSimulator\b/i.test(v) && (ge = (ge ? ge + " " : "") + "Simulator"),
                    "Opera Mini" == me && /\bOPiOS\b/.test(v) && ue.push("running in Turbo/Uncompressed mode"),
                    "IE" == me && /\blike iPhone OS\b/.test(v) ? (_e = (G = parse(v.replace(/like iPhone OS/, ""))).manufacturer,
                    ge = G.product) : /^iP/.test(ge) ? (me || (me = "Safari"),
                    ve = "iOS" + ((G = / OS ([\d_]+)/i.exec(v)) ? " " + G[1].replace(/_/g, ".") : "")) : "Konqueror" == me && /^Linux\b/i.test(ve) ? ve = "Kubuntu" : _e && "Google" != _e && (/Chrome/.test(me) && !/\bMobile Safari\b/i.test(v) || /\bVita\b/.test(ge)) || /\bAndroid\b/.test(ve) && /^Chrome/.test(me) && /\bVersion\//i.test(v) ? (me = "Android Browser",
                    ve = /\bAndroid\b/.test(ve) ? ve : "Android") : "Silk" == me ? (/\bMobi/i.test(v) || (ve = "Android",
                    ue.unshift("desktop mode")),
                    /Accelerated *= *true/i.test(v) && ue.unshift("accelerated")) : "UC Browser" == me && /\bUCWEB\b/.test(v) ? ue.push("speed mode") : "PaleMoon" == me && (G = /\bFirefox\/([\d.]+)\b/.exec(v)) ? ue.push("identifying as Firefox " + G[1]) : "Firefox" == me && (G = /\b(Mobile|Tablet|TV)\b/i.exec(v)) ? (ve || (ve = "Firefox OS"),
                    ge || (ge = G[1])) : !me || (G = !/\bMinefield\b/i.test(v) && /\b(?:Firefox|Safari)\b/.exec(me)) ? (me && !ge && /[\/,]|^[^(]+?\)/.test(v.slice(v.indexOf(G + "/") + 8)) && (me = null),
                    (G = ge || _e || ve) && (ge || _e || /\b(?:Android|Symbian OS|Tablet OS|webOS)\b/.test(ve)) && (me = /[a-z]+(?: Hat)?/i.exec(/\bAndroid\b/.test(ve) ? ve : G) + " Browser")) : "Electron" == me && (G = (/\bChrome\/([\d.]+)\b/.exec(v) || 0)[1]) && ue.push("Chromium " + G),
                    fe || (fe = getVersion(["(?:Cloud9|CriOS|CrMo|Edge|Edg|EdgA|EdgiOS|FxiOS|HeadlessChrome|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|SamsungBrowser|Silk(?!/[\\d.]+$)|UCBrowser|YaBrowser)", "Version", qualify(me), "(?:Firefox|Minefield|NetFront)"])),
                    (G = ("iCab" == he && parseFloat(fe) > 3 ? "WebKit" : /\bOpera\b/.test(me) && (/\bOPR\b/.test(v) ? "Blink" : "Presto")) || /\b(?:Midori|Nook|Safari)\b/i.test(v) && !/^(?:Trident|EdgeHTML)$/.test(he) && "WebKit" || !he && /\bMSIE\b/i.test(v) && ("Mac OS" == ve ? "Tasman" : "Trident") || "WebKit" == he && /\bPlayStation\b(?! Vita\b)/i.test(me) && "NetFront") && (he = [G]),
                    "IE" == me && (G = (/; *(?:XBLWP|ZuneWP)(\d+)/i.exec(v) || 0)[1]) ? (me += " Mobile",
                    ve = "Windows Phone " + (/\+$/.test(G) ? G : G + ".x"),
                    ue.unshift("desktop mode")) : /\bWPDesktop\b/i.test(v) ? (me = "IE Mobile",
                    ve = "Windows Phone 8.x",
                    ue.unshift("desktop mode"),
                    fe || (fe = (/\brv:([\d.]+)/.exec(v) || 0)[1])) : "IE" != me && "Trident" == he && (G = /\brv:([\d.]+)/.exec(v)) && (me && ue.push("identifying as " + me + (fe ? " " + fe : "")),
                    me = "IE",
                    fe = G[1]),
                    pe) {
                        if (function isHostType(v, E) {
                            var k = null != v ? typeof v[E] : "number";
                            return !(/^(?:boolean|number|string|undefined)$/.test(k) || "object" == k && !v[E])
                        }(E, "global"))
                            if (ne && (le = (G = ne.lang.System).getProperty("os.arch"),
                            ve = ve || G.getProperty("os.name") + " " + G.getProperty("os.version")),
                            re) {
                                try {
                                    fe = E.require("ringo/engine").version.join("."),
                                    me = "RingoJS"
                                } catch (v) {
                                    (G = E.system) && G.global.system == E.system && (me = "Narwhal",
                                    ve || (ve = G[0].os || null))
                                }
                                me || (me = "Rhino")
                            } else
                                "object" == typeof E.process && !E.process.browser && (G = E.process) && ("object" == typeof G.versions && ("string" == typeof G.versions.electron ? (ue.push("Node " + G.versions.node),
                                me = "Electron",
                                fe = G.versions.electron) : "string" == typeof G.versions.nw && (ue.push("Chromium " + fe, "Node " + G.versions.node),
                                me = "NW.js",
                                fe = G.versions.nw)),
                                me || (me = "Node.js",
                                le = G.arch,
                                ve = G.platform,
                                fe = (fe = /[\d.]+/.exec(G.version)) ? fe[0] : null));
                        else
                            getClassOf(G = E.runtime) == K ? (me = "Adobe AIR",
                            ve = G.flash.system.Capabilities.os) : getClassOf(G = E.phantom) == te ? (me = "PhantomJS",
                            fe = (G = G.version || null) && G.major + "." + G.minor + "." + G.patch) : "number" == typeof ae.documentMode && (G = /\bTrident\/(\d+)/i.exec(v)) ? (fe = [fe, ae.documentMode],
                            (G = +G[1] + 4) != fe[1] && (ue.push("IE " + fe[1] + " mode"),
                            he && (he[1] = ""),
                            fe[1] = G),
                            fe = "IE" == me ? String(fe[1].toFixed(1)) : fe[0]) : "number" == typeof ae.documentMode && /^(?:Chrome|Firefox)\b/.test(me) && (ue.push("masking as " + me + " " + fe),
                            me = "IE",
                            fe = "11.0",
                            he = ["Trident"],
                            ve = "Windows");
                        ve = ve && format(ve)
                    }
                    if (fe && (G = /(?:[ab]|dp|pre|[ab]\d+pre)(?:\d+\+?)?$/i.exec(fe) || /(?:alpha|beta)(?: ?\d)?/i.exec(v + ";" + (pe && R.appMinorVersion)) || /\bMinefield\b/i.test(v) && "a") && (de = /b/i.test(G) ? "beta" : "alpha",
                    fe = fe.replace(RegExp(G + "\\+?$"), "") + ("beta" == de ? ie : oe) + (/\d+\+?/.exec(G) || "")),
                    "Fennec" == me || "Firefox" == me && /\b(?:Android|Firefox OS|KaiOS)\b/.test(ve))
                        me = "Firefox Mobile";
                    else if ("Maxthon" == me && fe)
                        fe = fe.replace(/\.[\d.]+/, ".x");
                    else if (/\bXbox\b/i.test(ge))
                        "Xbox 360" == ge && (ve = null),
                        "Xbox 360" == ge && /\bIEMobile\b/.test(v) && ue.unshift("mobile mode");
                    else if (!/^(?:Chrome|IE|Opera)$/.test(me) && (!me || ge || /Browser|Mobi/.test(me)) || "Windows CE" != ve && !/Mobi/i.test(v))
                        if ("IE" == me && pe)
                            try {
                                null === E.external && ue.unshift("platform preview")
                            } catch (v) {
                                ue.unshift("embedded")
                            }
                        else
                            (/\bBlackBerry\b/.test(ge) || /\bBB10\b/.test(v)) && (G = (RegExp(ge.replace(/ +/g, " *") + "/([.\\d]+)", "i").exec(v) || 0)[1] || fe) ? (ve = ((G = [G, /BB10/.test(v)])[1] ? (ge = null,
                            _e = "BlackBerry") : "Device Software") + " " + G[0],
                            fe = null) : this != forOwn && "Wii" != ge && (pe && se || /Opera/.test(me) && /\b(?:MSIE|Firefox)\b/i.test(v) || "Firefox" == me && /\bOS X (?:\d+\.){2,}/.test(ve) || "IE" == me && (ve && !/^Win/.test(ve) && fe > 5.5 || /\bWindows XP\b/.test(ve) && fe > 8 || 8 == fe && !/\bTrident\b/.test(v))) && !J.test(G = parse.call(forOwn, v.replace(J, "") + ";")) && G.name && (G = "ing as " + G.name + ((G = G.version) ? " " + G : ""),
                            J.test(me) ? (/\bIE\b/.test(G) && "Mac OS" == ve && (ve = null),
                            G = "identify" + G) : (G = "mask" + G,
                            me = ce ? format(ce.replace(/([a-z])([A-Z])/g, "$1 $2")) : "Opera",
                            /\bIE\b/.test(G) && (ve = null),
                            pe || (fe = null)),
                            he = ["Presto"],
                            ue.push(G));
                    else
                        me += " Mobile";
                    (G = (/\bAppleWebKit\/([\d.]+\+?)/i.exec(v) || 0)[1]) && (G = [parseFloat(G.replace(/\.(\d)$/, ".0$1")), G],
                    "Safari" == me && "+" == G[1].slice(-1) ? (me = "WebKit Nightly",
                    de = "alpha",
                    fe = G[1].slice(0, -1)) : fe != G[1] && fe != (G[2] = (/\bSafari\/([\d.]+\+?)/i.exec(v) || 0)[1]) || (fe = null),
                    G[1] = (/\b(?:Headless)?Chrome\/([\d.]+)/i.exec(v) || 0)[1],
                    537.36 == G[0] && 537.36 == G[2] && parseFloat(G[1]) >= 28 && "WebKit" == he && (he = ["Blink"]),
                    pe && (Z || G[1]) ? (he && (he[1] = "like Chrome"),
                    G = G[1] || ((G = G[0]) < 530 ? 1 : G < 532 ? 2 : G < 532.05 ? 3 : G < 533 ? 4 : G < 534.03 ? 5 : G < 534.07 ? 6 : G < 534.1 ? 7 : G < 534.13 ? 8 : G < 534.16 ? 9 : G < 534.24 ? 10 : G < 534.3 ? 11 : G < 535.01 ? 12 : G < 535.02 ? "13+" : G < 535.07 ? 15 : G < 535.11 ? 16 : G < 535.19 ? 17 : G < 536.05 ? 18 : G < 536.1 ? 19 : G < 537.01 ? 20 : G < 537.11 ? "21+" : G < 537.13 ? 23 : G < 537.18 ? 24 : G < 537.24 ? 25 : G < 537.36 ? 26 : "Blink" != he ? "27" : "28")) : (he && (he[1] = "like Safari"),
                    G = (G = G[0]) < 400 ? 1 : G < 500 ? 2 : G < 526 ? 3 : G < 533 ? 4 : G < 534 ? "4+" : G < 535 ? 5 : G < 537 ? 6 : G < 538 ? 7 : G < 601 ? 8 : G < 602 ? 9 : G < 604 ? 10 : G < 606 ? 11 : G < 608 ? 12 : "12"),
                    he && (he[1] += " " + (G += "number" == typeof G ? ".x" : /[.+]/.test(G) ? "" : "+")),
                    "Safari" == me && (!fe || parseInt(fe) > 45) ? fe = G : "Chrome" == me && /\bHeadlessChrome/i.test(v) && ue.unshift("headless")),
                    "Opera" == me && (G = /\bzbov|zvav$/.exec(ve)) ? (me += " ",
                    ue.unshift("desktop mode"),
                    "zvav" == G ? (me += "Mini",
                    fe = null) : me += "Mobile",
                    ve = ve.replace(RegExp(" *" + G + "$"), "")) : "Safari" == me && /\bChrome\b/.exec(he && he[1]) ? (ue.unshift("desktop mode"),
                    me = "Chrome Mobile",
                    fe = null,
                    /\bOS X\b/.test(ve) ? (_e = "Apple",
                    ve = "iOS 4.3+") : ve = null) : /\bSRWare Iron\b/.test(me) && !fe && (fe = getVersion("Chrome")),
                    fe && 0 == fe.indexOf(G = /[\d.]+$/.exec(ve)) && v.indexOf("/" + G + "-") > -1 && (ve = trim(ve.replace(G, ""))),
                    ve && -1 != ve.indexOf(me) && !RegExp(me + " OS").test(ve) && (ve = ve.replace(RegExp(" *" + qualify(me) + " *"), "")),
                    he && !/\b(?:Avant|Nook)\b/.test(me) && (/Browser|Lunascape|Maxthon/.test(me) || "Safari" != me && /^iOS/.test(ve) && /\bSafari\b/.test(he[1]) || /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Samsung Internet|Sleipnir|SRWare Iron|Vivaldi|Web)/.test(me) && he[1]) && (G = he[he.length - 1]) && ue.push(G),
                    ue.length && (ue = ["(" + ue.join("; ") + ")"]),
                    _e && ge && ge.indexOf(_e) < 0 && ue.push("on " + _e),
                    ge && ue.push((/^on /.test(ue[ue.length - 1]) ? "" : "on ") + ge),
                    ve && (G = / ([\d.+]+)$/.exec(ve),
                    W = G && "/" == ve.charAt(ve.length - G[0].length - 1),
                    ve = {
                        "architecture": 32,
                        "family": G && !W ? ve.replace(G[0], "") : ve,
                        "version": G ? G[1] : null,
                        "toString": function() {
                            var v = this.version;
                            return this.family + (v && !W ? " " + v : "") + (64 == this.architecture ? " 64-bit" : "")
                        }
                    }),
                    (G = /\b(?:AMD|IA|Win|WOW|x86_|x)64\b/i.exec(le)) && !/\bi686\b/i.test(le) ? (ve && (ve.architecture = 64,
                    ve.family = ve.family.replace(RegExp(" *" + G), "")),
                    me && (/\bWOW64\b/i.test(v) || pe && /\w(?:86|32)$/.test(R.cpuClass || R.platform) && !/\bWin64; x64\b/i.test(v)) && ue.unshift("32-bit")) : ve && /^OS X/.test(ve.family) && "Chrome" == me && parseFloat(fe) >= 39 && (ve.architecture = 64),
                    v || (v = null);
                    var ye = {};
                    return ye.description = v,
                    ye.layout = he && he[0],
                    ye.manufacturer = _e,
                    ye.name = me,
                    ye.prerelease = de,
                    ye.product = ge,
                    ye.ua = v,
                    ye.version = me && fe,
                    ye.os = ve || {
                        "architecture": null,
                        "family": null,
                        "version": null,
                        "toString": function() {
                            return "null"
                        }
                    },
                    ye.parse = parse,
                    ye.toString = function toStringPlatform() {
                        return this.description || ""
                    }
                    ,
                    ye.version && ue.unshift(fe),
                    ye.name && ue.unshift(me),
                    ve && me && (ve != String(ve).split(" ")[0] || ve != me.split(" ")[0] && !ge) && ue.push(ge ? "(" + ve + ")" : "on " + ve),
                    ue.length && (ye.description = ue.join(" ")),
                    ye
                }();
                H.platform = ee,
                void 0 === (R = function() {
                    return ee
                }
                .call(E, k, E, v)) || (v.exports = R)
            }
            .call(this)
        },
        "5760": function(v) {
            "use strict";
            function Cache(v) {
                this._maxSize = v,
                this.clear()
            }
            Cache.prototype.clear = function() {
                this._size = 0,
                this._values = Object.create(null)
            }
            ,
            Cache.prototype.get = function(v) {
                return this._values[v]
            }
            ,
            Cache.prototype.set = function(v, E) {
                return this._size >= this._maxSize && this.clear(),
                v in this._values || this._size++,
                this._values[v] = E
            }
            ;
            var E = /[^.^\]^[]+|(?=\[\]|\.\.)/g
              , k = /^\d+$/
              , R = /^\d/
              , U = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g
              , H = /^\s*(['"]?)(.*?)(\1)\s*$/
              , G = new Cache(512)
              , W = new Cache(512)
              , Z = new Cache(512);
            function normalizePath(v) {
                return G.get(v) || G.set(v, split(v).map((function(v) {
                    return v.replace(H, "$2")
                }
                )))
            }
            function split(v) {
                return v.match(E) || [""]
            }
            function isQuoted(v) {
                return "string" == typeof v && v && -1 !== ["'", '"'].indexOf(v.charAt(0))
            }
            function shouldBeQuoted(v) {
                return !isQuoted(v) && (function hasLeadingNumber(v) {
                    return v.match(R) && !v.match(k)
                }(v) || function hasSpecialChars(v) {
                    return U.test(v)
                }(v))
            }
            v.exports = {
                "Cache": Cache,
                "split": split,
                "normalizePath": normalizePath,
                "setter": function(v) {
                    var E = normalizePath(v);
                    return W.get(v) || W.set(v, (function setter(v, k) {
                        for (var R = 0, U = E.length, H = v; R < U - 1; ) {
                            var G = E[R];
                            if ("__proto__" === G || "constructor" === G || "prototype" === G)
                                return v;
                            H = H[E[R++]]
                        }
                        H[E[R]] = k
                    }
                    ))
                },
                "getter": function(v, E) {
                    var k = normalizePath(v);
                    return Z.get(v) || Z.set(v, (function getter(v) {
                        for (var R = 0, U = k.length; R < U; ) {
                            if (null == v && E)
                                return;
                            v = v[k[R++]]
                        }
                        return v
                    }
                    ))
                },
                "join": function(v) {
                    return v.reduce((function(v, E) {
                        return v + (isQuoted(E) || k.test(E) ? "[" + E + "]" : (v ? "." : "") + E)
                    }
                    ), "")
                },
                "forEach": function(v, E, k) {
                    !function forEach(v, E, k) {
                        var R, U, H, G, W = v.length;
                        for (U = 0; U < W; U++)
                            (R = v[U]) && (shouldBeQuoted(R) && (R = '"' + R + '"'),
                            H = !(G = isQuoted(R)) && /^\d+$/.test(R),
                            E.call(k, R, G, H, U, v))
                    }(Array.isArray(v) ? v : split(v), E, k)
                }
            }
        },
        "7563": function(v, E, k) {
            "use strict";
            const R = k(610)
              , U = k(4020)
              , H = k(500)
              , G = k(2806)
              , W = Symbol("encodeFragmentIdentifier");
            function validateArrayFormatSeparator(v) {
                if ("string" != typeof v || 1 !== v.length)
                    throw new TypeError("arrayFormatSeparator must be single character string")
            }
            function encode(v, E) {
                return E.encode ? E.strict ? R(v) : encodeURIComponent(v) : v
            }
            function decode(v, E) {
                return E.decode ? U(v) : v
            }
            function keysSorter(v) {
                return Array.isArray(v) ? v.sort() : "object" == typeof v ? keysSorter(Object.keys(v)).sort(( (v, E) => Number(v) - Number(E))).map((E => v[E])) : v
            }
            function removeHash(v) {
                const E = v.indexOf("#");
                return -1 !== E && (v = v.slice(0, E)),
                v
            }
            function extract(v) {
                const E = (v = removeHash(v)).indexOf("?");
                return -1 === E ? "" : v.slice(E + 1)
            }
            function parseValue(v, E) {
                return E.parseNumbers && !Number.isNaN(Number(v)) && "string" == typeof v && "" !== v.trim() ? v = Number(v) : !E.parseBooleans || null === v || "true" !== v.toLowerCase() && "false" !== v.toLowerCase() || (v = "true" === v.toLowerCase()),
                v
            }
            function parse(v, E) {
                validateArrayFormatSeparator((E = Object.assign({
                    "decode": !0,
                    "sort": !0,
                    "arrayFormat": "none",
                    "arrayFormatSeparator": ",",
                    "parseNumbers": !1,
                    "parseBooleans": !1
                }, E)).arrayFormatSeparator);
                const k = function parserForArrayFormat(v) {
                    let E;
                    switch (v.arrayFormat) {
                    case "index":
                        return (v, k, R) => {
                            E = /\[(\d*)\]$/.exec(v),
                            v = v.replace(/\[\d*\]$/, ""),
                            E ? (void 0 === R[v] && (R[v] = {}),
                            R[v][E[1]] = k) : R[v] = k
                        }
                        ;
                    case "bracket":
                        return (v, k, R) => {
                            E = /(\[\])$/.exec(v),
                            v = v.replace(/\[\]$/, ""),
                            E ? void 0 !== R[v] ? R[v] = [].concat(R[v], k) : R[v] = [k] : R[v] = k
                        }
                        ;
                    case "colon-list-separator":
                        return (v, k, R) => {
                            E = /(:list)$/.exec(v),
                            v = v.replace(/:list$/, ""),
                            E ? void 0 !== R[v] ? R[v] = [].concat(R[v], k) : R[v] = [k] : R[v] = k
                        }
                        ;
                    case "comma":
                    case "separator":
                        return (E, k, R) => {
                            const U = "string" == typeof k && k.includes(v.arrayFormatSeparator)
                              , H = "string" == typeof k && !U && decode(k, v).includes(v.arrayFormatSeparator);
                            k = H ? decode(k, v) : k;
                            const G = U || H ? k.split(v.arrayFormatSeparator).map((E => decode(E, v))) : null === k ? k : decode(k, v);
                            R[E] = G
                        }
                        ;
                    case "bracket-separator":
                        return (E, k, R) => {
                            const U = /(\[\])$/.test(E);
                            if (E = E.replace(/\[\]$/, ""),
                            !U)
                                return void (R[E] = k ? decode(k, v) : k);
                            const H = null === k ? [] : k.split(v.arrayFormatSeparator).map((E => decode(E, v)));
                            void 0 !== R[E] ? R[E] = [].concat(R[E], H) : R[E] = H
                        }
                        ;
                    default:
                        return (v, E, k) => {
                            void 0 !== k[v] ? k[v] = [].concat(k[v], E) : k[v] = E
                        }
                    }
                }(E)
                  , R = Object.create(null);
                if ("string" != typeof v)
                    return R;
                if (!(v = v.trim().replace(/^[?#&]/, "")))
                    return R;
                for (const U of v.split("&")) {
                    if ("" === U)
                        continue;
                    let[v,G] = H(E.decode ? U.replace(/\+/g, " ") : U, "=");
                    G = void 0 === G ? null : ["comma", "separator", "bracket-separator"].includes(E.arrayFormat) ? G : decode(G, E),
                    k(decode(v, E), G, R)
                }
                for (const v of Object.keys(R)) {
                    const k = R[v];
                    if ("object" == typeof k && null !== k)
                        for (const v of Object.keys(k))
                            k[v] = parseValue(k[v], E);
                    else
                        R[v] = parseValue(k, E)
                }
                return !1 === E.sort ? R : (!0 === E.sort ? Object.keys(R).sort() : Object.keys(R).sort(E.sort)).reduce(( (v, E) => {
                    const k = R[E];
                    return Boolean(k) && "object" == typeof k && !Array.isArray(k) ? v[E] = keysSorter(k) : v[E] = k,
                    v
                }
                ), Object.create(null))
            }
            E.extract = extract,
            E.parse = parse,
            E.stringify = (v, E) => {
                if (!v)
                    return "";
                validateArrayFormatSeparator((E = Object.assign({
                    "encode": !0,
                    "strict": !0,
                    "arrayFormat": "none",
                    "arrayFormatSeparator": ","
                }, E)).arrayFormatSeparator);
                const shouldFilter = k => E.skipNull && null == v[k] || E.skipEmptyString && "" === v[k]
                  , k = function encoderForArrayFormat(v) {
                    switch (v.arrayFormat) {
                    case "index":
                        return E => (k, R) => {
                            const U = k.length;
                            return void 0 === R || v.skipNull && null === R || v.skipEmptyString && "" === R ? k : null === R ? [...k, [encode(E, v), "[", U, "]"].join("")] : [...k, [encode(E, v), "[", encode(U, v), "]=", encode(R, v)].join("")]
                        }
                        ;
                    case "bracket":
                        return E => (k, R) => void 0 === R || v.skipNull && null === R || v.skipEmptyString && "" === R ? k : null === R ? [...k, [encode(E, v), "[]"].join("")] : [...k, [encode(E, v), "[]=", encode(R, v)].join("")];
                    case "colon-list-separator":
                        return E => (k, R) => void 0 === R || v.skipNull && null === R || v.skipEmptyString && "" === R ? k : null === R ? [...k, [encode(E, v), ":list="].join("")] : [...k, [encode(E, v), ":list=", encode(R, v)].join("")];
                    case "comma":
                    case "separator":
                    case "bracket-separator":
                        {
                            const E = "bracket-separator" === v.arrayFormat ? "[]=" : "=";
                            return k => (R, U) => void 0 === U || v.skipNull && null === U || v.skipEmptyString && "" === U ? R : (U = null === U ? "" : U,
                            0 === R.length ? [[encode(k, v), E, encode(U, v)].join("")] : [[R, encode(U, v)].join(v.arrayFormatSeparator)])
                        }
                    default:
                        return E => (k, R) => void 0 === R || v.skipNull && null === R || v.skipEmptyString && "" === R ? k : null === R ? [...k, encode(E, v)] : [...k, [encode(E, v), "=", encode(R, v)].join("")]
                    }
                }(E)
                  , R = {};
                for (const E of Object.keys(v))
                    shouldFilter(E) || (R[E] = v[E]);
                const U = Object.keys(R);
                return !1 !== E.sort && U.sort(E.sort),
                U.map((R => {
                    const U = v[R];
                    return void 0 === U ? "" : null === U ? encode(R, E) : Array.isArray(U) ? 0 === U.length && "bracket-separator" === E.arrayFormat ? encode(R, E) + "[]" : U.reduce(k(R), []).join("&") : encode(R, E) + "=" + encode(U, E)
                }
                )).filter((v => v.length > 0)).join("&")
            }
            ,
            E.parseUrl = (v, E) => {
                E = Object.assign({
                    "decode": !0
                }, E);
                const [k,R] = H(v, "#");
                return Object.assign({
                    "url": k.split("?")[0] || "",
                    "query": parse(extract(v), E)
                }, E && E.parseFragmentIdentifier && R ? {
                    "fragmentIdentifier": decode(R, E)
                } : {})
            }
            ,
            E.stringifyUrl = (v, k) => {
                k = Object.assign({
                    "encode": !0,
                    "strict": !0,
                    [W]: !0
                }, k);
                const R = removeHash(v.url).split("?")[0] || ""
                  , U = E.extract(v.url)
                  , H = E.parse(U, {
                    "sort": !1
                })
                  , G = Object.assign(H, v.query);
                let Z = E.stringify(G, k);
                Z && (Z = `?${Z}`);
                let Y = function getHash(v) {
                    let E = "";
                    const k = v.indexOf("#");
                    return -1 !== k && (E = v.slice(k)),
                    E
                }(v.url);
                return v.fragmentIdentifier && (Y = `#${k[W] ? encode(v.fragmentIdentifier, k) : v.fragmentIdentifier}`),
                `${R}${Z}${Y}`
            }
            ,
            E.pick = (v, k, R) => {
                R = Object.assign({
                    "parseFragmentIdentifier": !0,
                    [W]: !1
                }, R);
                const {"url": U, "query": H, "fragmentIdentifier": Z} = E.parseUrl(v, R);
                return E.stringifyUrl({
                    "url": U,
                    "query": G(H, k),
                    "fragmentIdentifier": Z
                }, R)
            }
            ,
            E.exclude = (v, k, R) => {
                const U = Array.isArray(k) ? v => !k.includes(v) : (v, E) => !k(v, E);
                return E.pick(v, U, R)
            }
        },
        "8273": function(v, E) {
            "use strict";
            function isAbsolute(v) {
                return "/" === v.charAt(0)
            }
            function spliceOne(v, E) {
                for (var k = E, R = k + 1, U = v.length; R < U; k += 1,
                R += 1)
                    v[k] = v[R];
                v.pop()
            }
            E.Z = function resolvePathname(v, E) {
                void 0 === E && (E = "");
                var k, R = v && v.split("/") || [], U = E && E.split("/") || [], H = v && isAbsolute(v), G = E && isAbsolute(E), W = H || G;
                if (v && isAbsolute(v) ? U = R : R.length && (U.pop(),
                U = U.concat(R)),
                !U.length)
                    return "/";
                if (U.length) {
                    var Z = U[U.length - 1];
                    k = "." === Z || ".." === Z || "" === Z
                } else
                    k = !1;
                for (var Y = 0, J = U.length; J >= 0; J--) {
                    var K = U[J];
                    "." === K ? spliceOne(U, J) : ".." === K ? (spliceOne(U, J),
                    Y++) : Y && (spliceOne(U, J),
                    Y--)
                }
                if (!W)
                    for (; Y--; Y)
                        U.unshift("..");
                !W || "" === U[0] || U[0] && isAbsolute(U[0]) || U.unshift("");
                var X = U.join("/");
                return k && "/" !== X.substr(-1) && (X += "/"),
                X
            }
        },
        "500": function(v) {
            "use strict";
            v.exports = (v, E) => {
                if ("string" != typeof v || "string" != typeof E)
                    throw new TypeError("Expected the arguments to be of type `string`");
                if ("" === E)
                    return [v];
                const k = v.indexOf(E);
                return -1 === k ? [v] : [v.slice(0, k), v.slice(k + E.length)]
            }
        },
        "610": function(v) {
            "use strict";
            v.exports = v => encodeURIComponent(v).replace(/[!'()*]/g, (v => `%${v.charCodeAt(0).toString(16).toUpperCase()}`))
        },
        "9421": function(v, E, k) {
            "use strict";
            function isObject(v) {
                return null !== v && "object" == typeof v && "constructor"in v && v.constructor === Object
            }
            function extend(v, E) {
                void 0 === v && (v = {}),
                void 0 === E && (E = {}),
                Object.keys(E).forEach((function(k) {
                    void 0 === v[k] ? v[k] = E[k] : isObject(E[k]) && isObject(v[k]) && Object.keys(E[k]).length > 0 && extend(v[k], E[k])
                }
                ))
            }
            k.d(E, {
                "Z": function() {
                    return me
                }
            });
            var R = {
                "body": {},
                "addEventListener": function() {},
                "removeEventListener": function() {},
                "activeElement": {
                    "blur": function() {},
                    "nodeName": ""
                },
                "querySelector": function() {
                    return null
                },
                "querySelectorAll": function() {
                    return []
                },
                "getElementById": function() {
                    return null
                },
                "createEvent": function() {
                    return {
                        "initEvent": function() {}
                    }
                },
                "createElement": function() {
                    return {
                        "children": [],
                        "childNodes": [],
                        "style": {},
                        "setAttribute": function() {},
                        "getElementsByTagName": function() {
                            return []
                        }
                    }
                },
                "createElementNS": function() {
                    return {}
                },
                "importNode": function() {
                    return null
                },
                "location": {
                    "hash": "",
                    "host": "",
                    "hostname": "",
                    "href": "",
                    "origin": "",
                    "pathname": "",
                    "protocol": "",
                    "search": ""
                }
            };
            function getDocument() {
                var v = "undefined" != typeof document ? document : {};
                return extend(v, R),
                v
            }
            var U = {
                "document": R,
                "navigator": {
                    "userAgent": ""
                },
                "location": {
                    "hash": "",
                    "host": "",
                    "hostname": "",
                    "href": "",
                    "origin": "",
                    "pathname": "",
                    "protocol": "",
                    "search": ""
                },
                "history": {
                    "replaceState": function() {},
                    "pushState": function() {},
                    "go": function() {},
                    "back": function() {}
                },
                "CustomEvent": function CustomEvent() {
                    return this
                },
                "addEventListener": function() {},
                "removeEventListener": function() {},
                "getComputedStyle": function() {
                    return {
                        "getPropertyValue": function() {
                            return ""
                        }
                    }
                },
                "Image": function() {},
                "Date": function() {},
                "screen": {},
                "setTimeout": function() {},
                "clearTimeout": function() {},
                "matchMedia": function() {
                    return {}
                },
                "requestAnimationFrame": function(v) {
                    return "undefined" == typeof setTimeout ? (v(),
                    null) : setTimeout(v, 0)
                },
                "cancelAnimationFrame": function(v) {
                    "undefined" != typeof setTimeout && clearTimeout(v)
                }
            };
            function ssr_window_esm_getWindow() {
                var v = "undefined" != typeof window ? window : {};
                return extend(v, U),
                v
            }
            function _getPrototypeOf(v) {
                return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(v) {
                    return v.__proto__ || Object.getPrototypeOf(v)
                }
                ,
                _getPrototypeOf(v)
            }
            function _setPrototypeOf(v, E) {
                return _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(v, E) {
                    return v.__proto__ = E,
                    v
                }
                ,
                _setPrototypeOf(v, E)
            }
            function _construct(v, E, k) {
                return _construct = function _isNativeReflectConstruct() {
                    if ("undefined" == typeof Reflect || !Reflect.construct)
                        return !1;
                    if (Reflect.construct.sham)
                        return !1;
                    if ("function" == typeof Proxy)
                        return !0;
                    try {
                        return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}
                        ))),
                        !0
                    } catch (v) {
                        return !1
                    }
                }() ? Reflect.construct : function _construct(v, E, k) {
                    var R = [null];
                    R.push.apply(R, E);
                    var U = new (Function.bind.apply(v, R));
                    return k && _setPrototypeOf(U, k.prototype),
                    U
                }
                ,
                _construct.apply(null, arguments)
            }
            function _wrapNativeSuper(v) {
                var E = "function" == typeof Map ? new Map : void 0;
                return _wrapNativeSuper = function _wrapNativeSuper(v) {
                    if (null === v || !function _isNativeFunction(v) {
                        return -1 !== Function.toString.call(v).indexOf("[native code]")
                    }(v))
                        return v;
                    if ("function" != typeof v)
                        throw new TypeError("Super expression must either be null or a function");
                    if (void 0 !== E) {
                        if (E.has(v))
                            return E.get(v);
                        E.set(v, Wrapper)
                    }
                    function Wrapper() {
                        return _construct(v, arguments, _getPrototypeOf(this).constructor)
                    }
                    return Wrapper.prototype = Object.create(v.prototype, {
                        "constructor": {
                            "value": Wrapper,
                            "enumerable": !1,
                            "writable": !0,
                            "configurable": !0
                        }
                    }),
                    _setPrototypeOf(Wrapper, v)
                }
                ,
                _wrapNativeSuper(v)
            }
            var H = function(v) {
                function Dom7(E) {
                    var k;
                    return function makeReactive(v) {
                        var E = v.__proto__;
                        Object.defineProperty(v, "__proto__", {
                            "get": function get() {
                                return E
                            },
                            "set": function set(v) {
                                E.__proto__ = v
                            }
                        })
                    }(function _assertThisInitialized(v) {
                        if (void 0 === v)
                            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return v
                    }(k = v.call.apply(v, [this].concat(E)) || this)),
                    k
                }
                return function _inheritsLoose(v, E) {
                    v.prototype = Object.create(E.prototype),
                    v.prototype.constructor = v,
                    v.__proto__ = E
                }(Dom7, v),
                Dom7
            }(_wrapNativeSuper(Array));
            function arrayFlat(v) {
                void 0 === v && (v = []);
                var E = [];
                return v.forEach((function(v) {
                    Array.isArray(v) ? E.push.apply(E, arrayFlat(v)) : E.push(v)
                }
                )),
                E
            }
            function arrayFilter(v, E) {
                return Array.prototype.filter.call(v, E)
            }
            function $(v, E) {
                var k = ssr_window_esm_getWindow()
                  , R = getDocument()
                  , U = [];
                if (!E && v instanceof H)
                    return v;
                if (!v)
                    return new H(U);
                if ("string" == typeof v) {
                    var G = v.trim();
                    if (G.indexOf("<") >= 0 && G.indexOf(">") >= 0) {
                        var W = "div";
                        0 === G.indexOf("<li") && (W = "ul"),
                        0 === G.indexOf("<tr") && (W = "tbody"),
                        0 !== G.indexOf("<td") && 0 !== G.indexOf("<th") || (W = "tr"),
                        0 === G.indexOf("<tbody") && (W = "table"),
                        0 === G.indexOf("<option") && (W = "select");
                        var Z = R.createElement(W);
                        Z.innerHTML = G;
                        for (var Y = 0; Y < Z.childNodes.length; Y += 1)
                            U.push(Z.childNodes[Y])
                    } else
                        U = function qsa(v, E) {
                            if ("string" != typeof v)
                                return [v];
                            for (var k = [], R = E.querySelectorAll(v), U = 0; U < R.length; U += 1)
                                k.push(R[U]);
                            return k
                        }(v.trim(), E || R)
                } else if (v.nodeType || v === k || v === R)
                    U.push(v);
                else if (Array.isArray(v)) {
                    if (v instanceof H)
                        return v;
                    U = v
                }
                return new H(function arrayUnique(v) {
                    for (var E = [], k = 0; k < v.length; k += 1)
                        -1 === E.indexOf(v[k]) && E.push(v[k]);
                    return E
                }(U))
            }
            $.fn = H.prototype;
            var G = "resize scroll".split(" ");
            function shortcut(v) {
                return function eventHandler() {
                    for (var E = arguments.length, k = new Array(E), R = 0; R < E; R++)
                        k[R] = arguments[R];
                    if (void 0 === k[0]) {
                        for (var U = 0; U < this.length; U += 1)
                            G.indexOf(v) < 0 && (v in this[U] ? this[U][v]() : $(this[U]).trigger(v));
                        return this
                    }
                    return this.on.apply(this, [v].concat(k))
                }
            }
            shortcut("click"),
            shortcut("blur"),
            shortcut("focus"),
            shortcut("focusin"),
            shortcut("focusout"),
            shortcut("keyup"),
            shortcut("keydown"),
            shortcut("keypress"),
            shortcut("submit"),
            shortcut("change"),
            shortcut("mousedown"),
            shortcut("mousemove"),
            shortcut("mouseup"),
            shortcut("mouseenter"),
            shortcut("mouseleave"),
            shortcut("mouseout"),
            shortcut("mouseover"),
            shortcut("touchstart"),
            shortcut("touchend"),
            shortcut("touchmove"),
            shortcut("resize"),
            shortcut("scroll");
            var W = {
                "addClass": function addClass() {
                    for (var v = arguments.length, E = new Array(v), k = 0; k < v; k++)
                        E[k] = arguments[k];
                    var R = arrayFlat(E.map((function(v) {
                        return v.split(" ")
                    }
                    )));
                    return this.forEach((function(v) {
                        var E;
                        (E = v.classList).add.apply(E, R)
                    }
                    )),
                    this
                },
                "removeClass": function removeClass() {
                    for (var v = arguments.length, E = new Array(v), k = 0; k < v; k++)
                        E[k] = arguments[k];
                    var R = arrayFlat(E.map((function(v) {
                        return v.split(" ")
                    }
                    )));
                    return this.forEach((function(v) {
                        var E;
                        (E = v.classList).remove.apply(E, R)
                    }
                    )),
                    this
                },
                "hasClass": function hasClass() {
                    for (var v = arguments.length, E = new Array(v), k = 0; k < v; k++)
                        E[k] = arguments[k];
                    var R = arrayFlat(E.map((function(v) {
                        return v.split(" ")
                    }
                    )));
                    return arrayFilter(this, (function(v) {
                        return R.filter((function(E) {
                            return v.classList.contains(E)
                        }
                        )).length > 0
                    }
                    )).length > 0
                },
                "toggleClass": function toggleClass() {
                    for (var v = arguments.length, E = new Array(v), k = 0; k < v; k++)
                        E[k] = arguments[k];
                    var R = arrayFlat(E.map((function(v) {
                        return v.split(" ")
                    }
                    )));
                    this.forEach((function(v) {
                        R.forEach((function(E) {
                            v.classList.toggle(E)
                        }
                        ))
                    }
                    ))
                },
                "attr": function attr(v, E) {
                    if (1 === arguments.length && "string" == typeof v)
                        return this[0] ? this[0].getAttribute(v) : void 0;
                    for (var k = 0; k < this.length; k += 1)
                        if (2 === arguments.length)
                            this[k].setAttribute(v, E);
                        else
                            for (var R in v)
                                this[k][R] = v[R],
                                this[k].setAttribute(R, v[R]);
                    return this
                },
                "removeAttr": function removeAttr(v) {
                    for (var E = 0; E < this.length; E += 1)
                        this[E].removeAttribute(v);
                    return this
                },
                "transform": function transform(v) {
                    for (var E = 0; E < this.length; E += 1)
                        this[E].style.transform = v;
                    return this
                },
                "transition": function transition(v) {
                    for (var E = 0; E < this.length; E += 1)
                        this[E].style.transitionDuration = "string" != typeof v ? v + "ms" : v;
                    return this
                },
                "on": function on() {
                    for (var v = arguments.length, E = new Array(v), k = 0; k < v; k++)
                        E[k] = arguments[k];
                    var R = E[0]
                      , U = E[1]
                      , H = E[2]
                      , G = E[3];
                    function handleLiveEvent(v) {
                        var E = v.target;
                        if (E) {
                            var k = v.target.dom7EventData || [];
                            if (k.indexOf(v) < 0 && k.unshift(v),
                            $(E).is(U))
                                H.apply(E, k);
                            else
                                for (var R = $(E).parents(), G = 0; G < R.length; G += 1)
                                    $(R[G]).is(U) && H.apply(R[G], k)
                        }
                    }
                    function handleEvent(v) {
                        var E = v && v.target && v.target.dom7EventData || [];
                        E.indexOf(v) < 0 && E.unshift(v),
                        H.apply(this, E)
                    }
                    "function" == typeof E[1] && (R = E[0],
                    H = E[1],
                    G = E[2],
                    U = void 0),
                    G || (G = !1);
                    for (var W, Z = R.split(" "), Y = 0; Y < this.length; Y += 1) {
                        var J = this[Y];
                        if (U)
                            for (W = 0; W < Z.length; W += 1) {
                                var K = Z[W];
                                J.dom7LiveListeners || (J.dom7LiveListeners = {}),
                                J.dom7LiveListeners[K] || (J.dom7LiveListeners[K] = []),
                                J.dom7LiveListeners[K].push({
                                    "listener": H,
                                    "proxyListener": handleLiveEvent
                                }),
                                J.addEventListener(K, handleLiveEvent, G)
                            }
                        else
                            for (W = 0; W < Z.length; W += 1) {
                                var X = Z[W];
                                J.dom7Listeners || (J.dom7Listeners = {}),
                                J.dom7Listeners[X] || (J.dom7Listeners[X] = []),
                                J.dom7Listeners[X].push({
                                    "listener": H,
                                    "proxyListener": handleEvent
                                }),
                                J.addEventListener(X, handleEvent, G)
                            }
                    }
                    return this
                },
                "off": function off() {
                    for (var v = arguments.length, E = new Array(v), k = 0; k < v; k++)
                        E[k] = arguments[k];
                    var R = E[0]
                      , U = E[1]
                      , H = E[2]
                      , G = E[3];
                    "function" == typeof E[1] && (R = E[0],
                    H = E[1],
                    G = E[2],
                    U = void 0),
                    G || (G = !1);
                    for (var W = R.split(" "), Z = 0; Z < W.length; Z += 1)
                        for (var Y = W[Z], J = 0; J < this.length; J += 1) {
                            var K = this[J]
                              , X = void 0;
                            if (!U && K.dom7Listeners ? X = K.dom7Listeners[Y] : U && K.dom7LiveListeners && (X = K.dom7LiveListeners[Y]),
                            X && X.length)
                                for (var Q = X.length - 1; Q >= 0; Q -= 1) {
                                    var ee = X[Q];
                                    H && ee.listener === H || H && ee.listener && ee.listener.dom7proxy && ee.listener.dom7proxy === H ? (K.removeEventListener(Y, ee.proxyListener, G),
                                    X.splice(Q, 1)) : H || (K.removeEventListener(Y, ee.proxyListener, G),
                                    X.splice(Q, 1))
                                }
                        }
                    return this
                },
                "trigger": function trigger() {
                    for (var v = ssr_window_esm_getWindow(), E = arguments.length, k = new Array(E), R = 0; R < E; R++)
                        k[R] = arguments[R];
                    for (var U = k[0].split(" "), H = k[1], G = 0; G < U.length; G += 1)
                        for (var W = U[G], Z = 0; Z < this.length; Z += 1) {
                            var Y = this[Z];
                            if (v.CustomEvent) {
                                var J = new v.CustomEvent(W,{
                                    "detail": H,
                                    "bubbles": !0,
                                    "cancelable": !0
                                });
                                Y.dom7EventData = k.filter((function(v, E) {
                                    return E > 0
                                }
                                )),
                                Y.dispatchEvent(J),
                                Y.dom7EventData = [],
                                delete Y.dom7EventData
                            }
                        }
                    return this
                },
                "transitionEnd": function transitionEnd(v) {
                    var E = this;
                    return v && E.on("transitionend", (function fireCallBack(k) {
                        k.target === this && (v.call(this, k),
                        E.off("transitionend", fireCallBack))
                    }
                    )),
                    this
                },
                "outerWidth": function dom7_esm_outerWidth(v) {
                    if (this.length > 0) {
                        if (v) {
                            var E = this.styles();
                            return this[0].offsetWidth + parseFloat(E.getPropertyValue("margin-right")) + parseFloat(E.getPropertyValue("margin-left"))
                        }
                        return this[0].offsetWidth
                    }
                    return null
                },
                "outerHeight": function dom7_esm_outerHeight(v) {
                    if (this.length > 0) {
                        if (v) {
                            var E = this.styles();
                            return this[0].offsetHeight + parseFloat(E.getPropertyValue("margin-top")) + parseFloat(E.getPropertyValue("margin-bottom"))
                        }
                        return this[0].offsetHeight
                    }
                    return null
                },
                "styles": function styles() {
                    var v = ssr_window_esm_getWindow();
                    return this[0] ? v.getComputedStyle(this[0], null) : {}
                },
                "offset": function offset() {
                    if (this.length > 0) {
                        var v = ssr_window_esm_getWindow()
                          , E = getDocument()
                          , k = this[0]
                          , R = k.getBoundingClientRect()
                          , U = E.body
                          , H = k.clientTop || U.clientTop || 0
                          , G = k.clientLeft || U.clientLeft || 0
                          , W = k === v ? v.scrollY : k.scrollTop
                          , Z = k === v ? v.scrollX : k.scrollLeft;
                        return {
                            "top": R.top + W - H,
                            "left": R.left + Z - G
                        }
                    }
                    return null
                },
                "css": function css(v, E) {
                    var k, R = ssr_window_esm_getWindow();
                    if (1 === arguments.length) {
                        if ("string" != typeof v) {
                            for (k = 0; k < this.length; k += 1)
                                for (var U in v)
                                    this[k].style[U] = v[U];
                            return this
                        }
                        if (this[0])
                            return R.getComputedStyle(this[0], null).getPropertyValue(v)
                    }
                    if (2 === arguments.length && "string" == typeof v) {
                        for (k = 0; k < this.length; k += 1)
                            this[k].style[v] = E;
                        return this
                    }
                    return this
                },
                "each": function each(v) {
                    return v ? (this.forEach((function(E, k) {
                        v.apply(E, [E, k])
                    }
                    )),
                    this) : this
                },
                "html": function html(v) {
                    if (void 0 === v)
                        return this[0] ? this[0].innerHTML : null;
                    for (var E = 0; E < this.length; E += 1)
                        this[E].innerHTML = v;
                    return this
                },
                "text": function dom7_esm_text(v) {
                    if (void 0 === v)
                        return this[0] ? this[0].textContent.trim() : null;
                    for (var E = 0; E < this.length; E += 1)
                        this[E].textContent = v;
                    return this
                },
                "is": function is(v) {
                    var E, k, R = ssr_window_esm_getWindow(), U = getDocument(), G = this[0];
                    if (!G || void 0 === v)
                        return !1;
                    if ("string" == typeof v) {
                        if (G.matches)
                            return G.matches(v);
                        if (G.webkitMatchesSelector)
                            return G.webkitMatchesSelector(v);
                        if (G.msMatchesSelector)
                            return G.msMatchesSelector(v);
                        for (E = $(v),
                        k = 0; k < E.length; k += 1)
                            if (E[k] === G)
                                return !0;
                        return !1
                    }
                    if (v === U)
                        return G === U;
                    if (v === R)
                        return G === R;
                    if (v.nodeType || v instanceof H) {
                        for (E = v.nodeType ? [v] : v,
                        k = 0; k < E.length; k += 1)
                            if (E[k] === G)
                                return !0;
                        return !1
                    }
                    return !1
                },
                "index": function index() {
                    var v, E = this[0];
                    if (E) {
                        for (v = 0; null !== (E = E.previousSibling); )
                            1 === E.nodeType && (v += 1);
                        return v
                    }
                },
                "eq": function eq(v) {
                    if (void 0 === v)
                        return this;
                    var E = this.length;
                    if (v > E - 1)
                        return $([]);
                    if (v < 0) {
                        var k = E + v;
                        return $(k < 0 ? [] : [this[k]])
                    }
                    return $([this[v]])
                },
                "append": function append() {
                    for (var v, E = getDocument(), k = 0; k < arguments.length; k += 1) {
                        v = k < 0 || arguments.length <= k ? void 0 : arguments[k];
                        for (var R = 0; R < this.length; R += 1)
                            if ("string" == typeof v) {
                                var U = E.createElement("div");
                                for (U.innerHTML = v; U.firstChild; )
                                    this[R].appendChild(U.firstChild)
                            } else if (v instanceof H)
                                for (var G = 0; G < v.length; G += 1)
                                    this[R].appendChild(v[G]);
                            else
                                this[R].appendChild(v)
                    }
                    return this
                },
                "prepend": function prepend(v) {
                    var E, k, R = getDocument();
                    for (E = 0; E < this.length; E += 1)
                        if ("string" == typeof v) {
                            var U = R.createElement("div");
                            for (U.innerHTML = v,
                            k = U.childNodes.length - 1; k >= 0; k -= 1)
                                this[E].insertBefore(U.childNodes[k], this[E].childNodes[0])
                        } else if (v instanceof H)
                            for (k = 0; k < v.length; k += 1)
                                this[E].insertBefore(v[k], this[E].childNodes[0]);
                        else
                            this[E].insertBefore(v, this[E].childNodes[0]);
                    return this
                },
                "next": function next(v) {
                    return this.length > 0 ? v ? this[0].nextElementSibling && $(this[0].nextElementSibling).is(v) ? $([this[0].nextElementSibling]) : $([]) : this[0].nextElementSibling ? $([this[0].nextElementSibling]) : $([]) : $([])
                },
                "nextAll": function nextAll(v) {
                    var E = []
                      , k = this[0];
                    if (!k)
                        return $([]);
                    for (; k.nextElementSibling; ) {
                        var R = k.nextElementSibling;
                        v ? $(R).is(v) && E.push(R) : E.push(R),
                        k = R
                    }
                    return $(E)
                },
                "prev": function prev(v) {
                    if (this.length > 0) {
                        var E = this[0];
                        return v ? E.previousElementSibling && $(E.previousElementSibling).is(v) ? $([E.previousElementSibling]) : $([]) : E.previousElementSibling ? $([E.previousElementSibling]) : $([])
                    }
                    return $([])
                },
                "prevAll": function prevAll(v) {
                    var E = []
                      , k = this[0];
                    if (!k)
                        return $([]);
                    for (; k.previousElementSibling; ) {
                        var R = k.previousElementSibling;
                        v ? $(R).is(v) && E.push(R) : E.push(R),
                        k = R
                    }
                    return $(E)
                },
                "parent": function dom7_esm_parent(v) {
                    for (var E = [], k = 0; k < this.length; k += 1)
                        null !== this[k].parentNode && (v ? $(this[k].parentNode).is(v) && E.push(this[k].parentNode) : E.push(this[k].parentNode));
                    return $(E)
                },
                "parents": function parents(v) {
                    for (var E = [], k = 0; k < this.length; k += 1)
                        for (var R = this[k].parentNode; R; )
                            v ? $(R).is(v) && E.push(R) : E.push(R),
                            R = R.parentNode;
                    return $(E)
                },
                "closest": function closest(v) {
                    var E = this;
                    return void 0 === v ? $([]) : (E.is(v) || (E = E.parents(v).eq(0)),
                    E)
                },
                "find": function find(v) {
                    for (var E = [], k = 0; k < this.length; k += 1)
                        for (var R = this[k].querySelectorAll(v), U = 0; U < R.length; U += 1)
                            E.push(R[U]);
                    return $(E)
                },
                "children": function children(v) {
                    for (var E = [], k = 0; k < this.length; k += 1)
                        for (var R = this[k].children, U = 0; U < R.length; U += 1)
                            v && !$(R[U]).is(v) || E.push(R[U]);
                    return $(E)
                },
                "filter": function filter(v) {
                    return $(arrayFilter(this, v))
                },
                "remove": function remove() {
                    for (var v = 0; v < this.length; v += 1)
                        this[v].parentNode && this[v].parentNode.removeChild(this[v]);
                    return this
                }
            };
            Object.keys(W).forEach((function(v) {
                Object.defineProperty($.fn, v, {
                    "value": W[v],
                    "writable": !0
                })
            }
            ));
            var Z, Y, J, K = $;
            function nextTick(v, E) {
                return void 0 === E && (E = 0),
                setTimeout(v, E)
            }
            function now() {
                return Date.now()
            }
            function getTranslate(v, E) {
                void 0 === E && (E = "x");
                var k, R, U, H = ssr_window_esm_getWindow(), G = function utils_getComputedStyle(v) {
                    var E, k = ssr_window_esm_getWindow();
                    return k.getComputedStyle && (E = k.getComputedStyle(v, null)),
                    !E && v.currentStyle && (E = v.currentStyle),
                    E || (E = v.style),
                    E
                }(v);
                return H.WebKitCSSMatrix ? ((R = G.transform || G.webkitTransform).split(",").length > 6 && (R = R.split(", ").map((function(v) {
                    return v.replace(",", ".")
                }
                )).join(", ")),
                U = new H.WebKitCSSMatrix("none" === R ? "" : R)) : k = (U = G.MozTransform || G.OTransform || G.MsTransform || G.msTransform || G.transform || G.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,")).toString().split(","),
                "x" === E && (R = H.WebKitCSSMatrix ? U.m41 : 16 === k.length ? parseFloat(k[12]) : parseFloat(k[4])),
                "y" === E && (R = H.WebKitCSSMatrix ? U.m42 : 16 === k.length ? parseFloat(k[13]) : parseFloat(k[5])),
                R || 0
            }
            function utils_isObject(v) {
                return "object" == typeof v && null !== v && v.constructor && "Object" === Object.prototype.toString.call(v).slice(8, -1)
            }
            function utils_extend() {
                for (var v, E = Object(arguments.length <= 0 ? void 0 : arguments[0]), k = ["__proto__", "constructor", "prototype"], R = 1; R < arguments.length; R += 1) {
                    var U = R < 0 || arguments.length <= R ? void 0 : arguments[R];
                    if (null != U && (v = U,
                    !("undefined" != typeof window ? v instanceof HTMLElement : v && (1 === v.nodeType || 11 === v.nodeType))))
                        for (var H = Object.keys(Object(U)).filter((function(v) {
                            return k.indexOf(v) < 0
                        }
                        )), G = 0, W = H.length; G < W; G += 1) {
                            var Z = H[G]
                              , Y = Object.getOwnPropertyDescriptor(U, Z);
                            void 0 !== Y && Y.enumerable && (utils_isObject(E[Z]) && utils_isObject(U[Z]) ? U[Z].__swiper__ ? E[Z] = U[Z] : utils_extend(E[Z], U[Z]) : !utils_isObject(E[Z]) && utils_isObject(U[Z]) ? (E[Z] = {},
                            U[Z].__swiper__ ? E[Z] = U[Z] : utils_extend(E[Z], U[Z])) : E[Z] = U[Z])
                        }
                }
                return E
            }
            function bindModuleMethods(v, E) {
                Object.keys(E).forEach((function(k) {
                    utils_isObject(E[k]) && Object.keys(E[k]).forEach((function(R) {
                        "function" == typeof E[k][R] && (E[k][R] = E[k][R].bind(v))
                    }
                    )),
                    v[k] = E[k]
                }
                ))
            }
            function classesToSelector(v) {
                return void 0 === v && (v = ""),
                "." + v.trim().replace(/([\.:\/])/g, "\\$1").replace(/ /g, ".")
            }
            function createElementIfNotDefined(v, E, k, R) {
                var U = getDocument();
                return k && Object.keys(R).forEach((function(k) {
                    if (!E[k] && !0 === E.auto) {
                        var H = U.createElement("div");
                        H.className = R[k],
                        v.append(H),
                        E[k] = H
                    }
                }
                )),
                E
            }
            function getSupport() {
                return Z || (Z = function calcSupport() {
                    var v = ssr_window_esm_getWindow()
                      , E = getDocument();
                    return {
                        "touch": !!("ontouchstart"in v || v.DocumentTouch && E instanceof v.DocumentTouch),
                        "pointerEvents": !!v.PointerEvent && "maxTouchPoints"in v.navigator && v.navigator.maxTouchPoints >= 0,
                        "observer": function checkObserver() {
                            return "MutationObserver"in v || "WebkitMutationObserver"in v
                        }(),
                        "passiveListener": function checkPassiveListener() {
                            var E = !1;
                            try {
                                var k = Object.defineProperty({}, "passive", {
                                    "get": function get() {
                                        E = !0
                                    }
                                });
                                v.addEventListener("testPassiveListener", null, k)
                            } catch (v) {}
                            return E
                        }(),
                        "gestures": function checkGestures() {
                            return "ongesturestart"in v
                        }()
                    }
                }()),
                Z
            }
            function getDevice(v) {
                return void 0 === v && (v = {}),
                Y || (Y = function calcDevice(v) {
                    var E = (void 0 === v ? {} : v).userAgent
                      , k = getSupport()
                      , R = ssr_window_esm_getWindow()
                      , U = R.navigator.platform
                      , H = E || R.navigator.userAgent
                      , G = {
                        "ios": !1,
                        "android": !1
                    }
                      , W = R.screen.width
                      , Z = R.screen.height
                      , Y = H.match(/(Android);?[\s\/]+([\d.]+)?/)
                      , J = H.match(/(iPad).*OS\s([\d_]+)/)
                      , K = H.match(/(iPod)(.*OS\s([\d_]+))?/)
                      , X = !J && H.match(/(iPhone\sOS|iOS)\s([\d_]+)/)
                      , Q = "Win32" === U
                      , ee = "MacIntel" === U;
                    return !J && ee && k.touch && ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf(W + "x" + Z) >= 0 && ((J = H.match(/(Version)\/([\d.]+)/)) || (J = [0, 1, "13_0_0"]),
                    ee = !1),
                    Y && !Q && (G.os = "android",
                    G.android = !0),
                    (J || X || K) && (G.os = "ios",
                    G.ios = !0),
                    G
                }(v)),
                Y
            }
            function getBrowser() {
                return J || (J = function calcBrowser() {
                    var v = ssr_window_esm_getWindow();
                    return {
                        "isEdge": !!v.navigator.userAgent.match(/Edge/g),
                        "isSafari": function isSafari() {
                            var E = v.navigator.userAgent.toLowerCase();
                            return E.indexOf("safari") >= 0 && E.indexOf("chrome") < 0 && E.indexOf("android") < 0
                        }(),
                        "isWebView": /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(v.navigator.userAgent)
                    }
                }()),
                J
            }
            var X = {
                "name": "resize",
                "create": function create() {
                    var v = this;
                    utils_extend(v, {
                        "resize": {
                            "observer": null,
                            "createObserver": function createObserver() {
                                v && !v.destroyed && v.initialized && (v.resize.observer = new ResizeObserver((function(E) {
                                    var k = v.width
                                      , R = v.height
                                      , U = k
                                      , H = R;
                                    E.forEach((function(E) {
                                        var k = E.contentBoxSize
                                          , R = E.contentRect
                                          , G = E.target;
                                        G && G !== v.el || (U = R ? R.width : (k[0] || k).inlineSize,
                                        H = R ? R.height : (k[0] || k).blockSize)
                                    }
                                    )),
                                    U === k && H === R || v.resize.resizeHandler()
                                }
                                )),
                                v.resize.observer.observe(v.el))
                            },
                            "removeObserver": function removeObserver() {
                                v.resize.observer && v.resize.observer.unobserve && v.el && (v.resize.observer.unobserve(v.el),
                                v.resize.observer = null)
                            },
                            "resizeHandler": function resizeHandler() {
                                v && !v.destroyed && v.initialized && (v.emit("beforeResize"),
                                v.emit("resize"))
                            },
                            "orientationChangeHandler": function orientationChangeHandler() {
                                v && !v.destroyed && v.initialized && v.emit("orientationchange")
                            }
                        }
                    })
                },
                "on": {
                    "init": function init(v) {
                        var E = ssr_window_esm_getWindow();
                        v.params.resizeObserver && function supportsResizeObserver() {
                            return void 0 !== ssr_window_esm_getWindow().ResizeObserver
                        }() ? v.resize.createObserver() : (E.addEventListener("resize", v.resize.resizeHandler),
                        E.addEventListener("orientationchange", v.resize.orientationChangeHandler))
                    },
                    "destroy": function destroy(v) {
                        var E = ssr_window_esm_getWindow();
                        v.resize.removeObserver(),
                        E.removeEventListener("resize", v.resize.resizeHandler),
                        E.removeEventListener("orientationchange", v.resize.orientationChangeHandler)
                    }
                }
            };
            function _extends() {
                return _extends = Object.assign || function(v) {
                    for (var E = 1; E < arguments.length; E++) {
                        var k = arguments[E];
                        for (var R in k)
                            Object.prototype.hasOwnProperty.call(k, R) && (v[R] = k[R])
                    }
                    return v
                }
                ,
                _extends.apply(this, arguments)
            }
            var Q = {
                "attach": function attach(v, E) {
                    void 0 === E && (E = {});
                    var k = ssr_window_esm_getWindow()
                      , R = this
                      , U = new (k.MutationObserver || k.WebkitMutationObserver)((function(v) {
                        if (1 !== v.length) {
                            var E = function observerUpdate() {
                                R.emit("observerUpdate", v[0])
                            };
                            k.requestAnimationFrame ? k.requestAnimationFrame(E) : k.setTimeout(E, 0)
                        } else
                            R.emit("observerUpdate", v[0])
                    }
                    ));
                    U.observe(v, {
                        "attributes": void 0 === E.attributes || E.attributes,
                        "childList": void 0 === E.childList || E.childList,
                        "characterData": void 0 === E.characterData || E.characterData
                    }),
                    R.observer.observers.push(U)
                },
                "init": function init() {
                    var v = this;
                    if (v.support.observer && v.params.observer) {
                        if (v.params.observeParents)
                            for (var E = v.$el.parents(), k = 0; k < E.length; k += 1)
                                v.observer.attach(E[k]);
                        v.observer.attach(v.$el[0], {
                            "childList": v.params.observeSlideChildren
                        }),
                        v.observer.attach(v.$wrapperEl[0], {
                            "attributes": !1
                        })
                    }
                },
                "destroy": function destroy() {
                    this.observer.observers.forEach((function(v) {
                        v.disconnect()
                    }
                    )),
                    this.observer.observers = []
                }
            }
              , ee = {
                "name": "observer",
                "params": {
                    "observer": !1,
                    "observeParents": !1,
                    "observeSlideChildren": !1
                },
                "create": function create() {
                    bindModuleMethods(this, {
                        "observer": _extends({}, Q, {
                            "observers": []
                        })
                    })
                },
                "on": {
                    "init": function init(v) {
                        v.observer.init()
                    },
                    "destroy": function destroy(v) {
                        v.observer.destroy()
                    }
                }
            }
              , te = {
                "on": function on(v, E, k) {
                    var R = this;
                    if ("function" != typeof E)
                        return R;
                    var U = k ? "unshift" : "push";
                    return v.split(" ").forEach((function(v) {
                        R.eventsListeners[v] || (R.eventsListeners[v] = []),
                        R.eventsListeners[v][U](E)
                    }
                    )),
                    R
                },
                "once": function once(v, E, k) {
                    var R = this;
                    if ("function" != typeof E)
                        return R;
                    function onceHandler() {
                        R.off(v, onceHandler),
                        onceHandler.__emitterProxy && delete onceHandler.__emitterProxy;
                        for (var k = arguments.length, U = new Array(k), H = 0; H < k; H++)
                            U[H] = arguments[H];
                        E.apply(R, U)
                    }
                    return onceHandler.__emitterProxy = E,
                    R.on(v, onceHandler, k)
                },
                "onAny": function onAny(v, E) {
                    var k = this;
                    if ("function" != typeof v)
                        return k;
                    var R = E ? "unshift" : "push";
                    return k.eventsAnyListeners.indexOf(v) < 0 && k.eventsAnyListeners[R](v),
                    k
                },
                "offAny": function offAny(v) {
                    var E = this;
                    if (!E.eventsAnyListeners)
                        return E;
                    var k = E.eventsAnyListeners.indexOf(v);
                    return k >= 0 && E.eventsAnyListeners.splice(k, 1),
                    E
                },
                "off": function off(v, E) {
                    var k = this;
                    return k.eventsListeners ? (v.split(" ").forEach((function(v) {
                        void 0 === E ? k.eventsListeners[v] = [] : k.eventsListeners[v] && k.eventsListeners[v].forEach((function(R, U) {
                            (R === E || R.__emitterProxy && R.__emitterProxy === E) && k.eventsListeners[v].splice(U, 1)
                        }
                        ))
                    }
                    )),
                    k) : k
                },
                "emit": function emit() {
                    var v, E, k, R = this;
                    if (!R.eventsListeners)
                        return R;
                    for (var U = arguments.length, H = new Array(U), G = 0; G < U; G++)
                        H[G] = arguments[G];
                    return "string" == typeof H[0] || Array.isArray(H[0]) ? (v = H[0],
                    E = H.slice(1, H.length),
                    k = R) : (v = H[0].events,
                    E = H[0].data,
                    k = H[0].context || R),
                    E.unshift(k),
                    (Array.isArray(v) ? v : v.split(" ")).forEach((function(v) {
                        R.eventsAnyListeners && R.eventsAnyListeners.length && R.eventsAnyListeners.forEach((function(R) {
                            R.apply(k, [v].concat(E))
                        }
                        )),
                        R.eventsListeners && R.eventsListeners[v] && R.eventsListeners[v].forEach((function(v) {
                            v.apply(k, E)
                        }
                        ))
                    }
                    )),
                    R
                }
            };
            var ne = {
                "updateSize": function updateSize() {
                    var v, E, k = this, R = k.$el;
                    v = void 0 !== k.params.width && null !== k.params.width ? k.params.width : R[0].clientWidth,
                    E = void 0 !== k.params.height && null !== k.params.height ? k.params.height : R[0].clientHeight,
                    0 === v && k.isHorizontal() || 0 === E && k.isVertical() || (v = v - parseInt(R.css("padding-left") || 0, 10) - parseInt(R.css("padding-right") || 0, 10),
                    E = E - parseInt(R.css("padding-top") || 0, 10) - parseInt(R.css("padding-bottom") || 0, 10),
                    Number.isNaN(v) && (v = 0),
                    Number.isNaN(E) && (E = 0),
                    utils_extend(k, {
                        "width": v,
                        "height": E,
                        "size": k.isHorizontal() ? v : E
                    }))
                },
                "updateSlides": function updateSlides() {
                    var v = this;
                    function getDirectionLabel(E) {
                        return v.isHorizontal() ? E : {
                            "width": "height",
                            "margin-top": "margin-left",
                            "margin-bottom ": "margin-right",
                            "margin-left": "margin-top",
                            "margin-right": "margin-bottom",
                            "padding-left": "padding-top",
                            "padding-right": "padding-bottom",
                            "marginRight": "marginBottom"
                        }[E]
                    }
                    function getDirectionPropertyValue(v, E) {
                        return parseFloat(v.getPropertyValue(getDirectionLabel(E)) || 0)
                    }
                    var E = v.params
                      , k = v.$wrapperEl
                      , R = v.size
                      , U = v.rtlTranslate
                      , H = v.wrongRTL
                      , G = v.virtual && E.virtual.enabled
                      , W = G ? v.virtual.slides.length : v.slides.length
                      , Z = k.children("." + v.params.slideClass)
                      , Y = G ? v.virtual.slides.length : Z.length
                      , J = []
                      , K = []
                      , X = []
                      , Q = E.slidesOffsetBefore;
                    "function" == typeof Q && (Q = E.slidesOffsetBefore.call(v));
                    var ee = E.slidesOffsetAfter;
                    "function" == typeof ee && (ee = E.slidesOffsetAfter.call(v));
                    var te = v.snapGrid.length
                      , ne = v.slidesGrid.length
                      , re = E.spaceBetween
                      , oe = -Q
                      , ie = 0
                      , ae = 0;
                    if (void 0 !== R) {
                        var se, ce;
                        "string" == typeof re && re.indexOf("%") >= 0 && (re = parseFloat(re.replace("%", "")) / 100 * R),
                        v.virtualSize = -re,
                        U ? Z.css({
                            "marginLeft": "",
                            "marginTop": ""
                        }) : Z.css({
                            "marginRight": "",
                            "marginBottom": ""
                        }),
                        E.slidesPerColumn > 1 && (se = Math.floor(Y / E.slidesPerColumn) === Y / v.params.slidesPerColumn ? Y : Math.ceil(Y / E.slidesPerColumn) * E.slidesPerColumn,
                        "auto" !== E.slidesPerView && "row" === E.slidesPerColumnFill && (se = Math.max(se, E.slidesPerView * E.slidesPerColumn)));
                        for (var le, ue, de, pe = E.slidesPerColumn, fe = se / pe, he = Math.floor(Y / E.slidesPerColumn), me = 0; me < Y; me += 1) {
                            ce = 0;
                            var ge = Z.eq(me);
                            if (E.slidesPerColumn > 1) {
                                var _e = void 0
                                  , ve = void 0
                                  , ye = void 0;
                                if ("row" === E.slidesPerColumnFill && E.slidesPerGroup > 1) {
                                    var be = Math.floor(me / (E.slidesPerGroup * E.slidesPerColumn))
                                      , Se = me - E.slidesPerColumn * E.slidesPerGroup * be
                                      , we = 0 === be ? E.slidesPerGroup : Math.min(Math.ceil((Y - be * pe * E.slidesPerGroup) / pe), E.slidesPerGroup);
                                    _e = (ve = Se - (ye = Math.floor(Se / we)) * we + be * E.slidesPerGroup) + ye * se / pe,
                                    ge.css({
                                        "-webkit-box-ordinal-group": _e,
                                        "-moz-box-ordinal-group": _e,
                                        "-ms-flex-order": _e,
                                        "-webkit-order": _e,
                                        "order": _e
                                    })
                                } else
                                    "column" === E.slidesPerColumnFill ? (ye = me - (ve = Math.floor(me / pe)) * pe,
                                    (ve > he || ve === he && ye === pe - 1) && (ye += 1) >= pe && (ye = 0,
                                    ve += 1)) : ve = me - (ye = Math.floor(me / fe)) * fe;
                                ge.css(getDirectionLabel("margin-top"), 0 !== ye ? E.spaceBetween && E.spaceBetween + "px" : "")
                            }
                            if ("none" !== ge.css("display")) {
                                if ("auto" === E.slidesPerView) {
                                    var Ee = getComputedStyle(ge[0])
                                      , Ce = ge[0].style.transform
                                      , Te = ge[0].style.webkitTransform;
                                    if (Ce && (ge[0].style.transform = "none"),
                                    Te && (ge[0].style.webkitTransform = "none"),
                                    E.roundLengths)
                                        ce = v.isHorizontal() ? ge.outerWidth(!0) : ge.outerHeight(!0);
                                    else {
                                        var xe = getDirectionPropertyValue(Ee, "width")
                                          , Ae = getDirectionPropertyValue(Ee, "padding-left")
                                          , Ie = getDirectionPropertyValue(Ee, "padding-right")
                                          , ke = getDirectionPropertyValue(Ee, "margin-left")
                                          , Oe = getDirectionPropertyValue(Ee, "margin-right")
                                          , Pe = Ee.getPropertyValue("box-sizing");
                                        if (Pe && "border-box" === Pe)
                                            ce = xe + ke + Oe;
                                        else {
                                            var Re = ge[0]
                                              , Me = Re.clientWidth;
                                            ce = xe + Ae + Ie + ke + Oe + (Re.offsetWidth - Me)
                                        }
                                    }
                                    Ce && (ge[0].style.transform = Ce),
                                    Te && (ge[0].style.webkitTransform = Te),
                                    E.roundLengths && (ce = Math.floor(ce))
                                } else
                                    ce = (R - (E.slidesPerView - 1) * re) / E.slidesPerView,
                                    E.roundLengths && (ce = Math.floor(ce)),
                                    Z[me] && (Z[me].style[getDirectionLabel("width")] = ce + "px");
                                Z[me] && (Z[me].swiperSlideSize = ce),
                                X.push(ce),
                                E.centeredSlides ? (oe = oe + ce / 2 + ie / 2 + re,
                                0 === ie && 0 !== me && (oe = oe - R / 2 - re),
                                0 === me && (oe = oe - R / 2 - re),
                                Math.abs(oe) < .001 && (oe = 0),
                                E.roundLengths && (oe = Math.floor(oe)),
                                ae % E.slidesPerGroup == 0 && J.push(oe),
                                K.push(oe)) : (E.roundLengths && (oe = Math.floor(oe)),
                                (ae - Math.min(v.params.slidesPerGroupSkip, ae)) % v.params.slidesPerGroup == 0 && J.push(oe),
                                K.push(oe),
                                oe = oe + ce + re),
                                v.virtualSize += ce + re,
                                ie = ce,
                                ae += 1
                            }
                        }
                        if (v.virtualSize = Math.max(v.virtualSize, R) + ee,
                        U && H && ("slide" === E.effect || "coverflow" === E.effect) && k.css({
                            "width": v.virtualSize + E.spaceBetween + "px"
                        }),
                        E.setWrapperSize)
                            k.css(((ue = {})[getDirectionLabel("width")] = v.virtualSize + E.spaceBetween + "px",
                            ue));
                        if (E.slidesPerColumn > 1)
                            if (v.virtualSize = (ce + E.spaceBetween) * se,
                            v.virtualSize = Math.ceil(v.virtualSize / E.slidesPerColumn) - E.spaceBetween,
                            k.css(((de = {})[getDirectionLabel("width")] = v.virtualSize + E.spaceBetween + "px",
                            de)),
                            E.centeredSlides) {
                                le = [];
                                for (var Ne = 0; Ne < J.length; Ne += 1) {
                                    var De = J[Ne];
                                    E.roundLengths && (De = Math.floor(De)),
                                    J[Ne] < v.virtualSize + J[0] && le.push(De)
                                }
                                J = le
                            }
                        if (!E.centeredSlides) {
                            le = [];
                            for (var $e = 0; $e < J.length; $e += 1) {
                                var Le = J[$e];
                                E.roundLengths && (Le = Math.floor(Le)),
                                J[$e] <= v.virtualSize - R && le.push(Le)
                            }
                            J = le,
                            Math.floor(v.virtualSize - R) - Math.floor(J[J.length - 1]) > 1 && J.push(v.virtualSize - R)
                        }
                        if (0 === J.length && (J = [0]),
                        0 !== E.spaceBetween) {
                            var Fe, je = v.isHorizontal() && U ? "marginLeft" : getDirectionLabel("marginRight");
                            Z.filter((function(v, k) {
                                return !E.cssMode || k !== Z.length - 1
                            }
                            )).css(((Fe = {})[je] = re + "px",
                            Fe))
                        }
                        if (E.centeredSlides && E.centeredSlidesBounds) {
                            var Be = 0;
                            X.forEach((function(v) {
                                Be += v + (E.spaceBetween ? E.spaceBetween : 0)
                            }
                            ));
                            var Ue = (Be -= E.spaceBetween) - R;
                            J = J.map((function(v) {
                                return v < 0 ? -Q : v > Ue ? Ue + ee : v
                            }
                            ))
                        }
                        if (E.centerInsufficientSlides) {
                            var He = 0;
                            if (X.forEach((function(v) {
                                He += v + (E.spaceBetween ? E.spaceBetween : 0)
                            }
                            )),
                            (He -= E.spaceBetween) < R) {
                                var ze = (R - He) / 2;
                                J.forEach((function(v, E) {
                                    J[E] = v - ze
                                }
                                )),
                                K.forEach((function(v, E) {
                                    K[E] = v + ze
                                }
                                ))
                            }
                        }
                        utils_extend(v, {
                            "slides": Z,
                            "snapGrid": J,
                            "slidesGrid": K,
                            "slidesSizesGrid": X
                        }),
                        Y !== W && v.emit("slidesLengthChange"),
                        J.length !== te && (v.params.watchOverflow && v.checkOverflow(),
                        v.emit("snapGridLengthChange")),
                        K.length !== ne && v.emit("slidesGridLengthChange"),
                        (E.watchSlidesProgress || E.watchSlidesVisibility) && v.updateSlidesOffset()
                    }
                },
                "updateAutoHeight": function updateAutoHeight(v) {
                    var E, k = this, R = [], U = k.virtual && k.params.virtual.enabled, H = 0;
                    "number" == typeof v ? k.setTransition(v) : !0 === v && k.setTransition(k.params.speed);
                    var G = function getSlideByIndex(v) {
                        return U ? k.slides.filter((function(E) {
                            return parseInt(E.getAttribute("data-swiper-slide-index"), 10) === v
                        }
                        ))[0] : k.slides.eq(v)[0]
                    };
                    if ("auto" !== k.params.slidesPerView && k.params.slidesPerView > 1)
                        if (k.params.centeredSlides)
                            k.visibleSlides.each((function(v) {
                                R.push(v)
                            }
                            ));
                        else
                            for (E = 0; E < Math.ceil(k.params.slidesPerView); E += 1) {
                                var W = k.activeIndex + E;
                                if (W > k.slides.length && !U)
                                    break;
                                R.push(G(W))
                            }
                    else
                        R.push(G(k.activeIndex));
                    for (E = 0; E < R.length; E += 1)
                        if (void 0 !== R[E]) {
                            var Z = R[E].offsetHeight;
                            H = Z > H ? Z : H
                        }
                    H && k.$wrapperEl.css("height", H + "px")
                },
                "updateSlidesOffset": function updateSlidesOffset() {
                    for (var v = this.slides, E = 0; E < v.length; E += 1)
                        v[E].swiperSlideOffset = this.isHorizontal() ? v[E].offsetLeft : v[E].offsetTop
                },
                "updateSlidesProgress": function updateSlidesProgress(v) {
                    void 0 === v && (v = this && this.translate || 0);
                    var E = this
                      , k = E.params
                      , R = E.slides
                      , U = E.rtlTranslate;
                    if (0 !== R.length) {
                        void 0 === R[0].swiperSlideOffset && E.updateSlidesOffset();
                        var H = -v;
                        U && (H = v),
                        R.removeClass(k.slideVisibleClass),
                        E.visibleSlidesIndexes = [],
                        E.visibleSlides = [];
                        for (var G = 0; G < R.length; G += 1) {
                            var W = R[G]
                              , Z = (H + (k.centeredSlides ? E.minTranslate() : 0) - W.swiperSlideOffset) / (W.swiperSlideSize + k.spaceBetween);
                            if (k.watchSlidesVisibility || k.centeredSlides && k.autoHeight) {
                                var Y = -(H - W.swiperSlideOffset)
                                  , J = Y + E.slidesSizesGrid[G];
                                (Y >= 0 && Y < E.size - 1 || J > 1 && J <= E.size || Y <= 0 && J >= E.size) && (E.visibleSlides.push(W),
                                E.visibleSlidesIndexes.push(G),
                                R.eq(G).addClass(k.slideVisibleClass))
                            }
                            W.progress = U ? -Z : Z
                        }
                        E.visibleSlides = K(E.visibleSlides)
                    }
                },
                "updateProgress": function updateProgress(v) {
                    var E = this;
                    if (void 0 === v) {
                        var k = E.rtlTranslate ? -1 : 1;
                        v = E && E.translate && E.translate * k || 0
                    }
                    var R = E.params
                      , U = E.maxTranslate() - E.minTranslate()
                      , H = E.progress
                      , G = E.isBeginning
                      , W = E.isEnd
                      , Z = G
                      , Y = W;
                    0 === U ? (H = 0,
                    G = !0,
                    W = !0) : (G = (H = (v - E.minTranslate()) / U) <= 0,
                    W = H >= 1),
                    utils_extend(E, {
                        "progress": H,
                        "isBeginning": G,
                        "isEnd": W
                    }),
                    (R.watchSlidesProgress || R.watchSlidesVisibility || R.centeredSlides && R.autoHeight) && E.updateSlidesProgress(v),
                    G && !Z && E.emit("reachBeginning toEdge"),
                    W && !Y && E.emit("reachEnd toEdge"),
                    (Z && !G || Y && !W) && E.emit("fromEdge"),
                    E.emit("progress", H)
                },
                "updateSlidesClasses": function updateSlidesClasses() {
                    var v, E = this, k = E.slides, R = E.params, U = E.$wrapperEl, H = E.activeIndex, G = E.realIndex, W = E.virtual && R.virtual.enabled;
                    k.removeClass(R.slideActiveClass + " " + R.slideNextClass + " " + R.slidePrevClass + " " + R.slideDuplicateActiveClass + " " + R.slideDuplicateNextClass + " " + R.slideDuplicatePrevClass),
                    (v = W ? E.$wrapperEl.find("." + R.slideClass + '[data-swiper-slide-index="' + H + '"]') : k.eq(H)).addClass(R.slideActiveClass),
                    R.loop && (v.hasClass(R.slideDuplicateClass) ? U.children("." + R.slideClass + ":not(." + R.slideDuplicateClass + ')[data-swiper-slide-index="' + G + '"]').addClass(R.slideDuplicateActiveClass) : U.children("." + R.slideClass + "." + R.slideDuplicateClass + '[data-swiper-slide-index="' + G + '"]').addClass(R.slideDuplicateActiveClass));
                    var Z = v.nextAll("." + R.slideClass).eq(0).addClass(R.slideNextClass);
                    R.loop && 0 === Z.length && (Z = k.eq(0)).addClass(R.slideNextClass);
                    var Y = v.prevAll("." + R.slideClass).eq(0).addClass(R.slidePrevClass);
                    R.loop && 0 === Y.length && (Y = k.eq(-1)).addClass(R.slidePrevClass),
                    R.loop && (Z.hasClass(R.slideDuplicateClass) ? U.children("." + R.slideClass + ":not(." + R.slideDuplicateClass + ')[data-swiper-slide-index="' + Z.attr("data-swiper-slide-index") + '"]').addClass(R.slideDuplicateNextClass) : U.children("." + R.slideClass + "." + R.slideDuplicateClass + '[data-swiper-slide-index="' + Z.attr("data-swiper-slide-index") + '"]').addClass(R.slideDuplicateNextClass),
                    Y.hasClass(R.slideDuplicateClass) ? U.children("." + R.slideClass + ":not(." + R.slideDuplicateClass + ')[data-swiper-slide-index="' + Y.attr("data-swiper-slide-index") + '"]').addClass(R.slideDuplicatePrevClass) : U.children("." + R.slideClass + "." + R.slideDuplicateClass + '[data-swiper-slide-index="' + Y.attr("data-swiper-slide-index") + '"]').addClass(R.slideDuplicatePrevClass)),
                    E.emitSlidesClasses()
                },
                "updateActiveIndex": function updateActiveIndex(v) {
                    var E, k = this, R = k.rtlTranslate ? k.translate : -k.translate, U = k.slidesGrid, H = k.snapGrid, G = k.params, W = k.activeIndex, Z = k.realIndex, Y = k.snapIndex, J = v;
                    if (void 0 === J) {
                        for (var K = 0; K < U.length; K += 1)
                            void 0 !== U[K + 1] ? R >= U[K] && R < U[K + 1] - (U[K + 1] - U[K]) / 2 ? J = K : R >= U[K] && R < U[K + 1] && (J = K + 1) : R >= U[K] && (J = K);
                        G.normalizeSlideIndex && (J < 0 || void 0 === J) && (J = 0)
                    }
                    if (H.indexOf(R) >= 0)
                        E = H.indexOf(R);
                    else {
                        var X = Math.min(G.slidesPerGroupSkip, J);
                        E = X + Math.floor((J - X) / G.slidesPerGroup)
                    }
                    if (E >= H.length && (E = H.length - 1),
                    J !== W) {
                        var Q = parseInt(k.slides.eq(J).attr("data-swiper-slide-index") || J, 10);
                        utils_extend(k, {
                            "snapIndex": E,
                            "realIndex": Q,
                            "previousIndex": W,
                            "activeIndex": J
                        }),
                        k.emit("activeIndexChange"),
                        k.emit("snapIndexChange"),
                        Z !== Q && k.emit("realIndexChange"),
                        (k.initialized || k.params.runCallbacksOnInit) && k.emit("slideChange")
                    } else
                        E !== Y && (k.snapIndex = E,
                        k.emit("snapIndexChange"))
                },
                "updateClickedSlide": function updateClickedSlide(v) {
                    var E, k = this, R = k.params, U = K(v.target).closest("." + R.slideClass)[0], H = !1;
                    if (U)
                        for (var G = 0; G < k.slides.length; G += 1)
                            if (k.slides[G] === U) {
                                H = !0,
                                E = G;
                                break
                            }
                    if (!U || !H)
                        return k.clickedSlide = void 0,
                        void (k.clickedIndex = void 0);
                    k.clickedSlide = U,
                    k.virtual && k.params.virtual.enabled ? k.clickedIndex = parseInt(K(U).attr("data-swiper-slide-index"), 10) : k.clickedIndex = E,
                    R.slideToClickedSlide && void 0 !== k.clickedIndex && k.clickedIndex !== k.activeIndex && k.slideToClickedSlide()
                }
            };
            var re = {
                "getTranslate": function getSwiperTranslate(v) {
                    void 0 === v && (v = this.isHorizontal() ? "x" : "y");
                    var E = this
                      , k = E.params
                      , R = E.rtlTranslate
                      , U = E.translate
                      , H = E.$wrapperEl;
                    if (k.virtualTranslate)
                        return R ? -U : U;
                    if (k.cssMode)
                        return U;
                    var G = getTranslate(H[0], v);
                    return R && (G = -G),
                    G || 0
                },
                "setTranslate": function setTranslate(v, E) {
                    var k = this
                      , R = k.rtlTranslate
                      , U = k.params
                      , H = k.$wrapperEl
                      , G = k.wrapperEl
                      , W = k.progress
                      , Z = 0
                      , Y = 0;
                    k.isHorizontal() ? Z = R ? -v : v : Y = v,
                    U.roundLengths && (Z = Math.floor(Z),
                    Y = Math.floor(Y)),
                    U.cssMode ? G[k.isHorizontal() ? "scrollLeft" : "scrollTop"] = k.isHorizontal() ? -Z : -Y : U.virtualTranslate || H.transform("translate3d(" + Z + "px, " + Y + "px, 0px)"),
                    k.previousTranslate = k.translate,
                    k.translate = k.isHorizontal() ? Z : Y;
                    var J = k.maxTranslate() - k.minTranslate();
                    (0 === J ? 0 : (v - k.minTranslate()) / J) !== W && k.updateProgress(v),
                    k.emit("setTranslate", k.translate, E)
                },
                "minTranslate": function minTranslate() {
                    return -this.snapGrid[0]
                },
                "maxTranslate": function maxTranslate() {
                    return -this.snapGrid[this.snapGrid.length - 1]
                },
                "translateTo": function translateTo(v, E, k, R, U) {
                    void 0 === v && (v = 0),
                    void 0 === E && (E = this.params.speed),
                    void 0 === k && (k = !0),
                    void 0 === R && (R = !0);
                    var H = this
                      , G = H.params
                      , W = H.wrapperEl;
                    if (H.animating && G.preventInteractionOnTransition)
                        return !1;
                    var Z, Y = H.minTranslate(), J = H.maxTranslate();
                    if (Z = R && v > Y ? Y : R && v < J ? J : v,
                    H.updateProgress(Z),
                    G.cssMode) {
                        var K, X = H.isHorizontal();
                        if (0 === E)
                            W[X ? "scrollLeft" : "scrollTop"] = -Z;
                        else if (W.scrollTo)
                            W.scrollTo(((K = {})[X ? "left" : "top"] = -Z,
                            K.behavior = "smooth",
                            K));
                        else
                            W[X ? "scrollLeft" : "scrollTop"] = -Z;
                        return !0
                    }
                    return 0 === E ? (H.setTransition(0),
                    H.setTranslate(Z),
                    k && (H.emit("beforeTransitionStart", E, U),
                    H.emit("transitionEnd"))) : (H.setTransition(E),
                    H.setTranslate(Z),
                    k && (H.emit("beforeTransitionStart", E, U),
                    H.emit("transitionStart")),
                    H.animating || (H.animating = !0,
                    H.onTranslateToWrapperTransitionEnd || (H.onTranslateToWrapperTransitionEnd = function transitionEnd(v) {
                        H && !H.destroyed && v.target === this && (H.$wrapperEl[0].removeEventListener("transitionend", H.onTranslateToWrapperTransitionEnd),
                        H.$wrapperEl[0].removeEventListener("webkitTransitionEnd", H.onTranslateToWrapperTransitionEnd),
                        H.onTranslateToWrapperTransitionEnd = null,
                        delete H.onTranslateToWrapperTransitionEnd,
                        k && H.emit("transitionEnd"))
                    }
                    ),
                    H.$wrapperEl[0].addEventListener("transitionend", H.onTranslateToWrapperTransitionEnd),
                    H.$wrapperEl[0].addEventListener("webkitTransitionEnd", H.onTranslateToWrapperTransitionEnd))),
                    !0
                }
            };
            var oe = {
                "slideTo": function slideTo(v, E, k, R, U) {
                    if (void 0 === v && (v = 0),
                    void 0 === E && (E = this.params.speed),
                    void 0 === k && (k = !0),
                    "number" != typeof v && "string" != typeof v)
                        throw new Error("The 'index' argument cannot have type other than 'number' or 'string'. [" + typeof v + "] given.");
                    if ("string" == typeof v) {
                        var H = parseInt(v, 10);
                        if (!isFinite(H))
                            throw new Error("The passed-in 'index' (string) couldn't be converted to 'number'. [" + v + "] given.");
                        v = H
                    }
                    var G = this
                      , W = v;
                    W < 0 && (W = 0);
                    var Z = G.params
                      , Y = G.snapGrid
                      , J = G.slidesGrid
                      , K = G.previousIndex
                      , X = G.activeIndex
                      , Q = G.rtlTranslate
                      , ee = G.wrapperEl
                      , te = G.enabled;
                    if (G.animating && Z.preventInteractionOnTransition || !te && !R && !U)
                        return !1;
                    var ne = Math.min(G.params.slidesPerGroupSkip, W)
                      , re = ne + Math.floor((W - ne) / G.params.slidesPerGroup);
                    re >= Y.length && (re = Y.length - 1),
                    (X || Z.initialSlide || 0) === (K || 0) && k && G.emit("beforeSlideChangeStart");
                    var oe, ie = -Y[re];
                    if (G.updateProgress(ie),
                    Z.normalizeSlideIndex)
                        for (var ae = 0; ae < J.length; ae += 1) {
                            var se = -Math.floor(100 * ie)
                              , ce = Math.floor(100 * J[ae])
                              , le = Math.floor(100 * J[ae + 1]);
                            void 0 !== J[ae + 1] ? se >= ce && se < le - (le - ce) / 2 ? W = ae : se >= ce && se < le && (W = ae + 1) : se >= ce && (W = ae)
                        }
                    if (G.initialized && W !== X) {
                        if (!G.allowSlideNext && ie < G.translate && ie < G.minTranslate())
                            return !1;
                        if (!G.allowSlidePrev && ie > G.translate && ie > G.maxTranslate() && (X || 0) !== W)
                            return !1
                    }
                    if (oe = W > X ? "next" : W < X ? "prev" : "reset",
                    Q && -ie === G.translate || !Q && ie === G.translate)
                        return G.updateActiveIndex(W),
                        Z.autoHeight && G.updateAutoHeight(),
                        G.updateSlidesClasses(),
                        "slide" !== Z.effect && G.setTranslate(ie),
                        "reset" !== oe && (G.transitionStart(k, oe),
                        G.transitionEnd(k, oe)),
                        !1;
                    if (Z.cssMode) {
                        var ue, de = G.isHorizontal(), pe = -ie;
                        if (Q && (pe = ee.scrollWidth - ee.offsetWidth - pe),
                        0 === E)
                            ee[de ? "scrollLeft" : "scrollTop"] = pe;
                        else if (ee.scrollTo)
                            ee.scrollTo(((ue = {})[de ? "left" : "top"] = pe,
                            ue.behavior = "smooth",
                            ue));
                        else
                            ee[de ? "scrollLeft" : "scrollTop"] = pe;
                        return !0
                    }
                    return 0 === E ? (G.setTransition(0),
                    G.setTranslate(ie),
                    G.updateActiveIndex(W),
                    G.updateSlidesClasses(),
                    G.emit("beforeTransitionStart", E, R),
                    G.transitionStart(k, oe),
                    G.transitionEnd(k, oe)) : (G.setTransition(E),
                    G.setTranslate(ie),
                    G.updateActiveIndex(W),
                    G.updateSlidesClasses(),
                    G.emit("beforeTransitionStart", E, R),
                    G.transitionStart(k, oe),
                    G.animating || (G.animating = !0,
                    G.onSlideToWrapperTransitionEnd || (G.onSlideToWrapperTransitionEnd = function transitionEnd(v) {
                        G && !G.destroyed && v.target === this && (G.$wrapperEl[0].removeEventListener("transitionend", G.onSlideToWrapperTransitionEnd),
                        G.$wrapperEl[0].removeEventListener("webkitTransitionEnd", G.onSlideToWrapperTransitionEnd),
                        G.onSlideToWrapperTransitionEnd = null,
                        delete G.onSlideToWrapperTransitionEnd,
                        G.transitionEnd(k, oe))
                    }
                    ),
                    G.$wrapperEl[0].addEventListener("transitionend", G.onSlideToWrapperTransitionEnd),
                    G.$wrapperEl[0].addEventListener("webkitTransitionEnd", G.onSlideToWrapperTransitionEnd))),
                    !0
                },
                "slideToLoop": function slideToLoop(v, E, k, R) {
                    void 0 === v && (v = 0),
                    void 0 === E && (E = this.params.speed),
                    void 0 === k && (k = !0);
                    var U = this
                      , H = v;
                    return U.params.loop && (H += U.loopedSlides),
                    U.slideTo(H, E, k, R)
                },
                "slideNext": function slideNext(v, E, k) {
                    void 0 === v && (v = this.params.speed),
                    void 0 === E && (E = !0);
                    var R = this
                      , U = R.params
                      , H = R.animating;
                    if (!R.enabled)
                        return R;
                    var G = R.activeIndex < U.slidesPerGroupSkip ? 1 : U.slidesPerGroup;
                    if (U.loop) {
                        if (H && U.loopPreventsSlide)
                            return !1;
                        R.loopFix(),
                        R._clientLeft = R.$wrapperEl[0].clientLeft
                    }
                    return R.slideTo(R.activeIndex + G, v, E, k)
                },
                "slidePrev": function slidePrev(v, E, k) {
                    void 0 === v && (v = this.params.speed),
                    void 0 === E && (E = !0);
                    var R = this
                      , U = R.params
                      , H = R.animating
                      , G = R.snapGrid
                      , W = R.slidesGrid
                      , Z = R.rtlTranslate;
                    if (!R.enabled)
                        return R;
                    if (U.loop) {
                        if (H && U.loopPreventsSlide)
                            return !1;
                        R.loopFix(),
                        R._clientLeft = R.$wrapperEl[0].clientLeft
                    }
                    function normalize(v) {
                        return v < 0 ? -Math.floor(Math.abs(v)) : Math.floor(v)
                    }
                    var Y, J = normalize(Z ? R.translate : -R.translate), K = G.map((function(v) {
                        return normalize(v)
                    }
                    )), X = G[K.indexOf(J) - 1];
                    return void 0 === X && U.cssMode && G.forEach((function(v) {
                        !X && J >= v && (X = v)
                    }
                    )),
                    void 0 !== X && (Y = W.indexOf(X)) < 0 && (Y = R.activeIndex - 1),
                    R.slideTo(Y, v, E, k)
                },
                "slideReset": function slideReset(v, E, k) {
                    return void 0 === v && (v = this.params.speed),
                    void 0 === E && (E = !0),
                    this.slideTo(this.activeIndex, v, E, k)
                },
                "slideToClosest": function slideToClosest(v, E, k, R) {
                    void 0 === v && (v = this.params.speed),
                    void 0 === E && (E = !0),
                    void 0 === R && (R = .5);
                    var U = this
                      , H = U.activeIndex
                      , G = Math.min(U.params.slidesPerGroupSkip, H)
                      , W = G + Math.floor((H - G) / U.params.slidesPerGroup)
                      , Z = U.rtlTranslate ? U.translate : -U.translate;
                    if (Z >= U.snapGrid[W]) {
                        var Y = U.snapGrid[W];
                        Z - Y > (U.snapGrid[W + 1] - Y) * R && (H += U.params.slidesPerGroup)
                    } else {
                        var J = U.snapGrid[W - 1];
                        Z - J <= (U.snapGrid[W] - J) * R && (H -= U.params.slidesPerGroup)
                    }
                    return H = Math.max(H, 0),
                    H = Math.min(H, U.slidesGrid.length - 1),
                    U.slideTo(H, v, E, k)
                },
                "slideToClickedSlide": function slideToClickedSlide() {
                    var v, E = this, k = E.params, R = E.$wrapperEl, U = "auto" === k.slidesPerView ? E.slidesPerViewDynamic() : k.slidesPerView, H = E.clickedIndex;
                    if (k.loop) {
                        if (E.animating)
                            return;
                        v = parseInt(K(E.clickedSlide).attr("data-swiper-slide-index"), 10),
                        k.centeredSlides ? H < E.loopedSlides - U / 2 || H > E.slides.length - E.loopedSlides + U / 2 ? (E.loopFix(),
                        H = R.children("." + k.slideClass + '[data-swiper-slide-index="' + v + '"]:not(.' + k.slideDuplicateClass + ")").eq(0).index(),
                        nextTick((function() {
                            E.slideTo(H)
                        }
                        ))) : E.slideTo(H) : H > E.slides.length - U ? (E.loopFix(),
                        H = R.children("." + k.slideClass + '[data-swiper-slide-index="' + v + '"]:not(.' + k.slideDuplicateClass + ")").eq(0).index(),
                        nextTick((function() {
                            E.slideTo(H)
                        }
                        ))) : E.slideTo(H)
                    } else
                        E.slideTo(H)
                }
            };
            var ie = {
                "loopCreate": function loopCreate() {
                    var v = this
                      , E = getDocument()
                      , k = v.params
                      , R = v.$wrapperEl;
                    R.children("." + k.slideClass + "." + k.slideDuplicateClass).remove();
                    var U = R.children("." + k.slideClass);
                    if (k.loopFillGroupWithBlank) {
                        var H = k.slidesPerGroup - U.length % k.slidesPerGroup;
                        if (H !== k.slidesPerGroup) {
                            for (var G = 0; G < H; G += 1) {
                                var W = K(E.createElement("div")).addClass(k.slideClass + " " + k.slideBlankClass);
                                R.append(W)
                            }
                            U = R.children("." + k.slideClass)
                        }
                    }
                    "auto" !== k.slidesPerView || k.loopedSlides || (k.loopedSlides = U.length),
                    v.loopedSlides = Math.ceil(parseFloat(k.loopedSlides || k.slidesPerView, 10)),
                    v.loopedSlides += k.loopAdditionalSlides,
                    v.loopedSlides > U.length && (v.loopedSlides = U.length);
                    var Z = []
                      , Y = [];
                    U.each((function(E, k) {
                        var R = K(E);
                        k < v.loopedSlides && Y.push(E),
                        k < U.length && k >= U.length - v.loopedSlides && Z.push(E),
                        R.attr("data-swiper-slide-index", k)
                    }
                    ));
                    for (var J = 0; J < Y.length; J += 1)
                        R.append(K(Y[J].cloneNode(!0)).addClass(k.slideDuplicateClass));
                    for (var X = Z.length - 1; X >= 0; X -= 1)
                        R.prepend(K(Z[X].cloneNode(!0)).addClass(k.slideDuplicateClass))
                },
                "loopFix": function loopFix() {
                    var v = this;
                    v.emit("beforeLoopFix");
                    var E, k = v.activeIndex, R = v.slides, U = v.loopedSlides, H = v.allowSlidePrev, G = v.allowSlideNext, W = v.snapGrid, Z = v.rtlTranslate;
                    v.allowSlidePrev = !0,
                    v.allowSlideNext = !0;
                    var Y = -W[k] - v.getTranslate();
                    if (k < U)
                        E = R.length - 3 * U + k,
                        E += U,
                        v.slideTo(E, 0, !1, !0) && 0 !== Y && v.setTranslate((Z ? -v.translate : v.translate) - Y);
                    else if (k >= R.length - U) {
                        E = -R.length + k + U,
                        E += U,
                        v.slideTo(E, 0, !1, !0) && 0 !== Y && v.setTranslate((Z ? -v.translate : v.translate) - Y)
                    }
                    v.allowSlidePrev = H,
                    v.allowSlideNext = G,
                    v.emit("loopFix")
                },
                "loopDestroy": function loopDestroy() {
                    var v = this
                      , E = v.$wrapperEl
                      , k = v.params
                      , R = v.slides;
                    E.children("." + k.slideClass + "." + k.slideDuplicateClass + ",." + k.slideClass + "." + k.slideBlankClass).remove(),
                    R.removeAttr("data-swiper-slide-index")
                }
            };
            var ae = {
                "appendSlide": function appendSlide(v) {
                    var E = this
                      , k = E.$wrapperEl
                      , R = E.params;
                    if (R.loop && E.loopDestroy(),
                    "object" == typeof v && "length"in v)
                        for (var U = 0; U < v.length; U += 1)
                            v[U] && k.append(v[U]);
                    else
                        k.append(v);
                    R.loop && E.loopCreate(),
                    R.observer && E.support.observer || E.update()
                },
                "prependSlide": function prependSlide(v) {
                    var E = this
                      , k = E.params
                      , R = E.$wrapperEl
                      , U = E.activeIndex;
                    k.loop && E.loopDestroy();
                    var H = U + 1;
                    if ("object" == typeof v && "length"in v) {
                        for (var G = 0; G < v.length; G += 1)
                            v[G] && R.prepend(v[G]);
                        H = U + v.length
                    } else
                        R.prepend(v);
                    k.loop && E.loopCreate(),
                    k.observer && E.support.observer || E.update(),
                    E.slideTo(H, 0, !1)
                },
                "addSlide": function addSlide(v, E) {
                    var k = this
                      , R = k.$wrapperEl
                      , U = k.params
                      , H = k.activeIndex;
                    U.loop && (H -= k.loopedSlides,
                    k.loopDestroy(),
                    k.slides = R.children("." + U.slideClass));
                    var G = k.slides.length;
                    if (v <= 0)
                        k.prependSlide(E);
                    else if (v >= G)
                        k.appendSlide(E);
                    else {
                        for (var W = H > v ? H + 1 : H, Z = [], Y = G - 1; Y >= v; Y -= 1) {
                            var J = k.slides.eq(Y);
                            J.remove(),
                            Z.unshift(J)
                        }
                        if ("object" == typeof E && "length"in E) {
                            for (var K = 0; K < E.length; K += 1)
                                E[K] && R.append(E[K]);
                            W = H > v ? H + E.length : H
                        } else
                            R.append(E);
                        for (var X = 0; X < Z.length; X += 1)
                            R.append(Z[X]);
                        U.loop && k.loopCreate(),
                        U.observer && k.support.observer || k.update(),
                        U.loop ? k.slideTo(W + k.loopedSlides, 0, !1) : k.slideTo(W, 0, !1)
                    }
                },
                "removeSlide": function removeSlide(v) {
                    var E = this
                      , k = E.params
                      , R = E.$wrapperEl
                      , U = E.activeIndex;
                    k.loop && (U -= E.loopedSlides,
                    E.loopDestroy(),
                    E.slides = R.children("." + k.slideClass));
                    var H, G = U;
                    if ("object" == typeof v && "length"in v) {
                        for (var W = 0; W < v.length; W += 1)
                            H = v[W],
                            E.slides[H] && E.slides.eq(H).remove(),
                            H < G && (G -= 1);
                        G = Math.max(G, 0)
                    } else
                        H = v,
                        E.slides[H] && E.slides.eq(H).remove(),
                        H < G && (G -= 1),
                        G = Math.max(G, 0);
                    k.loop && E.loopCreate(),
                    k.observer && E.support.observer || E.update(),
                    k.loop ? E.slideTo(G + E.loopedSlides, 0, !1) : E.slideTo(G, 0, !1)
                },
                "removeAllSlides": function removeAllSlides() {
                    for (var v = [], E = 0; E < this.slides.length; E += 1)
                        v.push(E);
                    this.removeSlide(v)
                }
            };
            function onTouchStart(v) {
                var E = this
                  , k = getDocument()
                  , R = ssr_window_esm_getWindow()
                  , U = E.touchEventsData
                  , H = E.params
                  , G = E.touches;
                if (E.enabled && (!E.animating || !H.preventInteractionOnTransition)) {
                    var W = v;
                    W.originalEvent && (W = W.originalEvent);
                    var Z = K(W.target);
                    if ("wrapper" !== H.touchEventsTarget || Z.closest(E.wrapperEl).length)
                        if (U.isTouchEvent = "touchstart" === W.type,
                        U.isTouchEvent || !("which"in W) || 3 !== W.which)
                            if (!(!U.isTouchEvent && "button"in W && W.button > 0))
                                if (!U.isTouched || !U.isMoved)
                                    if (!!H.noSwipingClass && "" !== H.noSwipingClass && W.target && W.target.shadowRoot && v.path && v.path[0] && (Z = K(v.path[0])),
                                    H.noSwiping && Z.closest(H.noSwipingSelector ? H.noSwipingSelector : "." + H.noSwipingClass)[0])
                                        E.allowClick = !0;
                                    else if (!H.swipeHandler || Z.closest(H.swipeHandler)[0]) {
                                        G.currentX = "touchstart" === W.type ? W.targetTouches[0].pageX : W.pageX,
                                        G.currentY = "touchstart" === W.type ? W.targetTouches[0].pageY : W.pageY;
                                        var Y = G.currentX
                                          , J = G.currentY
                                          , X = H.edgeSwipeDetection || H.iOSEdgeSwipeDetection
                                          , Q = H.edgeSwipeThreshold || H.iOSEdgeSwipeThreshold;
                                        if (X && (Y <= Q || Y >= R.innerWidth - Q)) {
                                            if ("prevent" !== X)
                                                return;
                                            v.preventDefault()
                                        }
                                        if (utils_extend(U, {
                                            "isTouched": !0,
                                            "isMoved": !1,
                                            "allowTouchCallbacks": !0,
                                            "isScrolling": void 0,
                                            "startMoving": void 0
                                        }),
                                        G.startX = Y,
                                        G.startY = J,
                                        U.touchStartTime = now(),
                                        E.allowClick = !0,
                                        E.updateSize(),
                                        E.swipeDirection = void 0,
                                        H.threshold > 0 && (U.allowThresholdMove = !1),
                                        "touchstart" !== W.type) {
                                            var ee = !0;
                                            Z.is(U.focusableElements) && (ee = !1),
                                            k.activeElement && K(k.activeElement).is(U.focusableElements) && k.activeElement !== Z[0] && k.activeElement.blur();
                                            var te = ee && E.allowTouchMove && H.touchStartPreventDefault;
                                            !H.touchStartForcePreventDefault && !te || Z[0].isContentEditable || W.preventDefault()
                                        }
                                        E.emit("touchStart", W)
                                    }
                }
            }
            function onTouchMove(v) {
                var E = getDocument()
                  , k = this
                  , R = k.touchEventsData
                  , U = k.params
                  , H = k.touches
                  , G = k.rtlTranslate;
                if (k.enabled) {
                    var W = v;
                    if (W.originalEvent && (W = W.originalEvent),
                    R.isTouched) {
                        if (!R.isTouchEvent || "touchmove" === W.type) {
                            var Z = "touchmove" === W.type && W.targetTouches && (W.targetTouches[0] || W.changedTouches[0])
                              , Y = "touchmove" === W.type ? Z.pageX : W.pageX
                              , J = "touchmove" === W.type ? Z.pageY : W.pageY;
                            if (W.preventedByNestedSwiper)
                                return H.startX = Y,
                                void (H.startY = J);
                            if (!k.allowTouchMove)
                                return k.allowClick = !1,
                                void (R.isTouched && (utils_extend(H, {
                                    "startX": Y,
                                    "startY": J,
                                    "currentX": Y,
                                    "currentY": J
                                }),
                                R.touchStartTime = now()));
                            if (R.isTouchEvent && U.touchReleaseOnEdges && !U.loop)
                                if (k.isVertical()) {
                                    if (J < H.startY && k.translate <= k.maxTranslate() || J > H.startY && k.translate >= k.minTranslate())
                                        return R.isTouched = !1,
                                        void (R.isMoved = !1)
                                } else if (Y < H.startX && k.translate <= k.maxTranslate() || Y > H.startX && k.translate >= k.minTranslate())
                                    return;
                            if (R.isTouchEvent && E.activeElement && W.target === E.activeElement && K(W.target).is(R.focusableElements))
                                return R.isMoved = !0,
                                void (k.allowClick = !1);
                            if (R.allowTouchCallbacks && k.emit("touchMove", W),
                            !(W.targetTouches && W.targetTouches.length > 1)) {
                                H.currentX = Y,
                                H.currentY = J;
                                var X = H.currentX - H.startX
                                  , Q = H.currentY - H.startY;
                                if (!(k.params.threshold && Math.sqrt(Math.pow(X, 2) + Math.pow(Q, 2)) < k.params.threshold)) {
                                    var ee;
                                    if (void 0 === R.isScrolling)
                                        k.isHorizontal() && H.currentY === H.startY || k.isVertical() && H.currentX === H.startX ? R.isScrolling = !1 : X * X + Q * Q >= 25 && (ee = 180 * Math.atan2(Math.abs(Q), Math.abs(X)) / Math.PI,
                                        R.isScrolling = k.isHorizontal() ? ee > U.touchAngle : 90 - ee > U.touchAngle);
                                    if (R.isScrolling && k.emit("touchMoveOpposite", W),
                                    void 0 === R.startMoving && (H.currentX === H.startX && H.currentY === H.startY || (R.startMoving = !0)),
                                    R.isScrolling)
                                        R.isTouched = !1;
                                    else if (R.startMoving) {
                                        k.allowClick = !1,
                                        !U.cssMode && W.cancelable && W.preventDefault(),
                                        U.touchMoveStopPropagation && !U.nested && W.stopPropagation(),
                                        R.isMoved || (U.loop && k.loopFix(),
                                        R.startTranslate = k.getTranslate(),
                                        k.setTransition(0),
                                        k.animating && k.$wrapperEl.trigger("webkitTransitionEnd transitionend"),
                                        R.allowMomentumBounce = !1,
                                        !U.grabCursor || !0 !== k.allowSlideNext && !0 !== k.allowSlidePrev || k.setGrabCursor(!0),
                                        k.emit("sliderFirstMove", W)),
                                        k.emit("sliderMove", W),
                                        R.isMoved = !0;
                                        var te = k.isHorizontal() ? X : Q;
                                        H.diff = te,
                                        te *= U.touchRatio,
                                        G && (te = -te),
                                        k.swipeDirection = te > 0 ? "prev" : "next",
                                        R.currentTranslate = te + R.startTranslate;
                                        var ne = !0
                                          , re = U.resistanceRatio;
                                        if (U.touchReleaseOnEdges && (re = 0),
                                        te > 0 && R.currentTranslate > k.minTranslate() ? (ne = !1,
                                        U.resistance && (R.currentTranslate = k.minTranslate() - 1 + Math.pow(-k.minTranslate() + R.startTranslate + te, re))) : te < 0 && R.currentTranslate < k.maxTranslate() && (ne = !1,
                                        U.resistance && (R.currentTranslate = k.maxTranslate() + 1 - Math.pow(k.maxTranslate() - R.startTranslate - te, re))),
                                        ne && (W.preventedByNestedSwiper = !0),
                                        !k.allowSlideNext && "next" === k.swipeDirection && R.currentTranslate < R.startTranslate && (R.currentTranslate = R.startTranslate),
                                        !k.allowSlidePrev && "prev" === k.swipeDirection && R.currentTranslate > R.startTranslate && (R.currentTranslate = R.startTranslate),
                                        k.allowSlidePrev || k.allowSlideNext || (R.currentTranslate = R.startTranslate),
                                        U.threshold > 0) {
                                            if (!(Math.abs(te) > U.threshold || R.allowThresholdMove))
                                                return void (R.currentTranslate = R.startTranslate);
                                            if (!R.allowThresholdMove)
                                                return R.allowThresholdMove = !0,
                                                H.startX = H.currentX,
                                                H.startY = H.currentY,
                                                R.currentTranslate = R.startTranslate,
                                                void (H.diff = k.isHorizontal() ? H.currentX - H.startX : H.currentY - H.startY)
                                        }
                                        U.followFinger && !U.cssMode && ((U.freeMode || U.watchSlidesProgress || U.watchSlidesVisibility) && (k.updateActiveIndex(),
                                        k.updateSlidesClasses()),
                                        U.freeMode && (0 === R.velocities.length && R.velocities.push({
                                            "position": H[k.isHorizontal() ? "startX" : "startY"],
                                            "time": R.touchStartTime
                                        }),
                                        R.velocities.push({
                                            "position": H[k.isHorizontal() ? "currentX" : "currentY"],
                                            "time": now()
                                        })),
                                        k.updateProgress(R.currentTranslate),
                                        k.setTranslate(R.currentTranslate))
                                    }
                                }
                            }
                        }
                    } else
                        R.startMoving && R.isScrolling && k.emit("touchMoveOpposite", W)
                }
            }
            function onTouchEnd(v) {
                var E = this
                  , k = E.touchEventsData
                  , R = E.params
                  , U = E.touches
                  , H = E.rtlTranslate
                  , G = E.$wrapperEl
                  , W = E.slidesGrid
                  , Z = E.snapGrid;
                if (E.enabled) {
                    var Y = v;
                    if (Y.originalEvent && (Y = Y.originalEvent),
                    k.allowTouchCallbacks && E.emit("touchEnd", Y),
                    k.allowTouchCallbacks = !1,
                    !k.isTouched)
                        return k.isMoved && R.grabCursor && E.setGrabCursor(!1),
                        k.isMoved = !1,
                        void (k.startMoving = !1);
                    R.grabCursor && k.isMoved && k.isTouched && (!0 === E.allowSlideNext || !0 === E.allowSlidePrev) && E.setGrabCursor(!1);
                    var J, K = now(), X = K - k.touchStartTime;
                    if (E.allowClick && (E.updateClickedSlide(Y),
                    E.emit("tap click", Y),
                    X < 300 && K - k.lastClickTime < 300 && E.emit("doubleTap doubleClick", Y)),
                    k.lastClickTime = now(),
                    nextTick((function() {
                        E.destroyed || (E.allowClick = !0)
                    }
                    )),
                    !k.isTouched || !k.isMoved || !E.swipeDirection || 0 === U.diff || k.currentTranslate === k.startTranslate)
                        return k.isTouched = !1,
                        k.isMoved = !1,
                        void (k.startMoving = !1);
                    if (k.isTouched = !1,
                    k.isMoved = !1,
                    k.startMoving = !1,
                    J = R.followFinger ? H ? E.translate : -E.translate : -k.currentTranslate,
                    !R.cssMode)
                        if (R.freeMode) {
                            if (J < -E.minTranslate())
                                return void E.slideTo(E.activeIndex);
                            if (J > -E.maxTranslate())
                                return void (E.slides.length < Z.length ? E.slideTo(Z.length - 1) : E.slideTo(E.slides.length - 1));
                            if (R.freeModeMomentum) {
                                if (k.velocities.length > 1) {
                                    var Q = k.velocities.pop()
                                      , ee = k.velocities.pop()
                                      , te = Q.position - ee.position
                                      , ne = Q.time - ee.time;
                                    E.velocity = te / ne,
                                    E.velocity /= 2,
                                    Math.abs(E.velocity) < R.freeModeMinimumVelocity && (E.velocity = 0),
                                    (ne > 150 || now() - Q.time > 300) && (E.velocity = 0)
                                } else
                                    E.velocity = 0;
                                E.velocity *= R.freeModeMomentumVelocityRatio,
                                k.velocities.length = 0;
                                var re = 1e3 * R.freeModeMomentumRatio
                                  , oe = E.velocity * re
                                  , ie = E.translate + oe;
                                H && (ie = -ie);
                                var ae, se, ce = !1, le = 20 * Math.abs(E.velocity) * R.freeModeMomentumBounceRatio;
                                if (ie < E.maxTranslate())
                                    R.freeModeMomentumBounce ? (ie + E.maxTranslate() < -le && (ie = E.maxTranslate() - le),
                                    ae = E.maxTranslate(),
                                    ce = !0,
                                    k.allowMomentumBounce = !0) : ie = E.maxTranslate(),
                                    R.loop && R.centeredSlides && (se = !0);
                                else if (ie > E.minTranslate())
                                    R.freeModeMomentumBounce ? (ie - E.minTranslate() > le && (ie = E.minTranslate() + le),
                                    ae = E.minTranslate(),
                                    ce = !0,
                                    k.allowMomentumBounce = !0) : ie = E.minTranslate(),
                                    R.loop && R.centeredSlides && (se = !0);
                                else if (R.freeModeSticky) {
                                    for (var ue, de = 0; de < Z.length; de += 1)
                                        if (Z[de] > -ie) {
                                            ue = de;
                                            break
                                        }
                                    ie = -(ie = Math.abs(Z[ue] - ie) < Math.abs(Z[ue - 1] - ie) || "next" === E.swipeDirection ? Z[ue] : Z[ue - 1])
                                }
                                if (se && E.once("transitionEnd", (function() {
                                    E.loopFix()
                                }
                                )),
                                0 !== E.velocity) {
                                    if (re = H ? Math.abs((-ie - E.translate) / E.velocity) : Math.abs((ie - E.translate) / E.velocity),
                                    R.freeModeSticky) {
                                        var pe = Math.abs((H ? -ie : ie) - E.translate)
                                          , fe = E.slidesSizesGrid[E.activeIndex];
                                        re = pe < fe ? R.speed : pe < 2 * fe ? 1.5 * R.speed : 2.5 * R.speed
                                    }
                                } else if (R.freeModeSticky)
                                    return void E.slideToClosest();
                                R.freeModeMomentumBounce && ce ? (E.updateProgress(ae),
                                E.setTransition(re),
                                E.setTranslate(ie),
                                E.transitionStart(!0, E.swipeDirection),
                                E.animating = !0,
                                G.transitionEnd((function() {
                                    E && !E.destroyed && k.allowMomentumBounce && (E.emit("momentumBounce"),
                                    E.setTransition(R.speed),
                                    setTimeout((function() {
                                        E.setTranslate(ae),
                                        G.transitionEnd((function() {
                                            E && !E.destroyed && E.transitionEnd()
                                        }
                                        ))
                                    }
                                    ), 0))
                                }
                                ))) : E.velocity ? (E.updateProgress(ie),
                                E.setTransition(re),
                                E.setTranslate(ie),
                                E.transitionStart(!0, E.swipeDirection),
                                E.animating || (E.animating = !0,
                                G.transitionEnd((function() {
                                    E && !E.destroyed && E.transitionEnd()
                                }
                                )))) : (E.emit("_freeModeNoMomentumRelease"),
                                E.updateProgress(ie)),
                                E.updateActiveIndex(),
                                E.updateSlidesClasses()
                            } else {
                                if (R.freeModeSticky)
                                    return void E.slideToClosest();
                                R.freeMode && E.emit("_freeModeNoMomentumRelease")
                            }
                            (!R.freeModeMomentum || X >= R.longSwipesMs) && (E.updateProgress(),
                            E.updateActiveIndex(),
                            E.updateSlidesClasses())
                        } else {
                            for (var he = 0, me = E.slidesSizesGrid[0], ge = 0; ge < W.length; ge += ge < R.slidesPerGroupSkip ? 1 : R.slidesPerGroup) {
                                var _e = ge < R.slidesPerGroupSkip - 1 ? 1 : R.slidesPerGroup;
                                void 0 !== W[ge + _e] ? J >= W[ge] && J < W[ge + _e] && (he = ge,
                                me = W[ge + _e] - W[ge]) : J >= W[ge] && (he = ge,
                                me = W[W.length - 1] - W[W.length - 2])
                            }
                            var ve = (J - W[he]) / me
                              , ye = he < R.slidesPerGroupSkip - 1 ? 1 : R.slidesPerGroup;
                            if (X > R.longSwipesMs) {
                                if (!R.longSwipes)
                                    return void E.slideTo(E.activeIndex);
                                "next" === E.swipeDirection && (ve >= R.longSwipesRatio ? E.slideTo(he + ye) : E.slideTo(he)),
                                "prev" === E.swipeDirection && (ve > 1 - R.longSwipesRatio ? E.slideTo(he + ye) : E.slideTo(he))
                            } else {
                                if (!R.shortSwipes)
                                    return void E.slideTo(E.activeIndex);
                                E.navigation && (Y.target === E.navigation.nextEl || Y.target === E.navigation.prevEl) ? Y.target === E.navigation.nextEl ? E.slideTo(he + ye) : E.slideTo(he) : ("next" === E.swipeDirection && E.slideTo(he + ye),
                                "prev" === E.swipeDirection && E.slideTo(he))
                            }
                        }
                }
            }
            function onResize() {
                var v = this
                  , E = v.params
                  , k = v.el;
                if (!k || 0 !== k.offsetWidth) {
                    E.breakpoints && v.setBreakpoint();
                    var R = v.allowSlideNext
                      , U = v.allowSlidePrev
                      , H = v.snapGrid;
                    v.allowSlideNext = !0,
                    v.allowSlidePrev = !0,
                    v.updateSize(),
                    v.updateSlides(),
                    v.updateSlidesClasses(),
                    ("auto" === E.slidesPerView || E.slidesPerView > 1) && v.isEnd && !v.isBeginning && !v.params.centeredSlides ? v.slideTo(v.slides.length - 1, 0, !1, !0) : v.slideTo(v.activeIndex, 0, !1, !0),
                    v.autoplay && v.autoplay.running && v.autoplay.paused && v.autoplay.run(),
                    v.allowSlidePrev = U,
                    v.allowSlideNext = R,
                    v.params.watchOverflow && H !== v.snapGrid && v.checkOverflow()
                }
            }
            function onClick(v) {
                var E = this;
                E.enabled && (E.allowClick || (E.params.preventClicks && v.preventDefault(),
                E.params.preventClicksPropagation && E.animating && (v.stopPropagation(),
                v.stopImmediatePropagation())))
            }
            function onScroll() {
                var v = this
                  , E = v.wrapperEl
                  , k = v.rtlTranslate;
                if (v.enabled) {
                    v.previousTranslate = v.translate,
                    v.isHorizontal() ? v.translate = k ? E.scrollWidth - E.offsetWidth - E.scrollLeft : -E.scrollLeft : v.translate = -E.scrollTop,
                    -0 === v.translate && (v.translate = 0),
                    v.updateActiveIndex(),
                    v.updateSlidesClasses();
                    var R = v.maxTranslate() - v.minTranslate();
                    (0 === R ? 0 : (v.translate - v.minTranslate()) / R) !== v.progress && v.updateProgress(k ? -v.translate : v.translate),
                    v.emit("setTranslate", v.translate, !1)
                }
            }
            var se = !1;
            function dummyEventListener() {}
            var ce = {
                "attachEvents": function attachEvents() {
                    var v = this
                      , E = getDocument()
                      , k = v.params
                      , R = v.touchEvents
                      , U = v.el
                      , H = v.wrapperEl
                      , G = v.device
                      , W = v.support;
                    v.onTouchStart = onTouchStart.bind(v),
                    v.onTouchMove = onTouchMove.bind(v),
                    v.onTouchEnd = onTouchEnd.bind(v),
                    k.cssMode && (v.onScroll = onScroll.bind(v)),
                    v.onClick = onClick.bind(v);
                    var Z = !!k.nested;
                    if (!W.touch && W.pointerEvents)
                        U.addEventListener(R.start, v.onTouchStart, !1),
                        E.addEventListener(R.move, v.onTouchMove, Z),
                        E.addEventListener(R.end, v.onTouchEnd, !1);
                    else {
                        if (W.touch) {
                            var Y = !("touchstart" !== R.start || !W.passiveListener || !k.passiveListeners) && {
                                "passive": !0,
                                "capture": !1
                            };
                            U.addEventListener(R.start, v.onTouchStart, Y),
                            U.addEventListener(R.move, v.onTouchMove, W.passiveListener ? {
                                "passive": !1,
                                "capture": Z
                            } : Z),
                            U.addEventListener(R.end, v.onTouchEnd, Y),
                            R.cancel && U.addEventListener(R.cancel, v.onTouchEnd, Y),
                            se || (E.addEventListener("touchstart", dummyEventListener),
                            se = !0)
                        }
                        (k.simulateTouch && !G.ios && !G.android || k.simulateTouch && !W.touch && G.ios) && (U.addEventListener("mousedown", v.onTouchStart, !1),
                        E.addEventListener("mousemove", v.onTouchMove, Z),
                        E.addEventListener("mouseup", v.onTouchEnd, !1))
                    }
                    (k.preventClicks || k.preventClicksPropagation) && U.addEventListener("click", v.onClick, !0),
                    k.cssMode && H.addEventListener("scroll", v.onScroll),
                    k.updateOnWindowResize ? v.on(G.ios || G.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, !0) : v.on("observerUpdate", onResize, !0)
                },
                "detachEvents": function detachEvents() {
                    var v = this
                      , E = getDocument()
                      , k = v.params
                      , R = v.touchEvents
                      , U = v.el
                      , H = v.wrapperEl
                      , G = v.device
                      , W = v.support
                      , Z = !!k.nested;
                    if (!W.touch && W.pointerEvents)
                        U.removeEventListener(R.start, v.onTouchStart, !1),
                        E.removeEventListener(R.move, v.onTouchMove, Z),
                        E.removeEventListener(R.end, v.onTouchEnd, !1);
                    else {
                        if (W.touch) {
                            var Y = !("onTouchStart" !== R.start || !W.passiveListener || !k.passiveListeners) && {
                                "passive": !0,
                                "capture": !1
                            };
                            U.removeEventListener(R.start, v.onTouchStart, Y),
                            U.removeEventListener(R.move, v.onTouchMove, Z),
                            U.removeEventListener(R.end, v.onTouchEnd, Y),
                            R.cancel && U.removeEventListener(R.cancel, v.onTouchEnd, Y)
                        }
                        (k.simulateTouch && !G.ios && !G.android || k.simulateTouch && !W.touch && G.ios) && (U.removeEventListener("mousedown", v.onTouchStart, !1),
                        E.removeEventListener("mousemove", v.onTouchMove, Z),
                        E.removeEventListener("mouseup", v.onTouchEnd, !1))
                    }
                    (k.preventClicks || k.preventClicksPropagation) && U.removeEventListener("click", v.onClick, !0),
                    k.cssMode && H.removeEventListener("scroll", v.onScroll),
                    v.off(G.ios || G.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize)
                }
            };
            var le = {
                "setBreakpoint": function setBreakpoint() {
                    var v = this
                      , E = v.activeIndex
                      , k = v.initialized
                      , R = v.loopedSlides
                      , U = void 0 === R ? 0 : R
                      , H = v.params
                      , G = v.$el
                      , W = H.breakpoints;
                    if (W && (!W || 0 !== Object.keys(W).length)) {
                        var Z = v.getBreakpoint(W, v.params.breakpointsBase, v.el);
                        if (Z && v.currentBreakpoint !== Z) {
                            var Y = Z in W ? W[Z] : void 0;
                            Y && ["slidesPerView", "spaceBetween", "slidesPerGroup", "slidesPerGroupSkip", "slidesPerColumn"].forEach((function(v) {
                                var E = Y[v];
                                void 0 !== E && (Y[v] = "slidesPerView" !== v || "AUTO" !== E && "auto" !== E ? "slidesPerView" === v ? parseFloat(E) : parseInt(E, 10) : "auto")
                            }
                            ));
                            var J = Y || v.originalParams
                              , K = H.slidesPerColumn > 1
                              , X = J.slidesPerColumn > 1
                              , Q = H.enabled;
                            K && !X ? (G.removeClass(H.containerModifierClass + "multirow " + H.containerModifierClass + "multirow-column"),
                            v.emitContainerClasses()) : !K && X && (G.addClass(H.containerModifierClass + "multirow"),
                            "column" === J.slidesPerColumnFill && G.addClass(H.containerModifierClass + "multirow-column"),
                            v.emitContainerClasses());
                            var ee = J.direction && J.direction !== H.direction
                              , te = H.loop && (J.slidesPerView !== H.slidesPerView || ee);
                            ee && k && v.changeDirection(),
                            utils_extend(v.params, J);
                            var ne = v.params.enabled;
                            utils_extend(v, {
                                "allowTouchMove": v.params.allowTouchMove,
                                "allowSlideNext": v.params.allowSlideNext,
                                "allowSlidePrev": v.params.allowSlidePrev
                            }),
                            Q && !ne ? v.disable() : !Q && ne && v.enable(),
                            v.currentBreakpoint = Z,
                            v.emit("_beforeBreakpoint", J),
                            te && k && (v.loopDestroy(),
                            v.loopCreate(),
                            v.updateSlides(),
                            v.slideTo(E - U + v.loopedSlides, 0, !1)),
                            v.emit("breakpoint", J)
                        }
                    }
                },
                "getBreakpoint": function getBreakpoint(v, E, k) {
                    if (void 0 === E && (E = "window"),
                    v && ("container" !== E || k)) {
                        var R = !1
                          , U = ssr_window_esm_getWindow()
                          , H = "window" === E ? U.innerHeight : k.clientHeight
                          , G = Object.keys(v).map((function(v) {
                            if ("string" == typeof v && 0 === v.indexOf("@")) {
                                var E = parseFloat(v.substr(1));
                                return {
                                    "value": H * E,
                                    "point": v
                                }
                            }
                            return {
                                "value": v,
                                "point": v
                            }
                        }
                        ));
                        G.sort((function(v, E) {
                            return parseInt(v.value, 10) - parseInt(E.value, 10)
                        }
                        ));
                        for (var W = 0; W < G.length; W += 1) {
                            var Z = G[W]
                              , Y = Z.point
                              , J = Z.value;
                            "window" === E ? U.matchMedia("(min-width: " + J + "px)").matches && (R = Y) : J <= k.clientWidth && (R = Y)
                        }
                        return R || "max"
                    }
                }
            };
            var ue = {
                "addClasses": function addClasses() {
                    var v = this
                      , E = v.classNames
                      , k = v.params
                      , R = v.rtl
                      , U = v.$el
                      , H = v.device
                      , G = v.support
                      , W = function prepareClasses(v, E) {
                        var k = [];
                        return v.forEach((function(v) {
                            "object" == typeof v ? Object.keys(v).forEach((function(R) {
                                v[R] && k.push(E + R)
                            }
                            )) : "string" == typeof v && k.push(E + v)
                        }
                        )),
                        k
                    }(["initialized", k.direction, {
                        "pointer-events": G.pointerEvents && !G.touch
                    }, {
                        "free-mode": k.freeMode
                    }, {
                        "autoheight": k.autoHeight
                    }, {
                        "rtl": R
                    }, {
                        "multirow": k.slidesPerColumn > 1
                    }, {
                        "multirow-column": k.slidesPerColumn > 1 && "column" === k.slidesPerColumnFill
                    }, {
                        "android": H.android
                    }, {
                        "ios": H.ios
                    }, {
                        "css-mode": k.cssMode
                    }], k.containerModifierClass);
                    E.push.apply(E, W),
                    U.addClass([].concat(E).join(" ")),
                    v.emitContainerClasses()
                },
                "removeClasses": function removeClasses() {
                    var v = this
                      , E = v.$el
                      , k = v.classNames;
                    E.removeClass(k.join(" ")),
                    v.emitContainerClasses()
                }
            };
            var de = {
                "init": !0,
                "direction": "horizontal",
                "touchEventsTarget": "container",
                "initialSlide": 0,
                "speed": 300,
                "cssMode": !1,
                "updateOnWindowResize": !0,
                "resizeObserver": !1,
                "nested": !1,
                "createElements": !1,
                "enabled": !0,
                "focusableElements": "input, select, option, textarea, button, video, label",
                "width": null,
                "height": null,
                "preventInteractionOnTransition": !1,
                "userAgent": null,
                "url": null,
                "edgeSwipeDetection": !1,
                "edgeSwipeThreshold": 20,
                "freeMode": !1,
                "freeModeMomentum": !0,
                "freeModeMomentumRatio": 1,
                "freeModeMomentumBounce": !0,
                "freeModeMomentumBounceRatio": 1,
                "freeModeMomentumVelocityRatio": 1,
                "freeModeSticky": !1,
                "freeModeMinimumVelocity": .02,
                "autoHeight": !1,
                "setWrapperSize": !1,
                "virtualTranslate": !1,
                "effect": "slide",
                "breakpoints": void 0,
                "breakpointsBase": "window",
                "spaceBetween": 0,
                "slidesPerView": 1,
                "slidesPerColumn": 1,
                "slidesPerColumnFill": "column",
                "slidesPerGroup": 1,
                "slidesPerGroupSkip": 0,
                "centeredSlides": !1,
                "centeredSlidesBounds": !1,
                "slidesOffsetBefore": 0,
                "slidesOffsetAfter": 0,
                "normalizeSlideIndex": !0,
                "centerInsufficientSlides": !1,
                "watchOverflow": !1,
                "roundLengths": !1,
                "touchRatio": 1,
                "touchAngle": 45,
                "simulateTouch": !0,
                "shortSwipes": !0,
                "longSwipes": !0,
                "longSwipesRatio": .5,
                "longSwipesMs": 300,
                "followFinger": !0,
                "allowTouchMove": !0,
                "threshold": 0,
                "touchMoveStopPropagation": !1,
                "touchStartPreventDefault": !0,
                "touchStartForcePreventDefault": !1,
                "touchReleaseOnEdges": !1,
                "uniqueNavElements": !0,
                "resistance": !0,
                "resistanceRatio": .85,
                "watchSlidesProgress": !1,
                "watchSlidesVisibility": !1,
                "grabCursor": !1,
                "preventClicks": !0,
                "preventClicksPropagation": !0,
                "slideToClickedSlide": !1,
                "preloadImages": !0,
                "updateOnImagesReady": !0,
                "loop": !1,
                "loopAdditionalSlides": 0,
                "loopedSlides": null,
                "loopFillGroupWithBlank": !1,
                "loopPreventsSlide": !0,
                "allowSlidePrev": !0,
                "allowSlideNext": !0,
                "swipeHandler": null,
                "noSwiping": !0,
                "noSwipingClass": "swiper-no-swiping",
                "noSwipingSelector": null,
                "passiveListeners": !0,
                "containerModifierClass": "swiper-container-",
                "slideClass": "swiper-slide",
                "slideBlankClass": "swiper-slide-invisible-blank",
                "slideActiveClass": "swiper-slide-active",
                "slideDuplicateActiveClass": "swiper-slide-duplicate-active",
                "slideVisibleClass": "swiper-slide-visible",
                "slideDuplicateClass": "swiper-slide-duplicate",
                "slideNextClass": "swiper-slide-next",
                "slideDuplicateNextClass": "swiper-slide-duplicate-next",
                "slidePrevClass": "swiper-slide-prev",
                "slideDuplicatePrevClass": "swiper-slide-duplicate-prev",
                "wrapperClass": "swiper-wrapper",
                "runCallbacksOnInit": !0,
                "_emitClasses": !1
            };
            function _defineProperties(v, E) {
                for (var k = 0; k < E.length; k++) {
                    var R = E[k];
                    R.enumerable = R.enumerable || !1,
                    R.configurable = !0,
                    "value"in R && (R.writable = !0),
                    Object.defineProperty(v, R.key, R)
                }
            }
            var pe = {
                "modular": {
                    "useParams": function useParams(v) {
                        var E = this;
                        E.modules && Object.keys(E.modules).forEach((function(k) {
                            var R = E.modules[k];
                            R.params && utils_extend(v, R.params)
                        }
                        ))
                    },
                    "useModules": function useModules(v) {
                        void 0 === v && (v = {});
                        var E = this;
                        E.modules && Object.keys(E.modules).forEach((function(k) {
                            var R = E.modules[k]
                              , U = v[k] || {};
                            R.on && E.on && Object.keys(R.on).forEach((function(v) {
                                E.on(v, R.on[v])
                            }
                            )),
                            R.create && R.create.bind(E)(U)
                        }
                        ))
                    }
                },
                "eventsEmitter": te,
                "update": ne,
                "translate": re,
                "transition": {
                    "setTransition": function setTransition(v, E) {
                        var k = this;
                        k.params.cssMode || k.$wrapperEl.transition(v),
                        k.emit("setTransition", v, E)
                    },
                    "transitionStart": function transitionStart(v, E) {
                        void 0 === v && (v = !0);
                        var k = this
                          , R = k.activeIndex
                          , U = k.params
                          , H = k.previousIndex;
                        if (!U.cssMode) {
                            U.autoHeight && k.updateAutoHeight();
                            var G = E;
                            if (G || (G = R > H ? "next" : R < H ? "prev" : "reset"),
                            k.emit("transitionStart"),
                            v && R !== H) {
                                if ("reset" === G)
                                    return void k.emit("slideResetTransitionStart");
                                k.emit("slideChangeTransitionStart"),
                                "next" === G ? k.emit("slideNextTransitionStart") : k.emit("slidePrevTransitionStart")
                            }
                        }
                    },
                    "transitionEnd": function transitionEnd_transitionEnd(v, E) {
                        void 0 === v && (v = !0);
                        var k = this
                          , R = k.activeIndex
                          , U = k.previousIndex
                          , H = k.params;
                        if (k.animating = !1,
                        !H.cssMode) {
                            k.setTransition(0);
                            var G = E;
                            if (G || (G = R > U ? "next" : R < U ? "prev" : "reset"),
                            k.emit("transitionEnd"),
                            v && R !== U) {
                                if ("reset" === G)
                                    return void k.emit("slideResetTransitionEnd");
                                k.emit("slideChangeTransitionEnd"),
                                "next" === G ? k.emit("slideNextTransitionEnd") : k.emit("slidePrevTransitionEnd")
                            }
                        }
                    }
                },
                "slide": oe,
                "loop": ie,
                "grabCursor": {
                    "setGrabCursor": function setGrabCursor(v) {
                        var E = this;
                        if (!(E.support.touch || !E.params.simulateTouch || E.params.watchOverflow && E.isLocked || E.params.cssMode)) {
                            var k = E.el;
                            k.style.cursor = "move",
                            k.style.cursor = v ? "-webkit-grabbing" : "-webkit-grab",
                            k.style.cursor = v ? "-moz-grabbin" : "-moz-grab",
                            k.style.cursor = v ? "grabbing" : "grab"
                        }
                    },
                    "unsetGrabCursor": function unsetGrabCursor() {
                        var v = this;
                        v.support.touch || v.params.watchOverflow && v.isLocked || v.params.cssMode || (v.el.style.cursor = "")
                    }
                },
                "manipulation": ae,
                "events": ce,
                "breakpoints": le,
                "checkOverflow": {
                    "checkOverflow": function checkOverflow() {
                        var v = this
                          , E = v.params
                          , k = v.isLocked
                          , R = v.slides.length > 0 && E.slidesOffsetBefore + E.spaceBetween * (v.slides.length - 1) + v.slides[0].offsetWidth * v.slides.length;
                        E.slidesOffsetBefore && E.slidesOffsetAfter && R ? v.isLocked = R <= v.size : v.isLocked = 1 === v.snapGrid.length,
                        v.allowSlideNext = !v.isLocked,
                        v.allowSlidePrev = !v.isLocked,
                        k !== v.isLocked && v.emit(v.isLocked ? "lock" : "unlock"),
                        k && k !== v.isLocked && (v.isEnd = !1,
                        v.navigation && v.navigation.update())
                    }
                },
                "classes": ue,
                "images": {
                    "loadImage": function loadImage(v, E, k, R, U, H) {
                        var G, W = ssr_window_esm_getWindow();
                        function onReady() {
                            H && H()
                        }
                        K(v).parent("picture")[0] || v.complete && U ? onReady() : E ? ((G = new W.Image).onload = onReady,
                        G.onerror = onReady,
                        R && (G.sizes = R),
                        k && (G.srcset = k),
                        E && (G.src = E)) : onReady()
                    },
                    "preloadImages": function preloadImages() {
                        var v = this;
                        function onReady() {
                            null != v && v && !v.destroyed && (void 0 !== v.imagesLoaded && (v.imagesLoaded += 1),
                            v.imagesLoaded === v.imagesToLoad.length && (v.params.updateOnImagesReady && v.update(),
                            v.emit("imagesReady")))
                        }
                        v.imagesToLoad = v.$el.find("img");
                        for (var E = 0; E < v.imagesToLoad.length; E += 1) {
                            var k = v.imagesToLoad[E];
                            v.loadImage(k, k.currentSrc || k.getAttribute("src"), k.srcset || k.getAttribute("srcset"), k.sizes || k.getAttribute("sizes"), !0, onReady)
                        }
                    }
                }
            }
              , fe = {}
              , he = function() {
                function Swiper() {
                    for (var v, E, k = arguments.length, R = new Array(k), U = 0; U < k; U++)
                        R[U] = arguments[U];
                    if (1 === R.length && R[0].constructor && "Object" === Object.prototype.toString.call(R[0]).slice(8, -1) ? E = R[0] : (v = R[0],
                    E = R[1]),
                    E || (E = {}),
                    E = utils_extend({}, E),
                    v && !E.el && (E.el = v),
                    E.el && K(E.el).length > 1) {
                        var H = [];
                        return K(E.el).each((function(v) {
                            var k = utils_extend({}, E, {
                                "el": v
                            });
                            H.push(new Swiper(k))
                        }
                        )),
                        H
                    }
                    var G = this;
                    G.__swiper__ = !0,
                    G.support = getSupport(),
                    G.device = getDevice({
                        "userAgent": E.userAgent
                    }),
                    G.browser = getBrowser(),
                    G.eventsListeners = {},
                    G.eventsAnyListeners = [],
                    void 0 === G.modules && (G.modules = {}),
                    Object.keys(G.modules).forEach((function(v) {
                        var k = G.modules[v];
                        if (k.params) {
                            var R = Object.keys(k.params)[0]
                              , U = k.params[R];
                            if ("object" != typeof U || null === U)
                                return;
                            if (["navigation", "pagination", "scrollbar"].indexOf(R) >= 0 && !0 === E[R] && (E[R] = {
                                "auto": !0
                            }),
                            !(R in E) || !("enabled"in U))
                                return;
                            !0 === E[R] && (E[R] = {
                                "enabled": !0
                            }),
                            "object" != typeof E[R] || "enabled"in E[R] || (E[R].enabled = !0),
                            E[R] || (E[R] = {
                                "enabled": !1
                            })
                        }
                    }
                    ));
                    var W = utils_extend({}, de);
                    return G.useParams(W),
                    G.params = utils_extend({}, W, fe, E),
                    G.originalParams = utils_extend({}, G.params),
                    G.passedParams = utils_extend({}, E),
                    G.params && G.params.on && Object.keys(G.params.on).forEach((function(v) {
                        G.on(v, G.params.on[v])
                    }
                    )),
                    G.params && G.params.onAny && G.onAny(G.params.onAny),
                    G.$ = K,
                    utils_extend(G, {
                        "enabled": G.params.enabled,
                        "el": v,
                        "classNames": [],
                        "slides": K(),
                        "slidesGrid": [],
                        "snapGrid": [],
                        "slidesSizesGrid": [],
                        "isHorizontal": function isHorizontal() {
                            return "horizontal" === G.params.direction
                        },
                        "isVertical": function isVertical() {
                            return "vertical" === G.params.direction
                        },
                        "activeIndex": 0,
                        "realIndex": 0,
                        "isBeginning": !0,
                        "isEnd": !1,
                        "translate": 0,
                        "previousTranslate": 0,
                        "progress": 0,
                        "velocity": 0,
                        "animating": !1,
                        "allowSlideNext": G.params.allowSlideNext,
                        "allowSlidePrev": G.params.allowSlidePrev,
                        "touchEvents": function touchEvents() {
                            var v = ["touchstart", "touchmove", "touchend", "touchcancel"]
                              , E = ["mousedown", "mousemove", "mouseup"];
                            return G.support.pointerEvents && (E = ["pointerdown", "pointermove", "pointerup"]),
                            G.touchEventsTouch = {
                                "start": v[0],
                                "move": v[1],
                                "end": v[2],
                                "cancel": v[3]
                            },
                            G.touchEventsDesktop = {
                                "start": E[0],
                                "move": E[1],
                                "end": E[2]
                            },
                            G.support.touch || !G.params.simulateTouch ? G.touchEventsTouch : G.touchEventsDesktop
                        }(),
                        "touchEventsData": {
                            "isTouched": void 0,
                            "isMoved": void 0,
                            "allowTouchCallbacks": void 0,
                            "touchStartTime": void 0,
                            "isScrolling": void 0,
                            "currentTranslate": void 0,
                            "startTranslate": void 0,
                            "allowThresholdMove": void 0,
                            "focusableElements": G.params.focusableElements,
                            "lastClickTime": now(),
                            "clickTimeout": void 0,
                            "velocities": [],
                            "allowMomentumBounce": void 0,
                            "isTouchEvent": void 0,
                            "startMoving": void 0
                        },
                        "allowClick": !0,
                        "allowTouchMove": G.params.allowTouchMove,
                        "touches": {
                            "startX": 0,
                            "startY": 0,
                            "currentX": 0,
                            "currentY": 0,
                            "diff": 0
                        },
                        "imagesToLoad": [],
                        "imagesLoaded": 0
                    }),
                    G.useModules(),
                    G.emit("_swiper"),
                    G.params.init && G.init(),
                    G
                }
                var v = Swiper.prototype;
                return v.enable = function enable() {
                    var v = this;
                    v.enabled || (v.enabled = !0,
                    v.params.grabCursor && v.setGrabCursor(),
                    v.emit("enable"))
                }
                ,
                v.disable = function disable() {
                    var v = this;
                    v.enabled && (v.enabled = !1,
                    v.params.grabCursor && v.unsetGrabCursor(),
                    v.emit("disable"))
                }
                ,
                v.setProgress = function setProgress(v, E) {
                    var k = this;
                    v = Math.min(Math.max(v, 0), 1);
                    var R = k.minTranslate()
                      , U = (k.maxTranslate() - R) * v + R;
                    k.translateTo(U, void 0 === E ? 0 : E),
                    k.updateActiveIndex(),
                    k.updateSlidesClasses()
                }
                ,
                v.emitContainerClasses = function emitContainerClasses() {
                    var v = this;
                    if (v.params._emitClasses && v.el) {
                        var E = v.el.className.split(" ").filter((function(E) {
                            return 0 === E.indexOf("swiper-container") || 0 === E.indexOf(v.params.containerModifierClass)
                        }
                        ));
                        v.emit("_containerClasses", E.join(" "))
                    }
                }
                ,
                v.getSlideClasses = function getSlideClasses(v) {
                    var E = this;
                    return v.className.split(" ").filter((function(v) {
                        return 0 === v.indexOf("swiper-slide") || 0 === v.indexOf(E.params.slideClass)
                    }
                    )).join(" ")
                }
                ,
                v.emitSlidesClasses = function emitSlidesClasses() {
                    var v = this;
                    if (v.params._emitClasses && v.el) {
                        var E = [];
                        v.slides.each((function(k) {
                            var R = v.getSlideClasses(k);
                            E.push({
                                "slideEl": k,
                                "classNames": R
                            }),
                            v.emit("_slideClass", k, R)
                        }
                        )),
                        v.emit("_slideClasses", E)
                    }
                }
                ,
                v.slidesPerViewDynamic = function slidesPerViewDynamic() {
                    var v = this
                      , E = v.params
                      , k = v.slides
                      , R = v.slidesGrid
                      , U = v.size
                      , H = v.activeIndex
                      , G = 1;
                    if (E.centeredSlides) {
                        for (var W, Z = k[H].swiperSlideSize, Y = H + 1; Y < k.length; Y += 1)
                            k[Y] && !W && (G += 1,
                            (Z += k[Y].swiperSlideSize) > U && (W = !0));
                        for (var J = H - 1; J >= 0; J -= 1)
                            k[J] && !W && (G += 1,
                            (Z += k[J].swiperSlideSize) > U && (W = !0))
                    } else
                        for (var K = H + 1; K < k.length; K += 1)
                            R[K] - R[H] < U && (G += 1);
                    return G
                }
                ,
                v.update = function update() {
                    var v = this;
                    if (v && !v.destroyed) {
                        var E = v.snapGrid
                          , k = v.params;
                        k.breakpoints && v.setBreakpoint(),
                        v.updateSize(),
                        v.updateSlides(),
                        v.updateProgress(),
                        v.updateSlidesClasses(),
                        v.params.freeMode ? (setTranslate(),
                        v.params.autoHeight && v.updateAutoHeight()) : (("auto" === v.params.slidesPerView || v.params.slidesPerView > 1) && v.isEnd && !v.params.centeredSlides ? v.slideTo(v.slides.length - 1, 0, !1, !0) : v.slideTo(v.activeIndex, 0, !1, !0)) || setTranslate(),
                        k.watchOverflow && E !== v.snapGrid && v.checkOverflow(),
                        v.emit("update")
                    }
                    function setTranslate() {
                        var E = v.rtlTranslate ? -1 * v.translate : v.translate
                          , k = Math.min(Math.max(E, v.maxTranslate()), v.minTranslate());
                        v.setTranslate(k),
                        v.updateActiveIndex(),
                        v.updateSlidesClasses()
                    }
                }
                ,
                v.changeDirection = function changeDirection(v, E) {
                    void 0 === E && (E = !0);
                    var k = this
                      , R = k.params.direction;
                    return v || (v = "horizontal" === R ? "vertical" : "horizontal"),
                    v === R || "horizontal" !== v && "vertical" !== v || (k.$el.removeClass("" + k.params.containerModifierClass + R).addClass("" + k.params.containerModifierClass + v),
                    k.emitContainerClasses(),
                    k.params.direction = v,
                    k.slides.each((function(E) {
                        "vertical" === v ? E.style.width = "" : E.style.height = ""
                    }
                    )),
                    k.emit("changeDirection"),
                    E && k.update()),
                    k
                }
                ,
                v.mount = function mount(v) {
                    var E = this;
                    if (E.mounted)
                        return !0;
                    var k = K(v || E.params.el);
                    if (!(v = k[0]))
                        return !1;
                    v.swiper = E;
                    var R = function getWrapperSelector() {
                        return "." + (E.params.wrapperClass || "").trim().split(" ").join(".")
                    }
                      , U = function getWrapper() {
                        if (v && v.shadowRoot && v.shadowRoot.querySelector) {
                            var E = K(v.shadowRoot.querySelector(R()));
                            return E.children = function(v) {
                                return k.children(v)
                            }
                            ,
                            E
                        }
                        return k.children(R())
                    }();
                    if (0 === U.length && E.params.createElements) {
                        var H = getDocument().createElement("div");
                        U = K(H),
                        H.className = E.params.wrapperClass,
                        k.append(H),
                        k.children("." + E.params.slideClass).each((function(v) {
                            U.append(v)
                        }
                        ))
                    }
                    return utils_extend(E, {
                        "$el": k,
                        "el": v,
                        "$wrapperEl": U,
                        "wrapperEl": U[0],
                        "mounted": !0,
                        "rtl": "rtl" === v.dir.toLowerCase() || "rtl" === k.css("direction"),
                        "rtlTranslate": "horizontal" === E.params.direction && ("rtl" === v.dir.toLowerCase() || "rtl" === k.css("direction")),
                        "wrongRTL": "-webkit-box" === U.css("display")
                    }),
                    !0
                }
                ,
                v.init = function init(v) {
                    var E = this;
                    return E.initialized || !1 === E.mount(v) || (E.emit("beforeInit"),
                    E.params.breakpoints && E.setBreakpoint(),
                    E.addClasses(),
                    E.params.loop && E.loopCreate(),
                    E.updateSize(),
                    E.updateSlides(),
                    E.params.watchOverflow && E.checkOverflow(),
                    E.params.grabCursor && E.enabled && E.setGrabCursor(),
                    E.params.preloadImages && E.preloadImages(),
                    E.params.loop ? E.slideTo(E.params.initialSlide + E.loopedSlides, 0, E.params.runCallbacksOnInit, !1, !0) : E.slideTo(E.params.initialSlide, 0, E.params.runCallbacksOnInit, !1, !0),
                    E.attachEvents(),
                    E.initialized = !0,
                    E.emit("init"),
                    E.emit("afterInit")),
                    E
                }
                ,
                v.destroy = function destroy(v, E) {
                    void 0 === v && (v = !0),
                    void 0 === E && (E = !0);
                    var k = this
                      , R = k.params
                      , U = k.$el
                      , H = k.$wrapperEl
                      , G = k.slides;
                    return void 0 === k.params || k.destroyed || (k.emit("beforeDestroy"),
                    k.initialized = !1,
                    k.detachEvents(),
                    R.loop && k.loopDestroy(),
                    E && (k.removeClasses(),
                    U.removeAttr("style"),
                    H.removeAttr("style"),
                    G && G.length && G.removeClass([R.slideVisibleClass, R.slideActiveClass, R.slideNextClass, R.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index")),
                    k.emit("destroy"),
                    Object.keys(k.eventsListeners).forEach((function(v) {
                        k.off(v)
                    }
                    )),
                    !1 !== v && (k.$el[0].swiper = null,
                    function deleteProps(v) {
                        var E = v;
                        Object.keys(E).forEach((function(v) {
                            try {
                                E[v] = null
                            } catch (v) {}
                            try {
                                delete E[v]
                            } catch (v) {}
                        }
                        ))
                    }(k)),
                    k.destroyed = !0),
                    null
                }
                ,
                Swiper.extendDefaults = function extendDefaults(v) {
                    utils_extend(fe, v)
                }
                ,
                Swiper.installModule = function installModule(v) {
                    Swiper.prototype.modules || (Swiper.prototype.modules = {});
                    var E = v.name || Object.keys(Swiper.prototype.modules).length + "_" + now();
                    Swiper.prototype.modules[E] = v
                }
                ,
                Swiper.use = function use(v) {
                    return Array.isArray(v) ? (v.forEach((function(v) {
                        return Swiper.installModule(v)
                    }
                    )),
                    Swiper) : (Swiper.installModule(v),
                    Swiper)
                }
                ,
                function _createClass(v, E, k) {
                    return E && _defineProperties(v.prototype, E),
                    k && _defineProperties(v, k),
                    v
                }(Swiper, null, [{
                    "key": "extendedDefaults",
                    "get": function get() {
                        return fe
                    }
                }, {
                    "key": "defaults",
                    "get": function get() {
                        return de
                    }
                }]),
                Swiper
            }();
            Object.keys(pe).forEach((function(v) {
                Object.keys(pe[v]).forEach((function(E) {
                    he.prototype[E] = pe[v][E]
                }
                ))
            }
            )),
            he.use([X, ee]);
            var me = he;
            function virtual_extends() {
                return virtual_extends = Object.assign || function(v) {
                    for (var E = 1; E < arguments.length; E++) {
                        var k = arguments[E];
                        for (var R in k)
                            Object.prototype.hasOwnProperty.call(k, R) && (v[R] = k[R])
                    }
                    return v
                }
                ,
                virtual_extends.apply(this, arguments)
            }
            var ge = {
                "update": function update(v) {
                    var E = this
                      , k = E.params
                      , R = k.slidesPerView
                      , U = k.slidesPerGroup
                      , H = k.centeredSlides
                      , G = E.params.virtual
                      , W = G.addSlidesBefore
                      , Z = G.addSlidesAfter
                      , Y = E.virtual
                      , J = Y.from
                      , K = Y.to
                      , X = Y.slides
                      , Q = Y.slidesGrid
                      , ee = Y.renderSlide
                      , te = Y.offset;
                    E.updateActiveIndex();
                    var ne, re, oe, ie = E.activeIndex || 0;
                    ne = E.rtlTranslate ? "right" : E.isHorizontal() ? "left" : "top",
                    H ? (re = Math.floor(R / 2) + U + Z,
                    oe = Math.floor(R / 2) + U + W) : (re = R + (U - 1) + Z,
                    oe = U + W);
                    var ae = Math.max((ie || 0) - oe, 0)
                      , se = Math.min((ie || 0) + re, X.length - 1)
                      , ce = (E.slidesGrid[ae] || 0) - (E.slidesGrid[0] || 0);
                    function onRendered() {
                        E.updateSlides(),
                        E.updateProgress(),
                        E.updateSlidesClasses(),
                        E.lazy && E.params.lazy.enabled && E.lazy.load()
                    }
                    if (utils_extend(E.virtual, {
                        "from": ae,
                        "to": se,
                        "offset": ce,
                        "slidesGrid": E.slidesGrid
                    }),
                    J === ae && K === se && !v)
                        return E.slidesGrid !== Q && ce !== te && E.slides.css(ne, ce + "px"),
                        void E.updateProgress();
                    if (E.params.virtual.renderExternal)
                        return E.params.virtual.renderExternal.call(E, {
                            "offset": ce,
                            "from": ae,
                            "to": se,
                            "slides": function getSlides() {
                                for (var v = [], E = ae; E <= se; E += 1)
                                    v.push(X[E]);
                                return v
                            }()
                        }),
                        void (E.params.virtual.renderExternalUpdate && onRendered());
                    var le = []
                      , ue = [];
                    if (v)
                        E.$wrapperEl.find("." + E.params.slideClass).remove();
                    else
                        for (var de = J; de <= K; de += 1)
                            (de < ae || de > se) && E.$wrapperEl.find("." + E.params.slideClass + '[data-swiper-slide-index="' + de + '"]').remove();
                    for (var pe = 0; pe < X.length; pe += 1)
                        pe >= ae && pe <= se && (void 0 === K || v ? ue.push(pe) : (pe > K && ue.push(pe),
                        pe < J && le.push(pe)));
                    ue.forEach((function(v) {
                        E.$wrapperEl.append(ee(X[v], v))
                    }
                    )),
                    le.sort((function(v, E) {
                        return E - v
                    }
                    )).forEach((function(v) {
                        E.$wrapperEl.prepend(ee(X[v], v))
                    }
                    )),
                    E.$wrapperEl.children(".swiper-slide").css(ne, ce + "px"),
                    onRendered()
                },
                "renderSlide": function renderSlide(v, E) {
                    var k = this
                      , R = k.params.virtual;
                    if (R.cache && k.virtual.cache[E])
                        return k.virtual.cache[E];
                    var U = R.renderSlide ? K(R.renderSlide.call(k, v, E)) : K('<div class="' + k.params.slideClass + '" data-swiper-slide-index="' + E + '">' + v + "</div>");
                    return U.attr("data-swiper-slide-index") || U.attr("data-swiper-slide-index", E),
                    R.cache && (k.virtual.cache[E] = U),
                    U
                },
                "appendSlide": function appendSlide(v) {
                    var E = this;
                    if ("object" == typeof v && "length"in v)
                        for (var k = 0; k < v.length; k += 1)
                            v[k] && E.virtual.slides.push(v[k]);
                    else
                        E.virtual.slides.push(v);
                    E.virtual.update(!0)
                },
                "prependSlide": function prependSlide(v) {
                    var E = this
                      , k = E.activeIndex
                      , R = k + 1
                      , U = 1;
                    if (Array.isArray(v)) {
                        for (var H = 0; H < v.length; H += 1)
                            v[H] && E.virtual.slides.unshift(v[H]);
                        R = k + v.length,
                        U = v.length
                    } else
                        E.virtual.slides.unshift(v);
                    if (E.params.virtual.cache) {
                        var G = E.virtual.cache
                          , W = {};
                        Object.keys(G).forEach((function(v) {
                            var E = G[v]
                              , k = E.attr("data-swiper-slide-index");
                            k && E.attr("data-swiper-slide-index", parseInt(k, 10) + 1),
                            W[parseInt(v, 10) + U] = E
                        }
                        )),
                        E.virtual.cache = W
                    }
                    E.virtual.update(!0),
                    E.slideTo(R, 0)
                },
                "removeSlide": function removeSlide(v) {
                    var E = this;
                    if (null != v) {
                        var k = E.activeIndex;
                        if (Array.isArray(v))
                            for (var R = v.length - 1; R >= 0; R -= 1)
                                E.virtual.slides.splice(v[R], 1),
                                E.params.virtual.cache && delete E.virtual.cache[v[R]],
                                v[R] < k && (k -= 1),
                                k = Math.max(k, 0);
                        else
                            E.virtual.slides.splice(v, 1),
                            E.params.virtual.cache && delete E.virtual.cache[v],
                            v < k && (k -= 1),
                            k = Math.max(k, 0);
                        E.virtual.update(!0),
                        E.slideTo(k, 0)
                    }
                },
                "removeAllSlides": function removeAllSlides() {
                    var v = this;
                    v.virtual.slides = [],
                    v.params.virtual.cache && (v.virtual.cache = {}),
                    v.virtual.update(!0),
                    v.slideTo(0, 0)
                }
            }
              , _e = {
                "name": "virtual",
                "params": {
                    "virtual": {
                        "enabled": !1,
                        "slides": [],
                        "cache": !0,
                        "renderSlide": null,
                        "renderExternal": null,
                        "renderExternalUpdate": !0,
                        "addSlidesBefore": 0,
                        "addSlidesAfter": 0
                    }
                },
                "create": function create() {
                    bindModuleMethods(this, {
                        "virtual": virtual_extends({}, ge, {
                            "slides": this.params.virtual.slides,
                            "cache": {}
                        })
                    })
                },
                "on": {
                    "beforeInit": function beforeInit(v) {
                        if (v.params.virtual.enabled) {
                            v.classNames.push(v.params.containerModifierClass + "virtual");
                            var E = {
                                "watchSlidesProgress": !0
                            };
                            utils_extend(v.params, E),
                            utils_extend(v.originalParams, E),
                            v.params.initialSlide || v.virtual.update()
                        }
                    },
                    "setTranslate": function setTranslate(v) {
                        v.params.virtual.enabled && v.virtual.update()
                    }
                }
            };
            function keyboard_extends() {
                return keyboard_extends = Object.assign || function(v) {
                    for (var E = 1; E < arguments.length; E++) {
                        var k = arguments[E];
                        for (var R in k)
                            Object.prototype.hasOwnProperty.call(k, R) && (v[R] = k[R])
                    }
                    return v
                }
                ,
                keyboard_extends.apply(this, arguments)
            }
            var ve = {
                "handle": function handle(v) {
                    var E = this;
                    if (E.enabled) {
                        var k = ssr_window_esm_getWindow()
                          , R = getDocument()
                          , U = E.rtlTranslate
                          , H = v;
                        H.originalEvent && (H = H.originalEvent);
                        var G = H.keyCode || H.charCode
                          , W = E.params.keyboard.pageUpDown
                          , Z = W && 33 === G
                          , Y = W && 34 === G
                          , J = 37 === G
                          , K = 39 === G
                          , X = 38 === G
                          , Q = 40 === G;
                        if (!E.allowSlideNext && (E.isHorizontal() && K || E.isVertical() && Q || Y))
                            return !1;
                        if (!E.allowSlidePrev && (E.isHorizontal() && J || E.isVertical() && X || Z))
                            return !1;
                        if (!(H.shiftKey || H.altKey || H.ctrlKey || H.metaKey || R.activeElement && R.activeElement.nodeName && ("input" === R.activeElement.nodeName.toLowerCase() || "textarea" === R.activeElement.nodeName.toLowerCase()))) {
                            if (E.params.keyboard.onlyInViewport && (Z || Y || J || K || X || Q)) {
                                var ee = !1;
                                if (E.$el.parents("." + E.params.slideClass).length > 0 && 0 === E.$el.parents("." + E.params.slideActiveClass).length)
                                    return;
                                var te = E.$el
                                  , ne = te[0].clientWidth
                                  , re = te[0].clientHeight
                                  , oe = k.innerWidth
                                  , ie = k.innerHeight
                                  , ae = E.$el.offset();
                                U && (ae.left -= E.$el[0].scrollLeft);
                                for (var se = [[ae.left, ae.top], [ae.left + ne, ae.top], [ae.left, ae.top + re], [ae.left + ne, ae.top + re]], ce = 0; ce < se.length; ce += 1) {
                                    var le = se[ce];
                                    if (le[0] >= 0 && le[0] <= oe && le[1] >= 0 && le[1] <= ie) {
                                        if (0 === le[0] && 0 === le[1])
                                            continue;
                                        ee = !0
                                    }
                                }
                                if (!ee)
                                    return
                            }
                            E.isHorizontal() ? ((Z || Y || J || K) && (H.preventDefault ? H.preventDefault() : H.returnValue = !1),
                            ((Y || K) && !U || (Z || J) && U) && E.slideNext(),
                            ((Z || J) && !U || (Y || K) && U) && E.slidePrev()) : ((Z || Y || X || Q) && (H.preventDefault ? H.preventDefault() : H.returnValue = !1),
                            (Y || Q) && E.slideNext(),
                            (Z || X) && E.slidePrev()),
                            E.emit("keyPress", G)
                        }
                    }
                },
                "enable": function enable() {
                    var v = this
                      , E = getDocument();
                    v.keyboard.enabled || (K(E).on("keydown", v.keyboard.handle),
                    v.keyboard.enabled = !0)
                },
                "disable": function disable() {
                    var v = this
                      , E = getDocument();
                    v.keyboard.enabled && (K(E).off("keydown", v.keyboard.handle),
                    v.keyboard.enabled = !1)
                }
            }
              , ye = {
                "name": "keyboard",
                "params": {
                    "keyboard": {
                        "enabled": !1,
                        "onlyInViewport": !0,
                        "pageUpDown": !0
                    }
                },
                "create": function create() {
                    bindModuleMethods(this, {
                        "keyboard": keyboard_extends({
                            "enabled": !1
                        }, ve)
                    })
                },
                "on": {
                    "init": function init(v) {
                        v.params.keyboard.enabled && v.keyboard.enable()
                    },
                    "destroy": function destroy(v) {
                        v.keyboard.enabled && v.keyboard.disable()
                    }
                }
            };
            var be = {
                "lastScrollTime": now(),
                "lastEventBeforeSnap": void 0,
                "recentWheelEvents": [],
                "event": function event() {
                    return ssr_window_esm_getWindow().navigator.userAgent.indexOf("firefox") > -1 ? "DOMMouseScroll" : function isEventSupported() {
                        var v = getDocument()
                          , E = "onwheel"
                          , k = E in v;
                        if (!k) {
                            var R = v.createElement("div");
                            R.setAttribute(E, "return;"),
                            k = "function" == typeof R[E]
                        }
                        return !k && v.implementation && v.implementation.hasFeature && !0 !== v.implementation.hasFeature("", "") && (k = v.implementation.hasFeature("Events.wheel", "3.0")),
                        k
                    }() ? "wheel" : "mousewheel"
                },
                "normalize": function normalize(v) {
                    var E = 0
                      , k = 0
                      , R = 0
                      , U = 0;
                    return "detail"in v && (k = v.detail),
                    "wheelDelta"in v && (k = -v.wheelDelta / 120),
                    "wheelDeltaY"in v && (k = -v.wheelDeltaY / 120),
                    "wheelDeltaX"in v && (E = -v.wheelDeltaX / 120),
                    "axis"in v && v.axis === v.HORIZONTAL_AXIS && (E = k,
                    k = 0),
                    R = 10 * E,
                    U = 10 * k,
                    "deltaY"in v && (U = v.deltaY),
                    "deltaX"in v && (R = v.deltaX),
                    v.shiftKey && !R && (R = U,
                    U = 0),
                    (R || U) && v.deltaMode && (1 === v.deltaMode ? (R *= 40,
                    U *= 40) : (R *= 800,
                    U *= 800)),
                    R && !E && (E = R < 1 ? -1 : 1),
                    U && !k && (k = U < 1 ? -1 : 1),
                    {
                        "spinX": E,
                        "spinY": k,
                        "pixelX": R,
                        "pixelY": U
                    }
                },
                "handleMouseEnter": function handleMouseEnter() {
                    this.enabled && (this.mouseEntered = !0)
                },
                "handleMouseLeave": function handleMouseLeave() {
                    this.enabled && (this.mouseEntered = !1)
                },
                "handle": function handle(v) {
                    var E = v
                      , k = this;
                    if (k.enabled) {
                        var R = k.params.mousewheel;
                        k.params.cssMode && E.preventDefault();
                        var U = k.$el;
                        if ("container" !== k.params.mousewheel.eventsTarget && (U = K(k.params.mousewheel.eventsTarget)),
                        !k.mouseEntered && !U[0].contains(E.target) && !R.releaseOnEdges)
                            return !0;
                        E.originalEvent && (E = E.originalEvent);
                        var H = 0
                          , G = k.rtlTranslate ? -1 : 1
                          , W = be.normalize(E);
                        if (R.forceToAxis)
                            if (k.isHorizontal()) {
                                if (!(Math.abs(W.pixelX) > Math.abs(W.pixelY)))
                                    return !0;
                                H = -W.pixelX * G
                            } else {
                                if (!(Math.abs(W.pixelY) > Math.abs(W.pixelX)))
                                    return !0;
                                H = -W.pixelY
                            }
                        else
                            H = Math.abs(W.pixelX) > Math.abs(W.pixelY) ? -W.pixelX * G : -W.pixelY;
                        if (0 === H)
                            return !0;
                        R.invert && (H = -H);
                        var Z = k.getTranslate() + H * R.sensitivity;
                        if (Z >= k.minTranslate() && (Z = k.minTranslate()),
                        Z <= k.maxTranslate() && (Z = k.maxTranslate()),
                        (!!k.params.loop || !(Z === k.minTranslate() || Z === k.maxTranslate())) && k.params.nested && E.stopPropagation(),
                        k.params.freeMode) {
                            var Y = {
                                "time": now(),
                                "delta": Math.abs(H),
                                "direction": Math.sign(H)
                            }
                              , J = k.mousewheel.lastEventBeforeSnap
                              , X = J && Y.time < J.time + 500 && Y.delta <= J.delta && Y.direction === J.direction;
                            if (!X) {
                                k.mousewheel.lastEventBeforeSnap = void 0,
                                k.params.loop && k.loopFix();
                                var Q = k.getTranslate() + H * R.sensitivity
                                  , ee = k.isBeginning
                                  , te = k.isEnd;
                                if (Q >= k.minTranslate() && (Q = k.minTranslate()),
                                Q <= k.maxTranslate() && (Q = k.maxTranslate()),
                                k.setTransition(0),
                                k.setTranslate(Q),
                                k.updateProgress(),
                                k.updateActiveIndex(),
                                k.updateSlidesClasses(),
                                (!ee && k.isBeginning || !te && k.isEnd) && k.updateSlidesClasses(),
                                k.params.freeModeSticky) {
                                    clearTimeout(k.mousewheel.timeout),
                                    k.mousewheel.timeout = void 0;
                                    var ne = k.mousewheel.recentWheelEvents;
                                    ne.length >= 15 && ne.shift();
                                    var re = ne.length ? ne[ne.length - 1] : void 0
                                      , oe = ne[0];
                                    if (ne.push(Y),
                                    re && (Y.delta > re.delta || Y.direction !== re.direction))
                                        ne.splice(0);
                                    else if (ne.length >= 15 && Y.time - oe.time < 500 && oe.delta - Y.delta >= 1 && Y.delta <= 6) {
                                        var ie = H > 0 ? .8 : .2;
                                        k.mousewheel.lastEventBeforeSnap = Y,
                                        ne.splice(0),
                                        k.mousewheel.timeout = nextTick((function() {
                                            k.slideToClosest(k.params.speed, !0, void 0, ie)
                                        }
                                        ), 0)
                                    }
                                    k.mousewheel.timeout || (k.mousewheel.timeout = nextTick((function() {
                                        k.mousewheel.lastEventBeforeSnap = Y,
                                        ne.splice(0),
                                        k.slideToClosest(k.params.speed, !0, void 0, .5)
                                    }
                                    ), 500))
                                }
                                if (X || k.emit("scroll", E),
                                k.params.autoplay && k.params.autoplayDisableOnInteraction && k.autoplay.stop(),
                                Q === k.minTranslate() || Q === k.maxTranslate())
                                    return !0
                            }
                        } else {
                            var ae = {
                                "time": now(),
                                "delta": Math.abs(H),
                                "direction": Math.sign(H),
                                "raw": v
                            }
                              , se = k.mousewheel.recentWheelEvents;
                            se.length >= 2 && se.shift();
                            var ce = se.length ? se[se.length - 1] : void 0;
                            if (se.push(ae),
                            ce ? (ae.direction !== ce.direction || ae.delta > ce.delta || ae.time > ce.time + 150) && k.mousewheel.animateSlider(ae) : k.mousewheel.animateSlider(ae),
                            k.mousewheel.releaseScroll(ae))
                                return !0
                        }
                        return E.preventDefault ? E.preventDefault() : E.returnValue = !1,
                        !1
                    }
                },
                "animateSlider": function animateSlider(v) {
                    var E = this
                      , k = ssr_window_esm_getWindow();
                    return !(this.params.mousewheel.thresholdDelta && v.delta < this.params.mousewheel.thresholdDelta) && (!(this.params.mousewheel.thresholdTime && now() - E.mousewheel.lastScrollTime < this.params.mousewheel.thresholdTime) && (v.delta >= 6 && now() - E.mousewheel.lastScrollTime < 60 || (v.direction < 0 ? E.isEnd && !E.params.loop || E.animating || (E.slideNext(),
                    E.emit("scroll", v.raw)) : E.isBeginning && !E.params.loop || E.animating || (E.slidePrev(),
                    E.emit("scroll", v.raw)),
                    E.mousewheel.lastScrollTime = (new k.Date).getTime(),
                    !1)))
                },
                "releaseScroll": function releaseScroll(v) {
                    var E = this
                      , k = E.params.mousewheel;
                    if (v.direction < 0) {
                        if (E.isEnd && !E.params.loop && k.releaseOnEdges)
                            return !0
                    } else if (E.isBeginning && !E.params.loop && k.releaseOnEdges)
                        return !0;
                    return !1
                },
                "enable": function enable() {
                    var v = this
                      , E = be.event();
                    if (v.params.cssMode)
                        return v.wrapperEl.removeEventListener(E, v.mousewheel.handle),
                        !0;
                    if (!E)
                        return !1;
                    if (v.mousewheel.enabled)
                        return !1;
                    var k = v.$el;
                    return "container" !== v.params.mousewheel.eventsTarget && (k = K(v.params.mousewheel.eventsTarget)),
                    k.on("mouseenter", v.mousewheel.handleMouseEnter),
                    k.on("mouseleave", v.mousewheel.handleMouseLeave),
                    k.on(E, v.mousewheel.handle),
                    v.mousewheel.enabled = !0,
                    !0
                },
                "disable": function disable() {
                    var v = this
                      , E = be.event();
                    if (v.params.cssMode)
                        return v.wrapperEl.addEventListener(E, v.mousewheel.handle),
                        !0;
                    if (!E)
                        return !1;
                    if (!v.mousewheel.enabled)
                        return !1;
                    var k = v.$el;
                    return "container" !== v.params.mousewheel.eventsTarget && (k = K(v.params.mousewheel.eventsTarget)),
                    k.off(E, v.mousewheel.handle),
                    v.mousewheel.enabled = !1,
                    !0
                }
            };
            function navigation_extends() {
                return navigation_extends = Object.assign || function(v) {
                    for (var E = 1; E < arguments.length; E++) {
                        var k = arguments[E];
                        for (var R in k)
                            Object.prototype.hasOwnProperty.call(k, R) && (v[R] = k[R])
                    }
                    return v
                }
                ,
                navigation_extends.apply(this, arguments)
            }
            var Se = {
                "toggleEl": function toggleEl(v, E) {
                    v[E ? "addClass" : "removeClass"](this.params.navigation.disabledClass),
                    v[0] && "BUTTON" === v[0].tagName && (v[0].disabled = E)
                },
                "update": function update() {
                    var v = this
                      , E = v.params.navigation
                      , k = v.navigation.toggleEl;
                    if (!v.params.loop) {
                        var R = v.navigation
                          , U = R.$nextEl
                          , H = R.$prevEl;
                        H && H.length > 0 && (v.isBeginning ? k(H, !0) : k(H, !1),
                        v.params.watchOverflow && v.enabled && H[v.isLocked ? "addClass" : "removeClass"](E.lockClass)),
                        U && U.length > 0 && (v.isEnd ? k(U, !0) : k(U, !1),
                        v.params.watchOverflow && v.enabled && U[v.isLocked ? "addClass" : "removeClass"](E.lockClass))
                    }
                },
                "onPrevClick": function onPrevClick(v) {
                    var E = this;
                    v.preventDefault(),
                    E.isBeginning && !E.params.loop || E.slidePrev()
                },
                "onNextClick": function onNextClick(v) {
                    var E = this;
                    v.preventDefault(),
                    E.isEnd && !E.params.loop || E.slideNext()
                },
                "init": function init() {
                    var v, E, k = this, R = k.params.navigation;
                    (k.params.navigation = createElementIfNotDefined(k.$el, k.params.navigation, k.params.createElements, {
                        "nextEl": "swiper-button-next",
                        "prevEl": "swiper-button-prev"
                    }),
                    R.nextEl || R.prevEl) && (R.nextEl && (v = K(R.nextEl),
                    k.params.uniqueNavElements && "string" == typeof R.nextEl && v.length > 1 && 1 === k.$el.find(R.nextEl).length && (v = k.$el.find(R.nextEl))),
                    R.prevEl && (E = K(R.prevEl),
                    k.params.uniqueNavElements && "string" == typeof R.prevEl && E.length > 1 && 1 === k.$el.find(R.prevEl).length && (E = k.$el.find(R.prevEl))),
                    v && v.length > 0 && v.on("click", k.navigation.onNextClick),
                    E && E.length > 0 && E.on("click", k.navigation.onPrevClick),
                    utils_extend(k.navigation, {
                        "$nextEl": v,
                        "nextEl": v && v[0],
                        "$prevEl": E,
                        "prevEl": E && E[0]
                    }),
                    k.enabled || (v && v.addClass(R.lockClass),
                    E && E.addClass(R.lockClass)))
                },
                "destroy": function destroy() {
                    var v = this
                      , E = v.navigation
                      , k = E.$nextEl
                      , R = E.$prevEl;
                    k && k.length && (k.off("click", v.navigation.onNextClick),
                    k.removeClass(v.params.navigation.disabledClass)),
                    R && R.length && (R.off("click", v.navigation.onPrevClick),
                    R.removeClass(v.params.navigation.disabledClass))
                }
            };
            function pagination_extends() {
                return pagination_extends = Object.assign || function(v) {
                    for (var E = 1; E < arguments.length; E++) {
                        var k = arguments[E];
                        for (var R in k)
                            Object.prototype.hasOwnProperty.call(k, R) && (v[R] = k[R])
                    }
                    return v
                }
                ,
                pagination_extends.apply(this, arguments)
            }
            var we = {
                "update": function update() {
                    var v = this
                      , E = v.rtl
                      , k = v.params.pagination;
                    if (k.el && v.pagination.el && v.pagination.$el && 0 !== v.pagination.$el.length) {
                        var R, U = v.virtual && v.params.virtual.enabled ? v.virtual.slides.length : v.slides.length, H = v.pagination.$el, G = v.params.loop ? Math.ceil((U - 2 * v.loopedSlides) / v.params.slidesPerGroup) : v.snapGrid.length;
                        if (v.params.loop ? ((R = Math.ceil((v.activeIndex - v.loopedSlides) / v.params.slidesPerGroup)) > U - 1 - 2 * v.loopedSlides && (R -= U - 2 * v.loopedSlides),
                        R > G - 1 && (R -= G),
                        R < 0 && "bullets" !== v.params.paginationType && (R = G + R)) : R = void 0 !== v.snapIndex ? v.snapIndex : v.activeIndex || 0,
                        "bullets" === k.type && v.pagination.bullets && v.pagination.bullets.length > 0) {
                            var W, Z, Y, J = v.pagination.bullets;
                            if (k.dynamicBullets && (v.pagination.bulletSize = J.eq(0)[v.isHorizontal() ? "outerWidth" : "outerHeight"](!0),
                            H.css(v.isHorizontal() ? "width" : "height", v.pagination.bulletSize * (k.dynamicMainBullets + 4) + "px"),
                            k.dynamicMainBullets > 1 && void 0 !== v.previousIndex && (v.pagination.dynamicBulletIndex += R - v.previousIndex,
                            v.pagination.dynamicBulletIndex > k.dynamicMainBullets - 1 ? v.pagination.dynamicBulletIndex = k.dynamicMainBullets - 1 : v.pagination.dynamicBulletIndex < 0 && (v.pagination.dynamicBulletIndex = 0)),
                            W = R - v.pagination.dynamicBulletIndex,
                            Y = ((Z = W + (Math.min(J.length, k.dynamicMainBullets) - 1)) + W) / 2),
                            J.removeClass(k.bulletActiveClass + " " + k.bulletActiveClass + "-next " + k.bulletActiveClass + "-next-next " + k.bulletActiveClass + "-prev " + k.bulletActiveClass + "-prev-prev " + k.bulletActiveClass + "-main"),
                            H.length > 1)
                                J.each((function(v) {
                                    var E = K(v)
                                      , U = E.index();
                                    U === R && E.addClass(k.bulletActiveClass),
                                    k.dynamicBullets && (U >= W && U <= Z && E.addClass(k.bulletActiveClass + "-main"),
                                    U === W && E.prev().addClass(k.bulletActiveClass + "-prev").prev().addClass(k.bulletActiveClass + "-prev-prev"),
                                    U === Z && E.next().addClass(k.bulletActiveClass + "-next").next().addClass(k.bulletActiveClass + "-next-next"))
                                }
                                ));
                            else {
                                var X = J.eq(R)
                                  , Q = X.index();
                                if (X.addClass(k.bulletActiveClass),
                                k.dynamicBullets) {
                                    for (var ee = J.eq(W), te = J.eq(Z), ne = W; ne <= Z; ne += 1)
                                        J.eq(ne).addClass(k.bulletActiveClass + "-main");
                                    if (v.params.loop)
                                        if (Q >= J.length - k.dynamicMainBullets) {
                                            for (var re = k.dynamicMainBullets; re >= 0; re -= 1)
                                                J.eq(J.length - re).addClass(k.bulletActiveClass + "-main");
                                            J.eq(J.length - k.dynamicMainBullets - 1).addClass(k.bulletActiveClass + "-prev")
                                        } else
                                            ee.prev().addClass(k.bulletActiveClass + "-prev").prev().addClass(k.bulletActiveClass + "-prev-prev"),
                                            te.next().addClass(k.bulletActiveClass + "-next").next().addClass(k.bulletActiveClass + "-next-next");
                                    else
                                        ee.prev().addClass(k.bulletActiveClass + "-prev").prev().addClass(k.bulletActiveClass + "-prev-prev"),
                                        te.next().addClass(k.bulletActiveClass + "-next").next().addClass(k.bulletActiveClass + "-next-next")
                                }
                            }
                            if (k.dynamicBullets) {
                                var oe = Math.min(J.length, k.dynamicMainBullets + 4)
                                  , ie = (v.pagination.bulletSize * oe - v.pagination.bulletSize) / 2 - Y * v.pagination.bulletSize
                                  , ae = E ? "right" : "left";
                                J.css(v.isHorizontal() ? ae : "top", ie + "px")
                            }
                        }
                        if ("fraction" === k.type && (H.find(classesToSelector(k.currentClass)).text(k.formatFractionCurrent(R + 1)),
                        H.find(classesToSelector(k.totalClass)).text(k.formatFractionTotal(G))),
                        "progressbar" === k.type) {
                            var se;
                            se = k.progressbarOpposite ? v.isHorizontal() ? "vertical" : "horizontal" : v.isHorizontal() ? "horizontal" : "vertical";
                            var ce = (R + 1) / G
                              , le = 1
                              , ue = 1;
                            "horizontal" === se ? le = ce : ue = ce,
                            H.find(classesToSelector(k.progressbarFillClass)).transform("translate3d(0,0,0) scaleX(" + le + ") scaleY(" + ue + ")").transition(v.params.speed)
                        }
                        "custom" === k.type && k.renderCustom ? (H.html(k.renderCustom(v, R + 1, G)),
                        v.emit("paginationRender", H[0])) : v.emit("paginationUpdate", H[0]),
                        v.params.watchOverflow && v.enabled && H[v.isLocked ? "addClass" : "removeClass"](k.lockClass)
                    }
                },
                "render": function render() {
                    var v = this
                      , E = v.params.pagination;
                    if (E.el && v.pagination.el && v.pagination.$el && 0 !== v.pagination.$el.length) {
                        var k = v.virtual && v.params.virtual.enabled ? v.virtual.slides.length : v.slides.length
                          , R = v.pagination.$el
                          , U = "";
                        if ("bullets" === E.type) {
                            var H = v.params.loop ? Math.ceil((k - 2 * v.loopedSlides) / v.params.slidesPerGroup) : v.snapGrid.length;
                            v.params.freeMode && !v.params.loop && H > k && (H = k);
                            for (var G = 0; G < H; G += 1)
                                E.renderBullet ? U += E.renderBullet.call(v, G, E.bulletClass) : U += "<" + E.bulletElement + ' class="' + E.bulletClass + '"></' + E.bulletElement + ">";
                            R.html(U),
                            v.pagination.bullets = R.find(classesToSelector(E.bulletClass))
                        }
                        "fraction" === E.type && (U = E.renderFraction ? E.renderFraction.call(v, E.currentClass, E.totalClass) : '<span class="' + E.currentClass + '"></span> / <span class="' + E.totalClass + '"></span>',
                        R.html(U)),
                        "progressbar" === E.type && (U = E.renderProgressbar ? E.renderProgressbar.call(v, E.progressbarFillClass) : '<span class="' + E.progressbarFillClass + '"></span>',
                        R.html(U)),
                        "custom" !== E.type && v.emit("paginationRender", v.pagination.$el[0])
                    }
                },
                "init": function init() {
                    var v = this;
                    v.params.pagination = createElementIfNotDefined(v.$el, v.params.pagination, v.params.createElements, {
                        "el": "swiper-pagination"
                    });
                    var E = v.params.pagination;
                    if (E.el) {
                        var k = K(E.el);
                        0 !== k.length && (v.params.uniqueNavElements && "string" == typeof E.el && k.length > 1 && (k = v.$el.find(E.el)),
                        "bullets" === E.type && E.clickable && k.addClass(E.clickableClass),
                        k.addClass(E.modifierClass + E.type),
                        "bullets" === E.type && E.dynamicBullets && (k.addClass("" + E.modifierClass + E.type + "-dynamic"),
                        v.pagination.dynamicBulletIndex = 0,
                        E.dynamicMainBullets < 1 && (E.dynamicMainBullets = 1)),
                        "progressbar" === E.type && E.progressbarOpposite && k.addClass(E.progressbarOppositeClass),
                        E.clickable && k.on("click", classesToSelector(E.bulletClass), (function onClick(E) {
                            E.preventDefault();
                            var k = K(this).index() * v.params.slidesPerGroup;
                            v.params.loop && (k += v.loopedSlides),
                            v.slideTo(k)
                        }
                        )),
                        utils_extend(v.pagination, {
                            "$el": k,
                            "el": k[0]
                        }),
                        v.enabled || k.addClass(E.lockClass))
                    }
                },
                "destroy": function destroy() {
                    var v = this
                      , E = v.params.pagination;
                    if (E.el && v.pagination.el && v.pagination.$el && 0 !== v.pagination.$el.length) {
                        var k = v.pagination.$el;
                        k.removeClass(E.hiddenClass),
                        k.removeClass(E.modifierClass + E.type),
                        v.pagination.bullets && v.pagination.bullets.removeClass(E.bulletActiveClass),
                        E.clickable && k.off("click", classesToSelector(E.bulletClass))
                    }
                }
            };
            function scrollbar_extends() {
                return scrollbar_extends = Object.assign || function(v) {
                    for (var E = 1; E < arguments.length; E++) {
                        var k = arguments[E];
                        for (var R in k)
                            Object.prototype.hasOwnProperty.call(k, R) && (v[R] = k[R])
                    }
                    return v
                }
                ,
                scrollbar_extends.apply(this, arguments)
            }
            var Ee = {
                "setTranslate": function setTranslate() {
                    var v = this;
                    if (v.params.scrollbar.el && v.scrollbar.el) {
                        var E = v.scrollbar
                          , k = v.rtlTranslate
                          , R = v.progress
                          , U = E.dragSize
                          , H = E.trackSize
                          , G = E.$dragEl
                          , W = E.$el
                          , Z = v.params.scrollbar
                          , Y = U
                          , J = (H - U) * R;
                        k ? (J = -J) > 0 ? (Y = U - J,
                        J = 0) : -J + U > H && (Y = H + J) : J < 0 ? (Y = U + J,
                        J = 0) : J + U > H && (Y = H - J),
                        v.isHorizontal() ? (G.transform("translate3d(" + J + "px, 0, 0)"),
                        G[0].style.width = Y + "px") : (G.transform("translate3d(0px, " + J + "px, 0)"),
                        G[0].style.height = Y + "px"),
                        Z.hide && (clearTimeout(v.scrollbar.timeout),
                        W[0].style.opacity = 1,
                        v.scrollbar.timeout = setTimeout((function() {
                            W[0].style.opacity = 0,
                            W.transition(400)
                        }
                        ), 1e3))
                    }
                },
                "setTransition": function setTransition(v) {
                    var E = this;
                    E.params.scrollbar.el && E.scrollbar.el && E.scrollbar.$dragEl.transition(v)
                },
                "updateSize": function updateSize() {
                    var v = this;
                    if (v.params.scrollbar.el && v.scrollbar.el) {
                        var E = v.scrollbar
                          , k = E.$dragEl
                          , R = E.$el;
                        k[0].style.width = "",
                        k[0].style.height = "";
                        var U, H = v.isHorizontal() ? R[0].offsetWidth : R[0].offsetHeight, G = v.size / v.virtualSize, W = G * (H / v.size);
                        U = "auto" === v.params.scrollbar.dragSize ? H * G : parseInt(v.params.scrollbar.dragSize, 10),
                        v.isHorizontal() ? k[0].style.width = U + "px" : k[0].style.height = U + "px",
                        R[0].style.display = G >= 1 ? "none" : "",
                        v.params.scrollbar.hide && (R[0].style.opacity = 0),
                        utils_extend(E, {
                            "trackSize": H,
                            "divider": G,
                            "moveDivider": W,
                            "dragSize": U
                        }),
                        v.params.watchOverflow && v.enabled && E.$el[v.isLocked ? "addClass" : "removeClass"](v.params.scrollbar.lockClass)
                    }
                },
                "getPointerPosition": function getPointerPosition(v) {
                    return this.isHorizontal() ? "touchstart" === v.type || "touchmove" === v.type ? v.targetTouches[0].clientX : v.clientX : "touchstart" === v.type || "touchmove" === v.type ? v.targetTouches[0].clientY : v.clientY
                },
                "setDragPosition": function setDragPosition(v) {
                    var E, k = this, R = k.scrollbar, U = k.rtlTranslate, H = R.$el, G = R.dragSize, W = R.trackSize, Z = R.dragStartPos;
                    E = (R.getPointerPosition(v) - H.offset()[k.isHorizontal() ? "left" : "top"] - (null !== Z ? Z : G / 2)) / (W - G),
                    E = Math.max(Math.min(E, 1), 0),
                    U && (E = 1 - E);
                    var Y = k.minTranslate() + (k.maxTranslate() - k.minTranslate()) * E;
                    k.updateProgress(Y),
                    k.setTranslate(Y),
                    k.updateActiveIndex(),
                    k.updateSlidesClasses()
                },
                "onDragStart": function onDragStart(v) {
                    var E = this
                      , k = E.params.scrollbar
                      , R = E.scrollbar
                      , U = E.$wrapperEl
                      , H = R.$el
                      , G = R.$dragEl;
                    E.scrollbar.isTouched = !0,
                    E.scrollbar.dragStartPos = v.target === G[0] || v.target === G ? R.getPointerPosition(v) - v.target.getBoundingClientRect()[E.isHorizontal() ? "left" : "top"] : null,
                    v.preventDefault(),
                    v.stopPropagation(),
                    U.transition(100),
                    G.transition(100),
                    R.setDragPosition(v),
                    clearTimeout(E.scrollbar.dragTimeout),
                    H.transition(0),
                    k.hide && H.css("opacity", 1),
                    E.params.cssMode && E.$wrapperEl.css("scroll-snap-type", "none"),
                    E.emit("scrollbarDragStart", v)
                },
                "onDragMove": function onDragMove(v) {
                    var E = this
                      , k = E.scrollbar
                      , R = E.$wrapperEl
                      , U = k.$el
                      , H = k.$dragEl;
                    E.scrollbar.isTouched && (v.preventDefault ? v.preventDefault() : v.returnValue = !1,
                    k.setDragPosition(v),
                    R.transition(0),
                    U.transition(0),
                    H.transition(0),
                    E.emit("scrollbarDragMove", v))
                },
                "onDragEnd": function onDragEnd(v) {
                    var E = this
                      , k = E.params.scrollbar
                      , R = E.scrollbar
                      , U = E.$wrapperEl
                      , H = R.$el;
                    E.scrollbar.isTouched && (E.scrollbar.isTouched = !1,
                    E.params.cssMode && (E.$wrapperEl.css("scroll-snap-type", ""),
                    U.transition("")),
                    k.hide && (clearTimeout(E.scrollbar.dragTimeout),
                    E.scrollbar.dragTimeout = nextTick((function() {
                        H.css("opacity", 0),
                        H.transition(400)
                    }
                    ), 1e3)),
                    E.emit("scrollbarDragEnd", v),
                    k.snapOnRelease && E.slideToClosest())
                },
                "enableDraggable": function enableDraggable() {
                    var v = this;
                    if (v.params.scrollbar.el) {
                        var E = getDocument()
                          , k = v.scrollbar
                          , R = v.touchEventsTouch
                          , U = v.touchEventsDesktop
                          , H = v.params
                          , G = v.support
                          , W = k.$el[0]
                          , Z = !(!G.passiveListener || !H.passiveListeners) && {
                            "passive": !1,
                            "capture": !1
                        }
                          , Y = !(!G.passiveListener || !H.passiveListeners) && {
                            "passive": !0,
                            "capture": !1
                        };
                        W && (G.touch ? (W.addEventListener(R.start, v.scrollbar.onDragStart, Z),
                        W.addEventListener(R.move, v.scrollbar.onDragMove, Z),
                        W.addEventListener(R.end, v.scrollbar.onDragEnd, Y)) : (W.addEventListener(U.start, v.scrollbar.onDragStart, Z),
                        E.addEventListener(U.move, v.scrollbar.onDragMove, Z),
                        E.addEventListener(U.end, v.scrollbar.onDragEnd, Y)))
                    }
                },
                "disableDraggable": function disableDraggable() {
                    var v = this;
                    if (v.params.scrollbar.el) {
                        var E = getDocument()
                          , k = v.scrollbar
                          , R = v.touchEventsTouch
                          , U = v.touchEventsDesktop
                          , H = v.params
                          , G = v.support
                          , W = k.$el[0]
                          , Z = !(!G.passiveListener || !H.passiveListeners) && {
                            "passive": !1,
                            "capture": !1
                        }
                          , Y = !(!G.passiveListener || !H.passiveListeners) && {
                            "passive": !0,
                            "capture": !1
                        };
                        W && (G.touch ? (W.removeEventListener(R.start, v.scrollbar.onDragStart, Z),
                        W.removeEventListener(R.move, v.scrollbar.onDragMove, Z),
                        W.removeEventListener(R.end, v.scrollbar.onDragEnd, Y)) : (W.removeEventListener(U.start, v.scrollbar.onDragStart, Z),
                        E.removeEventListener(U.move, v.scrollbar.onDragMove, Z),
                        E.removeEventListener(U.end, v.scrollbar.onDragEnd, Y)))
                    }
                },
                "init": function init() {
                    var v = this
                      , E = v.scrollbar
                      , k = v.$el;
                    v.params.scrollbar = createElementIfNotDefined(k, v.params.scrollbar, v.params.createElements, {
                        "el": "swiper-scrollbar"
                    });
                    var R = v.params.scrollbar;
                    if (R.el) {
                        var U = K(R.el);
                        v.params.uniqueNavElements && "string" == typeof R.el && U.length > 1 && 1 === k.find(R.el).length && (U = k.find(R.el));
                        var H = U.find("." + v.params.scrollbar.dragClass);
                        0 === H.length && (H = K('<div class="' + v.params.scrollbar.dragClass + '"></div>'),
                        U.append(H)),
                        utils_extend(E, {
                            "$el": U,
                            "el": U[0],
                            "$dragEl": H,
                            "dragEl": H[0]
                        }),
                        R.draggable && E.enableDraggable(),
                        U && U[v.enabled ? "removeClass" : "addClass"](v.params.scrollbar.lockClass)
                    }
                },
                "destroy": function destroy() {
                    this.scrollbar.disableDraggable()
                }
            };
            function parallax_extends() {
                return parallax_extends = Object.assign || function(v) {
                    for (var E = 1; E < arguments.length; E++) {
                        var k = arguments[E];
                        for (var R in k)
                            Object.prototype.hasOwnProperty.call(k, R) && (v[R] = k[R])
                    }
                    return v
                }
                ,
                parallax_extends.apply(this, arguments)
            }
            var Ce = {
                "setTransform": function setTransform(v, E) {
                    var k = this.rtl
                      , R = K(v)
                      , U = k ? -1 : 1
                      , H = R.attr("data-swiper-parallax") || "0"
                      , G = R.attr("data-swiper-parallax-x")
                      , W = R.attr("data-swiper-parallax-y")
                      , Z = R.attr("data-swiper-parallax-scale")
                      , Y = R.attr("data-swiper-parallax-opacity");
                    if (G || W ? (G = G || "0",
                    W = W || "0") : this.isHorizontal() ? (G = H,
                    W = "0") : (W = H,
                    G = "0"),
                    G = G.indexOf("%") >= 0 ? parseInt(G, 10) * E * U + "%" : G * E * U + "px",
                    W = W.indexOf("%") >= 0 ? parseInt(W, 10) * E + "%" : W * E + "px",
                    null != Y) {
                        var J = Y - (Y - 1) * (1 - Math.abs(E));
                        R[0].style.opacity = J
                    }
                    if (null == Z)
                        R.transform("translate3d(" + G + ", " + W + ", 0px)");
                    else {
                        var X = Z - (Z - 1) * (1 - Math.abs(E));
                        R.transform("translate3d(" + G + ", " + W + ", 0px) scale(" + X + ")")
                    }
                },
                "setTranslate": function setTranslate() {
                    var v = this
                      , E = v.$el
                      , k = v.slides
                      , R = v.progress
                      , U = v.snapGrid;
                    E.children("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((function(E) {
                        v.parallax.setTransform(E, R)
                    }
                    )),
                    k.each((function(E, k) {
                        var H = E.progress;
                        v.params.slidesPerGroup > 1 && "auto" !== v.params.slidesPerView && (H += Math.ceil(k / 2) - R * (U.length - 1)),
                        H = Math.min(Math.max(H, -1), 1),
                        K(E).find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((function(E) {
                            v.parallax.setTransform(E, H)
                        }
                        ))
                    }
                    ))
                },
                "setTransition": function setTransition(v) {
                    void 0 === v && (v = this.params.speed);
                    this.$el.find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((function(E) {
                        var k = K(E)
                          , R = parseInt(k.attr("data-swiper-parallax-duration"), 10) || v;
                        0 === v && (R = 0),
                        k.transition(R)
                    }
                    ))
                }
            };
            function zoom_extends() {
                return zoom_extends = Object.assign || function(v) {
                    for (var E = 1; E < arguments.length; E++) {
                        var k = arguments[E];
                        for (var R in k)
                            Object.prototype.hasOwnProperty.call(k, R) && (v[R] = k[R])
                    }
                    return v
                }
                ,
                zoom_extends.apply(this, arguments)
            }
            var Te = {
                "getDistanceBetweenTouches": function getDistanceBetweenTouches(v) {
                    if (v.targetTouches.length < 2)
                        return 1;
                    var E = v.targetTouches[0].pageX
                      , k = v.targetTouches[0].pageY
                      , R = v.targetTouches[1].pageX
                      , U = v.targetTouches[1].pageY;
                    return Math.sqrt(Math.pow(R - E, 2) + Math.pow(U - k, 2))
                },
                "onGestureStart": function onGestureStart(v) {
                    var E = this
                      , k = E.support
                      , R = E.params.zoom
                      , U = E.zoom
                      , H = U.gesture;
                    if (U.fakeGestureTouched = !1,
                    U.fakeGestureMoved = !1,
                    !k.gestures) {
                        if ("touchstart" !== v.type || "touchstart" === v.type && v.targetTouches.length < 2)
                            return;
                        U.fakeGestureTouched = !0,
                        H.scaleStart = Te.getDistanceBetweenTouches(v)
                    }
                    H.$slideEl && H.$slideEl.length || (H.$slideEl = K(v.target).closest("." + E.params.slideClass),
                    0 === H.$slideEl.length && (H.$slideEl = E.slides.eq(E.activeIndex)),
                    H.$imageEl = H.$slideEl.find("img, svg, canvas, picture, .swiper-zoom-target"),
                    H.$imageWrapEl = H.$imageEl.parent("." + R.containerClass),
                    H.maxRatio = H.$imageWrapEl.attr("data-swiper-zoom") || R.maxRatio,
                    0 !== H.$imageWrapEl.length) ? (H.$imageEl && H.$imageEl.transition(0),
                    E.zoom.isScaling = !0) : H.$imageEl = void 0
                },
                "onGestureChange": function onGestureChange(v) {
                    var E = this
                      , k = E.support
                      , R = E.params.zoom
                      , U = E.zoom
                      , H = U.gesture;
                    if (!k.gestures) {
                        if ("touchmove" !== v.type || "touchmove" === v.type && v.targetTouches.length < 2)
                            return;
                        U.fakeGestureMoved = !0,
                        H.scaleMove = Te.getDistanceBetweenTouches(v)
                    }
                    H.$imageEl && 0 !== H.$imageEl.length ? (k.gestures ? U.scale = v.scale * U.currentScale : U.scale = H.scaleMove / H.scaleStart * U.currentScale,
                    U.scale > H.maxRatio && (U.scale = H.maxRatio - 1 + Math.pow(U.scale - H.maxRatio + 1, .5)),
                    U.scale < R.minRatio && (U.scale = R.minRatio + 1 - Math.pow(R.minRatio - U.scale + 1, .5)),
                    H.$imageEl.transform("translate3d(0,0,0) scale(" + U.scale + ")")) : "gesturechange" === v.type && U.onGestureStart(v)
                },
                "onGestureEnd": function onGestureEnd(v) {
                    var E = this
                      , k = E.device
                      , R = E.support
                      , U = E.params.zoom
                      , H = E.zoom
                      , G = H.gesture;
                    if (!R.gestures) {
                        if (!H.fakeGestureTouched || !H.fakeGestureMoved)
                            return;
                        if ("touchend" !== v.type || "touchend" === v.type && v.changedTouches.length < 2 && !k.android)
                            return;
                        H.fakeGestureTouched = !1,
                        H.fakeGestureMoved = !1
                    }
                    G.$imageEl && 0 !== G.$imageEl.length && (H.scale = Math.max(Math.min(H.scale, G.maxRatio), U.minRatio),
                    G.$imageEl.transition(E.params.speed).transform("translate3d(0,0,0) scale(" + H.scale + ")"),
                    H.currentScale = H.scale,
                    H.isScaling = !1,
                    1 === H.scale && (G.$slideEl = void 0))
                },
                "onTouchStart": function onTouchStart(v) {
                    var E = this.device
                      , k = this.zoom
                      , R = k.gesture
                      , U = k.image;
                    R.$imageEl && 0 !== R.$imageEl.length && (U.isTouched || (E.android && v.cancelable && v.preventDefault(),
                    U.isTouched = !0,
                    U.touchesStart.x = "touchstart" === v.type ? v.targetTouches[0].pageX : v.pageX,
                    U.touchesStart.y = "touchstart" === v.type ? v.targetTouches[0].pageY : v.pageY))
                },
                "onTouchMove": function onTouchMove(v) {
                    var E = this
                      , k = E.zoom
                      , R = k.gesture
                      , U = k.image
                      , H = k.velocity;
                    if (R.$imageEl && 0 !== R.$imageEl.length && (E.allowClick = !1,
                    U.isTouched && R.$slideEl)) {
                        U.isMoved || (U.width = R.$imageEl[0].offsetWidth,
                        U.height = R.$imageEl[0].offsetHeight,
                        U.startX = getTranslate(R.$imageWrapEl[0], "x") || 0,
                        U.startY = getTranslate(R.$imageWrapEl[0], "y") || 0,
                        R.slideWidth = R.$slideEl[0].offsetWidth,
                        R.slideHeight = R.$slideEl[0].offsetHeight,
                        R.$imageWrapEl.transition(0));
                        var G = U.width * k.scale
                          , W = U.height * k.scale;
                        if (!(G < R.slideWidth && W < R.slideHeight)) {
                            if (U.minX = Math.min(R.slideWidth / 2 - G / 2, 0),
                            U.maxX = -U.minX,
                            U.minY = Math.min(R.slideHeight / 2 - W / 2, 0),
                            U.maxY = -U.minY,
                            U.touchesCurrent.x = "touchmove" === v.type ? v.targetTouches[0].pageX : v.pageX,
                            U.touchesCurrent.y = "touchmove" === v.type ? v.targetTouches[0].pageY : v.pageY,
                            !U.isMoved && !k.isScaling) {
                                if (E.isHorizontal() && (Math.floor(U.minX) === Math.floor(U.startX) && U.touchesCurrent.x < U.touchesStart.x || Math.floor(U.maxX) === Math.floor(U.startX) && U.touchesCurrent.x > U.touchesStart.x))
                                    return void (U.isTouched = !1);
                                if (!E.isHorizontal() && (Math.floor(U.minY) === Math.floor(U.startY) && U.touchesCurrent.y < U.touchesStart.y || Math.floor(U.maxY) === Math.floor(U.startY) && U.touchesCurrent.y > U.touchesStart.y))
                                    return void (U.isTouched = !1)
                            }
                            v.cancelable && v.preventDefault(),
                            v.stopPropagation(),
                            U.isMoved = !0,
                            U.currentX = U.touchesCurrent.x - U.touchesStart.x + U.startX,
                            U.currentY = U.touchesCurrent.y - U.touchesStart.y + U.startY,
                            U.currentX < U.minX && (U.currentX = U.minX + 1 - Math.pow(U.minX - U.currentX + 1, .8)),
                            U.currentX > U.maxX && (U.currentX = U.maxX - 1 + Math.pow(U.currentX - U.maxX + 1, .8)),
                            U.currentY < U.minY && (U.currentY = U.minY + 1 - Math.pow(U.minY - U.currentY + 1, .8)),
                            U.currentY > U.maxY && (U.currentY = U.maxY - 1 + Math.pow(U.currentY - U.maxY + 1, .8)),
                            H.prevPositionX || (H.prevPositionX = U.touchesCurrent.x),
                            H.prevPositionY || (H.prevPositionY = U.touchesCurrent.y),
                            H.prevTime || (H.prevTime = Date.now()),
                            H.x = (U.touchesCurrent.x - H.prevPositionX) / (Date.now() - H.prevTime) / 2,
                            H.y = (U.touchesCurrent.y - H.prevPositionY) / (Date.now() - H.prevTime) / 2,
                            Math.abs(U.touchesCurrent.x - H.prevPositionX) < 2 && (H.x = 0),
                            Math.abs(U.touchesCurrent.y - H.prevPositionY) < 2 && (H.y = 0),
                            H.prevPositionX = U.touchesCurrent.x,
                            H.prevPositionY = U.touchesCurrent.y,
                            H.prevTime = Date.now(),
                            R.$imageWrapEl.transform("translate3d(" + U.currentX + "px, " + U.currentY + "px,0)")
                        }
                    }
                },
                "onTouchEnd": function onTouchEnd() {
                    var v = this.zoom
                      , E = v.gesture
                      , k = v.image
                      , R = v.velocity;
                    if (E.$imageEl && 0 !== E.$imageEl.length) {
                        if (!k.isTouched || !k.isMoved)
                            return k.isTouched = !1,
                            void (k.isMoved = !1);
                        k.isTouched = !1,
                        k.isMoved = !1;
                        var U = 300
                          , H = 300
                          , G = R.x * U
                          , W = k.currentX + G
                          , Z = R.y * H
                          , Y = k.currentY + Z;
                        0 !== R.x && (U = Math.abs((W - k.currentX) / R.x)),
                        0 !== R.y && (H = Math.abs((Y - k.currentY) / R.y));
                        var J = Math.max(U, H);
                        k.currentX = W,
                        k.currentY = Y;
                        var K = k.width * v.scale
                          , X = k.height * v.scale;
                        k.minX = Math.min(E.slideWidth / 2 - K / 2, 0),
                        k.maxX = -k.minX,
                        k.minY = Math.min(E.slideHeight / 2 - X / 2, 0),
                        k.maxY = -k.minY,
                        k.currentX = Math.max(Math.min(k.currentX, k.maxX), k.minX),
                        k.currentY = Math.max(Math.min(k.currentY, k.maxY), k.minY),
                        E.$imageWrapEl.transition(J).transform("translate3d(" + k.currentX + "px, " + k.currentY + "px,0)")
                    }
                },
                "onTransitionEnd": function onTransitionEnd() {
                    var v = this
                      , E = v.zoom
                      , k = E.gesture;
                    k.$slideEl && v.previousIndex !== v.activeIndex && (k.$imageEl && k.$imageEl.transform("translate3d(0,0,0) scale(1)"),
                    k.$imageWrapEl && k.$imageWrapEl.transform("translate3d(0,0,0)"),
                    E.scale = 1,
                    E.currentScale = 1,
                    k.$slideEl = void 0,
                    k.$imageEl = void 0,
                    k.$imageWrapEl = void 0)
                },
                "toggle": function toggle(v) {
                    var E = this.zoom;
                    E.scale && 1 !== E.scale ? E.out() : E.in(v)
                },
                "in": function _in(v) {
                    var E, k, R, U, H, G, W, Z, Y, J, X, Q, ee, te, ne, re, oe = this, ie = ssr_window_esm_getWindow(), ae = oe.zoom, se = oe.params.zoom, ce = ae.gesture, le = ae.image;
                    (ce.$slideEl || (v && v.target && (ce.$slideEl = K(v.target).closest("." + oe.params.slideClass)),
                    ce.$slideEl || (oe.params.virtual && oe.params.virtual.enabled && oe.virtual ? ce.$slideEl = oe.$wrapperEl.children("." + oe.params.slideActiveClass) : ce.$slideEl = oe.slides.eq(oe.activeIndex)),
                    ce.$imageEl = ce.$slideEl.find("img, svg, canvas, picture, .swiper-zoom-target"),
                    ce.$imageWrapEl = ce.$imageEl.parent("." + se.containerClass)),
                    ce.$imageEl && 0 !== ce.$imageEl.length && ce.$imageWrapEl && 0 !== ce.$imageWrapEl.length) && (ce.$slideEl.addClass("" + se.zoomedSlideClass),
                    void 0 === le.touchesStart.x && v ? (E = "touchend" === v.type ? v.changedTouches[0].pageX : v.pageX,
                    k = "touchend" === v.type ? v.changedTouches[0].pageY : v.pageY) : (E = le.touchesStart.x,
                    k = le.touchesStart.y),
                    ae.scale = ce.$imageWrapEl.attr("data-swiper-zoom") || se.maxRatio,
                    ae.currentScale = ce.$imageWrapEl.attr("data-swiper-zoom") || se.maxRatio,
                    v ? (ne = ce.$slideEl[0].offsetWidth,
                    re = ce.$slideEl[0].offsetHeight,
                    R = ce.$slideEl.offset().left + ie.scrollX + ne / 2 - E,
                    U = ce.$slideEl.offset().top + ie.scrollY + re / 2 - k,
                    W = ce.$imageEl[0].offsetWidth,
                    Z = ce.$imageEl[0].offsetHeight,
                    Y = W * ae.scale,
                    J = Z * ae.scale,
                    ee = -(X = Math.min(ne / 2 - Y / 2, 0)),
                    te = -(Q = Math.min(re / 2 - J / 2, 0)),
                    (H = R * ae.scale) < X && (H = X),
                    H > ee && (H = ee),
                    (G = U * ae.scale) < Q && (G = Q),
                    G > te && (G = te)) : (H = 0,
                    G = 0),
                    ce.$imageWrapEl.transition(300).transform("translate3d(" + H + "px, " + G + "px,0)"),
                    ce.$imageEl.transition(300).transform("translate3d(0,0,0) scale(" + ae.scale + ")"))
                },
                "out": function out() {
                    var v = this
                      , E = v.zoom
                      , k = v.params.zoom
                      , R = E.gesture;
                    R.$slideEl || (v.params.virtual && v.params.virtual.enabled && v.virtual ? R.$slideEl = v.$wrapperEl.children("." + v.params.slideActiveClass) : R.$slideEl = v.slides.eq(v.activeIndex),
                    R.$imageEl = R.$slideEl.find("img, svg, canvas, picture, .swiper-zoom-target"),
                    R.$imageWrapEl = R.$imageEl.parent("." + k.containerClass)),
                    R.$imageEl && 0 !== R.$imageEl.length && R.$imageWrapEl && 0 !== R.$imageWrapEl.length && (E.scale = 1,
                    E.currentScale = 1,
                    R.$imageWrapEl.transition(300).transform("translate3d(0,0,0)"),
                    R.$imageEl.transition(300).transform("translate3d(0,0,0) scale(1)"),
                    R.$slideEl.removeClass("" + k.zoomedSlideClass),
                    R.$slideEl = void 0)
                },
                "toggleGestures": function toggleGestures(v) {
                    var E = this
                      , k = E.zoom
                      , R = k.slideSelector
                      , U = k.passiveListener;
                    E.$wrapperEl[v]("gesturestart", R, k.onGestureStart, U),
                    E.$wrapperEl[v]("gesturechange", R, k.onGestureChange, U),
                    E.$wrapperEl[v]("gestureend", R, k.onGestureEnd, U)
                },
                "enableGestures": function enableGestures() {
                    this.zoom.gesturesEnabled || (this.zoom.gesturesEnabled = !0,
                    this.zoom.toggleGestures("on"))
                },
                "disableGestures": function disableGestures() {
                    this.zoom.gesturesEnabled && (this.zoom.gesturesEnabled = !1,
                    this.zoom.toggleGestures("off"))
                },
                "enable": function enable() {
                    var v = this
                      , E = v.support
                      , k = v.zoom;
                    if (!k.enabled) {
                        k.enabled = !0;
                        var R = !("touchstart" !== v.touchEvents.start || !E.passiveListener || !v.params.passiveListeners) && {
                            "passive": !0,
                            "capture": !1
                        }
                          , U = !E.passiveListener || {
                            "passive": !1,
                            "capture": !0
                        }
                          , H = "." + v.params.slideClass;
                        v.zoom.passiveListener = R,
                        v.zoom.slideSelector = H,
                        E.gestures ? (v.$wrapperEl.on(v.touchEvents.start, v.zoom.enableGestures, R),
                        v.$wrapperEl.on(v.touchEvents.end, v.zoom.disableGestures, R)) : "touchstart" === v.touchEvents.start && (v.$wrapperEl.on(v.touchEvents.start, H, k.onGestureStart, R),
                        v.$wrapperEl.on(v.touchEvents.move, H, k.onGestureChange, U),
                        v.$wrapperEl.on(v.touchEvents.end, H, k.onGestureEnd, R),
                        v.touchEvents.cancel && v.$wrapperEl.on(v.touchEvents.cancel, H, k.onGestureEnd, R)),
                        v.$wrapperEl.on(v.touchEvents.move, "." + v.params.zoom.containerClass, k.onTouchMove, U)
                    }
                },
                "disable": function disable() {
                    var v = this
                      , E = v.zoom;
                    if (E.enabled) {
                        var k = v.support;
                        v.zoom.enabled = !1;
                        var R = !("touchstart" !== v.touchEvents.start || !k.passiveListener || !v.params.passiveListeners) && {
                            "passive": !0,
                            "capture": !1
                        }
                          , U = !k.passiveListener || {
                            "passive": !1,
                            "capture": !0
                        }
                          , H = "." + v.params.slideClass;
                        k.gestures ? (v.$wrapperEl.off(v.touchEvents.start, v.zoom.enableGestures, R),
                        v.$wrapperEl.off(v.touchEvents.end, v.zoom.disableGestures, R)) : "touchstart" === v.touchEvents.start && (v.$wrapperEl.off(v.touchEvents.start, H, E.onGestureStart, R),
                        v.$wrapperEl.off(v.touchEvents.move, H, E.onGestureChange, U),
                        v.$wrapperEl.off(v.touchEvents.end, H, E.onGestureEnd, R),
                        v.touchEvents.cancel && v.$wrapperEl.off(v.touchEvents.cancel, H, E.onGestureEnd, R)),
                        v.$wrapperEl.off(v.touchEvents.move, "." + v.params.zoom.containerClass, E.onTouchMove, U)
                    }
                }
            }
              , xe = {
                "name": "zoom",
                "params": {
                    "zoom": {
                        "enabled": !1,
                        "maxRatio": 3,
                        "minRatio": 1,
                        "toggle": !0,
                        "containerClass": "swiper-zoom-container",
                        "zoomedSlideClass": "swiper-slide-zoomed"
                    }
                },
                "create": function create() {
                    var v = this;
                    bindModuleMethods(v, {
                        "zoom": zoom_extends({
                            "enabled": !1,
                            "scale": 1,
                            "currentScale": 1,
                            "isScaling": !1,
                            "gesture": {
                                "$slideEl": void 0,
                                "slideWidth": void 0,
                                "slideHeight": void 0,
                                "$imageEl": void 0,
                                "$imageWrapEl": void 0,
                                "maxRatio": 3
                            },
                            "image": {
                                "isTouched": void 0,
                                "isMoved": void 0,
                                "currentX": void 0,
                                "currentY": void 0,
                                "minX": void 0,
                                "minY": void 0,
                                "maxX": void 0,
                                "maxY": void 0,
                                "width": void 0,
                                "height": void 0,
                                "startX": void 0,
                                "startY": void 0,
                                "touchesStart": {},
                                "touchesCurrent": {}
                            },
                            "velocity": {
                                "x": void 0,
                                "y": void 0,
                                "prevPositionX": void 0,
                                "prevPositionY": void 0,
                                "prevTime": void 0
                            }
                        }, Te)
                    });
                    var E = 1;
                    Object.defineProperty(v.zoom, "scale", {
                        "get": function get() {
                            return E
                        },
                        "set": function set(k) {
                            if (E !== k) {
                                var R = v.zoom.gesture.$imageEl ? v.zoom.gesture.$imageEl[0] : void 0
                                  , U = v.zoom.gesture.$slideEl ? v.zoom.gesture.$slideEl[0] : void 0;
                                v.emit("zoomChange", k, R, U)
                            }
                            E = k
                        }
                    })
                },
                "on": {
                    "init": function init(v) {
                        v.params.zoom.enabled && v.zoom.enable()
                    },
                    "destroy": function destroy(v) {
                        v.zoom.disable()
                    },
                    "touchStart": function touchStart(v, E) {
                        v.zoom.enabled && v.zoom.onTouchStart(E)
                    },
                    "touchEnd": function touchEnd(v, E) {
                        v.zoom.enabled && v.zoom.onTouchEnd(E)
                    },
                    "doubleTap": function doubleTap(v, E) {
                        !v.animating && v.params.zoom.enabled && v.zoom.enabled && v.params.zoom.toggle && v.zoom.toggle(E)
                    },
                    "transitionEnd": function transitionEnd(v) {
                        v.zoom.enabled && v.params.zoom.enabled && v.zoom.onTransitionEnd()
                    },
                    "slideChange": function slideChange(v) {
                        v.zoom.enabled && v.params.zoom.enabled && v.params.cssMode && v.zoom.onTransitionEnd()
                    }
                }
            };
            function lazy_extends() {
                return lazy_extends = Object.assign || function(v) {
                    for (var E = 1; E < arguments.length; E++) {
                        var k = arguments[E];
                        for (var R in k)
                            Object.prototype.hasOwnProperty.call(k, R) && (v[R] = k[R])
                    }
                    return v
                }
                ,
                lazy_extends.apply(this, arguments)
            }
            var Ae = {
                "loadInSlide": function loadInSlide(v, E) {
                    void 0 === E && (E = !0);
                    var k = this
                      , R = k.params.lazy;
                    if (void 0 !== v && 0 !== k.slides.length) {
                        var U = k.virtual && k.params.virtual.enabled ? k.$wrapperEl.children("." + k.params.slideClass + '[data-swiper-slide-index="' + v + '"]') : k.slides.eq(v)
                          , H = U.find("." + R.elementClass + ":not(." + R.loadedClass + "):not(." + R.loadingClass + ")");
                        !U.hasClass(R.elementClass) || U.hasClass(R.loadedClass) || U.hasClass(R.loadingClass) || H.push(U[0]),
                        0 !== H.length && H.each((function(v) {
                            var H = K(v);
                            H.addClass(R.loadingClass);
                            var G = H.attr("data-background")
                              , W = H.attr("data-src")
                              , Z = H.attr("data-srcset")
                              , Y = H.attr("data-sizes")
                              , J = H.parent("picture");
                            k.loadImage(H[0], W || G, Z, Y, !1, (function() {
                                if (null != k && k && (!k || k.params) && !k.destroyed) {
                                    if (G ? (H.css("background-image", 'url("' + G + '")'),
                                    H.removeAttr("data-background")) : (Z && (H.attr("srcset", Z),
                                    H.removeAttr("data-srcset")),
                                    Y && (H.attr("sizes", Y),
                                    H.removeAttr("data-sizes")),
                                    J.length && J.children("source").each((function(v) {
                                        var E = K(v);
                                        E.attr("data-srcset") && (E.attr("srcset", E.attr("data-srcset")),
                                        E.removeAttr("data-srcset"))
                                    }
                                    )),
                                    W && (H.attr("src", W),
                                    H.removeAttr("data-src"))),
                                    H.addClass(R.loadedClass).removeClass(R.loadingClass),
                                    U.find("." + R.preloaderClass).remove(),
                                    k.params.loop && E) {
                                        var v = U.attr("data-swiper-slide-index");
                                        if (U.hasClass(k.params.slideDuplicateClass)) {
                                            var X = k.$wrapperEl.children('[data-swiper-slide-index="' + v + '"]:not(.' + k.params.slideDuplicateClass + ")");
                                            k.lazy.loadInSlide(X.index(), !1)
                                        } else {
                                            var Q = k.$wrapperEl.children("." + k.params.slideDuplicateClass + '[data-swiper-slide-index="' + v + '"]');
                                            k.lazy.loadInSlide(Q.index(), !1)
                                        }
                                    }
                                    k.emit("lazyImageReady", U[0], H[0]),
                                    k.params.autoHeight && k.updateAutoHeight()
                                }
                            }
                            )),
                            k.emit("lazyImageLoad", U[0], H[0])
                        }
                        ))
                    }
                },
                "load": function load() {
                    var v = this
                      , E = v.$wrapperEl
                      , k = v.params
                      , R = v.slides
                      , U = v.activeIndex
                      , H = v.virtual && k.virtual.enabled
                      , G = k.lazy
                      , W = k.slidesPerView;
                    function slideExist(v) {
                        if (H) {
                            if (E.children("." + k.slideClass + '[data-swiper-slide-index="' + v + '"]').length)
                                return !0
                        } else if (R[v])
                            return !0;
                        return !1
                    }
                    function slideIndex(v) {
                        return H ? K(v).attr("data-swiper-slide-index") : K(v).index()
                    }
                    if ("auto" === W && (W = 0),
                    v.lazy.initialImageLoaded || (v.lazy.initialImageLoaded = !0),
                    v.params.watchSlidesVisibility)
                        E.children("." + k.slideVisibleClass).each((function(E) {
                            var k = H ? K(E).attr("data-swiper-slide-index") : K(E).index();
                            v.lazy.loadInSlide(k)
                        }
                        ));
                    else if (W > 1)
                        for (var Z = U; Z < U + W; Z += 1)
                            slideExist(Z) && v.lazy.loadInSlide(Z);
                    else
                        v.lazy.loadInSlide(U);
                    if (G.loadPrevNext)
                        if (W > 1 || G.loadPrevNextAmount && G.loadPrevNextAmount > 1) {
                            for (var Y = G.loadPrevNextAmount, J = W, X = Math.min(U + J + Math.max(Y, J), R.length), Q = Math.max(U - Math.max(J, Y), 0), ee = U + W; ee < X; ee += 1)
                                slideExist(ee) && v.lazy.loadInSlide(ee);
                            for (var te = Q; te < U; te += 1)
                                slideExist(te) && v.lazy.loadInSlide(te)
                        } else {
                            var ne = E.children("." + k.slideNextClass);
                            ne.length > 0 && v.lazy.loadInSlide(slideIndex(ne));
                            var re = E.children("." + k.slidePrevClass);
                            re.length > 0 && v.lazy.loadInSlide(slideIndex(re))
                        }
                },
                "checkInViewOnLoad": function checkInViewOnLoad() {
                    var v = ssr_window_esm_getWindow()
                      , E = this;
                    if (E && !E.destroyed) {
                        var k = E.params.lazy.scrollingElement ? K(E.params.lazy.scrollingElement) : K(v)
                          , R = k[0] === v
                          , U = R ? v.innerWidth : k[0].offsetWidth
                          , H = R ? v.innerHeight : k[0].offsetHeight
                          , G = E.$el.offset()
                          , W = !1;
                        E.rtlTranslate && (G.left -= E.$el[0].scrollLeft);
                        for (var Z = [[G.left, G.top], [G.left + E.width, G.top], [G.left, G.top + E.height], [G.left + E.width, G.top + E.height]], Y = 0; Y < Z.length; Y += 1) {
                            var J = Z[Y];
                            if (J[0] >= 0 && J[0] <= U && J[1] >= 0 && J[1] <= H) {
                                if (0 === J[0] && 0 === J[1])
                                    continue;
                                W = !0
                            }
                        }
                        var X = !("touchstart" !== E.touchEvents.start || !E.support.passiveListener || !E.params.passiveListeners) && {
                            "passive": !0,
                            "capture": !1
                        };
                        W ? (E.lazy.load(),
                        k.off("scroll", E.lazy.checkInViewOnLoad, X)) : E.lazy.scrollHandlerAttached || (E.lazy.scrollHandlerAttached = !0,
                        k.on("scroll", E.lazy.checkInViewOnLoad, X))
                    }
                }
            };
            function controller_extends() {
                return controller_extends = Object.assign || function(v) {
                    for (var E = 1; E < arguments.length; E++) {
                        var k = arguments[E];
                        for (var R in k)
                            Object.prototype.hasOwnProperty.call(k, R) && (v[R] = k[R])
                    }
                    return v
                }
                ,
                controller_extends.apply(this, arguments)
            }
            var Ie = {
                "LinearSpline": function LinearSpline(v, E) {
                    var k, R, U = function search() {
                        var v, E, k;
                        return function(R, U) {
                            for (E = -1,
                            v = R.length; v - E > 1; )
                                R[k = v + E >> 1] <= U ? E = k : v = k;
                            return v
                        }
                    }();
                    return this.x = v,
                    this.y = E,
                    this.lastIndex = v.length - 1,
                    this.interpolate = function interpolate(v) {
                        return v ? (R = U(this.x, v),
                        k = R - 1,
                        (v - this.x[k]) * (this.y[R] - this.y[k]) / (this.x[R] - this.x[k]) + this.y[k]) : 0
                    }
                    ,
                    this
                },
                "getInterpolateFunction": function getInterpolateFunction(v) {
                    var E = this;
                    E.controller.spline || (E.controller.spline = E.params.loop ? new Ie.LinearSpline(E.slidesGrid,v.slidesGrid) : new Ie.LinearSpline(E.snapGrid,v.snapGrid))
                },
                "setTranslate": function setTranslate(v, E) {
                    var k, R, U = this, H = U.controller.control, G = U.constructor;
                    function setControlledTranslate(v) {
                        var E = U.rtlTranslate ? -U.translate : U.translate;
                        "slide" === U.params.controller.by && (U.controller.getInterpolateFunction(v),
                        R = -U.controller.spline.interpolate(-E)),
                        R && "container" !== U.params.controller.by || (k = (v.maxTranslate() - v.minTranslate()) / (U.maxTranslate() - U.minTranslate()),
                        R = (E - U.minTranslate()) * k + v.minTranslate()),
                        U.params.controller.inverse && (R = v.maxTranslate() - R),
                        v.updateProgress(R),
                        v.setTranslate(R, U),
                        v.updateActiveIndex(),
                        v.updateSlidesClasses()
                    }
                    if (Array.isArray(H))
                        for (var W = 0; W < H.length; W += 1)
                            H[W] !== E && H[W]instanceof G && setControlledTranslate(H[W]);
                    else
                        H instanceof G && E !== H && setControlledTranslate(H)
                },
                "setTransition": function setTransition(v, E) {
                    var k, R = this, U = R.constructor, H = R.controller.control;
                    function setControlledTransition(E) {
                        E.setTransition(v, R),
                        0 !== v && (E.transitionStart(),
                        E.params.autoHeight && nextTick((function() {
                            E.updateAutoHeight()
                        }
                        )),
                        E.$wrapperEl.transitionEnd((function() {
                            H && (E.params.loop && "slide" === R.params.controller.by && E.loopFix(),
                            E.transitionEnd())
                        }
                        )))
                    }
                    if (Array.isArray(H))
                        for (k = 0; k < H.length; k += 1)
                            H[k] !== E && H[k]instanceof U && setControlledTransition(H[k]);
                    else
                        H instanceof U && E !== H && setControlledTransition(H)
                }
            }
              , ke = {
                "name": "controller",
                "params": {
                    "controller": {
                        "control": void 0,
                        "inverse": !1,
                        "by": "slide"
                    }
                },
                "create": function create() {
                    bindModuleMethods(this, {
                        "controller": controller_extends({
                            "control": this.params.controller.control
                        }, Ie)
                    })
                },
                "on": {
                    "update": function update(v) {
                        v.controller.control && v.controller.spline && (v.controller.spline = void 0,
                        delete v.controller.spline)
                    },
                    "resize": function resize(v) {
                        v.controller.control && v.controller.spline && (v.controller.spline = void 0,
                        delete v.controller.spline)
                    },
                    "observerUpdate": function observerUpdate(v) {
                        v.controller.control && v.controller.spline && (v.controller.spline = void 0,
                        delete v.controller.spline)
                    },
                    "setTranslate": function setTranslate(v, E, k) {
                        v.controller.control && v.controller.setTranslate(E, k)
                    },
                    "setTransition": function setTransition(v, E, k) {
                        v.controller.control && v.controller.setTransition(E, k)
                    }
                }
            };
            function a11y_extends() {
                return a11y_extends = Object.assign || function(v) {
                    for (var E = 1; E < arguments.length; E++) {
                        var k = arguments[E];
                        for (var R in k)
                            Object.prototype.hasOwnProperty.call(k, R) && (v[R] = k[R])
                    }
                    return v
                }
                ,
                a11y_extends.apply(this, arguments)
            }
            var Oe = {
                "getRandomNumber": function getRandomNumber(v) {
                    void 0 === v && (v = 16);
                    return "x".repeat(v).replace(/x/g, (function randomChar() {
                        return Math.round(16 * Math.random()).toString(16)
                    }
                    ))
                },
                "makeElFocusable": function makeElFocusable(v) {
                    return v.attr("tabIndex", "0"),
                    v
                },
                "makeElNotFocusable": function makeElNotFocusable(v) {
                    return v.attr("tabIndex", "-1"),
                    v
                },
                "addElRole": function addElRole(v, E) {
                    return v.attr("role", E),
                    v
                },
                "addElRoleDescription": function addElRoleDescription(v, E) {
                    return v.attr("aria-roledescription", E),
                    v
                },
                "addElControls": function addElControls(v, E) {
                    return v.attr("aria-controls", E),
                    v
                },
                "addElLabel": function addElLabel(v, E) {
                    return v.attr("aria-label", E),
                    v
                },
                "addElId": function addElId(v, E) {
                    return v.attr("id", E),
                    v
                },
                "addElLive": function addElLive(v, E) {
                    return v.attr("aria-live", E),
                    v
                },
                "disableEl": function disableEl(v) {
                    return v.attr("aria-disabled", !0),
                    v
                },
                "enableEl": function enableEl(v) {
                    return v.attr("aria-disabled", !1),
                    v
                },
                "onEnterOrSpaceKey": function onEnterOrSpaceKey(v) {
                    if (13 === v.keyCode || 32 === v.keyCode) {
                        var E = this
                          , k = E.params.a11y
                          , R = K(v.target);
                        E.navigation && E.navigation.$nextEl && R.is(E.navigation.$nextEl) && (E.isEnd && !E.params.loop || E.slideNext(),
                        E.isEnd ? E.a11y.notify(k.lastSlideMessage) : E.a11y.notify(k.nextSlideMessage)),
                        E.navigation && E.navigation.$prevEl && R.is(E.navigation.$prevEl) && (E.isBeginning && !E.params.loop || E.slidePrev(),
                        E.isBeginning ? E.a11y.notify(k.firstSlideMessage) : E.a11y.notify(k.prevSlideMessage)),
                        E.pagination && R.is(classesToSelector(E.params.pagination.bulletClass)) && R[0].click()
                    }
                },
                "notify": function notify(v) {
                    var E = this.a11y.liveRegion;
                    0 !== E.length && (E.html(""),
                    E.html(v))
                },
                "updateNavigation": function updateNavigation() {
                    var v = this;
                    if (!v.params.loop && v.navigation) {
                        var E = v.navigation
                          , k = E.$nextEl
                          , R = E.$prevEl;
                        R && R.length > 0 && (v.isBeginning ? (v.a11y.disableEl(R),
                        v.a11y.makeElNotFocusable(R)) : (v.a11y.enableEl(R),
                        v.a11y.makeElFocusable(R))),
                        k && k.length > 0 && (v.isEnd ? (v.a11y.disableEl(k),
                        v.a11y.makeElNotFocusable(k)) : (v.a11y.enableEl(k),
                        v.a11y.makeElFocusable(k)))
                    }
                },
                "updatePagination": function updatePagination() {
                    var v = this
                      , E = v.params.a11y;
                    v.pagination && v.params.pagination.clickable && v.pagination.bullets && v.pagination.bullets.length && v.pagination.bullets.each((function(k) {
                        var R = K(k);
                        v.a11y.makeElFocusable(R),
                        v.params.pagination.renderBullet || (v.a11y.addElRole(R, "button"),
                        v.a11y.addElLabel(R, E.paginationBulletMessage.replace(/\{\{index\}\}/, R.index() + 1)))
                    }
                    ))
                },
                "init": function init() {
                    var v = this
                      , E = v.params.a11y;
                    v.$el.append(v.a11y.liveRegion);
                    var k = v.$el;
                    E.containerRoleDescriptionMessage && v.a11y.addElRoleDescription(k, E.containerRoleDescriptionMessage),
                    E.containerMessage && v.a11y.addElLabel(k, E.containerMessage);
                    var R = v.$wrapperEl
                      , U = R.attr("id") || "swiper-wrapper-" + v.a11y.getRandomNumber(16)
                      , H = v.params.autoplay && v.params.autoplay.enabled ? "off" : "polite";
                    v.a11y.addElId(R, U),
                    v.a11y.addElLive(R, H),
                    E.itemRoleDescriptionMessage && v.a11y.addElRoleDescription(K(v.slides), E.itemRoleDescriptionMessage),
                    v.a11y.addElRole(K(v.slides), E.slideRole);
                    var G, W, Z = v.params.loop ? v.slides.filter((function(E) {
                        return !E.classList.contains(v.params.slideDuplicateClass)
                    }
                    )).length : v.slides.length;
                    v.slides.each((function(k, R) {
                        var U = K(k)
                          , H = v.params.loop ? parseInt(U.attr("data-swiper-slide-index"), 10) : R
                          , G = E.slideLabelMessage.replace(/\{\{index\}\}/, H + 1).replace(/\{\{slidesLength\}\}/, Z);
                        v.a11y.addElLabel(U, G)
                    }
                    )),
                    v.navigation && v.navigation.$nextEl && (G = v.navigation.$nextEl),
                    v.navigation && v.navigation.$prevEl && (W = v.navigation.$prevEl),
                    G && G.length && (v.a11y.makeElFocusable(G),
                    "BUTTON" !== G[0].tagName && (v.a11y.addElRole(G, "button"),
                    G.on("keydown", v.a11y.onEnterOrSpaceKey)),
                    v.a11y.addElLabel(G, E.nextSlideMessage),
                    v.a11y.addElControls(G, U)),
                    W && W.length && (v.a11y.makeElFocusable(W),
                    "BUTTON" !== W[0].tagName && (v.a11y.addElRole(W, "button"),
                    W.on("keydown", v.a11y.onEnterOrSpaceKey)),
                    v.a11y.addElLabel(W, E.prevSlideMessage),
                    v.a11y.addElControls(W, U)),
                    v.pagination && v.params.pagination.clickable && v.pagination.bullets && v.pagination.bullets.length && v.pagination.$el.on("keydown", classesToSelector(v.params.pagination.bulletClass), v.a11y.onEnterOrSpaceKey)
                },
                "destroy": function destroy() {
                    var v, E, k = this;
                    k.a11y.liveRegion && k.a11y.liveRegion.length > 0 && k.a11y.liveRegion.remove(),
                    k.navigation && k.navigation.$nextEl && (v = k.navigation.$nextEl),
                    k.navigation && k.navigation.$prevEl && (E = k.navigation.$prevEl),
                    v && v.off("keydown", k.a11y.onEnterOrSpaceKey),
                    E && E.off("keydown", k.a11y.onEnterOrSpaceKey),
                    k.pagination && k.params.pagination.clickable && k.pagination.bullets && k.pagination.bullets.length && k.pagination.$el.off("keydown", classesToSelector(k.params.pagination.bulletClass), k.a11y.onEnterOrSpaceKey)
                }
            };
            function history_extends() {
                return history_extends = Object.assign || function(v) {
                    for (var E = 1; E < arguments.length; E++) {
                        var k = arguments[E];
                        for (var R in k)
                            Object.prototype.hasOwnProperty.call(k, R) && (v[R] = k[R])
                    }
                    return v
                }
                ,
                history_extends.apply(this, arguments)
            }
            var Pe = {
                "init": function init() {
                    var v = this
                      , E = ssr_window_esm_getWindow();
                    if (v.params.history) {
                        if (!E.history || !E.history.pushState)
                            return v.params.history.enabled = !1,
                            void (v.params.hashNavigation.enabled = !0);
                        var k = v.history;
                        k.initialized = !0,
                        k.paths = Pe.getPathValues(v.params.url),
                        (k.paths.key || k.paths.value) && (k.scrollToSlide(0, k.paths.value, v.params.runCallbacksOnInit),
                        v.params.history.replaceState || E.addEventListener("popstate", v.history.setHistoryPopState))
                    }
                },
                "destroy": function destroy() {
                    var v = ssr_window_esm_getWindow();
                    this.params.history.replaceState || v.removeEventListener("popstate", this.history.setHistoryPopState)
                },
                "setHistoryPopState": function setHistoryPopState() {
                    var v = this;
                    v.history.paths = Pe.getPathValues(v.params.url),
                    v.history.scrollToSlide(v.params.speed, v.history.paths.value, !1)
                },
                "getPathValues": function getPathValues(v) {
                    var E = ssr_window_esm_getWindow()
                      , k = (v ? new URL(v) : E.location).pathname.slice(1).split("/").filter((function(v) {
                        return "" !== v
                    }
                    ))
                      , R = k.length;
                    return {
                        "key": k[R - 2],
                        "value": k[R - 1]
                    }
                },
                "setHistory": function setHistory(v, E) {
                    var k = this
                      , R = ssr_window_esm_getWindow();
                    if (k.history.initialized && k.params.history.enabled) {
                        var U;
                        U = k.params.url ? new URL(k.params.url) : R.location;
                        var H = k.slides.eq(E)
                          , G = Pe.slugify(H.attr("data-history"));
                        if (k.params.history.root.length > 0) {
                            var W = k.params.history.root;
                            "/" === W[W.length - 1] && (W = W.slice(0, W.length - 1)),
                            G = W + "/" + v + "/" + G
                        } else
                            U.pathname.includes(v) || (G = v + "/" + G);
                        var Z = R.history.state;
                        Z && Z.value === G || (k.params.history.replaceState ? R.history.replaceState({
                            "value": G
                        }, null, G) : R.history.pushState({
                            "value": G
                        }, null, G))
                    }
                },
                "slugify": function slugify(v) {
                    return v.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, "")
                },
                "scrollToSlide": function scrollToSlide(v, E, k) {
                    var R = this;
                    if (E)
                        for (var U = 0, H = R.slides.length; U < H; U += 1) {
                            var G = R.slides.eq(U);
                            if (Pe.slugify(G.attr("data-history")) === E && !G.hasClass(R.params.slideDuplicateClass)) {
                                var W = G.index();
                                R.slideTo(W, v, k)
                            }
                        }
                    else
                        R.slideTo(0, v, k)
                }
            };
            function hash_navigation_extends() {
                return hash_navigation_extends = Object.assign || function(v) {
                    for (var E = 1; E < arguments.length; E++) {
                        var k = arguments[E];
                        for (var R in k)
                            Object.prototype.hasOwnProperty.call(k, R) && (v[R] = k[R])
                    }
                    return v
                }
                ,
                hash_navigation_extends.apply(this, arguments)
            }
            var Re = {
                "onHashChange": function onHashChange() {
                    var v = this
                      , E = getDocument();
                    v.emit("hashChange");
                    var k = E.location.hash.replace("#", "");
                    if (k !== v.slides.eq(v.activeIndex).attr("data-hash")) {
                        var R = v.$wrapperEl.children("." + v.params.slideClass + '[data-hash="' + k + '"]').index();
                        if (void 0 === R)
                            return;
                        v.slideTo(R)
                    }
                },
                "setHash": function setHash() {
                    var v = this
                      , E = ssr_window_esm_getWindow()
                      , k = getDocument();
                    if (v.hashNavigation.initialized && v.params.hashNavigation.enabled)
                        if (v.params.hashNavigation.replaceState && E.history && E.history.replaceState)
                            E.history.replaceState(null, null, "#" + v.slides.eq(v.activeIndex).attr("data-hash") || 0),
                            v.emit("hashSet");
                        else {
                            var R = v.slides.eq(v.activeIndex)
                              , U = R.attr("data-hash") || R.attr("data-history");
                            k.location.hash = U || "",
                            v.emit("hashSet")
                        }
                },
                "init": function init() {
                    var v = this
                      , E = getDocument()
                      , k = ssr_window_esm_getWindow();
                    if (!(!v.params.hashNavigation.enabled || v.params.history && v.params.history.enabled)) {
                        v.hashNavigation.initialized = !0;
                        var R = E.location.hash.replace("#", "");
                        if (R)
                            for (var U = 0, H = v.slides.length; U < H; U += 1) {
                                var G = v.slides.eq(U);
                                if ((G.attr("data-hash") || G.attr("data-history")) === R && !G.hasClass(v.params.slideDuplicateClass)) {
                                    var W = G.index();
                                    v.slideTo(W, 0, v.params.runCallbacksOnInit, !0)
                                }
                            }
                        v.params.hashNavigation.watchState && K(k).on("hashchange", v.hashNavigation.onHashChange)
                    }
                },
                "destroy": function destroy() {
                    var v = ssr_window_esm_getWindow();
                    this.params.hashNavigation.watchState && K(v).off("hashchange", this.hashNavigation.onHashChange)
                }
            };
            function autoplay_extends() {
                return autoplay_extends = Object.assign || function(v) {
                    for (var E = 1; E < arguments.length; E++) {
                        var k = arguments[E];
                        for (var R in k)
                            Object.prototype.hasOwnProperty.call(k, R) && (v[R] = k[R])
                    }
                    return v
                }
                ,
                autoplay_extends.apply(this, arguments)
            }
            var Me = {
                "run": function run() {
                    var v = this
                      , E = v.slides.eq(v.activeIndex)
                      , k = v.params.autoplay.delay;
                    E.attr("data-swiper-autoplay") && (k = E.attr("data-swiper-autoplay") || v.params.autoplay.delay),
                    clearTimeout(v.autoplay.timeout),
                    v.autoplay.timeout = nextTick((function() {
                        var E;
                        v.params.autoplay.reverseDirection ? v.params.loop ? (v.loopFix(),
                        E = v.slidePrev(v.params.speed, !0, !0),
                        v.emit("autoplay")) : v.isBeginning ? v.params.autoplay.stopOnLastSlide ? v.autoplay.stop() : (E = v.slideTo(v.slides.length - 1, v.params.speed, !0, !0),
                        v.emit("autoplay")) : (E = v.slidePrev(v.params.speed, !0, !0),
                        v.emit("autoplay")) : v.params.loop ? (v.loopFix(),
                        E = v.slideNext(v.params.speed, !0, !0),
                        v.emit("autoplay")) : v.isEnd ? v.params.autoplay.stopOnLastSlide ? v.autoplay.stop() : (E = v.slideTo(0, v.params.speed, !0, !0),
                        v.emit("autoplay")) : (E = v.slideNext(v.params.speed, !0, !0),
                        v.emit("autoplay")),
                        (v.params.cssMode && v.autoplay.running || !1 === E) && v.autoplay.run()
                    }
                    ), k)
                },
                "start": function start() {
                    var v = this;
                    return void 0 === v.autoplay.timeout && (!v.autoplay.running && (v.autoplay.running = !0,
                    v.emit("autoplayStart"),
                    v.autoplay.run(),
                    !0))
                },
                "stop": function stop() {
                    var v = this;
                    return !!v.autoplay.running && (void 0 !== v.autoplay.timeout && (v.autoplay.timeout && (clearTimeout(v.autoplay.timeout),
                    v.autoplay.timeout = void 0),
                    v.autoplay.running = !1,
                    v.emit("autoplayStop"),
                    !0))
                },
                "pause": function pause(v) {
                    var E = this;
                    E.autoplay.running && (E.autoplay.paused || (E.autoplay.timeout && clearTimeout(E.autoplay.timeout),
                    E.autoplay.paused = !0,
                    0 !== v && E.params.autoplay.waitForTransition ? ["transitionend", "webkitTransitionEnd"].forEach((function(v) {
                        E.$wrapperEl[0].addEventListener(v, E.autoplay.onTransitionEnd)
                    }
                    )) : (E.autoplay.paused = !1,
                    E.autoplay.run())))
                },
                "onVisibilityChange": function onVisibilityChange() {
                    var v = this
                      , E = getDocument();
                    "hidden" === E.visibilityState && v.autoplay.running && v.autoplay.pause(),
                    "visible" === E.visibilityState && v.autoplay.paused && (v.autoplay.run(),
                    v.autoplay.paused = !1)
                },
                "onTransitionEnd": function onTransitionEnd(v) {
                    var E = this;
                    E && !E.destroyed && E.$wrapperEl && v.target === E.$wrapperEl[0] && (["transitionend", "webkitTransitionEnd"].forEach((function(v) {
                        E.$wrapperEl[0].removeEventListener(v, E.autoplay.onTransitionEnd)
                    }
                    )),
                    E.autoplay.paused = !1,
                    E.autoplay.running ? E.autoplay.run() : E.autoplay.stop())
                },
                "onMouseEnter": function onMouseEnter() {
                    var v = this;
                    v.params.autoplay.disableOnInteraction ? v.autoplay.stop() : v.autoplay.pause(),
                    ["transitionend", "webkitTransitionEnd"].forEach((function(E) {
                        v.$wrapperEl[0].removeEventListener(E, v.autoplay.onTransitionEnd)
                    }
                    ))
                },
                "onMouseLeave": function onMouseLeave() {
                    var v = this;
                    v.params.autoplay.disableOnInteraction || (v.autoplay.paused = !1,
                    v.autoplay.run())
                },
                "attachMouseEvents": function attachMouseEvents() {
                    var v = this;
                    v.params.autoplay.pauseOnMouseEnter && (v.$el.on("mouseenter", v.autoplay.onMouseEnter),
                    v.$el.on("mouseleave", v.autoplay.onMouseLeave))
                },
                "detachMouseEvents": function detachMouseEvents() {
                    var v = this;
                    v.$el.off("mouseenter", v.autoplay.onMouseEnter),
                    v.$el.off("mouseleave", v.autoplay.onMouseLeave)
                }
            };
            function effect_fade_extends() {
                return effect_fade_extends = Object.assign || function(v) {
                    for (var E = 1; E < arguments.length; E++) {
                        var k = arguments[E];
                        for (var R in k)
                            Object.prototype.hasOwnProperty.call(k, R) && (v[R] = k[R])
                    }
                    return v
                }
                ,
                effect_fade_extends.apply(this, arguments)
            }
            var Ne = {
                "setTranslate": function setTranslate() {
                    for (var v = this, E = v.slides, k = 0; k < E.length; k += 1) {
                        var R = v.slides.eq(k)
                          , U = -R[0].swiperSlideOffset;
                        v.params.virtualTranslate || (U -= v.translate);
                        var H = 0;
                        v.isHorizontal() || (H = U,
                        U = 0);
                        var G = v.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(R[0].progress), 0) : 1 + Math.min(Math.max(R[0].progress, -1), 0);
                        R.css({
                            "opacity": G
                        }).transform("translate3d(" + U + "px, " + H + "px, 0px)")
                    }
                },
                "setTransition": function setTransition(v) {
                    var E = this
                      , k = E.slides
                      , R = E.$wrapperEl;
                    if (k.transition(v),
                    E.params.virtualTranslate && 0 !== v) {
                        var U = !1;
                        k.transitionEnd((function() {
                            if (!U && E && !E.destroyed) {
                                U = !0,
                                E.animating = !1;
                                for (var v = ["webkitTransitionEnd", "transitionend"], k = 0; k < v.length; k += 1)
                                    R.trigger(v[k])
                            }
                        }
                        ))
                    }
                }
            };
            function effect_cube_extends() {
                return effect_cube_extends = Object.assign || function(v) {
                    for (var E = 1; E < arguments.length; E++) {
                        var k = arguments[E];
                        for (var R in k)
                            Object.prototype.hasOwnProperty.call(k, R) && (v[R] = k[R])
                    }
                    return v
                }
                ,
                effect_cube_extends.apply(this, arguments)
            }
            var De = {
                "setTranslate": function setTranslate() {
                    var v, E = this, k = E.$el, R = E.$wrapperEl, U = E.slides, H = E.width, G = E.height, W = E.rtlTranslate, Z = E.size, Y = E.browser, J = E.params.cubeEffect, X = E.isHorizontal(), Q = E.virtual && E.params.virtual.enabled, ee = 0;
                    J.shadow && (X ? (0 === (v = R.find(".swiper-cube-shadow")).length && (v = K('<div class="swiper-cube-shadow"></div>'),
                    R.append(v)),
                    v.css({
                        "height": H + "px"
                    })) : 0 === (v = k.find(".swiper-cube-shadow")).length && (v = K('<div class="swiper-cube-shadow"></div>'),
                    k.append(v)));
                    for (var te = 0; te < U.length; te += 1) {
                        var ne = U.eq(te)
                          , re = te;
                        Q && (re = parseInt(ne.attr("data-swiper-slide-index"), 10));
                        var oe = 90 * re
                          , ie = Math.floor(oe / 360);
                        W && (oe = -oe,
                        ie = Math.floor(-oe / 360));
                        var ae = Math.max(Math.min(ne[0].progress, 1), -1)
                          , se = 0
                          , ce = 0
                          , le = 0;
                        re % 4 == 0 ? (se = 4 * -ie * Z,
                        le = 0) : (re - 1) % 4 == 0 ? (se = 0,
                        le = 4 * -ie * Z) : (re - 2) % 4 == 0 ? (se = Z + 4 * ie * Z,
                        le = Z) : (re - 3) % 4 == 0 && (se = -Z,
                        le = 3 * Z + 4 * Z * ie),
                        W && (se = -se),
                        X || (ce = se,
                        se = 0);
                        var ue = "rotateX(" + (X ? 0 : -oe) + "deg) rotateY(" + (X ? oe : 0) + "deg) translate3d(" + se + "px, " + ce + "px, " + le + "px)";
                        if (ae <= 1 && ae > -1 && (ee = 90 * re + 90 * ae,
                        W && (ee = 90 * -re - 90 * ae)),
                        ne.transform(ue),
                        J.slideShadows) {
                            var de = X ? ne.find(".swiper-slide-shadow-left") : ne.find(".swiper-slide-shadow-top")
                              , pe = X ? ne.find(".swiper-slide-shadow-right") : ne.find(".swiper-slide-shadow-bottom");
                            0 === de.length && (de = K('<div class="swiper-slide-shadow-' + (X ? "left" : "top") + '"></div>'),
                            ne.append(de)),
                            0 === pe.length && (pe = K('<div class="swiper-slide-shadow-' + (X ? "right" : "bottom") + '"></div>'),
                            ne.append(pe)),
                            de.length && (de[0].style.opacity = Math.max(-ae, 0)),
                            pe.length && (pe[0].style.opacity = Math.max(ae, 0))
                        }
                    }
                    if (R.css({
                        "-webkit-transform-origin": "50% 50% -" + Z / 2 + "px",
                        "-moz-transform-origin": "50% 50% -" + Z / 2 + "px",
                        "-ms-transform-origin": "50% 50% -" + Z / 2 + "px",
                        "transform-origin": "50% 50% -" + Z / 2 + "px"
                    }),
                    J.shadow)
                        if (X)
                            v.transform("translate3d(0px, " + (H / 2 + J.shadowOffset) + "px, " + -H / 2 + "px) rotateX(90deg) rotateZ(0deg) scale(" + J.shadowScale + ")");
                        else {
                            var fe = Math.abs(ee) - 90 * Math.floor(Math.abs(ee) / 90)
                              , he = 1.5 - (Math.sin(2 * fe * Math.PI / 360) / 2 + Math.cos(2 * fe * Math.PI / 360) / 2)
                              , me = J.shadowScale
                              , ge = J.shadowScale / he
                              , _e = J.shadowOffset;
                            v.transform("scale3d(" + me + ", 1, " + ge + ") translate3d(0px, " + (G / 2 + _e) + "px, " + -G / 2 / ge + "px) rotateX(-90deg)")
                        }
                    var ve = Y.isSafari || Y.isWebView ? -Z / 2 : 0;
                    R.transform("translate3d(0px,0," + ve + "px) rotateX(" + (E.isHorizontal() ? 0 : ee) + "deg) rotateY(" + (E.isHorizontal() ? -ee : 0) + "deg)")
                },
                "setTransition": function setTransition(v) {
                    var E = this
                      , k = E.$el;
                    E.slides.transition(v).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(v),
                    E.params.cubeEffect.shadow && !E.isHorizontal() && k.find(".swiper-cube-shadow").transition(v)
                }
            };
            function effect_flip_extends() {
                return effect_flip_extends = Object.assign || function(v) {
                    for (var E = 1; E < arguments.length; E++) {
                        var k = arguments[E];
                        for (var R in k)
                            Object.prototype.hasOwnProperty.call(k, R) && (v[R] = k[R])
                    }
                    return v
                }
                ,
                effect_flip_extends.apply(this, arguments)
            }
            var $e = {
                "setTranslate": function setTranslate() {
                    for (var v = this, E = v.slides, k = v.rtlTranslate, R = 0; R < E.length; R += 1) {
                        var U = E.eq(R)
                          , H = U[0].progress;
                        v.params.flipEffect.limitRotation && (H = Math.max(Math.min(U[0].progress, 1), -1));
                        var G = -180 * H
                          , W = 0
                          , Z = -U[0].swiperSlideOffset
                          , Y = 0;
                        if (v.isHorizontal() ? k && (G = -G) : (Y = Z,
                        Z = 0,
                        W = -G,
                        G = 0),
                        U[0].style.zIndex = -Math.abs(Math.round(H)) + E.length,
                        v.params.flipEffect.slideShadows) {
                            var J = v.isHorizontal() ? U.find(".swiper-slide-shadow-left") : U.find(".swiper-slide-shadow-top")
                              , X = v.isHorizontal() ? U.find(".swiper-slide-shadow-right") : U.find(".swiper-slide-shadow-bottom");
                            0 === J.length && (J = K('<div class="swiper-slide-shadow-' + (v.isHorizontal() ? "left" : "top") + '"></div>'),
                            U.append(J)),
                            0 === X.length && (X = K('<div class="swiper-slide-shadow-' + (v.isHorizontal() ? "right" : "bottom") + '"></div>'),
                            U.append(X)),
                            J.length && (J[0].style.opacity = Math.max(-H, 0)),
                            X.length && (X[0].style.opacity = Math.max(H, 0))
                        }
                        U.transform("translate3d(" + Z + "px, " + Y + "px, 0px) rotateX(" + W + "deg) rotateY(" + G + "deg)")
                    }
                },
                "setTransition": function setTransition(v) {
                    var E = this
                      , k = E.slides
                      , R = E.activeIndex
                      , U = E.$wrapperEl;
                    if (k.transition(v).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(v),
                    E.params.virtualTranslate && 0 !== v) {
                        var H = !1;
                        k.eq(R).transitionEnd((function onTransitionEnd() {
                            if (!H && E && !E.destroyed) {
                                H = !0,
                                E.animating = !1;
                                for (var v = ["webkitTransitionEnd", "transitionend"], k = 0; k < v.length; k += 1)
                                    U.trigger(v[k])
                            }
                        }
                        ))
                    }
                }
            };
            function effect_coverflow_extends() {
                return effect_coverflow_extends = Object.assign || function(v) {
                    for (var E = 1; E < arguments.length; E++) {
                        var k = arguments[E];
                        for (var R in k)
                            Object.prototype.hasOwnProperty.call(k, R) && (v[R] = k[R])
                    }
                    return v
                }
                ,
                effect_coverflow_extends.apply(this, arguments)
            }
            var Le = {
                "setTranslate": function setTranslate() {
                    for (var v = this, E = v.width, k = v.height, R = v.slides, U = v.slidesSizesGrid, H = v.params.coverflowEffect, G = v.isHorizontal(), W = v.translate, Z = G ? E / 2 - W : k / 2 - W, Y = G ? H.rotate : -H.rotate, J = H.depth, X = 0, Q = R.length; X < Q; X += 1) {
                        var ee = R.eq(X)
                          , te = U[X]
                          , ne = (Z - ee[0].swiperSlideOffset - te / 2) / te * H.modifier
                          , re = G ? Y * ne : 0
                          , oe = G ? 0 : Y * ne
                          , ie = -J * Math.abs(ne)
                          , ae = H.stretch;
                        "string" == typeof ae && -1 !== ae.indexOf("%") && (ae = parseFloat(H.stretch) / 100 * te);
                        var se = G ? 0 : ae * ne
                          , ce = G ? ae * ne : 0
                          , le = 1 - (1 - H.scale) * Math.abs(ne);
                        Math.abs(ce) < .001 && (ce = 0),
                        Math.abs(se) < .001 && (se = 0),
                        Math.abs(ie) < .001 && (ie = 0),
                        Math.abs(re) < .001 && (re = 0),
                        Math.abs(oe) < .001 && (oe = 0),
                        Math.abs(le) < .001 && (le = 0);
                        var ue = "translate3d(" + ce + "px," + se + "px," + ie + "px)  rotateX(" + oe + "deg) rotateY(" + re + "deg) scale(" + le + ")";
                        if (ee.transform(ue),
                        ee[0].style.zIndex = 1 - Math.abs(Math.round(ne)),
                        H.slideShadows) {
                            var de = G ? ee.find(".swiper-slide-shadow-left") : ee.find(".swiper-slide-shadow-top")
                              , pe = G ? ee.find(".swiper-slide-shadow-right") : ee.find(".swiper-slide-shadow-bottom");
                            0 === de.length && (de = K('<div class="swiper-slide-shadow-' + (G ? "left" : "top") + '"></div>'),
                            ee.append(de)),
                            0 === pe.length && (pe = K('<div class="swiper-slide-shadow-' + (G ? "right" : "bottom") + '"></div>'),
                            ee.append(pe)),
                            de.length && (de[0].style.opacity = ne > 0 ? ne : 0),
                            pe.length && (pe[0].style.opacity = -ne > 0 ? -ne : 0)
                        }
                    }
                },
                "setTransition": function setTransition(v) {
                    this.slides.transition(v).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(v)
                }
            };
            function thumbs_extends() {
                return thumbs_extends = Object.assign || function(v) {
                    for (var E = 1; E < arguments.length; E++) {
                        var k = arguments[E];
                        for (var R in k)
                            Object.prototype.hasOwnProperty.call(k, R) && (v[R] = k[R])
                    }
                    return v
                }
                ,
                thumbs_extends.apply(this, arguments)
            }
            var Fe = {
                "init": function init() {
                    var v = this
                      , E = v.params.thumbs;
                    if (v.thumbs.initialized)
                        return !1;
                    v.thumbs.initialized = !0;
                    var k = v.constructor;
                    return E.swiper instanceof k ? (v.thumbs.swiper = E.swiper,
                    utils_extend(v.thumbs.swiper.originalParams, {
                        "watchSlidesProgress": !0,
                        "slideToClickedSlide": !1
                    }),
                    utils_extend(v.thumbs.swiper.params, {
                        "watchSlidesProgress": !0,
                        "slideToClickedSlide": !1
                    })) : utils_isObject(E.swiper) && (v.thumbs.swiper = new k(utils_extend({}, E.swiper, {
                        "watchSlidesVisibility": !0,
                        "watchSlidesProgress": !0,
                        "slideToClickedSlide": !1
                    })),
                    v.thumbs.swiperCreated = !0),
                    v.thumbs.swiper.$el.addClass(v.params.thumbs.thumbsContainerClass),
                    v.thumbs.swiper.on("tap", v.thumbs.onThumbClick),
                    !0
                },
                "onThumbClick": function onThumbClick() {
                    var v = this
                      , E = v.thumbs.swiper;
                    if (E) {
                        var k = E.clickedIndex
                          , R = E.clickedSlide;
                        if (!(R && K(R).hasClass(v.params.thumbs.slideThumbActiveClass) || null == k)) {
                            var U;
                            if (U = E.params.loop ? parseInt(K(E.clickedSlide).attr("data-swiper-slide-index"), 10) : k,
                            v.params.loop) {
                                var H = v.activeIndex;
                                v.slides.eq(H).hasClass(v.params.slideDuplicateClass) && (v.loopFix(),
                                v._clientLeft = v.$wrapperEl[0].clientLeft,
                                H = v.activeIndex);
                                var G = v.slides.eq(H).prevAll('[data-swiper-slide-index="' + U + '"]').eq(0).index()
                                  , W = v.slides.eq(H).nextAll('[data-swiper-slide-index="' + U + '"]').eq(0).index();
                                U = void 0 === G ? W : void 0 === W ? G : W - H < H - G ? W : G
                            }
                            v.slideTo(U)
                        }
                    }
                },
                "update": function update(v) {
                    var E = this
                      , k = E.thumbs.swiper;
                    if (k) {
                        var R = "auto" === k.params.slidesPerView ? k.slidesPerViewDynamic() : k.params.slidesPerView
                          , U = E.params.thumbs.autoScrollOffset
                          , H = U && !k.params.loop;
                        if (E.realIndex !== k.realIndex || H) {
                            var G, W, Z = k.activeIndex;
                            if (k.params.loop) {
                                k.slides.eq(Z).hasClass(k.params.slideDuplicateClass) && (k.loopFix(),
                                k._clientLeft = k.$wrapperEl[0].clientLeft,
                                Z = k.activeIndex);
                                var Y = k.slides.eq(Z).prevAll('[data-swiper-slide-index="' + E.realIndex + '"]').eq(0).index()
                                  , J = k.slides.eq(Z).nextAll('[data-swiper-slide-index="' + E.realIndex + '"]').eq(0).index();
                                G = void 0 === Y ? J : void 0 === J ? Y : J - Z == Z - Y ? k.params.slidesPerGroup > 1 ? J : Z : J - Z < Z - Y ? J : Y,
                                W = E.activeIndex > E.previousIndex ? "next" : "prev"
                            } else
                                W = (G = E.realIndex) > E.previousIndex ? "next" : "prev";
                            H && (G += "next" === W ? U : -1 * U),
                            k.visibleSlidesIndexes && k.visibleSlidesIndexes.indexOf(G) < 0 && (k.params.centeredSlides ? G = G > Z ? G - Math.floor(R / 2) + 1 : G + Math.floor(R / 2) - 1 : G > Z && k.params.slidesPerGroup,
                            k.slideTo(G, v ? 0 : void 0))
                        }
                        var K = 1
                          , X = E.params.thumbs.slideThumbActiveClass;
                        if (E.params.slidesPerView > 1 && !E.params.centeredSlides && (K = E.params.slidesPerView),
                        E.params.thumbs.multipleActiveThumbs || (K = 1),
                        K = Math.floor(K),
                        k.slides.removeClass(X),
                        k.params.loop || k.params.virtual && k.params.virtual.enabled)
                            for (var Q = 0; Q < K; Q += 1)
                                k.$wrapperEl.children('[data-swiper-slide-index="' + (E.realIndex + Q) + '"]').addClass(X);
                        else
                            for (var ee = 0; ee < K; ee += 1)
                                k.slides.eq(E.realIndex + ee).addClass(X)
                    }
                }
            }
              , je = [_e, ye, {
                "name": "mousewheel",
                "params": {
                    "mousewheel": {
                        "enabled": !1,
                        "releaseOnEdges": !1,
                        "invert": !1,
                        "forceToAxis": !1,
                        "sensitivity": 1,
                        "eventsTarget": "container",
                        "thresholdDelta": null,
                        "thresholdTime": null
                    }
                },
                "create": function create() {
                    bindModuleMethods(this, {
                        "mousewheel": {
                            "enabled": !1,
                            "lastScrollTime": now(),
                            "lastEventBeforeSnap": void 0,
                            "recentWheelEvents": [],
                            "enable": be.enable,
                            "disable": be.disable,
                            "handle": be.handle,
                            "handleMouseEnter": be.handleMouseEnter,
                            "handleMouseLeave": be.handleMouseLeave,
                            "animateSlider": be.animateSlider,
                            "releaseScroll": be.releaseScroll
                        }
                    })
                },
                "on": {
                    "init": function init(v) {
                        !v.params.mousewheel.enabled && v.params.cssMode && v.mousewheel.disable(),
                        v.params.mousewheel.enabled && v.mousewheel.enable()
                    },
                    "destroy": function destroy(v) {
                        v.params.cssMode && v.mousewheel.enable(),
                        v.mousewheel.enabled && v.mousewheel.disable()
                    }
                }
            }, {
                "name": "navigation",
                "params": {
                    "navigation": {
                        "nextEl": null,
                        "prevEl": null,
                        "hideOnClick": !1,
                        "disabledClass": "swiper-button-disabled",
                        "hiddenClass": "swiper-button-hidden",
                        "lockClass": "swiper-button-lock"
                    }
                },
                "create": function create() {
                    bindModuleMethods(this, {
                        "navigation": navigation_extends({}, Se)
                    })
                },
                "on": {
                    "init": function init(v) {
                        v.navigation.init(),
                        v.navigation.update()
                    },
                    "toEdge": function toEdge(v) {
                        v.navigation.update()
                    },
                    "fromEdge": function fromEdge(v) {
                        v.navigation.update()
                    },
                    "destroy": function destroy(v) {
                        v.navigation.destroy()
                    },
                    "enable disable": function enableDisable(v) {
                        var E = v.navigation
                          , k = E.$nextEl
                          , R = E.$prevEl;
                        k && k[v.enabled ? "removeClass" : "addClass"](v.params.navigation.lockClass),
                        R && R[v.enabled ? "removeClass" : "addClass"](v.params.navigation.lockClass)
                    },
                    "click": function click(v, E) {
                        var k = v.navigation
                          , R = k.$nextEl
                          , U = k.$prevEl
                          , H = E.target;
                        if (v.params.navigation.hideOnClick && !K(H).is(U) && !K(H).is(R)) {
                            if (v.pagination && v.params.pagination && v.params.pagination.clickable && (v.pagination.el === H || v.pagination.el.contains(H)))
                                return;
                            var G;
                            R ? G = R.hasClass(v.params.navigation.hiddenClass) : U && (G = U.hasClass(v.params.navigation.hiddenClass)),
                            !0 === G ? v.emit("navigationShow") : v.emit("navigationHide"),
                            R && R.toggleClass(v.params.navigation.hiddenClass),
                            U && U.toggleClass(v.params.navigation.hiddenClass)
                        }
                    }
                }
            }, {
                "name": "pagination",
                "params": {
                    "pagination": {
                        "el": null,
                        "bulletElement": "span",
                        "clickable": !1,
                        "hideOnClick": !1,
                        "renderBullet": null,
                        "renderProgressbar": null,
                        "renderFraction": null,
                        "renderCustom": null,
                        "progressbarOpposite": !1,
                        "type": "bullets",
                        "dynamicBullets": !1,
                        "dynamicMainBullets": 1,
                        "formatFractionCurrent": function formatFractionCurrent(v) {
                            return v
                        },
                        "formatFractionTotal": function formatFractionTotal(v) {
                            return v
                        },
                        "bulletClass": "swiper-pagination-bullet",
                        "bulletActiveClass": "swiper-pagination-bullet-active",
                        "modifierClass": "swiper-pagination-",
                        "currentClass": "swiper-pagination-current",
                        "totalClass": "swiper-pagination-total",
                        "hiddenClass": "swiper-pagination-hidden",
                        "progressbarFillClass": "swiper-pagination-progressbar-fill",
                        "progressbarOppositeClass": "swiper-pagination-progressbar-opposite",
                        "clickableClass": "swiper-pagination-clickable",
                        "lockClass": "swiper-pagination-lock"
                    }
                },
                "create": function create() {
                    bindModuleMethods(this, {
                        "pagination": pagination_extends({
                            "dynamicBulletIndex": 0
                        }, we)
                    })
                },
                "on": {
                    "init": function init(v) {
                        v.pagination.init(),
                        v.pagination.render(),
                        v.pagination.update()
                    },
                    "activeIndexChange": function activeIndexChange(v) {
                        (v.params.loop || void 0 === v.snapIndex) && v.pagination.update()
                    },
                    "snapIndexChange": function snapIndexChange(v) {
                        v.params.loop || v.pagination.update()
                    },
                    "slidesLengthChange": function slidesLengthChange(v) {
                        v.params.loop && (v.pagination.render(),
                        v.pagination.update())
                    },
                    "snapGridLengthChange": function snapGridLengthChange(v) {
                        v.params.loop || (v.pagination.render(),
                        v.pagination.update())
                    },
                    "destroy": function destroy(v) {
                        v.pagination.destroy()
                    },
                    "enable disable": function enableDisable(v) {
                        var E = v.pagination.$el;
                        E && E[v.enabled ? "removeClass" : "addClass"](v.params.pagination.lockClass)
                    },
                    "click": function click(v, E) {
                        var k = E.target;
                        if (v.params.pagination.el && v.params.pagination.hideOnClick && v.pagination.$el.length > 0 && !K(k).hasClass(v.params.pagination.bulletClass)) {
                            if (v.navigation && (v.navigation.nextEl && k === v.navigation.nextEl || v.navigation.prevEl && k === v.navigation.prevEl))
                                return;
                            !0 === v.pagination.$el.hasClass(v.params.pagination.hiddenClass) ? v.emit("paginationShow") : v.emit("paginationHide"),
                            v.pagination.$el.toggleClass(v.params.pagination.hiddenClass)
                        }
                    }
                }
            }, {
                "name": "scrollbar",
                "params": {
                    "scrollbar": {
                        "el": null,
                        "dragSize": "auto",
                        "hide": !1,
                        "draggable": !1,
                        "snapOnRelease": !0,
                        "lockClass": "swiper-scrollbar-lock",
                        "dragClass": "swiper-scrollbar-drag"
                    }
                },
                "create": function create() {
                    bindModuleMethods(this, {
                        "scrollbar": scrollbar_extends({
                            "isTouched": !1,
                            "timeout": null,
                            "dragTimeout": null
                        }, Ee)
                    })
                },
                "on": {
                    "init": function init(v) {
                        v.scrollbar.init(),
                        v.scrollbar.updateSize(),
                        v.scrollbar.setTranslate()
                    },
                    "update": function update(v) {
                        v.scrollbar.updateSize()
                    },
                    "resize": function resize(v) {
                        v.scrollbar.updateSize()
                    },
                    "observerUpdate": function observerUpdate(v) {
                        v.scrollbar.updateSize()
                    },
                    "setTranslate": function setTranslate(v) {
                        v.scrollbar.setTranslate()
                    },
                    "setTransition": function setTransition(v, E) {
                        v.scrollbar.setTransition(E)
                    },
                    "enable disable": function enableDisable(v) {
                        var E = v.scrollbar.$el;
                        E && E[v.enabled ? "removeClass" : "addClass"](v.params.scrollbar.lockClass)
                    },
                    "destroy": function destroy(v) {
                        v.scrollbar.destroy()
                    }
                }
            }, {
                "name": "parallax",
                "params": {
                    "parallax": {
                        "enabled": !1
                    }
                },
                "create": function create() {
                    bindModuleMethods(this, {
                        "parallax": parallax_extends({}, Ce)
                    })
                },
                "on": {
                    "beforeInit": function beforeInit(v) {
                        v.params.parallax.enabled && (v.params.watchSlidesProgress = !0,
                        v.originalParams.watchSlidesProgress = !0)
                    },
                    "init": function init(v) {
                        v.params.parallax.enabled && v.parallax.setTranslate()
                    },
                    "setTranslate": function setTranslate(v) {
                        v.params.parallax.enabled && v.parallax.setTranslate()
                    },
                    "setTransition": function setTransition(v, E) {
                        v.params.parallax.enabled && v.parallax.setTransition(E)
                    }
                }
            }, xe, {
                "name": "lazy",
                "params": {
                    "lazy": {
                        "checkInView": !1,
                        "enabled": !1,
                        "loadPrevNext": !1,
                        "loadPrevNextAmount": 1,
                        "loadOnTransitionStart": !1,
                        "scrollingElement": "",
                        "elementClass": "swiper-lazy",
                        "loadingClass": "swiper-lazy-loading",
                        "loadedClass": "swiper-lazy-loaded",
                        "preloaderClass": "swiper-lazy-preloader"
                    }
                },
                "create": function create() {
                    bindModuleMethods(this, {
                        "lazy": lazy_extends({
                            "initialImageLoaded": !1
                        }, Ae)
                    })
                },
                "on": {
                    "beforeInit": function beforeInit(v) {
                        v.params.lazy.enabled && v.params.preloadImages && (v.params.preloadImages = !1)
                    },
                    "init": function init(v) {
                        v.params.lazy.enabled && !v.params.loop && 0 === v.params.initialSlide && (v.params.lazy.checkInView ? v.lazy.checkInViewOnLoad() : v.lazy.load())
                    },
                    "scroll": function scroll(v) {
                        v.params.freeMode && !v.params.freeModeSticky && v.lazy.load()
                    },
                    "scrollbarDragMove resize _freeModeNoMomentumRelease": function lazyLoad(v) {
                        v.params.lazy.enabled && v.lazy.load()
                    },
                    "transitionStart": function transitionStart(v) {
                        v.params.lazy.enabled && (v.params.lazy.loadOnTransitionStart || !v.params.lazy.loadOnTransitionStart && !v.lazy.initialImageLoaded) && v.lazy.load()
                    },
                    "transitionEnd": function transitionEnd(v) {
                        v.params.lazy.enabled && !v.params.lazy.loadOnTransitionStart && v.lazy.load()
                    },
                    "slideChange": function slideChange(v) {
                        var E = v.params
                          , k = E.lazy
                          , R = E.cssMode
                          , U = E.watchSlidesVisibility
                          , H = E.watchSlidesProgress
                          , G = E.touchReleaseOnEdges
                          , W = E.resistanceRatio;
                        k.enabled && (R || (U || H) && (G || 0 === W)) && v.lazy.load()
                    }
                }
            }, ke, {
                "name": "a11y",
                "params": {
                    "a11y": {
                        "enabled": !0,
                        "notificationClass": "swiper-notification",
                        "prevSlideMessage": "Previous slide",
                        "nextSlideMessage": "Next slide",
                        "firstSlideMessage": "This is the first slide",
                        "lastSlideMessage": "This is the last slide",
                        "paginationBulletMessage": "Go to slide {{index}}",
                        "slideLabelMessage": "{{index}} / {{slidesLength}}",
                        "containerMessage": null,
                        "containerRoleDescriptionMessage": null,
                        "itemRoleDescriptionMessage": null,
                        "slideRole": "group"
                    }
                },
                "create": function create() {
                    bindModuleMethods(this, {
                        "a11y": a11y_extends({}, Oe, {
                            "liveRegion": K('<span class="' + this.params.a11y.notificationClass + '" aria-live="assertive" aria-atomic="true"></span>')
                        })
                    })
                },
                "on": {
                    "afterInit": function afterInit(v) {
                        v.params.a11y.enabled && (v.a11y.init(),
                        v.a11y.updateNavigation())
                    },
                    "toEdge": function toEdge(v) {
                        v.params.a11y.enabled && v.a11y.updateNavigation()
                    },
                    "fromEdge": function fromEdge(v) {
                        v.params.a11y.enabled && v.a11y.updateNavigation()
                    },
                    "paginationUpdate": function paginationUpdate(v) {
                        v.params.a11y.enabled && v.a11y.updatePagination()
                    },
                    "destroy": function destroy(v) {
                        v.params.a11y.enabled && v.a11y.destroy()
                    }
                }
            }, {
                "name": "history",
                "params": {
                    "history": {
                        "enabled": !1,
                        "root": "",
                        "replaceState": !1,
                        "key": "slides"
                    }
                },
                "create": function create() {
                    bindModuleMethods(this, {
                        "history": history_extends({}, Pe)
                    })
                },
                "on": {
                    "init": function init(v) {
                        v.params.history.enabled && v.history.init()
                    },
                    "destroy": function destroy(v) {
                        v.params.history.enabled && v.history.destroy()
                    },
                    "transitionEnd _freeModeNoMomentumRelease": function transitionEnd_freeModeNoMomentumRelease(v) {
                        v.history.initialized && v.history.setHistory(v.params.history.key, v.activeIndex)
                    },
                    "slideChange": function slideChange(v) {
                        v.history.initialized && v.params.cssMode && v.history.setHistory(v.params.history.key, v.activeIndex)
                    }
                }
            }, {
                "name": "hash-navigation",
                "params": {
                    "hashNavigation": {
                        "enabled": !1,
                        "replaceState": !1,
                        "watchState": !1
                    }
                },
                "create": function create() {
                    bindModuleMethods(this, {
                        "hashNavigation": hash_navigation_extends({
                            "initialized": !1
                        }, Re)
                    })
                },
                "on": {
                    "init": function init(v) {
                        v.params.hashNavigation.enabled && v.hashNavigation.init()
                    },
                    "destroy": function destroy(v) {
                        v.params.hashNavigation.enabled && v.hashNavigation.destroy()
                    },
                    "transitionEnd _freeModeNoMomentumRelease": function transitionEnd_freeModeNoMomentumRelease(v) {
                        v.hashNavigation.initialized && v.hashNavigation.setHash()
                    },
                    "slideChange": function slideChange(v) {
                        v.hashNavigation.initialized && v.params.cssMode && v.hashNavigation.setHash()
                    }
                }
            }, {
                "name": "autoplay",
                "params": {
                    "autoplay": {
                        "enabled": !1,
                        "delay": 3e3,
                        "waitForTransition": !0,
                        "disableOnInteraction": !0,
                        "stopOnLastSlide": !1,
                        "reverseDirection": !1,
                        "pauseOnMouseEnter": !1
                    }
                },
                "create": function create() {
                    bindModuleMethods(this, {
                        "autoplay": autoplay_extends({}, Me, {
                            "running": !1,
                            "paused": !1
                        })
                    })
                },
                "on": {
                    "init": function init(v) {
                        v.params.autoplay.enabled && (v.autoplay.start(),
                        getDocument().addEventListener("visibilitychange", v.autoplay.onVisibilityChange),
                        v.autoplay.attachMouseEvents())
                    },
                    "beforeTransitionStart": function beforeTransitionStart(v, E, k) {
                        v.autoplay.running && (k || !v.params.autoplay.disableOnInteraction ? v.autoplay.pause(E) : v.autoplay.stop())
                    },
                    "sliderFirstMove": function sliderFirstMove(v) {
                        v.autoplay.running && (v.params.autoplay.disableOnInteraction ? v.autoplay.stop() : v.autoplay.pause())
                    },
                    "touchEnd": function touchEnd(v) {
                        v.params.cssMode && v.autoplay.paused && !v.params.autoplay.disableOnInteraction && v.autoplay.run()
                    },
                    "destroy": function destroy(v) {
                        v.autoplay.detachMouseEvents(),
                        v.autoplay.running && v.autoplay.stop(),
                        getDocument().removeEventListener("visibilitychange", v.autoplay.onVisibilityChange)
                    }
                }
            }, {
                "name": "effect-fade",
                "params": {
                    "fadeEffect": {
                        "crossFade": !1
                    }
                },
                "create": function create() {
                    bindModuleMethods(this, {
                        "fadeEffect": effect_fade_extends({}, Ne)
                    })
                },
                "on": {
                    "beforeInit": function beforeInit(v) {
                        if ("fade" === v.params.effect) {
                            v.classNames.push(v.params.containerModifierClass + "fade");
                            var E = {
                                "slidesPerView": 1,
                                "slidesPerColumn": 1,
                                "slidesPerGroup": 1,
                                "watchSlidesProgress": !0,
                                "spaceBetween": 0,
                                "virtualTranslate": !0
                            };
                            utils_extend(v.params, E),
                            utils_extend(v.originalParams, E)
                        }
                    },
                    "setTranslate": function setTranslate(v) {
                        "fade" === v.params.effect && v.fadeEffect.setTranslate()
                    },
                    "setTransition": function setTransition(v, E) {
                        "fade" === v.params.effect && v.fadeEffect.setTransition(E)
                    }
                }
            }, {
                "name": "effect-cube",
                "params": {
                    "cubeEffect": {
                        "slideShadows": !0,
                        "shadow": !0,
                        "shadowOffset": 20,
                        "shadowScale": .94
                    }
                },
                "create": function create() {
                    bindModuleMethods(this, {
                        "cubeEffect": effect_cube_extends({}, De)
                    })
                },
                "on": {
                    "beforeInit": function beforeInit(v) {
                        if ("cube" === v.params.effect) {
                            v.classNames.push(v.params.containerModifierClass + "cube"),
                            v.classNames.push(v.params.containerModifierClass + "3d");
                            var E = {
                                "slidesPerView": 1,
                                "slidesPerColumn": 1,
                                "slidesPerGroup": 1,
                                "watchSlidesProgress": !0,
                                "resistanceRatio": 0,
                                "spaceBetween": 0,
                                "centeredSlides": !1,
                                "virtualTranslate": !0
                            };
                            utils_extend(v.params, E),
                            utils_extend(v.originalParams, E)
                        }
                    },
                    "setTranslate": function setTranslate(v) {
                        "cube" === v.params.effect && v.cubeEffect.setTranslate()
                    },
                    "setTransition": function setTransition(v, E) {
                        "cube" === v.params.effect && v.cubeEffect.setTransition(E)
                    }
                }
            }, {
                "name": "effect-flip",
                "params": {
                    "flipEffect": {
                        "slideShadows": !0,
                        "limitRotation": !0
                    }
                },
                "create": function create() {
                    bindModuleMethods(this, {
                        "flipEffect": effect_flip_extends({}, $e)
                    })
                },
                "on": {
                    "beforeInit": function beforeInit(v) {
                        if ("flip" === v.params.effect) {
                            v.classNames.push(v.params.containerModifierClass + "flip"),
                            v.classNames.push(v.params.containerModifierClass + "3d");
                            var E = {
                                "slidesPerView": 1,
                                "slidesPerColumn": 1,
                                "slidesPerGroup": 1,
                                "watchSlidesProgress": !0,
                                "spaceBetween": 0,
                                "virtualTranslate": !0
                            };
                            utils_extend(v.params, E),
                            utils_extend(v.originalParams, E)
                        }
                    },
                    "setTranslate": function setTranslate(v) {
                        "flip" === v.params.effect && v.flipEffect.setTranslate()
                    },
                    "setTransition": function setTransition(v, E) {
                        "flip" === v.params.effect && v.flipEffect.setTransition(E)
                    }
                }
            }, {
                "name": "effect-coverflow",
                "params": {
                    "coverflowEffect": {
                        "rotate": 50,
                        "stretch": 0,
                        "depth": 100,
                        "scale": 1,
                        "modifier": 1,
                        "slideShadows": !0
                    }
                },
                "create": function create() {
                    bindModuleMethods(this, {
                        "coverflowEffect": effect_coverflow_extends({}, Le)
                    })
                },
                "on": {
                    "beforeInit": function beforeInit(v) {
                        "coverflow" === v.params.effect && (v.classNames.push(v.params.containerModifierClass + "coverflow"),
                        v.classNames.push(v.params.containerModifierClass + "3d"),
                        v.params.watchSlidesProgress = !0,
                        v.originalParams.watchSlidesProgress = !0)
                    },
                    "setTranslate": function setTranslate(v) {
                        "coverflow" === v.params.effect && v.coverflowEffect.setTranslate()
                    },
                    "setTransition": function setTransition(v, E) {
                        "coverflow" === v.params.effect && v.coverflowEffect.setTransition(E)
                    }
                }
            }, {
                "name": "thumbs",
                "params": {
                    "thumbs": {
                        "swiper": null,
                        "multipleActiveThumbs": !0,
                        "autoScrollOffset": 0,
                        "slideThumbActiveClass": "swiper-slide-thumb-active",
                        "thumbsContainerClass": "swiper-container-thumbs"
                    }
                },
                "create": function create() {
                    bindModuleMethods(this, {
                        "thumbs": thumbs_extends({
                            "swiper": null,
                            "initialized": !1
                        }, Fe)
                    })
                },
                "on": {
                    "beforeInit": function beforeInit(v) {
                        var E = v.params.thumbs;
                        E && E.swiper && (v.thumbs.init(),
                        v.thumbs.update(!0))
                    },
                    "slideChange": function slideChange(v) {
                        v.thumbs.swiper && v.thumbs.update()
                    },
                    "update": function update(v) {
                        v.thumbs.swiper && v.thumbs.update()
                    },
                    "resize": function resize(v) {
                        v.thumbs.swiper && v.thumbs.update()
                    },
                    "observerUpdate": function observerUpdate(v) {
                        v.thumbs.swiper && v.thumbs.update()
                    },
                    "setTransition": function setTransition(v, E) {
                        var k = v.thumbs.swiper;
                        k && k.setTransition(E)
                    },
                    "beforeDestroy": function beforeDestroy(v) {
                        var E = v.thumbs.swiper;
                        E && v.thumbs.swiperCreated && E && E.destroy()
                    }
                }
            }];
            me.use(je)
        },
        "9885": function(v) {
            const E = /[A-Z\xc0-\xd6\xd8-\xde]?[a-z\xdf-\xf6\xf8-\xff]+(?:['’](?:d|ll|m|re|s|t|ve))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde]|$)|(?:[A-Z\xc0-\xd6\xd8-\xde]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['’](?:D|LL|M|RE|S|T|VE))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde](?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])|$)|[A-Z\xc0-\xd6\xd8-\xde]?(?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['’](?:d|ll|m|re|s|t|ve))?|[A-Z\xc0-\xd6\xd8-\xde]+(?:['’](?:D|LL|M|RE|S|T|VE))?|\d*(?:1ST|2ND|3RD|(?![123])\dTH)(?=\b|[a-z_])|\d*(?:1st|2nd|3rd|(?![123])\dth)(?=\b|[A-Z_])|\d+|(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?(?:\u200d(?:[^\ud800-\udfff]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?)*/g
              , words = v => v.match(E) || []
              , upperFirst = v => v[0].toUpperCase() + v.slice(1)
              , join = (v, E) => words(v).join(E).toLowerCase()
              , camelCase = v => words(v).reduce(( (v, E) => `${v}${v ? E[0].toUpperCase() + E.slice(1).toLowerCase() : E.toLowerCase()}`), "");
            v.exports = {
                "words": words,
                "upperFirst": upperFirst,
                "camelCase": camelCase,
                "pascalCase": v => upperFirst(camelCase(v)),
                "snakeCase": v => join(v, "_"),
                "kebabCase": v => join(v, "-"),
                "sentenceCase": v => upperFirst(join(v, " ")),
                "titleCase": v => words(v).map(upperFirst).join(" ")
            }
        },
        "1742": function(v) {
            v.exports = function() {
                var v = document.getSelection();
                if (!v.rangeCount)
                    return function() {}
                    ;
                for (var E = document.activeElement, k = [], R = 0; R < v.rangeCount; R++)
                    k.push(v.getRangeAt(R));
                switch (E.tagName.toUpperCase()) {
                case "INPUT":
                case "TEXTAREA":
                    E.blur();
                    break;
                default:
                    E = null
                }
                return v.removeAllRanges(),
                function() {
                    "Caret" === v.type && v.removeAllRanges(),
                    v.rangeCount || k.forEach((function(E) {
                        v.addRange(E)
                    }
                    )),
                    E && E.focus()
                }
            }
        },
        "4633": function(v) {
            function toposort(v, E) {
                var k = v.length
                  , R = new Array(k)
                  , U = {}
                  , H = k
                  , G = function makeOutgoingEdges(v) {
                    for (var E = new Map, k = 0, R = v.length; k < R; k++) {
                        var U = v[k];
                        E.has(U[0]) || E.set(U[0], new Set),
                        E.has(U[1]) || E.set(U[1], new Set),
                        E.get(U[0]).add(U[1])
                    }
                    return E
                }(E)
                  , W = function makeNodesHash(v) {
                    for (var E = new Map, k = 0, R = v.length; k < R; k++)
                        E.set(v[k], k);
                    return E
                }(v);
                for (E.forEach((function(v) {
                    if (!W.has(v[0]) || !W.has(v[1]))
                        throw new Error("Unknown node. There is an unknown node in the supplied edges.")
                }
                )); H--; )
                    U[H] || visit(v[H], H, new Set);
                return R;
                function visit(v, E, H) {
                    if (H.has(v)) {
                        var Z;
                        try {
                            Z = ", node was:" + JSON.stringify(v)
                        } catch (v) {
                            Z = ""
                        }
                        throw new Error("Cyclic dependency" + Z)
                    }
                    if (!W.has(v))
                        throw new Error("Found unknown node. Make sure to provided all involved nodes. Unknown node: " + JSON.stringify(v));
                    if (!U[E]) {
                        U[E] = !0;
                        var Y = G.get(v) || new Set;
                        if (E = (Y = Array.from(Y)).length) {
                            H.add(v);
                            do {
                                var J = Y[--E];
                                visit(J, W.get(J), H)
                            } while (E);
                            H.delete(v)
                        }
                        R[--k] = v
                    }
                }
            }
            v.exports = function(v) {
                return toposort(function uniqueNodes(v) {
                    for (var E = new Set, k = 0, R = v.length; k < R; k++) {
                        var U = v[k];
                        E.add(U[0]),
                        E.add(U[1])
                    }
                    return Array.from(E)
                }(v), v)
            }
            ,
            v.exports.array = toposort
        },
        "9724": function(v, E, k) {
            "use strict";
            var R = k(2095)
              , U = k.n(R)
              , H = Object.prototype.hasOwnProperty
              , G = new Map;
            function decodeParam(v) {
                try {
                    return decodeURIComponent(v)
                } catch (E) {
                    return v
                }
            }
            function matchRoute(v, E, k, R, W) {
                var Z, Y, J = 0;
                return {
                    "next": function next(K) {
                        if (v === K)
                            return {
                                "done": !0
                            };
                        if (!Z && (Z = function matchPath(v, E, k, R) {
                            var W = !v.children
                              , Z = (v.path || "") + "|" + W
                              , Y = G.get(Z);
                            if (!Y) {
                                var J = [];
                                Y = {
                                    "keys": J,
                                    "pattern": U()(v.path || "", J, {
                                        "end": W
                                    })
                                },
                                G.set(Z, Y)
                            }
                            var K = Y.pattern.exec(E);
                            if (!K)
                                return null;
                            for (var X = K[0], Q = Object.assign({}, R), ee = 1; ee < K.length; ee++) {
                                var te = Y.keys[ee - 1]
                                  , ne = te.name
                                  , re = K[ee];
                                void 0 === re && H.call(Q, ne) || (te.repeat ? Q[ne] = re ? re.split(te.delimiter).map(decodeParam) : [] : Q[ne] = re ? decodeParam(re) : re)
                            }
                            return {
                                "path": W || "/" !== X.charAt(X.length - 1) ? X : X.substr(1),
                                "keys": k.concat(Y.keys),
                                "params": Q
                            }
                        }(v, k, R, W),
                        Z))
                            return {
                                "done": !1,
                                "value": {
                                    "route": v,
                                    "baseUrl": E,
                                    "path": Z.path,
                                    "keys": Z.keys,
                                    "params": Z.params
                                }
                            };
                        if (Z && v.children)
                            for (; J < v.children.length; ) {
                                if (!Y) {
                                    var X = v.children[J];
                                    X.parent = v,
                                    Y = matchRoute(X, E + Z.path, k.substr(Z.path.length), Z.keys, Z.params)
                                }
                                var Q = Y.next(K);
                                if (!Q.done)
                                    return {
                                        "done": !1,
                                        "value": Q.value
                                    };
                                Y = null,
                                J++
                            }
                        return {
                            "done": !0
                        }
                    }
                }
            }
            function resolveRoute(v, E) {
                if ("function" == typeof v.route.action)
                    return v.route.action(v, E)
            }
            var W = function() {
                function UniversalRouter(v, E) {
                    if (void 0 === E && (E = {}),
                    !v || "object" != typeof v)
                        throw new TypeError("Invalid routes");
                    this.baseUrl = E.baseUrl || "",
                    this.errorHandler = E.errorHandler,
                    this.resolveRoute = E.resolveRoute || resolveRoute,
                    this.context = Object.assign({
                        "router": this
                    }, E.context),
                    this.root = Array.isArray(v) ? {
                        "path": "",
                        "children": v,
                        "parent": null
                    } : v,
                    this.root.parent = null
                }
                return UniversalRouter.prototype.resolve = function resolve(v) {
                    var E = this
                      , k = Object.assign({}, this.context, {}, "string" == typeof v ? {
                        "pathname": v
                    } : v)
                      , R = matchRoute(this.root, this.baseUrl, k.pathname.substr(this.baseUrl.length), [], null)
                      , resolve = this.resolveRoute
                      , U = null
                      , H = null
                      , G = k;
                    function next(v, E, W) {
                        void 0 === E && (E = U.value.route);
                        var Z = null === W && !U.done && U.value.route;
                        if (U = H || R.next(Z),
                        H = null,
                        !v && (U.done || !function isChildRoute(v, E) {
                            for (var k = E; k; )
                                if ((k = k.parent) === v)
                                    return !0;
                            return !1
                        }(E, U.value.route)))
                            return H = U,
                            Promise.resolve(null);
                        if (U.done) {
                            var Y = new Error("Route not found");
                            return Y.status = 404,
                            Promise.reject(Y)
                        }
                        return G = Object.assign({}, k, {}, U.value),
                        Promise.resolve(resolve(G, U.value.params)).then((function(k) {
                            return null != k ? k : next(v, E, k)
                        }
                        ))
                    }
                    return k.next = next,
                    Promise.resolve().then((function() {
                        return next(!0, E.root)
                    }
                    )).catch((function(v) {
                        if (E.errorHandler)
                            return E.errorHandler(v, G);
                        throw v
                    }
                    ))
                }
                ,
                UniversalRouter
            }();
            W.pathToRegexp = U(),
            E.Z = W
        },
        "2095": function(v) {
            v.exports = pathToRegexp,
            v.exports.match = function match(v, E) {
                var k = [];
                return regexpToFunction(pathToRegexp(v, k, E), k)
            }
            ,
            v.exports.regexpToFunction = regexpToFunction,
            v.exports.parse = parse,
            v.exports.compile = function compile(v, E) {
                return tokensToFunction(parse(v, E), E)
            }
            ,
            v.exports.tokensToFunction = tokensToFunction,
            v.exports.tokensToRegExp = tokensToRegExp;
            var E = "/"
              , k = new RegExp(["(\\\\.)", "(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?"].join("|"),"g");
            function parse(v, R) {
                for (var U, H = [], G = 0, W = 0, Z = "", Y = R && R.delimiter || E, J = R && R.whitelist || void 0, K = !1; null !== (U = k.exec(v)); ) {
                    var X = U[0]
                      , Q = U[1]
                      , ee = U.index;
                    if (Z += v.slice(W, ee),
                    W = ee + X.length,
                    Q)
                        Z += Q[1],
                        K = !0;
                    else {
                        var te = ""
                          , ne = U[2]
                          , re = U[3]
                          , oe = U[4]
                          , ie = U[5];
                        if (!K && Z.length) {
                            var ae = Z.length - 1
                              , se = Z[ae];
                            (!J || J.indexOf(se) > -1) && (te = se,
                            Z = Z.slice(0, ae))
                        }
                        Z && (H.push(Z),
                        Z = "",
                        K = !1);
                        var ce = "+" === ie || "*" === ie
                          , le = "?" === ie || "*" === ie
                          , ue = re || oe
                          , de = te || Y;
                        H.push({
                            "name": ne || G++,
                            "prefix": te,
                            "delimiter": de,
                            "optional": le,
                            "repeat": ce,
                            "pattern": ue ? escapeGroup(ue) : "[^" + escapeString(de === Y ? de : de + Y) + "]+?"
                        })
                    }
                }
                return (Z || W < v.length) && H.push(Z + v.substr(W)),
                H
            }
            function regexpToFunction(v, E) {
                return function(k, R) {
                    var U = v.exec(k);
                    if (!U)
                        return !1;
                    for (var H = U[0], G = U.index, W = {}, Z = R && R.decode || decodeURIComponent, Y = 1; Y < U.length; Y++)
                        if (void 0 !== U[Y]) {
                            var J = E[Y - 1];
                            J.repeat ? W[J.name] = U[Y].split(J.delimiter).map((function(v) {
                                return Z(v, J)
                            }
                            )) : W[J.name] = Z(U[Y], J)
                        }
                    return {
                        "path": H,
                        "index": G,
                        "params": W
                    }
                }
            }
            function tokensToFunction(v, E) {
                for (var k = new Array(v.length), R = 0; R < v.length; R++)
                    "object" == typeof v[R] && (k[R] = new RegExp("^(?:" + v[R].pattern + ")$",flags(E)));
                return function(E, R) {
                    for (var U = "", H = R && R.encode || encodeURIComponent, G = !R || !1 !== R.validate, W = 0; W < v.length; W++) {
                        var Z = v[W];
                        if ("string" != typeof Z) {
                            var Y, J = E ? E[Z.name] : void 0;
                            if (Array.isArray(J)) {
                                if (!Z.repeat)
                                    throw new TypeError('Expected "' + Z.name + '" to not repeat, but got array');
                                if (0 === J.length) {
                                    if (Z.optional)
                                        continue;
                                    throw new TypeError('Expected "' + Z.name + '" to not be empty')
                                }
                                for (var K = 0; K < J.length; K++) {
                                    if (Y = H(J[K], Z),
                                    G && !k[W].test(Y))
                                        throw new TypeError('Expected all "' + Z.name + '" to match "' + Z.pattern + '"');
                                    U += (0 === K ? Z.prefix : Z.delimiter) + Y
                                }
                            } else if ("string" != typeof J && "number" != typeof J && "boolean" != typeof J) {
                                if (!Z.optional)
                                    throw new TypeError('Expected "' + Z.name + '" to be ' + (Z.repeat ? "an array" : "a string"))
                            } else {
                                if (Y = H(String(J), Z),
                                G && !k[W].test(Y))
                                    throw new TypeError('Expected "' + Z.name + '" to match "' + Z.pattern + '", but got "' + Y + '"');
                                U += Z.prefix + Y
                            }
                        } else
                            U += Z
                    }
                    return U
                }
            }
            function escapeString(v) {
                return v.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1")
            }
            function escapeGroup(v) {
                return v.replace(/([=!:$/()])/g, "\\$1")
            }
            function flags(v) {
                return v && v.sensitive ? "" : "i"
            }
            function tokensToRegExp(v, k, R) {
                for (var U = (R = R || {}).strict, H = !1 !== R.start, G = !1 !== R.end, W = R.delimiter || E, Z = [].concat(R.endsWith || []).map(escapeString).concat("$").join("|"), Y = H ? "^" : "", J = 0; J < v.length; J++) {
                    var K = v[J];
                    if ("string" == typeof K)
                        Y += escapeString(K);
                    else {
                        var X = K.repeat ? "(?:" + K.pattern + ")(?:" + escapeString(K.delimiter) + "(?:" + K.pattern + "))*" : K.pattern;
                        k && k.push(K),
                        K.optional ? K.prefix ? Y += "(?:" + escapeString(K.prefix) + "(" + X + "))?" : Y += "(" + X + ")?" : Y += escapeString(K.prefix) + "(" + X + ")"
                    }
                }
                if (G)
                    U || (Y += "(?:" + escapeString(W) + ")?"),
                    Y += "$" === Z ? "$" : "(?=" + Z + ")";
                else {
                    var Q = v[v.length - 1]
                      , ee = "string" == typeof Q ? Q[Q.length - 1] === W : void 0 === Q;
                    U || (Y += "(?:" + escapeString(W) + "(?=" + Z + "))?"),
                    ee || (Y += "(?=" + escapeString(W) + "|" + Z + ")")
                }
                return new RegExp(Y,flags(R))
            }
            function pathToRegexp(v, E, k) {
                return v instanceof RegExp ? function regexpToRegexp(v, E) {
                    if (!E)
                        return v;
                    var k = v.source.match(/\((?!\?)/g);
                    if (k)
                        for (var R = 0; R < k.length; R++)
                            E.push({
                                "name": R,
                                "prefix": null,
                                "delimiter": null,
                                "optional": !1,
                                "repeat": !1,
                                "pattern": null
                            });
                    return v
                }(v, E) : Array.isArray(v) ? function arrayToRegexp(v, E, k) {
                    for (var R = [], U = 0; U < v.length; U++)
                        R.push(pathToRegexp(v[U], E, k).source);
                    return new RegExp("(?:" + R.join("|") + ")",flags(k))
                }(v, E, k) : function stringToRegexp(v, E, k) {
                    return tokensToRegExp(parse(v, k), E, k)
                }(v, E, k)
            }
        },
        "989": function(v, E, k) {
            "use strict";
            k.d(E, {
                "MT": function() {
                    return createStore
                },
                "nv": function() {
                    return ue
                },
                "Se": function() {
                    return le
                },
                "OI": function() {
                    return ce
                },
                "rn": function() {
                    return se
                }
            });
            var R = k(6252)
              , U = k(2610);
            function getTarget() {
                return "undefined" != typeof navigator && "undefined" != typeof window ? window : "undefined" != typeof globalThis ? globalThis : {}
            }
            const H = "function" == typeof Proxy
              , G = "devtools-plugin:setup";
            let W, Z;
            function now() {
                return function isPerformanceSupported() {
                    var v;
                    return void 0 !== W || ("undefined" != typeof window && window.performance ? (W = !0,
                    Z = window.performance) : "undefined" != typeof globalThis && (null === (v = globalThis.perf_hooks) || void 0 === v ? void 0 : v.performance) ? (W = !0,
                    Z = globalThis.perf_hooks.performance) : W = !1),
                    W
                }() ? Z.now() : Date.now()
            }
            class ApiProxy {
                "constructor"(v, E) {
                    this.target = null,
                    this.targetQueue = [],
                    this.onQueue = [],
                    this.plugin = v,
                    this.hook = E;
                    const k = {};
                    if (v.settings)
                        for (const E in v.settings) {
                            const R = v.settings[E];
                            k[E] = R.defaultValue
                        }
                    const R = `__vue-devtools-plugin-settings__${v.id}`;
                    let U = Object.assign({}, k);
                    try {
                        const v = localStorage.getItem(R)
                          , E = JSON.parse(v);
                        Object.assign(U, E)
                    } catch (v) {}
                    this.fallbacks = {
                        "getSettings"() {
                            return U
                        },
                        "setSettings"(v) {
                            try {
                                localStorage.setItem(R, JSON.stringify(v))
                            } catch (v) {}
                            U = v
                        },
                        "now"() {
                            return now()
                        }
                    },
                    E && E.on("plugin:settings:set", ( (v, E) => {
                        v === this.plugin.id && this.fallbacks.setSettings(E)
                    }
                    )),
                    this.proxiedOn = new Proxy({},{
                        "get": (v, E) => this.target ? this.target.on[E] : (...v) => {
                            this.onQueue.push({
                                "method": E,
                                "args": v
                            })
                        }
                    }),
                    this.proxiedTarget = new Proxy({},{
                        "get": (v, E) => this.target ? this.target[E] : "on" === E ? this.proxiedOn : Object.keys(this.fallbacks).includes(E) ? (...v) => (this.targetQueue.push({
                            "method": E,
                            "args": v,
                            "resolve": () => {}
                        }),
                        this.fallbacks[E](...v)) : (...v) => new Promise((k => {
                            this.targetQueue.push({
                                "method": E,
                                "args": v,
                                "resolve": k
                            })
                        }
                        ))
                    })
                }
                async "setRealTarget"(v) {
                    this.target = v;
                    for (const v of this.onQueue)
                        this.target.on[v.method](...v.args);
                    for (const v of this.targetQueue)
                        v.resolve(await this.target[v.method](...v.args))
                }
            }
            function setupDevtoolsPlugin(v, E) {
                const k = v
                  , R = getTarget()
                  , U = function getDevtoolsGlobalHook() {
                    return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__
                }()
                  , W = H && k.enableEarlyProxy;
                if (!U || !R.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ && W) {
                    const v = W ? new ApiProxy(k,U) : null;
                    (R.__VUE_DEVTOOLS_PLUGINS__ = R.__VUE_DEVTOOLS_PLUGINS__ || []).push({
                        "pluginDescriptor": k,
                        "setupFn": E,
                        "proxy": v
                    }),
                    v && E(v.proxiedTarget)
                } else
                    U.emit(G, v, E)
            }
            var Y = "store";
            function forEachValue(v, E) {
                Object.keys(v).forEach((function(k) {
                    return E(v[k], k)
                }
                ))
            }
            function isObject(v) {
                return null !== v && "object" == typeof v
            }
            function genericSubscribe(v, E, k) {
                return E.indexOf(v) < 0 && (k && k.prepend ? E.unshift(v) : E.push(v)),
                function() {
                    var k = E.indexOf(v);
                    k > -1 && E.splice(k, 1)
                }
            }
            function resetStore(v, E) {
                v._actions = Object.create(null),
                v._mutations = Object.create(null),
                v._wrappedGetters = Object.create(null),
                v._modulesNamespaceMap = Object.create(null);
                var k = v.state;
                installModule(v, k, [], v._modules.root, !0),
                resetStoreState(v, k, E)
            }
            function resetStoreState(v, E, k) {
                var H = v._state
                  , G = v._scope;
                v.getters = {},
                v._makeLocalGettersCache = Object.create(null);
                var W = v._wrappedGetters
                  , Z = {}
                  , Y = {}
                  , J = (0,
                U.B)(!0);
                J.run((function() {
                    forEachValue(W, (function(E, k) {
                        Z[k] = function partial(v, E) {
                            return function() {
                                return v(E)
                            }
                        }(E, v),
                        Y[k] = (0,
                        R.Fl)((function() {
                            return Z[k]()
                        }
                        )),
                        Object.defineProperty(v.getters, k, {
                            "get": function() {
                                return Y[k].value
                            },
                            "enumerable": !0
                        })
                    }
                    ))
                }
                )),
                v._state = (0,
                U.qj)({
                    "data": E
                }),
                v._scope = J,
                v.strict && function enableStrictMode(v) {
                    (0,
                    R.YP)((function() {
                        return v._state.data
                    }
                    ), (function() {
                        0
                    }
                    ), {
                        "deep": !0,
                        "flush": "sync"
                    })
                }(v),
                H && k && v._withCommit((function() {
                    H.data = null
                }
                )),
                G && G.stop()
            }
            function installModule(v, E, k, R, U) {
                var H = !k.length
                  , G = v._modules.getNamespace(k);
                if (R.namespaced && (v._modulesNamespaceMap[G],
                v._modulesNamespaceMap[G] = R),
                !H && !U) {
                    var W = getNestedState(E, k.slice(0, -1))
                      , Z = k[k.length - 1];
                    v._withCommit((function() {
                        W[Z] = R.state
                    }
                    ))
                }
                var Y = R.context = function makeLocalContext(v, E, k) {
                    var R = "" === E
                      , U = {
                        "dispatch": R ? v.dispatch : function(k, R, U) {
                            var H = unifyObjectStyle(k, R, U)
                              , G = H.payload
                              , W = H.options
                              , Z = H.type;
                            return W && W.root || (Z = E + Z),
                            v.dispatch(Z, G)
                        }
                        ,
                        "commit": R ? v.commit : function(k, R, U) {
                            var H = unifyObjectStyle(k, R, U)
                              , G = H.payload
                              , W = H.options
                              , Z = H.type;
                            W && W.root || (Z = E + Z),
                            v.commit(Z, G, W)
                        }
                    };
                    return Object.defineProperties(U, {
                        "getters": {
                            "get": R ? function() {
                                return v.getters
                            }
                            : function() {
                                return makeLocalGetters(v, E)
                            }
                        },
                        "state": {
                            "get": function() {
                                return getNestedState(v.state, k)
                            }
                        }
                    }),
                    U
                }(v, G, k);
                R.forEachMutation((function(E, k) {
                    !function registerMutation(v, E, k, R) {
                        var U = v._mutations[E] || (v._mutations[E] = []);
                        U.push((function wrappedMutationHandler(E) {
                            k.call(v, R.state, E)
                        }
                        ))
                    }(v, G + k, E, Y)
                }
                )),
                R.forEachAction((function(E, k) {
                    var R = E.root ? k : G + k
                      , U = E.handler || E;
                    !function registerAction(v, E, k, R) {
                        var U = v._actions[E] || (v._actions[E] = []);
                        U.push((function wrappedActionHandler(E) {
                            var U = k.call(v, {
                                "dispatch": R.dispatch,
                                "commit": R.commit,
                                "getters": R.getters,
                                "state": R.state,
                                "rootGetters": v.getters,
                                "rootState": v.state
                            }, E);
                            return function isPromise(v) {
                                return v && "function" == typeof v.then
                            }(U) || (U = Promise.resolve(U)),
                            v._devtoolHook ? U.catch((function(E) {
                                throw v._devtoolHook.emit("vuex:error", E),
                                E
                            }
                            )) : U
                        }
                        ))
                    }(v, R, U, Y)
                }
                )),
                R.forEachGetter((function(E, k) {
                    !function registerGetter(v, E, k, R) {
                        if (v._wrappedGetters[E])
                            return void 0;
                        v._wrappedGetters[E] = function wrappedGetter(v) {
                            return k(R.state, R.getters, v.state, v.getters)
                        }
                    }(v, G + k, E, Y)
                }
                )),
                R.forEachChild((function(R, H) {
                    installModule(v, E, k.concat(H), R, U)
                }
                ))
            }
            function makeLocalGetters(v, E) {
                if (!v._makeLocalGettersCache[E]) {
                    var k = {}
                      , R = E.length;
                    Object.keys(v.getters).forEach((function(U) {
                        if (U.slice(0, R) === E) {
                            var H = U.slice(R);
                            Object.defineProperty(k, H, {
                                "get": function() {
                                    return v.getters[U]
                                },
                                "enumerable": !0
                            })
                        }
                    }
                    )),
                    v._makeLocalGettersCache[E] = k
                }
                return v._makeLocalGettersCache[E]
            }
            function getNestedState(v, E) {
                return E.reduce((function(v, E) {
                    return v[E]
                }
                ), v)
            }
            function unifyObjectStyle(v, E, k) {
                return isObject(v) && v.type && (k = E,
                E = v,
                v = v.type),
                {
                    "type": v,
                    "payload": E,
                    "options": k
                }
            }
            var J = "vuex:mutations"
              , K = "vuex:actions"
              , X = "vuex"
              , Q = 0;
            function addDevtools(v, E) {
                setupDevtoolsPlugin({
                    "id": "org.vuejs.vuex",
                    "app": v,
                    "label": "Vuex",
                    "homepage": "https://next.vuex.vuejs.org/",
                    "logo": "https://vuejs.org/images/icons/favicon-96x96.png",
                    "packageName": "vuex",
                    "componentStateTypes": ["vuex bindings"]
                }, (function(k) {
                    k.addTimelineLayer({
                        "id": J,
                        "label": "Vuex Mutations",
                        "color": ee
                    }),
                    k.addTimelineLayer({
                        "id": K,
                        "label": "Vuex Actions",
                        "color": ee
                    }),
                    k.addInspector({
                        "id": X,
                        "label": "Vuex",
                        "icon": "storage",
                        "treeFilterPlaceholder": "Filter stores..."
                    }),
                    k.on.getInspectorTree((function(k) {
                        if (k.app === v && k.inspectorId === X)
                            if (k.filter) {
                                var R = [];
                                flattenStoreForInspectorTree(R, E._modules.root, k.filter, ""),
                                k.rootNodes = R
                            } else
                                k.rootNodes = [formatStoreForInspectorTree(E._modules.root, "")]
                    }
                    )),
                    k.on.getInspectorState((function(k) {
                        if (k.app === v && k.inspectorId === X) {
                            var R = k.nodeId;
                            makeLocalGetters(E, R),
                            k.state = function formatStoreForInspectorState(v, E, k) {
                                E = "root" === k ? E : E[k];
                                var R = Object.keys(E)
                                  , U = {
                                    "state": Object.keys(v.state).map((function(E) {
                                        return {
                                            "key": E,
                                            "editable": !0,
                                            "value": v.state[E]
                                        }
                                    }
                                    ))
                                };
                                if (R.length) {
                                    var H = function transformPathsToObjectTree(v) {
                                        var E = {};
                                        return Object.keys(v).forEach((function(k) {
                                            var R = k.split("/");
                                            if (R.length > 1) {
                                                var U = E
                                                  , H = R.pop();
                                                R.forEach((function(v) {
                                                    U[v] || (U[v] = {
                                                        "_custom": {
                                                            "value": {},
                                                            "display": v,
                                                            "tooltip": "Module",
                                                            "abstract": !0
                                                        }
                                                    }),
                                                    U = U[v]._custom.value
                                                }
                                                )),
                                                U[H] = canThrow((function() {
                                                    return v[k]
                                                }
                                                ))
                                            } else
                                                E[k] = canThrow((function() {
                                                    return v[k]
                                                }
                                                ))
                                        }
                                        )),
                                        E
                                    }(E);
                                    U.getters = Object.keys(H).map((function(v) {
                                        return {
                                            "key": v.endsWith("/") ? extractNameFromPath(v) : v,
                                            "editable": !1,
                                            "value": canThrow((function() {
                                                return H[v]
                                            }
                                            ))
                                        }
                                    }
                                    ))
                                }
                                return U
                            }(function getStoreModule(v, E) {
                                var k = E.split("/").filter((function(v) {
                                    return v
                                }
                                ));
                                return k.reduce((function(v, R, U) {
                                    var H = v[R];
                                    if (!H)
                                        throw new Error('Missing module "' + R + '" for path "' + E + '".');
                                    return U === k.length - 1 ? H : H._children
                                }
                                ), "root" === E ? v : v.root._children)
                            }(E._modules, R), "root" === R ? E.getters : E._makeLocalGettersCache, R)
                        }
                    }
                    )),
                    k.on.editInspectorState((function(k) {
                        if (k.app === v && k.inspectorId === X) {
                            var R = k.nodeId
                              , U = k.path;
                            "root" !== R && (U = R.split("/").filter(Boolean).concat(U)),
                            E._withCommit((function() {
                                k.set(E._state.data, U, k.state.value)
                            }
                            ))
                        }
                    }
                    )),
                    E.subscribe((function(v, E) {
                        var R = {};
                        v.payload && (R.payload = v.payload),
                        R.state = E,
                        k.notifyComponentUpdate(),
                        k.sendInspectorTree(X),
                        k.sendInspectorState(X),
                        k.addTimelineEvent({
                            "layerId": J,
                            "event": {
                                "time": Date.now(),
                                "title": v.type,
                                "data": R
                            }
                        })
                    }
                    )),
                    E.subscribeAction({
                        "before": function(v, E) {
                            var R = {};
                            v.payload && (R.payload = v.payload),
                            v._id = Q++,
                            v._time = Date.now(),
                            R.state = E,
                            k.addTimelineEvent({
                                "layerId": K,
                                "event": {
                                    "time": v._time,
                                    "title": v.type,
                                    "groupId": v._id,
                                    "subtitle": "start",
                                    "data": R
                                }
                            })
                        },
                        "after": function(v, E) {
                            var R = {}
                              , U = Date.now() - v._time;
                            R.duration = {
                                "_custom": {
                                    "type": "duration",
                                    "display": U + "ms",
                                    "tooltip": "Action duration",
                                    "value": U
                                }
                            },
                            v.payload && (R.payload = v.payload),
                            R.state = E,
                            k.addTimelineEvent({
                                "layerId": K,
                                "event": {
                                    "time": Date.now(),
                                    "title": v.type,
                                    "groupId": v._id,
                                    "subtitle": "end",
                                    "data": R
                                }
                            })
                        }
                    })
                }
                ))
            }
            var ee = 8702998
              , te = {
                "label": "namespaced",
                "textColor": 16777215,
                "backgroundColor": 6710886
            };
            function extractNameFromPath(v) {
                return v && "root" !== v ? v.split("/").slice(-2, -1)[0] : "Root"
            }
            function formatStoreForInspectorTree(v, E) {
                return {
                    "id": E || "root",
                    "label": extractNameFromPath(E),
                    "tags": v.namespaced ? [te] : [],
                    "children": Object.keys(v._children).map((function(k) {
                        return formatStoreForInspectorTree(v._children[k], E + k + "/")
                    }
                    ))
                }
            }
            function flattenStoreForInspectorTree(v, E, k, R) {
                R.includes(k) && v.push({
                    "id": R || "root",
                    "label": R.endsWith("/") ? R.slice(0, R.length - 1) : R || "Root",
                    "tags": E.namespaced ? [te] : []
                }),
                Object.keys(E._children).forEach((function(U) {
                    flattenStoreForInspectorTree(v, E._children[U], k, R + U + "/")
                }
                ))
            }
            function canThrow(v) {
                try {
                    return v()
                } catch (v) {
                    return v
                }
            }
            var ne = function Module(v, E) {
                this.runtime = E,
                this._children = Object.create(null),
                this._rawModule = v;
                var k = v.state;
                this.state = ("function" == typeof k ? k() : k) || {}
            }
              , re = {
                "namespaced": {
                    "configurable": !0
                }
            };
            re.namespaced.get = function() {
                return !!this._rawModule.namespaced
            }
            ,
            ne.prototype.addChild = function addChild(v, E) {
                this._children[v] = E
            }
            ,
            ne.prototype.removeChild = function removeChild(v) {
                delete this._children[v]
            }
            ,
            ne.prototype.getChild = function getChild(v) {
                return this._children[v]
            }
            ,
            ne.prototype.hasChild = function hasChild(v) {
                return v in this._children
            }
            ,
            ne.prototype.update = function update(v) {
                this._rawModule.namespaced = v.namespaced,
                v.actions && (this._rawModule.actions = v.actions),
                v.mutations && (this._rawModule.mutations = v.mutations),
                v.getters && (this._rawModule.getters = v.getters)
            }
            ,
            ne.prototype.forEachChild = function forEachChild(v) {
                forEachValue(this._children, v)
            }
            ,
            ne.prototype.forEachGetter = function forEachGetter(v) {
                this._rawModule.getters && forEachValue(this._rawModule.getters, v)
            }
            ,
            ne.prototype.forEachAction = function forEachAction(v) {
                this._rawModule.actions && forEachValue(this._rawModule.actions, v)
            }
            ,
            ne.prototype.forEachMutation = function forEachMutation(v) {
                this._rawModule.mutations && forEachValue(this._rawModule.mutations, v)
            }
            ,
            Object.defineProperties(ne.prototype, re);
            var oe = function ModuleCollection(v) {
                this.register([], v, !1)
            };
            function update(v, E, k) {
                if (E.update(k),
                k.modules)
                    for (var R in k.modules) {
                        if (!E.getChild(R))
                            return void 0;
                        update(v.concat(R), E.getChild(R), k.modules[R])
                    }
            }
            oe.prototype.get = function get(v) {
                return v.reduce((function(v, E) {
                    return v.getChild(E)
                }
                ), this.root)
            }
            ,
            oe.prototype.getNamespace = function getNamespace(v) {
                var E = this.root;
                return v.reduce((function(v, k) {
                    return v + ((E = E.getChild(k)).namespaced ? k + "/" : "")
                }
                ), "")
            }
            ,
            oe.prototype.update = function update$1(v) {
                update([], this.root, v)
            }
            ,
            oe.prototype.register = function register(v, E, k) {
                var R = this;
                void 0 === k && (k = !0);
                var U = new ne(E,k);
                0 === v.length ? this.root = U : this.get(v.slice(0, -1)).addChild(v[v.length - 1], U);
                E.modules && forEachValue(E.modules, (function(E, U) {
                    R.register(v.concat(U), E, k)
                }
                ))
            }
            ,
            oe.prototype.unregister = function unregister(v) {
                var E = this.get(v.slice(0, -1))
                  , k = v[v.length - 1]
                  , R = E.getChild(k);
                R && R.runtime && E.removeChild(k)
            }
            ,
            oe.prototype.isRegistered = function isRegistered(v) {
                var E = this.get(v.slice(0, -1))
                  , k = v[v.length - 1];
                return !!E && E.hasChild(k)
            }
            ;
            function createStore(v) {
                return new ie(v)
            }
            var ie = function Store(v) {
                var E = this;
                void 0 === v && (v = {});
                var k = v.plugins;
                void 0 === k && (k = []);
                var R = v.strict;
                void 0 === R && (R = !1);
                var U = v.devtools;
                this._committing = !1,
                this._actions = Object.create(null),
                this._actionSubscribers = [],
                this._mutations = Object.create(null),
                this._wrappedGetters = Object.create(null),
                this._modules = new oe(v),
                this._modulesNamespaceMap = Object.create(null),
                this._subscribers = [],
                this._makeLocalGettersCache = Object.create(null),
                this._scope = null,
                this._devtools = U;
                var H = this
                  , G = this.dispatch
                  , W = this.commit;
                this.dispatch = function boundDispatch(v, E) {
                    return G.call(H, v, E)
                }
                ,
                this.commit = function boundCommit(v, E, k) {
                    return W.call(H, v, E, k)
                }
                ,
                this.strict = R;
                var Z = this._modules.root.state;
                installModule(this, Z, [], this._modules.root),
                resetStoreState(this, Z),
                k.forEach((function(v) {
                    return v(E)
                }
                ))
            }
              , ae = {
                "state": {
                    "configurable": !0
                }
            };
            ie.prototype.install = function install(v, E) {
                v.provide(E || Y, this),
                v.config.globalProperties.$store = this,
                void 0 !== this._devtools && this._devtools && addDevtools(v, this)
            }
            ,
            ae.state.get = function() {
                return this._state.data
            }
            ,
            ae.state.set = function(v) {
                0
            }
            ,
            ie.prototype.commit = function commit(v, E, k) {
                var R = this
                  , U = unifyObjectStyle(v, E, k)
                  , H = U.type
                  , G = U.payload
                  , W = (U.options,
                {
                    "type": H,
                    "payload": G
                })
                  , Z = this._mutations[H];
                Z && (this._withCommit((function() {
                    Z.forEach((function commitIterator(v) {
                        v(G)
                    }
                    ))
                }
                )),
                this._subscribers.slice().forEach((function(v) {
                    return v(W, R.state)
                }
                )))
            }
            ,
            ie.prototype.dispatch = function dispatch(v, E) {
                var k = this
                  , R = unifyObjectStyle(v, E)
                  , U = R.type
                  , H = R.payload
                  , G = {
                    "type": U,
                    "payload": H
                }
                  , W = this._actions[U];
                if (W) {
                    try {
                        this._actionSubscribers.slice().filter((function(v) {
                            return v.before
                        }
                        )).forEach((function(v) {
                            return v.before(G, k.state)
                        }
                        ))
                    } catch (v) {
                        0
                    }
                    var Z = W.length > 1 ? Promise.all(W.map((function(v) {
                        return v(H)
                    }
                    ))) : W[0](H);
                    return new Promise((function(v, E) {
                        Z.then((function(E) {
                            try {
                                k._actionSubscribers.filter((function(v) {
                                    return v.after
                                }
                                )).forEach((function(v) {
                                    return v.after(G, k.state)
                                }
                                ))
                            } catch (v) {
                                0
                            }
                            v(E)
                        }
                        ), (function(v) {
                            try {
                                k._actionSubscribers.filter((function(v) {
                                    return v.error
                                }
                                )).forEach((function(E) {
                                    return E.error(G, k.state, v)
                                }
                                ))
                            } catch (v) {
                                0
                            }
                            E(v)
                        }
                        ))
                    }
                    ))
                }
            }
            ,
            ie.prototype.subscribe = function subscribe(v, E) {
                return genericSubscribe(v, this._subscribers, E)
            }
            ,
            ie.prototype.subscribeAction = function subscribeAction(v, E) {
                return genericSubscribe("function" == typeof v ? {
                    "before": v
                } : v, this._actionSubscribers, E)
            }
            ,
            ie.prototype.watch = function watch$1(v, E, k) {
                var U = this;
                return (0,
                R.YP)((function() {
                    return v(U.state, U.getters)
                }
                ), E, Object.assign({}, k))
            }
            ,
            ie.prototype.replaceState = function replaceState(v) {
                var E = this;
                this._withCommit((function() {
                    E._state.data = v
                }
                ))
            }
            ,
            ie.prototype.registerModule = function registerModule(v, E, k) {
                void 0 === k && (k = {}),
                "string" == typeof v && (v = [v]),
                this._modules.register(v, E),
                installModule(this, this.state, v, this._modules.get(v), k.preserveState),
                resetStoreState(this, this.state)
            }
            ,
            ie.prototype.unregisterModule = function unregisterModule(v) {
                var E = this;
                "string" == typeof v && (v = [v]),
                this._modules.unregister(v),
                this._withCommit((function() {
                    delete getNestedState(E.state, v.slice(0, -1))[v[v.length - 1]]
                }
                )),
                resetStore(this)
            }
            ,
            ie.prototype.hasModule = function hasModule(v) {
                return "string" == typeof v && (v = [v]),
                this._modules.isRegistered(v)
            }
            ,
            ie.prototype.hotUpdate = function hotUpdate(v) {
                this._modules.update(v),
                resetStore(this, !0)
            }
            ,
            ie.prototype._withCommit = function _withCommit(v) {
                var E = this._committing;
                this._committing = !0,
                v(),
                this._committing = E
            }
            ,
            Object.defineProperties(ie.prototype, ae);
            var se = normalizeNamespace((function(v, E) {
                var k = {};
                return normalizeMap(E).forEach((function(E) {
                    var R = E.key
                      , U = E.val;
                    k[R] = function mappedState() {
                        var E = this.$store.state
                          , k = this.$store.getters;
                        if (v) {
                            var R = getModuleByNamespace(this.$store, "mapState", v);
                            if (!R)
                                return;
                            E = R.context.state,
                            k = R.context.getters
                        }
                        return "function" == typeof U ? U.call(this, E, k) : E[U]
                    }
                    ,
                    k[R].vuex = !0
                }
                )),
                k
            }
            ))
              , ce = normalizeNamespace((function(v, E) {
                var k = {};
                return normalizeMap(E).forEach((function(E) {
                    var R = E.key
                      , U = E.val;
                    k[R] = function mappedMutation() {
                        for (var E = [], k = arguments.length; k--; )
                            E[k] = arguments[k];
                        var R = this.$store.commit;
                        if (v) {
                            var H = getModuleByNamespace(this.$store, "mapMutations", v);
                            if (!H)
                                return;
                            R = H.context.commit
                        }
                        return "function" == typeof U ? U.apply(this, [R].concat(E)) : R.apply(this.$store, [U].concat(E))
                    }
                }
                )),
                k
            }
            ))
              , le = normalizeNamespace((function(v, E) {
                var k = {};
                return normalizeMap(E).forEach((function(E) {
                    var R = E.key
                      , U = E.val;
                    U = v + U,
                    k[R] = function mappedGetter() {
                        if (!v || getModuleByNamespace(this.$store, "mapGetters", v))
                            return this.$store.getters[U]
                    }
                    ,
                    k[R].vuex = !0
                }
                )),
                k
            }
            ))
              , ue = normalizeNamespace((function(v, E) {
                var k = {};
                return normalizeMap(E).forEach((function(E) {
                    var R = E.key
                      , U = E.val;
                    k[R] = function mappedAction() {
                        for (var E = [], k = arguments.length; k--; )
                            E[k] = arguments[k];
                        var R = this.$store.dispatch;
                        if (v) {
                            var H = getModuleByNamespace(this.$store, "mapActions", v);
                            if (!H)
                                return;
                            R = H.context.dispatch
                        }
                        return "function" == typeof U ? U.apply(this, [R].concat(E)) : R.apply(this.$store, [U].concat(E))
                    }
                }
                )),
                k
            }
            ));
            function normalizeMap(v) {
                return function isValidMap(v) {
                    return Array.isArray(v) || isObject(v)
                }(v) ? Array.isArray(v) ? v.map((function(v) {
                    return {
                        "key": v,
                        "val": v
                    }
                }
                )) : Object.keys(v).map((function(E) {
                    return {
                        "key": E,
                        "val": v[E]
                    }
                }
                )) : []
            }
            function normalizeNamespace(v) {
                return function(E, k) {
                    return "string" != typeof E ? (k = E,
                    E = "") : "/" !== E.charAt(E.length - 1) && (E += "/"),
                    v(E, k)
                }
            }
            function getModuleByNamespace(v, E, k) {
                return v._modulesNamespaceMap[k]
            }
        },
        "7147": function(v, E, k) {
            "use strict";
            var R = "undefined" != typeof globalThis && globalThis || "undefined" != typeof self && self || void 0 !== k.g && k.g || {}
              , U = "URLSearchParams"in R
              , H = "Symbol"in R && "iterator"in Symbol
              , G = "FileReader"in R && "Blob"in R && function() {
                try {
                    return new Blob,
                    !0
                } catch (v) {
                    return !1
                }
            }()
              , W = "FormData"in R
              , Z = "ArrayBuffer"in R;
            if (Z)
                var Y = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"]
                  , J = ArrayBuffer.isView || function(v) {
                    return v && Y.indexOf(Object.prototype.toString.call(v)) > -1
                }
                ;
            function normalizeName(v) {
                if ("string" != typeof v && (v = String(v)),
                /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(v) || "" === v)
                    throw new TypeError('Invalid character in header field name: "' + v + '"');
                return v.toLowerCase()
            }
            function normalizeValue(v) {
                return "string" != typeof v && (v = String(v)),
                v
            }
            function iteratorFor(v) {
                var E = {
                    "next": function() {
                        var E = v.shift();
                        return {
                            "done": void 0 === E,
                            "value": E
                        }
                    }
                };
                return H && (E[Symbol.iterator] = function() {
                    return E
                }
                ),
                E
            }
            function Headers(v) {
                this.map = {},
                v instanceof Headers ? v.forEach((function(v, E) {
                    this.append(E, v)
                }
                ), this) : Array.isArray(v) ? v.forEach((function(v) {
                    if (2 != v.length)
                        throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + v.length);
                    this.append(v[0], v[1])
                }
                ), this) : v && Object.getOwnPropertyNames(v).forEach((function(E) {
                    this.append(E, v[E])
                }
                ), this)
            }
            function consumed(v) {
                if (!v._noBody)
                    return v.bodyUsed ? Promise.reject(new TypeError("Already read")) : void (v.bodyUsed = !0)
            }
            function fileReaderReady(v) {
                return new Promise((function(E, k) {
                    v.onload = function() {
                        E(v.result)
                    }
                    ,
                    v.onerror = function() {
                        k(v.error)
                    }
                }
                ))
            }
            function readBlobAsArrayBuffer(v) {
                var E = new FileReader
                  , k = fileReaderReady(E);
                return E.readAsArrayBuffer(v),
                k
            }
            function bufferClone(v) {
                if (v.slice)
                    return v.slice(0);
                var E = new Uint8Array(v.byteLength);
                return E.set(new Uint8Array(v)),
                E.buffer
            }
            function Body() {
                return this.bodyUsed = !1,
                this._initBody = function(v) {
                    this.bodyUsed = this.bodyUsed,
                    this._bodyInit = v,
                    v ? "string" == typeof v ? this._bodyText = v : G && Blob.prototype.isPrototypeOf(v) ? this._bodyBlob = v : W && FormData.prototype.isPrototypeOf(v) ? this._bodyFormData = v : U && URLSearchParams.prototype.isPrototypeOf(v) ? this._bodyText = v.toString() : Z && G && function isDataView(v) {
                        return v && DataView.prototype.isPrototypeOf(v)
                    }(v) ? (this._bodyArrayBuffer = bufferClone(v.buffer),
                    this._bodyInit = new Blob([this._bodyArrayBuffer])) : Z && (ArrayBuffer.prototype.isPrototypeOf(v) || J(v)) ? this._bodyArrayBuffer = bufferClone(v) : this._bodyText = v = Object.prototype.toString.call(v) : (this._noBody = !0,
                    this._bodyText = ""),
                    this.headers.get("content-type") || ("string" == typeof v ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : U && URLSearchParams.prototype.isPrototypeOf(v) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"))
                }
                ,
                G && (this.blob = function() {
                    var v = consumed(this);
                    if (v)
                        return v;
                    if (this._bodyBlob)
                        return Promise.resolve(this._bodyBlob);
                    if (this._bodyArrayBuffer)
                        return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                    if (this._bodyFormData)
                        throw new Error("could not read FormData body as blob");
                    return Promise.resolve(new Blob([this._bodyText]))
                }
                ),
                this.arrayBuffer = function() {
                    if (this._bodyArrayBuffer) {
                        var v = consumed(this);
                        return v || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength)) : Promise.resolve(this._bodyArrayBuffer))
                    }
                    if (G)
                        return this.blob().then(readBlobAsArrayBuffer);
                    throw new Error("could not read as ArrayBuffer")
                }
                ,
                this.text = function() {
                    var v = consumed(this);
                    if (v)
                        return v;
                    if (this._bodyBlob)
                        return function readBlobAsText(v) {
                            var E = new FileReader
                              , k = fileReaderReady(E)
                              , R = /charset=([A-Za-z0-9_-]+)/.exec(v.type)
                              , U = R ? R[1] : "utf-8";
                            return E.readAsText(v, U),
                            k
                        }(this._bodyBlob);
                    if (this._bodyArrayBuffer)
                        return Promise.resolve(function readArrayBufferAsText(v) {
                            for (var E = new Uint8Array(v), k = new Array(E.length), R = 0; R < E.length; R++)
                                k[R] = String.fromCharCode(E[R]);
                            return k.join("")
                        }(this._bodyArrayBuffer));
                    if (this._bodyFormData)
                        throw new Error("could not read FormData body as text");
                    return Promise.resolve(this._bodyText)
                }
                ,
                W && (this.formData = function() {
                    return this.text().then(decode)
                }
                ),
                this.json = function() {
                    return this.text().then(JSON.parse)
                }
                ,
                this
            }
            Headers.prototype.append = function(v, E) {
                v = normalizeName(v),
                E = normalizeValue(E);
                var k = this.map[v];
                this.map[v] = k ? k + ", " + E : E
            }
            ,
            Headers.prototype.delete = function(v) {
                delete this.map[normalizeName(v)]
            }
            ,
            Headers.prototype.get = function(v) {
                return v = normalizeName(v),
                this.has(v) ? this.map[v] : null
            }
            ,
            Headers.prototype.has = function(v) {
                return this.map.hasOwnProperty(normalizeName(v))
            }
            ,
            Headers.prototype.set = function(v, E) {
                this.map[normalizeName(v)] = normalizeValue(E)
            }
            ,
            Headers.prototype.forEach = function(v, E) {
                for (var k in this.map)
                    this.map.hasOwnProperty(k) && v.call(E, this.map[k], k, this)
            }
            ,
            Headers.prototype.keys = function() {
                var v = [];
                return this.forEach((function(E, k) {
                    v.push(k)
                }
                )),
                iteratorFor(v)
            }
            ,
            Headers.prototype.values = function() {
                var v = [];
                return this.forEach((function(E) {
                    v.push(E)
                }
                )),
                iteratorFor(v)
            }
            ,
            Headers.prototype.entries = function() {
                var v = [];
                return this.forEach((function(E, k) {
                    v.push([k, E])
                }
                )),
                iteratorFor(v)
            }
            ,
            H && (Headers.prototype[Symbol.iterator] = Headers.prototype.entries);
            var K = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
            function Request(v, E) {
                if (!(this instanceof Request))
                    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
                var k = (E = E || {}).body;
                if (v instanceof Request) {
                    if (v.bodyUsed)
                        throw new TypeError("Already read");
                    this.url = v.url,
                    this.credentials = v.credentials,
                    E.headers || (this.headers = new Headers(v.headers)),
                    this.method = v.method,
                    this.mode = v.mode,
                    this.signal = v.signal,
                    k || null == v._bodyInit || (k = v._bodyInit,
                    v.bodyUsed = !0)
                } else
                    this.url = String(v);
                if (this.credentials = E.credentials || this.credentials || "same-origin",
                !E.headers && this.headers || (this.headers = new Headers(E.headers)),
                this.method = function normalizeMethod(v) {
                    var E = v.toUpperCase();
                    return K.indexOf(E) > -1 ? E : v
                }(E.method || this.method || "GET"),
                this.mode = E.mode || this.mode || null,
                this.signal = E.signal || this.signal || function() {
                    if ("AbortController"in R)
                        return (new AbortController).signal
                }(),
                this.referrer = null,
                ("GET" === this.method || "HEAD" === this.method) && k)
                    throw new TypeError("Body not allowed for GET or HEAD requests");
                if (this._initBody(k),
                !("GET" !== this.method && "HEAD" !== this.method || "no-store" !== E.cache && "no-cache" !== E.cache)) {
                    var U = /([?&])_=[^&]*/;
                    if (U.test(this.url))
                        this.url = this.url.replace(U, "$1_=" + (new Date).getTime());
                    else {
                        this.url += (/\?/.test(this.url) ? "&" : "?") + "_=" + (new Date).getTime()
                    }
                }
            }
            function decode(v) {
                var E = new FormData;
                return v.trim().split("&").forEach((function(v) {
                    if (v) {
                        var k = v.split("=")
                          , R = k.shift().replace(/\+/g, " ")
                          , U = k.join("=").replace(/\+/g, " ");
                        E.append(decodeURIComponent(R), decodeURIComponent(U))
                    }
                }
                )),
                E
            }
            function Response(v, E) {
                if (!(this instanceof Response))
                    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
                if (E || (E = {}),
                this.type = "default",
                this.status = void 0 === E.status ? 200 : E.status,
                this.status < 200 || this.status > 599)
                    throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
                this.ok = this.status >= 200 && this.status < 300,
                this.statusText = void 0 === E.statusText ? "" : "" + E.statusText,
                this.headers = new Headers(E.headers),
                this.url = E.url || "",
                this._initBody(v)
            }
            Request.prototype.clone = function() {
                return new Request(this,{
                    "body": this._bodyInit
                })
            }
            ,
            Body.call(Request.prototype),
            Body.call(Response.prototype),
            Response.prototype.clone = function() {
                return new Response(this._bodyInit,{
                    "status": this.status,
                    "statusText": this.statusText,
                    "headers": new Headers(this.headers),
                    "url": this.url
                })
            }
            ,
            Response.error = function() {
                var v = new Response(null,{
                    "status": 200,
                    "statusText": ""
                });
                return v.ok = !1,
                v.status = 0,
                v.type = "error",
                v
            }
            ;
            var X = [301, 302, 303, 307, 308];
            Response.redirect = function(v, E) {
                if (-1 === X.indexOf(E))
                    throw new RangeError("Invalid status code");
                return new Response(null,{
                    "status": E,
                    "headers": {
                        "location": v
                    }
                })
            }
            ;
            var Q = R.DOMException;
            try {
                new Q
            } catch (v) {
                (Q = function(v, E) {
                    this.message = v,
                    this.name = E;
                    var k = Error(v);
                    this.stack = k.stack
                }
                ).prototype = Object.create(Error.prototype),
                Q.prototype.constructor = Q
            }
            function fetch(v, E) {
                return new Promise((function(k, U) {
                    var H = new Request(v,E);
                    if (H.signal && H.signal.aborted)
                        return U(new Q("Aborted","AbortError"));
                    var W = new XMLHttpRequest;
                    function abortXhr() {
                        W.abort()
                    }
                    if (W.onload = function() {
                        var v, E, R = {
                            "statusText": W.statusText,
                            "headers": (v = W.getAllResponseHeaders() || "",
                            E = new Headers,
                            v.replace(/\r?\n[\t ]+/g, " ").split("\r").map((function(v) {
                                return 0 === v.indexOf("\n") ? v.substr(1, v.length) : v
                            }
                            )).forEach((function(v) {
                                var k = v.split(":")
                                  , R = k.shift().trim();
                                if (R) {
                                    var U = k.join(":").trim();
                                    try {
                                        E.append(R, U)
                                    } catch (v) {
                                        console.warn("Response " + v.message)
                                    }
                                }
                            }
                            )),
                            E)
                        };
                        0 === H.url.indexOf("file://") && (W.status < 200 || W.status > 599) ? R.status = 200 : R.status = W.status,
                        R.url = "responseURL"in W ? W.responseURL : R.headers.get("X-Request-URL");
                        var U = "response"in W ? W.response : W.responseText;
                        setTimeout((function() {
                            k(new Response(U,R))
                        }
                        ), 0)
                    }
                    ,
                    W.onerror = function() {
                        setTimeout((function() {
                            U(new TypeError("Network request failed"))
                        }
                        ), 0)
                    }
                    ,
                    W.ontimeout = function() {
                        setTimeout((function() {
                            U(new TypeError("Network request timed out"))
                        }
                        ), 0)
                    }
                    ,
                    W.onabort = function() {
                        setTimeout((function() {
                            U(new Q("Aborted","AbortError"))
                        }
                        ), 0)
                    }
                    ,
                    W.open(H.method, function fixUrl(v) {
                        try {
                            return "" === v && R.location.href ? R.location.href : v
                        } catch (E) {
                            return v
                        }
                    }(H.url), !0),
                    "include" === H.credentials ? W.withCredentials = !0 : "omit" === H.credentials && (W.withCredentials = !1),
                    "responseType"in W && (G ? W.responseType = "blob" : Z && (W.responseType = "arraybuffer")),
                    E && "object" == typeof E.headers && !(E.headers instanceof Headers || R.Headers && E.headers instanceof R.Headers)) {
                        var Y = [];
                        Object.getOwnPropertyNames(E.headers).forEach((function(v) {
                            Y.push(normalizeName(v)),
                            W.setRequestHeader(v, normalizeValue(E.headers[v]))
                        }
                        )),
                        H.headers.forEach((function(v, E) {
                            -1 === Y.indexOf(E) && W.setRequestHeader(E, v)
                        }
                        ))
                    } else
                        H.headers.forEach((function(v, E) {
                            W.setRequestHeader(E, v)
                        }
                        ));
                    H.signal && (H.signal.addEventListener("abort", abortXhr),
                    W.onreadystatechange = function() {
                        4 === W.readyState && H.signal.removeEventListener("abort", abortXhr)
                    }
                    ),
                    W.send(void 0 === H._bodyInit ? null : H._bodyInit)
                }
                ))
            }
            fetch.polyfill = !0,
            R.fetch || (R.fetch = fetch,
            R.Headers = Headers,
            R.Request = Request,
            R.Response = Response)
        },
        "6310": function(v, E, k) {
            "use strict";
            k.r(E),
            k.d(E, {
                "ArraySchema": function() {
                    return ArraySchema
                },
                "BooleanSchema": function() {
                    return BooleanSchema
                },
                "DateSchema": function() {
                    return DateSchema
                },
                "MixedSchema": function() {
                    return MixedSchema
                },
                "NumberSchema": function() {
                    return NumberSchema
                },
                "ObjectSchema": function() {
                    return ObjectSchema
                },
                "Schema": function() {
                    return Schema
                },
                "StringSchema": function() {
                    return StringSchema
                },
                "TupleSchema": function() {
                    return TupleSchema
                },
                "ValidationError": function() {
                    return ValidationError
                },
                "addMethod": function() {
                    return addMethod
                },
                "array": function() {
                    return create$2
                },
                "bool": function() {
                    return create$7
                },
                "boolean": function() {
                    return create$7
                },
                "date": function() {
                    return create$4
                },
                "defaultLocale": function() {
                    return ue
                },
                "getIn": function() {
                    return getIn
                },
                "isSchema": function() {
                    return isSchema
                },
                "lazy": function() {
                    return create
                },
                "mixed": function() {
                    return create$8
                },
                "number": function() {
                    return create$5
                },
                "object": function() {
                    return create$3
                },
                "printValue": function() {
                    return printValue
                },
                "reach": function() {
                    return reach
                },
                "ref": function() {
                    return create$9
                },
                "setLocale": function() {
                    return setLocale
                },
                "string": function() {
                    return create$6
                },
                "tuple": function() {
                    return create$1
                }
            });
            var R = k(5760)
              , U = k(9885)
              , H = k(4633)
              , G = k.n(H);
            const W = Object.prototype.toString
              , Z = Error.prototype.toString
              , Y = RegExp.prototype.toString
              , J = "undefined" != typeof Symbol ? Symbol.prototype.toString : () => ""
              , K = /^Symbol\((.*)\)(.*)$/;
            function printSimpleValue(v, E=!1) {
                if (null == v || !0 === v || !1 === v)
                    return "" + v;
                const k = typeof v;
                if ("number" === k)
                    return function printNumber(v) {
                        return v != +v ? "NaN" : 0 === v && 1 / v < 0 ? "-0" : "" + v
                    }(v);
                if ("string" === k)
                    return E ? `"${v}"` : v;
                if ("function" === k)
                    return "[Function " + (v.name || "anonymous") + "]";
                if ("symbol" === k)
                    return J.call(v).replace(K, "Symbol($1)");
                const R = W.call(v).slice(8, -1);
                return "Date" === R ? isNaN(v.getTime()) ? "" + v : v.toISOString(v) : "Error" === R || v instanceof Error ? "[" + Z.call(v) + "]" : "RegExp" === R ? Y.call(v) : null
            }
            function printValue(v, E) {
                let k = printSimpleValue(v, E);
                return null !== k ? k : JSON.stringify(v, (function(v, k) {
                    let R = printSimpleValue(this[v], E);
                    return null !== R ? R : k
                }
                ), 2)
            }
            function toArray(v) {
                return null == v ? [] : [].concat(v)
            }
            let X, Q, ee, te = /\$\{\s*(\w+)\s*\}/g;
            X = Symbol.toStringTag;
            class ValidationErrorNoStack {
                "constructor"(v, E, k, R) {
                    this.name = void 0,
                    this.message = void 0,
                    this.value = void 0,
                    this.path = void 0,
                    this.type = void 0,
                    this.params = void 0,
                    this.errors = void 0,
                    this.inner = void 0,
                    this[X] = "Error",
                    this.name = "ValidationError",
                    this.value = E,
                    this.path = k,
                    this.type = R,
                    this.errors = [],
                    this.inner = [],
                    toArray(v).forEach((v => {
                        if (ValidationError.isError(v)) {
                            this.errors.push(...v.errors);
                            const E = v.inner.length ? v.inner : [v];
                            this.inner.push(...E)
                        } else
                            this.errors.push(v)
                    }
                    )),
                    this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0]
                }
            }
            Q = Symbol.hasInstance,
            ee = Symbol.toStringTag;
            class ValidationError extends Error {
                static "formatError"(v, E) {
                    const k = E.label || E.path || "this";
                    return k !== E.path && (E = Object.assign({}, E, {
                        "path": k
                    })),
                    "string" == typeof v ? v.replace(te, ( (v, k) => printValue(E[k]))) : "function" == typeof v ? v(E) : v
                }
                static "isError"(v) {
                    return v && "ValidationError" === v.name
                }
                "constructor"(v, E, k, R, U) {
                    const H = new ValidationErrorNoStack(v,E,k,R);
                    if (U)
                        return H;
                    super(),
                    this.value = void 0,
                    this.path = void 0,
                    this.type = void 0,
                    this.params = void 0,
                    this.errors = [],
                    this.inner = [],
                    this[ee] = "Error",
                    this.name = H.name,
                    this.message = H.message,
                    this.type = H.type,
                    this.value = H.value,
                    this.path = H.path,
                    this.errors = H.errors,
                    this.inner = H.inner,
                    Error.captureStackTrace && Error.captureStackTrace(this, ValidationError)
                }
                static[Q](v) {
                    return ValidationErrorNoStack[Symbol.hasInstance](v) || super[Symbol.hasInstance](v)
                }
            }
            let ne = {
                "default": "${path} is invalid",
                "required": "${path} is a required field",
                "defined": "${path} must be defined",
                "notNull": "${path} cannot be null",
                "oneOf": "${path} must be one of the following values: ${values}",
                "notOneOf": "${path} must not be one of the following values: ${values}",
                "notType": ({"path": v, "type": E, "value": k, "originalValue": R}) => {
                    const U = null != R && R !== k ? ` (cast from the value \`${printValue(R, !0)}\`).` : ".";
                    return "mixed" !== E ? `${v} must be a \`${E}\` type, but the final value was: \`${printValue(k, !0)}\`` + U : `${v} must match the configured type. The validated value was: \`${printValue(k, !0)}\`` + U
                }
            }
              , re = {
                "length": "${path} must be exactly ${length} characters",
                "min": "${path} must be at least ${min} characters",
                "max": "${path} must be at most ${max} characters",
                "matches": '${path} must match the following: "${regex}"',
                "email": "${path} must be a valid email",
                "url": "${path} must be a valid URL",
                "uuid": "${path} must be a valid UUID",
                "datetime": "${path} must be a valid ISO date-time",
                "datetime_precision": "${path} must be a valid ISO date-time with a sub-second precision of exactly ${precision} digits",
                "datetime_offset": '${path} must be a valid ISO date-time with UTC "Z" timezone',
                "trim": "${path} must be a trimmed string",
                "lowercase": "${path} must be a lowercase string",
                "uppercase": "${path} must be a upper case string"
            }
              , oe = {
                "min": "${path} must be greater than or equal to ${min}",
                "max": "${path} must be less than or equal to ${max}",
                "lessThan": "${path} must be less than ${less}",
                "moreThan": "${path} must be greater than ${more}",
                "positive": "${path} must be a positive number",
                "negative": "${path} must be a negative number",
                "integer": "${path} must be an integer"
            }
              , ie = {
                "min": "${path} field must be later than ${min}",
                "max": "${path} field must be at earlier than ${max}"
            }
              , ae = {
                "isValue": "${path} field must be ${value}"
            }
              , se = {
                "noUnknown": "${path} field has unspecified keys: ${unknown}"
            }
              , ce = {
                "min": "${path} field must have at least ${min} items",
                "max": "${path} field must have less than or equal to ${max} items",
                "length": "${path} must have ${length} items"
            }
              , le = {
                "notType": v => {
                    const {"path": E, "value": k, "spec": R} = v
                      , U = R.types.length;
                    if (Array.isArray(k)) {
                        if (k.length < U)
                            return `${E} tuple value has too few items, expected a length of ${U} but got ${k.length} for value: \`${printValue(k, !0)}\``;
                        if (k.length > U)
                            return `${E} tuple value has too many items, expected a length of ${U} but got ${k.length} for value: \`${printValue(k, !0)}\``
                    }
                    return ValidationError.formatError(ne.notType, v)
                }
            };
            var ue = Object.assign(Object.create(null), {
                "mixed": ne,
                "string": re,
                "number": oe,
                "date": ie,
                "object": se,
                "array": ce,
                "boolean": ae,
                "tuple": le
            });
            const isSchema = v => v && v.__isYupSchema__;
            class Condition {
                static "fromOptions"(v, E) {
                    if (!E.then && !E.otherwise)
                        throw new TypeError("either `then:` or `otherwise:` is required for `when()` conditions");
                    let {"is": k, "then": R, "otherwise": U} = E
                      , H = "function" == typeof k ? k : (...v) => v.every((v => v === k));
                    return new Condition(v,( (v, E) => {
                        var k;
                        let G = H(...v) ? R : U;
                        return null != (k = null == G ? void 0 : G(E)) ? k : E
                    }
                    ))
                }
                "constructor"(v, E) {
                    this.fn = void 0,
                    this.refs = v,
                    this.refs = v,
                    this.fn = E
                }
                "resolve"(v, E) {
                    let k = this.refs.map((v => v.getValue(null == E ? void 0 : E.value, null == E ? void 0 : E.parent, null == E ? void 0 : E.context)))
                      , R = this.fn(k, v, E);
                    if (void 0 === R || R === v)
                        return v;
                    if (!isSchema(R))
                        throw new TypeError("conditions must return a schema object");
                    return R.resolve(E)
                }
            }
            const de = "$"
              , pe = ".";
            function create$9(v, E) {
                return new Reference(v,E)
            }
            class Reference {
                "constructor"(v, E={}) {
                    if (this.key = void 0,
                    this.isContext = void 0,
                    this.isValue = void 0,
                    this.isSibling = void 0,
                    this.path = void 0,
                    this.getter = void 0,
                    this.map = void 0,
                    "string" != typeof v)
                        throw new TypeError("ref must be a string, got: " + v);
                    if (this.key = v.trim(),
                    "" === v)
                        throw new TypeError("ref must be a non-empty string");
                    this.isContext = this.key[0] === de,
                    this.isValue = this.key[0] === pe,
                    this.isSibling = !this.isContext && !this.isValue;
                    let k = this.isContext ? de : this.isValue ? pe : "";
                    this.path = this.key.slice(k.length),
                    this.getter = this.path && (0,
                    R.getter)(this.path, !0),
                    this.map = E.map
                }
                "getValue"(v, E, k) {
                    let R = this.isContext ? k : this.isValue ? v : E;
                    return this.getter && (R = this.getter(R || {})),
                    this.map && (R = this.map(R)),
                    R
                }
                "cast"(v, E) {
                    return this.getValue(v, null == E ? void 0 : E.parent, null == E ? void 0 : E.context)
                }
                "resolve"() {
                    return this
                }
                "describe"() {
                    return {
                        "type": "ref",
                        "key": this.key
                    }
                }
                "toString"() {
                    return `Ref(${this.key})`
                }
                static "isRef"(v) {
                    return v && v.__isYupRef
                }
            }
            Reference.prototype.__isYupRef = !0;
            const isAbsent = v => null == v;
            function createValidation(v) {
                function validate({"value": E, "path": k="", "options": R, "originalValue": U, "schema": H}, G, W) {
                    const {"name": Z, "test": Y, "params": J, "message": K, "skipAbsent": X} = v;
                    let {"parent": Q, "context": ee, "abortEarly": te=H.spec.abortEarly, "disableStackTrace": ne=H.spec.disableStackTrace} = R;
                    function resolve(v) {
                        return Reference.isRef(v) ? v.getValue(E, Q, ee) : v
                    }
                    function createError(v={}) {
                        const R = Object.assign({
                            "value": E,
                            "originalValue": U,
                            "label": H.spec.label,
                            "path": v.path || k,
                            "spec": H.spec,
                            "disableStackTrace": v.disableStackTrace || ne
                        }, J, v.params);
                        for (const v of Object.keys(R))
                            R[v] = resolve(R[v]);
                        const G = new ValidationError(ValidationError.formatError(v.message || K, R),E,R.path,v.type || Z,R.disableStackTrace);
                        return G.params = R,
                        G
                    }
                    const re = te ? G : W;
                    let oe = {
                        "path": k,
                        "parent": Q,
                        "type": Z,
                        "from": R.from,
                        "createError": createError,
                        "resolve": resolve,
                        "options": R,
                        "originalValue": U,
                        "schema": H
                    };
                    const handleResult = v => {
                        ValidationError.isError(v) ? re(v) : v ? W(null) : re(createError())
                    }
                      , handleError = v => {
                        ValidationError.isError(v) ? re(v) : G(v)
                    }
                    ;
                    if (X && isAbsent(E))
                        return handleResult(!0);
                    let ie;
                    try {
                        var ae;
                        if (ie = Y.call(oe, E, oe),
                        "function" == typeof (null == (ae = ie) ? void 0 : ae.then)) {
                            if (R.sync)
                                throw new Error(`Validation test of type: "${oe.type}" returned a Promise during a synchronous validate. This test will finish after the validate call has returned`);
                            return Promise.resolve(ie).then(handleResult, handleError)
                        }
                    } catch (v) {
                        return void handleError(v)
                    }
                    handleResult(ie)
                }
                return validate.OPTIONS = v,
                validate
            }
            function getIn(v, E, k, U=k) {
                let H, G, W;
                return E ? ((0,
                R.forEach)(E, ( (R, Z, Y) => {
                    let J = Z ? R.slice(1, R.length - 1) : R
                      , K = "tuple" === (v = v.resolve({
                        "context": U,
                        "parent": H,
                        "value": k
                    })).type
                      , X = Y ? parseInt(J, 10) : 0;
                    if (v.innerType || K) {
                        if (K && !Y)
                            throw new Error(`Yup.reach cannot implicitly index into a tuple type. the path part "${W}" must contain an index to the tuple element, e.g. "${W}[0]"`);
                        if (k && X >= k.length)
                            throw new Error(`Yup.reach cannot resolve an array item at index: ${R}, in the path: ${E}. because there is no value at that index. `);
                        H = k,
                        k = k && k[X],
                        v = K ? v.spec.types[X] : v.innerType
                    }
                    if (!Y) {
                        if (!v.fields || !v.fields[J])
                            throw new Error(`The schema does not contain the path: ${E}. (failed at: ${W} which is a type: "${v.type}")`);
                        H = k,
                        k = k && k[J],
                        v = v.fields[J]
                    }
                    G = J,
                    W = Z ? "[" + R + "]" : "." + R
                }
                )),
                {
                    "schema": v,
                    "parent": H,
                    "parentPath": G
                }) : {
                    "parent": H,
                    "parentPath": E,
                    "schema": v
                }
            }
            function reach(v, E, k, R) {
                return getIn(v, E, k, R).schema
            }
            class ReferenceSet extends Set {
                "describe"() {
                    const v = [];
                    for (const E of this.values())
                        v.push(Reference.isRef(E) ? E.describe() : E);
                    return v
                }
                "resolveAll"(v) {
                    let E = [];
                    for (const k of this.values())
                        E.push(v(k));
                    return E
                }
                "clone"() {
                    return new ReferenceSet(this.values())
                }
                "merge"(v, E) {
                    const k = this.clone();
                    return v.forEach((v => k.add(v))),
                    E.forEach((v => k.delete(v))),
                    k
                }
            }
            function clone(v, E=new Map) {
                if (isSchema(v) || !v || "object" != typeof v)
                    return v;
                if (E.has(v))
                    return E.get(v);
                let k;
                if (v instanceof Date)
                    k = new Date(v.getTime()),
                    E.set(v, k);
                else if (v instanceof RegExp)
                    k = new RegExp(v),
                    E.set(v, k);
                else if (Array.isArray(v)) {
                    k = new Array(v.length),
                    E.set(v, k);
                    for (let R = 0; R < v.length; R++)
                        k[R] = clone(v[R], E)
                } else if (v instanceof Map) {
                    k = new Map,
                    E.set(v, k);
                    for (const [R,U] of v.entries())
                        k.set(R, clone(U, E))
                } else if (v instanceof Set) {
                    k = new Set,
                    E.set(v, k);
                    for (const R of v)
                        k.add(clone(R, E))
                } else {
                    if (!(v instanceof Object))
                        throw Error(`Unable to clone ${v}`);
                    k = {},
                    E.set(v, k);
                    for (const [R,U] of Object.entries(v))
                        k[R] = clone(U, E)
                }
                return k
            }
            class Schema {
                "constructor"(v) {
                    this.type = void 0,
                    this.deps = [],
                    this.tests = void 0,
                    this.transforms = void 0,
                    this.conditions = [],
                    this._mutate = void 0,
                    this.internalTests = {},
                    this._whitelist = new ReferenceSet,
                    this._blacklist = new ReferenceSet,
                    this.exclusiveTests = Object.create(null),
                    this._typeCheck = void 0,
                    this.spec = void 0,
                    this.tests = [],
                    this.transforms = [],
                    this.withMutation(( () => {
                        this.typeError(ne.notType)
                    }
                    )),
                    this.type = v.type,
                    this._typeCheck = v.check,
                    this.spec = Object.assign({
                        "strip": !1,
                        "strict": !1,
                        "abortEarly": !0,
                        "recursive": !0,
                        "disableStackTrace": !1,
                        "nullable": !1,
                        "optional": !0,
                        "coerce": !0
                    }, null == v ? void 0 : v.spec),
                    this.withMutation((v => {
                        v.nonNullable()
                    }
                    ))
                }
                get "_type"() {
                    return this.type
                }
                "clone"(v) {
                    if (this._mutate)
                        return v && Object.assign(this.spec, v),
                        this;
                    const E = Object.create(Object.getPrototypeOf(this));
                    return E.type = this.type,
                    E._typeCheck = this._typeCheck,
                    E._whitelist = this._whitelist.clone(),
                    E._blacklist = this._blacklist.clone(),
                    E.internalTests = Object.assign({}, this.internalTests),
                    E.exclusiveTests = Object.assign({}, this.exclusiveTests),
                    E.deps = [...this.deps],
                    E.conditions = [...this.conditions],
                    E.tests = [...this.tests],
                    E.transforms = [...this.transforms],
                    E.spec = clone(Object.assign({}, this.spec, v)),
                    E
                }
                "label"(v) {
                    let E = this.clone();
                    return E.spec.label = v,
                    E
                }
                "meta"(...v) {
                    if (0 === v.length)
                        return this.spec.meta;
                    let E = this.clone();
                    return E.spec.meta = Object.assign(E.spec.meta || {}, v[0]),
                    E
                }
                "withMutation"(v) {
                    let E = this._mutate;
                    this._mutate = !0;
                    let k = v(this);
                    return this._mutate = E,
                    k
                }
                "concat"(v) {
                    if (!v || v === this)
                        return this;
                    if (v.type !== this.type && "mixed" !== this.type)
                        throw new TypeError(`You cannot \`concat()\` schema's of different types: ${this.type} and ${v.type}`);
                    let E = this
                      , k = v.clone();
                    const R = Object.assign({}, E.spec, k.spec);
                    return k.spec = R,
                    k.internalTests = Object.assign({}, E.internalTests, k.internalTests),
                    k._whitelist = E._whitelist.merge(v._whitelist, v._blacklist),
                    k._blacklist = E._blacklist.merge(v._blacklist, v._whitelist),
                    k.tests = E.tests,
                    k.exclusiveTests = E.exclusiveTests,
                    k.withMutation((E => {
                        v.tests.forEach((v => {
                            E.test(v.OPTIONS)
                        }
                        ))
                    }
                    )),
                    k.transforms = [...E.transforms, ...k.transforms],
                    k
                }
                "isType"(v) {
                    return null == v ? !(!this.spec.nullable || null !== v) || !(!this.spec.optional || void 0 !== v) : this._typeCheck(v)
                }
                "resolve"(v) {
                    let E = this;
                    if (E.conditions.length) {
                        let k = E.conditions;
                        E = E.clone(),
                        E.conditions = [],
                        E = k.reduce(( (E, k) => k.resolve(E, v)), E),
                        E = E.resolve(v)
                    }
                    return E
                }
                "resolveOptions"(v) {
                    var E, k, R, U;
                    return Object.assign({}, v, {
                        "from": v.from || [],
                        "strict": null != (E = v.strict) ? E : this.spec.strict,
                        "abortEarly": null != (k = v.abortEarly) ? k : this.spec.abortEarly,
                        "recursive": null != (R = v.recursive) ? R : this.spec.recursive,
                        "disableStackTrace": null != (U = v.disableStackTrace) ? U : this.spec.disableStackTrace
                    })
                }
                "cast"(v, E={}) {
                    let k = this.resolve(Object.assign({
                        "value": v
                    }, E))
                      , R = "ignore-optionality" === E.assert
                      , U = k._cast(v, E);
                    if (!1 !== E.assert && !k.isType(U)) {
                        if (R && isAbsent(U))
                            return U;
                        let H = printValue(v)
                          , G = printValue(U);
                        throw new TypeError(`The value of ${E.path || "field"} could not be cast to a value that satisfies the schema type: "${k.type}". \n\nattempted value: ${H} \n` + (G !== H ? `result of cast: ${G}` : ""))
                    }
                    return U
                }
                "_cast"(v, E) {
                    let k = void 0 === v ? v : this.transforms.reduce(( (E, k) => k.call(this, E, v, this)), v);
                    return void 0 === k && (k = this.getDefault(E)),
                    k
                }
                "_validate"(v, E={}, k, R) {
                    let {"path": U, "originalValue": H=v, "strict": G=this.spec.strict} = E
                      , W = v;
                    G || (W = this._cast(W, Object.assign({
                        "assert": !1
                    }, E)));
                    let Z = [];
                    for (let v of Object.values(this.internalTests))
                        v && Z.push(v);
                    this.runTests({
                        "path": U,
                        "value": W,
                        "originalValue": H,
                        "options": E,
                        "tests": Z
                    }, k, (v => {
                        if (v.length)
                            return R(v, W);
                        this.runTests({
                            "path": U,
                            "value": W,
                            "originalValue": H,
                            "options": E,
                            "tests": this.tests
                        }, k, R)
                    }
                    ))
                }
                "runTests"(v, E, k) {
                    let R = !1
                      , {"tests": U, "value": H, "originalValue": G, "path": W, "options": Z} = v
                      , panicOnce = v => {
                        R || (R = !0,
                        E(v, H))
                    }
                      , nextOnce = v => {
                        R || (R = !0,
                        k(v, H))
                    }
                      , Y = U.length
                      , J = [];
                    if (!Y)
                        return nextOnce([]);
                    let K = {
                        "value": H,
                        "originalValue": G,
                        "path": W,
                        "options": Z,
                        "schema": this
                    };
                    for (let v = 0; v < U.length; v++) {
                        (0,
                        U[v])(K, panicOnce, (function finishTestRun(v) {
                            v && (Array.isArray(v) ? J.push(...v) : J.push(v)),
                            --Y <= 0 && nextOnce(J)
                        }
                        ))
                    }
                }
                "asNestedTest"({"key": v, "index": E, "parent": k, "parentPath": R, "originalParent": U, "options": H}) {
                    const G = null != v ? v : E;
                    if (null == G)
                        throw TypeError("Must include `key` or `index` for nested validations");
                    const W = "number" == typeof G;
                    let Z = k[G];
                    const Y = Object.assign({}, H, {
                        "strict": !0,
                        "parent": k,
                        "value": Z,
                        "originalValue": U[G],
                        "key": void 0,
                        [W ? "index" : "key"]: G,
                        "path": W || G.includes(".") ? `${R || ""}[${W ? G : `"${G}"`}]` : (R ? `${R}.` : "") + v
                    });
                    return (v, E, k) => this.resolve(Y)._validate(Z, Y, E, k)
                }
                "validate"(v, E) {
                    var k;
                    let R = this.resolve(Object.assign({}, E, {
                        "value": v
                    }))
                      , U = null != (k = null == E ? void 0 : E.disableStackTrace) ? k : R.spec.disableStackTrace;
                    return new Promise(( (k, H) => R._validate(v, E, ( (v, E) => {
                        ValidationError.isError(v) && (v.value = E),
                        H(v)
                    }
                    ), ( (v, E) => {
                        v.length ? H(new ValidationError(v,E,void 0,void 0,U)) : k(E)
                    }
                    ))))
                }
                "validateSync"(v, E) {
                    var k;
                    let R, U = this.resolve(Object.assign({}, E, {
                        "value": v
                    })), H = null != (k = null == E ? void 0 : E.disableStackTrace) ? k : U.spec.disableStackTrace;
                    return U._validate(v, Object.assign({}, E, {
                        "sync": !0
                    }), ( (v, E) => {
                        throw ValidationError.isError(v) && (v.value = E),
                        v
                    }
                    ), ( (E, k) => {
                        if (E.length)
                            throw new ValidationError(E,v,void 0,void 0,H);
                        R = k
                    }
                    )),
                    R
                }
                "isValid"(v, E) {
                    return this.validate(v, E).then(( () => !0), (v => {
                        if (ValidationError.isError(v))
                            return !1;
                        throw v
                    }
                    ))
                }
                "isValidSync"(v, E) {
                    try {
                        return this.validateSync(v, E),
                        !0
                    } catch (v) {
                        if (ValidationError.isError(v))
                            return !1;
                        throw v
                    }
                }
                "_getDefault"(v) {
                    let E = this.spec.default;
                    return null == E ? E : "function" == typeof E ? E.call(this, v) : clone(E)
                }
                "getDefault"(v) {
                    return this.resolve(v || {})._getDefault(v)
                }
                "default"(v) {
                    if (0 === arguments.length)
                        return this._getDefault();
                    return this.clone({
                        "default": v
                    })
                }
                "strict"(v=!0) {
                    return this.clone({
                        "strict": v
                    })
                }
                "nullability"(v, E) {
                    const k = this.clone({
                        "nullable": v
                    });
                    return k.internalTests.nullable = createValidation({
                        "message": E,
                        "name": "nullable",
                        "test"(v) {
                            return null !== v || this.schema.spec.nullable
                        }
                    }),
                    k
                }
                "optionality"(v, E) {
                    const k = this.clone({
                        "optional": v
                    });
                    return k.internalTests.optionality = createValidation({
                        "message": E,
                        "name": "optionality",
                        "test"(v) {
                            return void 0 !== v || this.schema.spec.optional
                        }
                    }),
                    k
                }
                "optional"() {
                    return this.optionality(!0)
                }
                "defined"(v=ne.defined) {
                    return this.optionality(!1, v)
                }
                "nullable"() {
                    return this.nullability(!0)
                }
                "nonNullable"(v=ne.notNull) {
                    return this.nullability(!1, v)
                }
                "required"(v=ne.required) {
                    return this.clone().withMutation((E => E.nonNullable(v).defined(v)))
                }
                "notRequired"() {
                    return this.clone().withMutation((v => v.nullable().optional()))
                }
                "transform"(v) {
                    let E = this.clone();
                    return E.transforms.push(v),
                    E
                }
                "test"(...v) {
                    let E;
                    if (E = 1 === v.length ? "function" == typeof v[0] ? {
                        "test": v[0]
                    } : v[0] : 2 === v.length ? {
                        "name": v[0],
                        "test": v[1]
                    } : {
                        "name": v[0],
                        "message": v[1],
                        "test": v[2]
                    },
                    void 0 === E.message && (E.message = ne.default),
                    "function" != typeof E.test)
                        throw new TypeError("`test` is a required parameters");
                    let k = this.clone()
                      , R = createValidation(E)
                      , U = E.exclusive || E.name && !0 === k.exclusiveTests[E.name];
                    if (E.exclusive && !E.name)
                        throw new TypeError("Exclusive tests must provide a unique `name` identifying the test");
                    return E.name && (k.exclusiveTests[E.name] = !!E.exclusive),
                    k.tests = k.tests.filter((v => {
                        if (v.OPTIONS.name === E.name) {
                            if (U)
                                return !1;
                            if (v.OPTIONS.test === R.OPTIONS.test)
                                return !1
                        }
                        return !0
                    }
                    )),
                    k.tests.push(R),
                    k
                }
                "when"(v, E) {
                    Array.isArray(v) || "string" == typeof v || (E = v,
                    v = ".");
                    let k = this.clone()
                      , R = toArray(v).map((v => new Reference(v)));
                    return R.forEach((v => {
                        v.isSibling && k.deps.push(v.key)
                    }
                    )),
                    k.conditions.push("function" == typeof E ? new Condition(R,E) : Condition.fromOptions(R, E)),
                    k
                }
                "typeError"(v) {
                    let E = this.clone();
                    return E.internalTests.typeError = createValidation({
                        "message": v,
                        "name": "typeError",
                        "skipAbsent": !0,
                        "test"(v) {
                            return !!this.schema._typeCheck(v) || this.createError({
                                "params": {
                                    "type": this.schema.type
                                }
                            })
                        }
                    }),
                    E
                }
                "oneOf"(v, E=ne.oneOf) {
                    let k = this.clone();
                    return v.forEach((v => {
                        k._whitelist.add(v),
                        k._blacklist.delete(v)
                    }
                    )),
                    k.internalTests.whiteList = createValidation({
                        "message": E,
                        "name": "oneOf",
                        "skipAbsent": !0,
                        "test"(v) {
                            let E = this.schema._whitelist
                              , k = E.resolveAll(this.resolve);
                            return !!k.includes(v) || this.createError({
                                "params": {
                                    "values": Array.from(E).join(", "),
                                    "resolved": k
                                }
                            })
                        }
                    }),
                    k
                }
                "notOneOf"(v, E=ne.notOneOf) {
                    let k = this.clone();
                    return v.forEach((v => {
                        k._blacklist.add(v),
                        k._whitelist.delete(v)
                    }
                    )),
                    k.internalTests.blacklist = createValidation({
                        "message": E,
                        "name": "notOneOf",
                        "test"(v) {
                            let E = this.schema._blacklist
                              , k = E.resolveAll(this.resolve);
                            return !k.includes(v) || this.createError({
                                "params": {
                                    "values": Array.from(E).join(", "),
                                    "resolved": k
                                }
                            })
                        }
                    }),
                    k
                }
                "strip"(v=!0) {
                    let E = this.clone();
                    return E.spec.strip = v,
                    E
                }
                "describe"(v) {
                    const E = (v ? this.resolve(v) : this).clone()
                      , {"label": k, "meta": R, "optional": U, "nullable": H} = E.spec;
                    return {
                        "meta": R,
                        "label": k,
                        "optional": U,
                        "nullable": H,
                        "default": E.getDefault(v),
                        "type": E.type,
                        "oneOf": E._whitelist.describe(),
                        "notOneOf": E._blacklist.describe(),
                        "tests": E.tests.map((v => ({
                            "name": v.OPTIONS.name,
                            "params": v.OPTIONS.params
                        }))).filter(( (v, E, k) => k.findIndex((E => E.name === v.name)) === E))
                    }
                }
            }
            Schema.prototype.__isYupSchema__ = !0;
            for (const v of ["validate", "validateSync"])
                Schema.prototype[`${v}At`] = function(E, k, R={}) {
                    const {"parent": U, "parentPath": H, "schema": G} = getIn(this, E, k, R.context);
                    return G[v](U && U[H], Object.assign({}, R, {
                        "parent": U,
                        "path": E
                    }))
                }
                ;
            for (const v of ["equals", "is"])
                Schema.prototype[v] = Schema.prototype.oneOf;
            for (const v of ["not", "nope"])
                Schema.prototype[v] = Schema.prototype.notOneOf;
            const returnsTrue = () => !0;
            function create$8(v) {
                return new MixedSchema(v)
            }
            class MixedSchema extends Schema {
                "constructor"(v) {
                    super("function" == typeof v ? {
                        "type": "mixed",
                        "check": v
                    } : Object.assign({
                        "type": "mixed",
                        "check": returnsTrue
                    }, v))
                }
            }
            function create$7() {
                return new BooleanSchema
            }
            create$8.prototype = MixedSchema.prototype;
            class BooleanSchema extends Schema {
                "constructor"() {
                    super({
                        "type": "boolean",
                        "check"(v) {
                            return v instanceof Boolean && (v = v.valueOf()),
                            "boolean" == typeof v
                        }
                    }),
                    this.withMutation(( () => {
                        this.transform(( (v, E, k) => {
                            if (k.spec.coerce && !k.isType(v)) {
                                if (/^(true|1)$/i.test(String(v)))
                                    return !0;
                                if (/^(false|0)$/i.test(String(v)))
                                    return !1
                            }
                            return v
                        }
                        ))
                    }
                    ))
                }
                "isTrue"(v=ae.isValue) {
                    return this.test({
                        "message": v,
                        "name": "is-value",
                        "exclusive": !0,
                        "params": {
                            "value": "true"
                        },
                        "test"(v) {
                            return isAbsent(v) || !0 === v
                        }
                    })
                }
                "isFalse"(v=ae.isValue) {
                    return this.test({
                        "message": v,
                        "name": "is-value",
                        "exclusive": !0,
                        "params": {
                            "value": "false"
                        },
                        "test"(v) {
                            return isAbsent(v) || !1 === v
                        }
                    })
                }
                "default"(v) {
                    return super.default(v)
                }
                "defined"(v) {
                    return super.defined(v)
                }
                "optional"() {
                    return super.optional()
                }
                "required"(v) {
                    return super.required(v)
                }
                "notRequired"() {
                    return super.notRequired()
                }
                "nullable"() {
                    return super.nullable()
                }
                "nonNullable"(v) {
                    return super.nonNullable(v)
                }
                "strip"(v) {
                    return super.strip(v)
                }
            }
            create$7.prototype = BooleanSchema.prototype;
            const fe = /^(\d{4}|[+-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,.](\d{1,}))?)?(?:(Z)|([+-])(\d{2})(?::?(\d{2}))?)?)?$/;
            function parseDateStruct(v) {
                var E, k;
                const R = fe.exec(v);
                return R ? {
                    "year": toNumber(R[1]),
                    "month": toNumber(R[2], 1) - 1,
                    "day": toNumber(R[3], 1),
                    "hour": toNumber(R[4]),
                    "minute": toNumber(R[5]),
                    "second": toNumber(R[6]),
                    "millisecond": R[7] ? toNumber(R[7].substring(0, 3)) : 0,
                    "precision": null != (E = null == (k = R[7]) ? void 0 : k.length) ? E : void 0,
                    "z": R[8] || void 0,
                    "plusMinus": R[9] || void 0,
                    "hourOffset": toNumber(R[10]),
                    "minuteOffset": toNumber(R[11])
                } : null
            }
            function toNumber(v, E=0) {
                return Number(v) || E
            }
            let he = /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/
              , me = /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i
              , ge = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i
              , _e = new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$")
              , isTrimmed = v => isAbsent(v) || v === v.trim()
              , ve = {}.toString();
            function create$6() {
                return new StringSchema
            }
            class StringSchema extends Schema {
                "constructor"() {
                    super({
                        "type": "string",
                        "check"(v) {
                            return v instanceof String && (v = v.valueOf()),
                            "string" == typeof v
                        }
                    }),
                    this.withMutation(( () => {
                        this.transform(( (v, E, k) => {
                            if (!k.spec.coerce || k.isType(v))
                                return v;
                            if (Array.isArray(v))
                                return v;
                            const R = null != v && v.toString ? v.toString() : v;
                            return R === ve ? v : R
                        }
                        ))
                    }
                    ))
                }
                "required"(v) {
                    return super.required(v).withMutation((E => E.test({
                        "message": v || ne.required,
                        "name": "required",
                        "skipAbsent": !0,
                        "test": v => !!v.length
                    })))
                }
                "notRequired"() {
                    return super.notRequired().withMutation((v => (v.tests = v.tests.filter((v => "required" !== v.OPTIONS.name)),
                    v)))
                }
                "length"(v, E=re.length) {
                    return this.test({
                        "message": E,
                        "name": "length",
                        "exclusive": !0,
                        "params": {
                            "length": v
                        },
                        "skipAbsent": !0,
                        "test"(E) {
                            return E.length === this.resolve(v)
                        }
                    })
                }
                "min"(v, E=re.min) {
                    return this.test({
                        "message": E,
                        "name": "min",
                        "exclusive": !0,
                        "params": {
                            "min": v
                        },
                        "skipAbsent": !0,
                        "test"(E) {
                            return E.length >= this.resolve(v)
                        }
                    })
                }
                "max"(v, E=re.max) {
                    return this.test({
                        "name": "max",
                        "exclusive": !0,
                        "message": E,
                        "params": {
                            "max": v
                        },
                        "skipAbsent": !0,
                        "test"(E) {
                            return E.length <= this.resolve(v)
                        }
                    })
                }
                "matches"(v, E) {
                    let k, R, U = !1;
                    return E && ("object" == typeof E ? ({"excludeEmptyString": U=!1, "message": k, "name": R} = E) : k = E),
                    this.test({
                        "name": R || "matches",
                        "message": k || re.matches,
                        "params": {
                            "regex": v
                        },
                        "skipAbsent": !0,
                        "test": E => "" === E && U || -1 !== E.search(v)
                    })
                }
                "email"(v=re.email) {
                    return this.matches(he, {
                        "name": "email",
                        "message": v,
                        "excludeEmptyString": !0
                    })
                }
                "url"(v=re.url) {
                    return this.matches(me, {
                        "name": "url",
                        "message": v,
                        "excludeEmptyString": !0
                    })
                }
                "uuid"(v=re.uuid) {
                    return this.matches(ge, {
                        "name": "uuid",
                        "message": v,
                        "excludeEmptyString": !1
                    })
                }
                "datetime"(v) {
                    let E, k, R = "";
                    return v && ("object" == typeof v ? ({"message": R="", "allowOffset": E=!1, "precision": k} = v) : R = v),
                    this.matches(_e, {
                        "name": "datetime",
                        "message": R || re.datetime,
                        "excludeEmptyString": !0
                    }).test({
                        "name": "datetime_offset",
                        "message": R || re.datetime_offset,
                        "params": {
                            "allowOffset": E
                        },
                        "skipAbsent": !0,
                        "test": v => {
                            if (!v || E)
                                return !0;
                            const k = parseDateStruct(v);
                            return !!k && !!k.z
                        }
                    }).test({
                        "name": "datetime_precision",
                        "message": R || re.datetime_precision,
                        "params": {
                            "precision": k
                        },
                        "skipAbsent": !0,
                        "test": v => {
                            if (!v || null == k)
                                return !0;
                            const E = parseDateStruct(v);
                            return !!E && E.precision === k
                        }
                    })
                }
                "ensure"() {
                    return this.default("").transform((v => null === v ? "" : v))
                }
                "trim"(v=re.trim) {
                    return this.transform((v => null != v ? v.trim() : v)).test({
                        "message": v,
                        "name": "trim",
                        "test": isTrimmed
                    })
                }
                "lowercase"(v=re.lowercase) {
                    return this.transform((v => isAbsent(v) ? v : v.toLowerCase())).test({
                        "message": v,
                        "name": "string_case",
                        "exclusive": !0,
                        "skipAbsent": !0,
                        "test": v => isAbsent(v) || v === v.toLowerCase()
                    })
                }
                "uppercase"(v=re.uppercase) {
                    return this.transform((v => isAbsent(v) ? v : v.toUpperCase())).test({
                        "message": v,
                        "name": "string_case",
                        "exclusive": !0,
                        "skipAbsent": !0,
                        "test": v => isAbsent(v) || v === v.toUpperCase()
                    })
                }
            }
            create$6.prototype = StringSchema.prototype;
            function create$5() {
                return new NumberSchema
            }
            class NumberSchema extends Schema {
                "constructor"() {
                    super({
                        "type": "number",
                        "check"(v) {
                            return v instanceof Number && (v = v.valueOf()),
                            "number" == typeof v && !(v => v != +v)(v)
                        }
                    }),
                    this.withMutation(( () => {
                        this.transform(( (v, E, k) => {
                            if (!k.spec.coerce)
                                return v;
                            let R = v;
                            if ("string" == typeof R) {
                                if (R = R.replace(/\s/g, ""),
                                "" === R)
                                    return NaN;
                                R = +R
                            }
                            return k.isType(R) || null === R ? R : parseFloat(R)
                        }
                        ))
                    }
                    ))
                }
                "min"(v, E=oe.min) {
                    return this.test({
                        "message": E,
                        "name": "min",
                        "exclusive": !0,
                        "params": {
                            "min": v
                        },
                        "skipAbsent": !0,
                        "test"(E) {
                            return E >= this.resolve(v)
                        }
                    })
                }
                "max"(v, E=oe.max) {
                    return this.test({
                        "message": E,
                        "name": "max",
                        "exclusive": !0,
                        "params": {
                            "max": v
                        },
                        "skipAbsent": !0,
                        "test"(E) {
                            return E <= this.resolve(v)
                        }
                    })
                }
                "lessThan"(v, E=oe.lessThan) {
                    return this.test({
                        "message": E,
                        "name": "max",
                        "exclusive": !0,
                        "params": {
                            "less": v
                        },
                        "skipAbsent": !0,
                        "test"(E) {
                            return E < this.resolve(v)
                        }
                    })
                }
                "moreThan"(v, E=oe.moreThan) {
                    return this.test({
                        "message": E,
                        "name": "min",
                        "exclusive": !0,
                        "params": {
                            "more": v
                        },
                        "skipAbsent": !0,
                        "test"(E) {
                            return E > this.resolve(v)
                        }
                    })
                }
                "positive"(v=oe.positive) {
                    return this.moreThan(0, v)
                }
                "negative"(v=oe.negative) {
                    return this.lessThan(0, v)
                }
                "integer"(v=oe.integer) {
                    return this.test({
                        "name": "integer",
                        "message": v,
                        "skipAbsent": !0,
                        "test": v => Number.isInteger(v)
                    })
                }
                "truncate"() {
                    return this.transform((v => isAbsent(v) ? v : 0 | v))
                }
                "round"(v) {
                    var E;
                    let k = ["ceil", "floor", "round", "trunc"];
                    if ("trunc" === (v = (null == (E = v) ? void 0 : E.toLowerCase()) || "round"))
                        return this.truncate();
                    if (-1 === k.indexOf(v.toLowerCase()))
                        throw new TypeError("Only valid options for round() are: " + k.join(", "));
                    return this.transform((E => isAbsent(E) ? E : Math[v](E)))
                }
            }
            create$5.prototype = NumberSchema.prototype;
            let ye = new Date("");
            function create$4() {
                return new DateSchema
            }
            class DateSchema extends Schema {
                "constructor"() {
                    super({
                        "type": "date",
                        "check"(v) {
                            return E = v,
                            "[object Date]" === Object.prototype.toString.call(E) && !isNaN(v.getTime());
                            var E
                        }
                    }),
                    this.withMutation(( () => {
                        this.transform(( (v, E, k) => !k.spec.coerce || k.isType(v) || null === v ? v : (v = function parseIsoDate(v) {
                            const E = parseDateStruct(v);
                            if (!E)
                                return Date.parse ? Date.parse(v) : Number.NaN;
                            if (void 0 === E.z && void 0 === E.plusMinus)
                                return new Date(E.year,E.month,E.day,E.hour,E.minute,E.second,E.millisecond).valueOf();
                            let k = 0;
                            return "Z" !== E.z && void 0 !== E.plusMinus && (k = 60 * E.hourOffset + E.minuteOffset,
                            "+" === E.plusMinus && (k = 0 - k)),
                            Date.UTC(E.year, E.month, E.day, E.hour, E.minute + k, E.second, E.millisecond)
                        }(v),
                        isNaN(v) ? DateSchema.INVALID_DATE : new Date(v))))
                    }
                    ))
                }
                "prepareParam"(v, E) {
                    let k;
                    if (Reference.isRef(v))
                        k = v;
                    else {
                        let R = this.cast(v);
                        if (!this._typeCheck(R))
                            throw new TypeError(`\`${E}\` must be a Date or a value that can be \`cast()\` to a Date`);
                        k = R
                    }
                    return k
                }
                "min"(v, E=ie.min) {
                    let k = this.prepareParam(v, "min");
                    return this.test({
                        "message": E,
                        "name": "min",
                        "exclusive": !0,
                        "params": {
                            "min": v
                        },
                        "skipAbsent": !0,
                        "test"(v) {
                            return v >= this.resolve(k)
                        }
                    })
                }
                "max"(v, E=ie.max) {
                    let k = this.prepareParam(v, "max");
                    return this.test({
                        "message": E,
                        "name": "max",
                        "exclusive": !0,
                        "params": {
                            "max": v
                        },
                        "skipAbsent": !0,
                        "test"(v) {
                            return v <= this.resolve(k)
                        }
                    })
                }
            }
            function findIndex(v, E) {
                let k = 1 / 0;
                return v.some(( (v, R) => {
                    var U;
                    if (null != (U = E.path) && U.includes(v))
                        return k = R,
                        !0
                }
                )),
                k
            }
            function sortByKeyOrder(v) {
                return (E, k) => findIndex(v, E) - findIndex(v, k)
            }
            DateSchema.INVALID_DATE = ye,
            create$4.prototype = DateSchema.prototype,
            create$4.INVALID_DATE = ye;
            const parseJson = (v, E, k) => {
                if ("string" != typeof v)
                    return v;
                let R = v;
                try {
                    R = JSON.parse(v)
                } catch (v) {}
                return k.isType(R) ? R : v
            }
            ;
            function deepPartial(v) {
                if ("fields"in v) {
                    const E = {};
                    for (const [k,R] of Object.entries(v.fields))
                        E[k] = deepPartial(R);
                    return v.setFields(E)
                }
                if ("array" === v.type) {
                    const E = v.optional();
                    return E.innerType && (E.innerType = deepPartial(E.innerType)),
                    E
                }
                return "tuple" === v.type ? v.optional().clone({
                    "types": v.spec.types.map(deepPartial)
                }) : "optional"in v ? v.optional() : v
            }
            let isObject = v => "[object Object]" === Object.prototype.toString.call(v);
            const be = sortByKeyOrder([]);
            function create$3(v) {
                return new ObjectSchema(v)
            }
            class ObjectSchema extends Schema {
                "constructor"(v) {
                    super({
                        "type": "object",
                        "check"(v) {
                            return isObject(v) || "function" == typeof v
                        }
                    }),
                    this.fields = Object.create(null),
                    this._sortErrors = be,
                    this._nodes = [],
                    this._excludedEdges = [],
                    this.withMutation(( () => {
                        v && this.shape(v)
                    }
                    ))
                }
                "_cast"(v, E={}) {
                    var k;
                    let R = super._cast(v, E);
                    if (void 0 === R)
                        return this.getDefault(E);
                    if (!this._typeCheck(R))
                        return R;
                    let U = this.fields
                      , H = null != (k = E.stripUnknown) ? k : this.spec.noUnknown
                      , G = [].concat(this._nodes, Object.keys(R).filter((v => !this._nodes.includes(v))))
                      , W = {}
                      , Z = Object.assign({}, E, {
                        "parent": W,
                        "__validating": E.__validating || !1
                    })
                      , Y = !1;
                    for (const v of G) {
                        let k = U[v]
                          , G = v in R;
                        if (k) {
                            let U, H = R[v];
                            Z.path = (E.path ? `${E.path}.` : "") + v,
                            k = k.resolve({
                                "value": H,
                                "context": E.context,
                                "parent": W
                            });
                            let G = k instanceof Schema ? k.spec : void 0
                              , J = null == G ? void 0 : G.strict;
                            if (null != G && G.strip) {
                                Y = Y || v in R;
                                continue
                            }
                            U = E.__validating && J ? R[v] : k.cast(R[v], Z),
                            void 0 !== U && (W[v] = U)
                        } else
                            G && !H && (W[v] = R[v]);
                        G === v in W && W[v] === R[v] || (Y = !0)
                    }
                    return Y ? W : R
                }
                "_validate"(v, E={}, k, R) {
                    let {"from": U=[], "originalValue": H=v, "recursive": G=this.spec.recursive} = E;
                    E.from = [{
                        "schema": this,
                        "value": H
                    }, ...U],
                    E.__validating = !0,
                    E.originalValue = H,
                    super._validate(v, E, k, ( (v, U) => {
                        if (!G || !isObject(U))
                            return void R(v, U);
                        H = H || U;
                        let W = [];
                        for (let v of this._nodes) {
                            let k = this.fields[v];
                            k && !Reference.isRef(k) && W.push(k.asNestedTest({
                                "options": E,
                                "key": v,
                                "parent": U,
                                "parentPath": E.path,
                                "originalParent": H
                            }))
                        }
                        this.runTests({
                            "tests": W,
                            "value": U,
                            "originalValue": H,
                            "options": E
                        }, k, (E => {
                            R(E.sort(this._sortErrors).concat(v), U)
                        }
                        ))
                    }
                    ))
                }
                "clone"(v) {
                    const E = super.clone(v);
                    return E.fields = Object.assign({}, this.fields),
                    E._nodes = this._nodes,
                    E._excludedEdges = this._excludedEdges,
                    E._sortErrors = this._sortErrors,
                    E
                }
                "concat"(v) {
                    let E = super.concat(v)
                      , k = E.fields;
                    for (let[v,E] of Object.entries(this.fields)) {
                        const R = k[v];
                        k[v] = void 0 === R ? E : R
                    }
                    return E.withMutation((E => E.setFields(k, [...this._excludedEdges, ...v._excludedEdges])))
                }
                "_getDefault"(v) {
                    if ("default"in this.spec)
                        return super._getDefault(v);
                    if (!this._nodes.length)
                        return;
                    let E = {};
                    return this._nodes.forEach((k => {
                        var R;
                        const U = this.fields[k];
                        let H = v;
                        null != (R = H) && R.value && (H = Object.assign({}, H, {
                            "parent": H.value,
                            "value": H.value[k]
                        })),
                        E[k] = U && "getDefault"in U ? U.getDefault(H) : void 0
                    }
                    )),
                    E
                }
                "setFields"(v, E) {
                    let k = this.clone();
                    return k.fields = v,
                    k._nodes = function sortFields(v, E=[]) {
                        let k = []
                          , U = new Set
                          , H = new Set(E.map(( ([v,E]) => `${v}-${E}`)));
                        function addNode(v, E) {
                            let G = (0,
                            R.split)(v)[0];
                            U.add(G),
                            H.has(`${E}-${G}`) || k.push([E, G])
                        }
                        for (const E of Object.keys(v)) {
                            let k = v[E];
                            U.add(E),
                            Reference.isRef(k) && k.isSibling ? addNode(k.path, E) : isSchema(k) && "deps"in k && k.deps.forEach((v => addNode(v, E)))
                        }
                        return G().array(Array.from(U), k).reverse()
                    }(v, E),
                    k._sortErrors = sortByKeyOrder(Object.keys(v)),
                    E && (k._excludedEdges = E),
                    k
                }
                "shape"(v, E=[]) {
                    return this.clone().withMutation((k => {
                        let R = k._excludedEdges;
                        return E.length && (Array.isArray(E[0]) || (E = [E]),
                        R = [...k._excludedEdges, ...E]),
                        k.setFields(Object.assign(k.fields, v), R)
                    }
                    ))
                }
                "partial"() {
                    const v = {};
                    for (const [E,k] of Object.entries(this.fields))
                        v[E] = "optional"in k && k.optional instanceof Function ? k.optional() : k;
                    return this.setFields(v)
                }
                "deepPartial"() {
                    return deepPartial(this)
                }
                "pick"(v) {
                    const E = {};
                    for (const k of v)
                        this.fields[k] && (E[k] = this.fields[k]);
                    return this.setFields(E, this._excludedEdges.filter(( ([E,k]) => v.includes(E) && v.includes(k))))
                }
                "omit"(v) {
                    const E = [];
                    for (const k of Object.keys(this.fields))
                        v.includes(k) || E.push(k);
                    return this.pick(E)
                }
                "from"(v, E, k) {
                    let U = (0,
                    R.getter)(v, !0);
                    return this.transform((H => {
                        if (!H)
                            return H;
                        let G = H;
                        return ( (v, E) => {
                            const k = [...(0,
                            R.normalizePath)(E)];
                            if (1 === k.length)
                                return k[0]in v;
                            let U = k.pop()
                              , H = (0,
                            R.getter)((0,
                            R.join)(k), !0)(v);
                            return !(!H || !(U in H))
                        }
                        )(H, v) && (G = Object.assign({}, H),
                        k || delete G[v],
                        G[E] = U(H)),
                        G
                    }
                    ))
                }
                "json"() {
                    return this.transform(parseJson)
                }
                "noUnknown"(v=!0, E=se.noUnknown) {
                    "boolean" != typeof v && (E = v,
                    v = !0);
                    let k = this.test({
                        "name": "noUnknown",
                        "exclusive": !0,
                        "message": E,
                        "test"(E) {
                            if (null == E)
                                return !0;
                            const k = function unknown(v, E) {
                                let k = Object.keys(v.fields);
                                return Object.keys(E).filter((v => -1 === k.indexOf(v)))
                            }(this.schema, E);
                            return !v || 0 === k.length || this.createError({
                                "params": {
                                    "unknown": k.join(", ")
                                }
                            })
                        }
                    });
                    return k.spec.noUnknown = v,
                    k
                }
                "unknown"(v=!0, E=se.noUnknown) {
                    return this.noUnknown(!v, E)
                }
                "transformKeys"(v) {
                    return this.transform((E => {
                        if (!E)
                            return E;
                        const k = {};
                        for (const R of Object.keys(E))
                            k[v(R)] = E[R];
                        return k
                    }
                    ))
                }
                "camelCase"() {
                    return this.transformKeys(U.camelCase)
                }
                "snakeCase"() {
                    return this.transformKeys(U.snakeCase)
                }
                "constantCase"() {
                    return this.transformKeys((v => (0,
                    U.snakeCase)(v).toUpperCase()))
                }
                "describe"(v) {
                    const E = (v ? this.resolve(v) : this).clone()
                      , k = super.describe(v);
                    k.fields = {};
                    for (const [U,H] of Object.entries(E.fields)) {
                        var R;
                        let E = v;
                        null != (R = E) && R.value && (E = Object.assign({}, E, {
                            "parent": E.value,
                            "value": E.value[U]
                        })),
                        k.fields[U] = H.describe(E)
                    }
                    return k
                }
            }
            function create$2(v) {
                return new ArraySchema(v)
            }
            create$3.prototype = ObjectSchema.prototype;
            class ArraySchema extends Schema {
                "constructor"(v) {
                    super({
                        "type": "array",
                        "spec": {
                            "types": v
                        },
                        "check"(v) {
                            return Array.isArray(v)
                        }
                    }),
                    this.innerType = void 0,
                    this.innerType = v
                }
                "_cast"(v, E) {
                    const k = super._cast(v, E);
                    if (!this._typeCheck(k) || !this.innerType)
                        return k;
                    let R = !1;
                    const U = k.map(( (v, k) => {
                        const U = this.innerType.cast(v, Object.assign({}, E, {
                            "path": `${E.path || ""}[${k}]`
                        }));
                        return U !== v && (R = !0),
                        U
                    }
                    ));
                    return R ? U : k
                }
                "_validate"(v, E={}, k, R) {
                    var U;
                    let H = this.innerType
                      , G = null != (U = E.recursive) ? U : this.spec.recursive;
                    null != E.originalValue && E.originalValue,
                    super._validate(v, E, k, ( (U, W) => {
                        var Z;
                        if (!G || !H || !this._typeCheck(W))
                            return void R(U, W);
                        let Y = new Array(W.length);
                        for (let k = 0; k < W.length; k++) {
                            var J;
                            Y[k] = H.asNestedTest({
                                "options": E,
                                "index": k,
                                "parent": W,
                                "parentPath": E.path,
                                "originalParent": null != (J = E.originalValue) ? J : v
                            })
                        }
                        this.runTests({
                            "value": W,
                            "tests": Y,
                            "originalValue": null != (Z = E.originalValue) ? Z : v,
                            "options": E
                        }, k, (v => R(v.concat(U), W)))
                    }
                    ))
                }
                "clone"(v) {
                    const E = super.clone(v);
                    return E.innerType = this.innerType,
                    E
                }
                "json"() {
                    return this.transform(parseJson)
                }
                "concat"(v) {
                    let E = super.concat(v);
                    return E.innerType = this.innerType,
                    v.innerType && (E.innerType = E.innerType ? E.innerType.concat(v.innerType) : v.innerType),
                    E
                }
                "of"(v) {
                    let E = this.clone();
                    if (!isSchema(v))
                        throw new TypeError("`array.of()` sub-schema must be a valid yup schema not: " + printValue(v));
                    return E.innerType = v,
                    E.spec = Object.assign({}, E.spec, {
                        "types": v
                    }),
                    E
                }
                "length"(v, E=ce.length) {
                    return this.test({
                        "message": E,
                        "name": "length",
                        "exclusive": !0,
                        "params": {
                            "length": v
                        },
                        "skipAbsent": !0,
                        "test"(E) {
                            return E.length === this.resolve(v)
                        }
                    })
                }
                "min"(v, E) {
                    return E = E || ce.min,
                    this.test({
                        "message": E,
                        "name": "min",
                        "exclusive": !0,
                        "params": {
                            "min": v
                        },
                        "skipAbsent": !0,
                        "test"(E) {
                            return E.length >= this.resolve(v)
                        }
                    })
                }
                "max"(v, E) {
                    return E = E || ce.max,
                    this.test({
                        "message": E,
                        "name": "max",
                        "exclusive": !0,
                        "params": {
                            "max": v
                        },
                        "skipAbsent": !0,
                        "test"(E) {
                            return E.length <= this.resolve(v)
                        }
                    })
                }
                "ensure"() {
                    return this.default(( () => [])).transform(( (v, E) => this._typeCheck(v) ? v : null == E ? [] : [].concat(E)))
                }
                "compact"(v) {
                    let E = v ? (E, k, R) => !v(E, k, R) : v => !!v;
                    return this.transform((v => null != v ? v.filter(E) : v))
                }
                "describe"(v) {
                    const E = (v ? this.resolve(v) : this).clone()
                      , k = super.describe(v);
                    if (E.innerType) {
                        var R;
                        let U = v;
                        null != (R = U) && R.value && (U = Object.assign({}, U, {
                            "parent": U.value,
                            "value": U.value[0]
                        })),
                        k.innerType = E.innerType.describe(U)
                    }
                    return k
                }
            }
            function create$1(v) {
                return new TupleSchema(v)
            }
            create$2.prototype = ArraySchema.prototype;
            class TupleSchema extends Schema {
                "constructor"(v) {
                    super({
                        "type": "tuple",
                        "spec": {
                            "types": v
                        },
                        "check"(v) {
                            const E = this.spec.types;
                            return Array.isArray(v) && v.length === E.length
                        }
                    }),
                    this.withMutation(( () => {
                        this.typeError(le.notType)
                    }
                    ))
                }
                "_cast"(v, E) {
                    const {"types": k} = this.spec
                      , R = super._cast(v, E);
                    if (!this._typeCheck(R))
                        return R;
                    let U = !1;
                    const H = k.map(( (v, k) => {
                        const H = v.cast(R[k], Object.assign({}, E, {
                            "path": `${E.path || ""}[${k}]`
                        }));
                        return H !== R[k] && (U = !0),
                        H
                    }
                    ));
                    return U ? H : R
                }
                "_validate"(v, E={}, k, R) {
                    let U = this.spec.types;
                    super._validate(v, E, k, ( (H, G) => {
                        var W;
                        if (!this._typeCheck(G))
                            return void R(H, G);
                        let Z = [];
                        for (let[k,R] of U.entries()) {
                            var Y;
                            Z[k] = R.asNestedTest({
                                "options": E,
                                "index": k,
                                "parent": G,
                                "parentPath": E.path,
                                "originalParent": null != (Y = E.originalValue) ? Y : v
                            })
                        }
                        this.runTests({
                            "value": G,
                            "tests": Z,
                            "originalValue": null != (W = E.originalValue) ? W : v,
                            "options": E
                        }, k, (v => R(v.concat(H), G)))
                    }
                    ))
                }
                "describe"(v) {
                    const E = (v ? this.resolve(v) : this).clone()
                      , k = super.describe(v);
                    return k.innerType = E.spec.types.map(( (E, k) => {
                        var R;
                        let U = v;
                        return null != (R = U) && R.value && (U = Object.assign({}, U, {
                            "parent": U.value,
                            "value": U.value[k]
                        })),
                        E.describe(U)
                    }
                    )),
                    k
                }
            }
            function create(v) {
                return new Lazy(v)
            }
            create$1.prototype = TupleSchema.prototype;
            class Lazy {
                "constructor"(v) {
                    this.type = "lazy",
                    this.__isYupSchema__ = !0,
                    this.spec = void 0,
                    this._resolve = (v, E={}) => {
                        let k = this.builder(v, E);
                        if (!isSchema(k))
                            throw new TypeError("lazy() functions must return a valid schema");
                        return this.spec.optional && (k = k.optional()),
                        k.resolve(E)
                    }
                    ,
                    this.builder = v,
                    this.spec = {
                        "meta": void 0,
                        "optional": !1
                    }
                }
                "clone"(v) {
                    const E = new Lazy(this.builder);
                    return E.spec = Object.assign({}, this.spec, v),
                    E
                }
                "optionality"(v) {
                    return this.clone({
                        "optional": v
                    })
                }
                "optional"() {
                    return this.optionality(!0)
                }
                "resolve"(v) {
                    return this._resolve(v.value, v)
                }
                "cast"(v, E) {
                    return this._resolve(v, E).cast(v, E)
                }
                "asNestedTest"(v) {
                    let {"key": E, "index": k, "parent": R, "options": U} = v
                      , H = R[null != k ? k : E];
                    return this._resolve(H, Object.assign({}, U, {
                        "value": H,
                        "parent": R
                    })).asNestedTest(v)
                }
                "validate"(v, E) {
                    return this._resolve(v, E).validate(v, E)
                }
                "validateSync"(v, E) {
                    return this._resolve(v, E).validateSync(v, E)
                }
                "validateAt"(v, E, k) {
                    return this._resolve(E, k).validateAt(v, E, k)
                }
                "validateSyncAt"(v, E, k) {
                    return this._resolve(E, k).validateSyncAt(v, E, k)
                }
                "isValid"(v, E) {
                    return this._resolve(v, E).isValid(v, E)
                }
                "isValidSync"(v, E) {
                    return this._resolve(v, E).isValidSync(v, E)
                }
                "describe"(v) {
                    return v ? this.resolve(v).describe(v) : {
                        "type": "lazy",
                        "meta": this.spec.meta,
                        "label": void 0
                    }
                }
                "meta"(...v) {
                    if (0 === v.length)
                        return this.spec.meta;
                    let E = this.clone();
                    return E.spec.meta = Object.assign(E.spec.meta || {}, v[0]),
                    E
                }
            }
            function setLocale(v) {
                Object.keys(v).forEach((E => {
                    Object.keys(v[E]).forEach((k => {
                        ue[E][k] = v[E][k]
                    }
                    ))
                }
                ))
            }
            function addMethod(v, E, k) {
                if (!v || !isSchema(v.prototype))
                    throw new TypeError("You must provide a yup schema constructor function");
                if ("string" != typeof E)
                    throw new TypeError("A Method name must be provided");
                if ("function" != typeof k)
                    throw new TypeError("Method function must be provided");
                v.prototype[E] = k
            }
        },
        "8111": function(v) {
            "use strict";
            v.exports = "data:application/octet-stream;base64,AAEAAAALAIAAAwAwR1NVQrD+s+0AAAE4AAAAQk9TLzJAKEx+AAABfAAAAFZjbWFw65cFHQAAAhwAAAJQZ2x5ZvCRR/EAAASUAAAKtGhlYWQMPROtAAAA4AAAADZoaGVhCCwD+gAAALwAAAAkaG10eEJo//8AAAHUAAAASGxvY2EYqhW4AAAEbAAAACZtYXhwASEAVQAAARgAAAAgbmFtZeNcHtgAAA9IAAAB5nBvc3T6bLhLAAARMAAAAOYAAQAAA+gAAABaA+j/////A+kAAQAAAAAAAAAAAAAAAAAAABIAAQAAAAEAACbZbxtfDzz1AAsD6AAAAADUm2dvAAAAANSbZ2///wAAA+kD6gAAAAgAAgAAAAAAAAABAAAAEgBJAAUAAAAAAAIAAAAKAAoAAAD/AAAAAAAAAAEAAAAKAB4ALAABREZMVAAIAAQAAAAAAAAAAQAAAAFsaWdhAAgAAAABAAAAAQAEAAQAAAABAAgAAQAGAAAAAQAAAAAAAQOwAZAABQAIAnoCvAAAAIwCegK8AAAB4AAxAQIAAAIABQMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUGZFZABA6gHqEQPoAAAAWgPqAAAAAAABAAAAAAAAAAAAAAPoAAAD6AAAA+gAAAPoAAAD6AAAA+gAAAPoAAAD6AAAA+gAAAPoAAAD6AAAA+gAAAPoAAAD6AAAA+j//wPoAAAD6AAAAAAABQAAAAMAAAAsAAAABAAAAXQAAQAAAAAAbgADAAEAAAAsAAMACgAAAXQABABCAAAABAAEAAEAAOoR//8AAOoB//8AAAABAAQAAAABAAIAAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAAAEGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAANwAAAAAAAAAEQAA6gEAAOoBAAAAAQAA6gIAAOoCAAAAAgAA6gMAAOoDAAAAAwAA6gQAAOoEAAAABAAA6gUAAOoFAAAABQAA6gYAAOoGAAAABgAA6gcAAOoHAAAABwAA6ggAAOoIAAAACAAA6gkAAOoJAAAACQAA6goAAOoKAAAACgAA6gsAAOoLAAAACwAA6gwAAOoMAAAADAAA6g0AAOoNAAAADQAA6g4AAOoOAAAADgAA6g8AAOoPAAAADwAA6hAAAOoQAAAAEAAA6hEAAOoRAAAAEQAAAAAARgCMANIBJAF4AcQCMgJgAqgC/ANIA6YD/gROBKAE9AVaAAAAAgAAAAADrwOtABQAKQAAASIHBgcGFBcWFxYyNzY3NjQnJicmAyInJicmNDc2NzYyFxYXFhQHBgcGAfV4Z2Q7PDw7ZGfwZmQ7PDw7ZGZ4bl5bNjc3Nlte215bNjc3NlteA608O2Rn8GdjOzw8O2Nn8GdkOzz8rzc1W17bXlw1Nzc1XF7bXls1NwAAAAACAAAAAAOzA7MAFwAtAAABIgcGBwYVFBcWFxYzMjc2NzY1NCcmJyYTBwYiLwEmNjsBETQ2OwEyFhURMzIWAe52Z2Q7PT07ZGd2fGpmOz4+O2ZpIXYOKA52Dg0XXQsHJgcLXRcNA7M+O2ZqfHZnZDs9PTtkZ3Z9aWY7Pv3wmhISmhIaARcICwsI/ukaAAMAAAAAA+UD5QAXACMALAAAASIHBgcGFRQXFhcWMzI3Njc2NTQnJicmAxQrASI1AzQ7ATIHJyImNDYyFhQGAe6Ecm9BRERBb3KEiXZxQkREQnF1aQIxAwgCQgMBIxIZGSQZGQPkREJxdomEcm9BRERBb3KEinVxQkT9HQICAWICAjEZIxkZIxkAAAAAAgAAAAADsQPkABkALgAAAQYHBgc2BREUFxYXFhc2NzY3NjURJBcmJyYTAQYvASY/ATYyHwEWNjclNjIfARYB9VVVQk+v/tFHPmxebGxdbT1I/tGvT0JVo/7VBASKAwMSAQUBcQEFAgESAgUBEQQD4xMYEhk3YP6sjnVlSD8cHD9IZXWOAVRgNxkSGP62/tkDA48EBBkCAVYCAQHlAQIQBAAAAAADAAAAAAOxA+QAGwAqADMAAAEGBwYHBgcGNxEUFxYXFhc2NzY3NjURJBcmJyYHMzIWFQMUBisBIicDNDYTIiY0NjIWFAYB9UFBODssO38gRz5sXmxsXW09SP7YqFBBVW80BAYMAwImBQELBh4PFhYeFRUD5A8SDhIOEikK/q2PdWRJPh0dPklkdY8BU141GRIY/AYE/sYCAwUBOgQG/kAVHxUVHxUAAAACAAAAAAPkA+QAFwAtAAABIgcGBwYVFBcWFxYzMjc2NzY1NCcmJyYTAQYiLwEmPwE2Mh8BFjI3ATYyHwEWAe6Ecm9BQ0NCbnODiXVxQkREQnF1kf6gAQUBowMDFgEFAYUCBQEBQwIFARUEA+NEQnF1iYNzbkJDQ0FvcoSJdXFCRP6j/qUBAagEBR4CAWYBAQENAgIVBAAAAAQAAAAAA68DrQAUACkAPwBDAAABIgcGBwYUFxYXFjI3Njc2NCcmJyYDIicmJyY0NzY3NjIXFhcWFAcGBwYTBQ4BLwEmBg8BBhYfARYyNwE+ASYiFzAfAQH1eGdkOzw8O2Rn8GZkOzw8O2RmeG5eWzY3NzZbXtteWzY3NzZbXmn+9gYSBmAGDwUDBQEGfQUQBgElBQELEBUBAQOtPDtkZ/BnYzs8PDtjZ/BnZDs8/K83NVte215cNTc3NVxe215bNTcCJt0FAQVJBQIGBAcRBoAGBQEhBQ8LBAEBAAABAAAAAAO7AzoAFwAAEy4BPwE+AR8BFjY3ATYWFycWFAcBBiInPQoGBwUHGgzLDCELAh0LHwsNCgr9uQoeCgGzCyEOCw0HCZMJAQoBvgkCCg0LHQv9sQsKAAAAAAIAAAAAA+UD5gAXACwAAAEiBwYHBhUUFxYXFjMyNzY3NjU0JyYnJhMHBi8BJicmNRM0NjsBMhYVExceAQHvhHJvQUNDQm5zg4l1cUJEREJxdVcQAwT6AwIEEAMCKwIDDsUCAQPlREJxdYmDc25CQ0NBb3KEiXVxQkT9VhwEAncCAgMGAXoCAwMC/q2FAgQAAAQAAAAAA68DrQADABgALQAzAAABMB8BAyIHBgcGFBcWFxYyNzY3NjQnJicmAyInJicmNDc2NzYyFxYXFhQHBgcGAyMVMzUjAuUBAfJ4Z2Q7PDw7ZGfwZmQ7PDw7ZGZ4bl5bNjc3Nlte215bNjc3NltemyT92QKDAQEBLDw7ZGfwZ2M7PDw7Y2fwZ2Q7PPyvNzVbXtteXDU3NzVcXtteWzU3AjH9JAAAAAMAAAAAA+QD5AAXACcAMAAAASIHBgcGFRQXFhcWMzI3Njc2NTQnJicmAzMyFhUDFAYrASImNQM0NhMiJjQ2MhYUBgHuhHJvQUNDQm5zg4l1cUJEREJxdZ42BAYMAwInAwMMBh8PFhYeFhYD40RCcXWJg3NuQkNDQW9yhIl1cUJE/vYGBf7AAgMDAgFABQb+NhYfFhYfFgAABAAAAAADwAPAAAgAEgAoAD0AAAEyNjQmIgYUFhcjFTMRIxUzNSMDIgcGBwYVFBYXFjMyNzY3NjU0Jy4BAyInJicmNDc2NzYyFxYXFhQHBgcGAfQYISEwISFRjzk5yTorhG5rPT99am+DdmhlPD4+PMyFbV5bNTc3NVte2l5bNTc3NVteAqAiLyIiLyI5Hf7EHBwCsT89a26Ed8w8Pj48ZWh2g29qffyjNzVbXtpeWzU3NzVbXtpeWzU3AAADAAAAAAOoA6gACwAgADUAAAEHJwcXBxc3FzcnNwMiBwYHBhQXFhcWMjc2NzY0JyYnJgMiJyYnJjQ3Njc2MhcWFxYUBwYHBgKOmpocmpocmpocmpq2dmZiOjs7OmJm7GZiOjs7OmJmdmtdWTQ2NjRZXdZdWTQ2NjRZXQKqmpocmpocmpocmpoBGTs6YmbsZmI6Ozs6YmbsZmI6O/zCNjRZXdZdWTQ2NjRZXdZdWTQ2AAMAAAAAA+kD6gAaAC8AMAAAAQYHBiMiJyYnJjQ3Njc2MhcWFxYVFAcGBwEHATI3Njc2NCcmJyYiBwYHBhQXFhcWMwKONUBCR21dWjU3NzVaXdpdWzU2GBcrASM5/eBXS0grKysrSEuuSkkqLCwqSUpXASMrFxg2NVtd2l1aNTc3NVpdbUdCQDX+3jkBGSsrSEuuSkkqLCwqSUquS0grKwAC//8AAAPoA+gAFAAwAAABIgcGBwYQFxYXFiA3Njc2ECcmJyYTFg4BIi8BBwYuATQ/AScmPgEWHwE3Nh4BBg8BAfSIdHFDRERDcXQBEHRxQ0REQ3F0SQoBFBsKoqgKGxMKqKIKARQbCqKoChsUAQqoA+hEQ3F0/vB0cUNERENxdAEQdHFDRP1jChsTCqiiCgEUGwqiqAobFAEKqKIKARQbCqIAAAIAAAAAA+QD5AAXADQAAAEiBwYHBhUUFxYXFjMyNzY3NjU0JyYnJhMUBiMFFxYUDwEGLwEuAT8BNh8BFhQPAQUyFh0BAe6Ecm9BQ0NCbnODiXVxQkREQnF1fwQC/pGDAQEVAwTsAgEC7AQEFAIBhAFwAgMD40RCcXWJg3NuQkNDQW9yhIl1cUJE/fYCAwuVAgQCFAQE0AIFAtEEBBQCBQGVCwMDJwAAAAUAAAAAA9QD0wAjACcANwBHAEgAAAERFAYjISImNREjIiY9ATQ2MyE1NDYzITIWHQEhMhYdARQGIyERIREHIgYVERQWOwEyNjURNCYjISIGFREUFjsBMjY1ETQmKwEDeyYb/XYbJkMJDQ0JAQYZEgEvExkBBgkNDQn9CQJc0QkNDQktCQ0NCf7sCQ0NCS0JDQ0JLQMi/TQbJiYbAswMCiwJDS4SGRkSLg0JLAoM/UwCtGsNCf5NCQ0NCQGzCQ0NCf5NCQ0NCQGzCQ0AAAAAEADGAAEAAAAAAAEABAAAAAEAAAAAAAIABwAEAAEAAAAAAAMABAALAAEAAAAAAAQABAAPAAEAAAAAAAUACwATAAEAAAAAAAYABAAeAAEAAAAAAAoAKwAiAAEAAAAAAAsAEwBNAAMAAQQJAAEACABgAAMAAQQJAAIADgBoAAMAAQQJAAMACAB2AAMAAQQJAAQACAB+AAMAAQQJAAUAFgCGAAMAAQQJAAYACACcAAMAAQQJAAoAVgCkAAMAAQQJAAsAJgD6d2V1aVJlZ3VsYXJ3ZXVpd2V1aVZlcnNpb24gMS4wd2V1aUdlbmVyYXRlZCBieSBzdmcydHRmIGZyb20gRm9udGVsbG8gcHJvamVjdC5odHRwOi8vZm9udGVsbG8uY29tAHcAZQB1AGkAUgBlAGcAdQBsAGEAcgB3AGUAdQBpAHcAZQB1AGkAVgBlAHIAcwBpAG8AbgAgADEALgAwAHcAZQB1AGkARwBlAG4AZQByAGEAdABlAGQAIABiAHkAIABzAHYAZwAyAHQAdABmACAAZgByAG8AbQAgAEYAbwBuAHQAZQBsAGwAbwAgAHAAcgBvAGoAZQBjAHQALgBoAHQAdABwADoALwAvAGYAbwBuAHQAZQBsAGwAbwAuAGMAbwBtAAAAAgAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASAQIBAwEEAQUBBgEHAQgBCQEKAQsBDAENAQ4BDwEQAREBEgETAAZjaXJjbGUIZG93bmxvYWQEaW5mbwxzYWZlX3N1Y2Nlc3MJc2FmZV93YXJuB3N1Y2Nlc3MOc3VjY2Vzcy1jaXJjbGURc3VjY2Vzcy1uby1jaXJjbGUHd2FpdGluZw53YWl0aW5nLWNpcmNsZQR3YXJuC2luZm8tY2lyY2xlBmNhbmNlbAZzZWFyY2gFY2xlYXIEYmFjawZkZWxldGUAAAAA"
        },
        "4285": function(v, E, k) {
            "use strict";
            v.exports = k(4324)
        },
        "4324": function(v) {
            "use strict";
            var E;
            !function(v) {
                v[v.HIGH_SURROGATE_START = 55296] = "HIGH_SURROGATE_START",
                v[v.HIGH_SURROGATE_END = 56319] = "HIGH_SURROGATE_END",
                v[v.LOW_SURROGATE_START = 56320] = "LOW_SURROGATE_START",
                v[v.REGIONAL_INDICATOR_START = 127462] = "REGIONAL_INDICATOR_START",
                v[v.REGIONAL_INDICATOR_END = 127487] = "REGIONAL_INDICATOR_END",
                v[v.FITZPATRICK_MODIFIER_START = 127995] = "FITZPATRICK_MODIFIER_START",
                v[v.FITZPATRICK_MODIFIER_END = 127999] = "FITZPATRICK_MODIFIER_END",
                v[v.VARIATION_MODIFIER_START = 65024] = "VARIATION_MODIFIER_START",
                v[v.VARIATION_MODIFIER_END = 65039] = "VARIATION_MODIFIER_END",
                v[v.DIACRITICAL_MARKS_START = 8400] = "DIACRITICAL_MARKS_START",
                v[v.DIACRITICAL_MARKS_END = 8447] = "DIACRITICAL_MARKS_END",
                v[v.SUBDIVISION_INDICATOR_START = 127988] = "SUBDIVISION_INDICATOR_START",
                v[v.TAGS_START = 917504] = "TAGS_START",
                v[v.TAGS_END = 917631] = "TAGS_END",
                v[v.ZWJ = 8205] = "ZWJ"
            }(E || (E = {}));
            const k = Object.freeze([776, 2359, 2367, 2984, 3007, 3021, 3633, 3635, 3648, 3657, 4352, 4449, 4520]);
            var R;
            function runes(v) {
                if ("string" != typeof v)
                    throw new TypeError("string cannot be undefined or null");
                const E = [];
                let k = 0
                  , R = 0;
                for (; k < v.length; )
                    R += nextUnits(k + R, v),
                    isGrapheme(v[k + R]) && R++,
                    isVariationSelector(v[k + R]) && R++,
                    isDiacriticalMark(v[k + R]) && R++,
                    isZeroWidthJoiner(v[k + R]) ? R++ : (E.push(v.substring(k, k + R)),
                    k += R,
                    R = 0);
                return E
            }
            function nextUnits(v, E) {
                const k = E[v];
                if (!function isFirstOfSurrogatePair(v) {
                    return v && betweenInclusive(v[0].charCodeAt(0), 55296, 56319)
                }(k) || v === E.length - 1)
                    return 1;
                const R = k + E[v + 1];
                let U = E.substring(v + 2, v + 5);
                return isRegionalIndicator(R) && isRegionalIndicator(U) ? 4 : function isSubdivisionFlag(v) {
                    return betweenInclusive(codePointFromSurrogatePair(v), 127988, 127988)
                }(R) && function isSupplementarySpecialpurposePlane(v) {
                    const E = v.codePointAt(0);
                    return "string" == typeof v && "number" == typeof E && betweenInclusive(E, 917504, 917631)
                }(U) ? E.slice(v).indexOf(String.fromCodePoint(917631)) + 2 : function isFitzpatrickModifier(v) {
                    return betweenInclusive(codePointFromSurrogatePair(v), 127995, 127999)
                }(U) ? 4 : 2
            }
            function isRegionalIndicator(v) {
                return betweenInclusive(codePointFromSurrogatePair(v), 127462, 127487)
            }
            function isVariationSelector(v) {
                return "string" == typeof v && betweenInclusive(v.charCodeAt(0), 65024, 65039)
            }
            function isDiacriticalMark(v) {
                return "string" == typeof v && betweenInclusive(v.charCodeAt(0), 8400, 8447)
            }
            function isGrapheme(v) {
                return "string" == typeof v && k.includes(v.charCodeAt(0))
            }
            function isZeroWidthJoiner(v) {
                return "string" == typeof v && 8205 === v.charCodeAt(0)
            }
            function codePointFromSurrogatePair(v) {
                return (v.charCodeAt(0) - 55296 << 10) + (v.charCodeAt(1) - 56320) + 65536
            }
            function betweenInclusive(v, E, k) {
                return v >= E && v <= k
            }
            function substring(v, E, k) {
                const R = runes(v);
                if (void 0 === E)
                    return v;
                if (E >= R.length)
                    return "";
                const U = R.length - E;
                let H = E + (void 0 === k ? U : k);
                return H > E + U && (H = void 0),
                R.slice(E, H).join("")
            }
            !function(v) {
                v[v.unit_1 = 1] = "unit_1",
                v[v.unit_2 = 2] = "unit_2",
                v[v.unit_4 = 4] = "unit_4"
            }(R || (R = {})),
            Object.defineProperty(runes, "runes", {
                "value": runes
            }),
            Object.defineProperty(runes, "default", {
                "value": runes
            }),
            Object.defineProperty(runes, "__esModule", {
                "value": !0
            }),
            Object.defineProperty(runes, "substr", {
                "value": substring
            }),
            Object.defineProperty(runes, "substring", {
                "value": substring
            }),
            Object.defineProperty(runes, "EnumRunesCode", {
                "value": E
            }),
            Object.defineProperty(runes, "EnumCodeUnits", {
                "value": R
            }),
            Object.defineProperty(runes, "GRAPHEMES", {
                "value": k
            }),
            v.exports = runes
        },
        "907": function(v, E, k) {
            "use strict";
            function _arrayLikeToArray(v, E) {
                (null == E || E > v.length) && (E = v.length);
                for (var k = 0, R = Array(E); k < E; k++)
                    R[k] = v[k];
                return R
            }
            k.d(E, {
                "Z": function() {
                    return _arrayLikeToArray
                }
            })
        },
        "5861": function(v, E, k) {
            "use strict";
            function asyncGeneratorStep(v, E, k, R, U, H, G) {
                try {
                    var W = v[H](G)
                      , Z = W.value
                } catch (v) {
                    return void k(v)
                }
                W.done ? E(Z) : Promise.resolve(Z).then(R, U)
            }
            function _asyncToGenerator(v) {
                return function() {
                    var E = this
                      , k = arguments;
                    return new Promise((function(R, U) {
                        var H = v.apply(E, k);
                        function _next(v) {
                            asyncGeneratorStep(H, R, U, _next, _throw, "next", v)
                        }
                        function _throw(v) {
                            asyncGeneratorStep(H, R, U, _next, _throw, "throw", v)
                        }
                        _next(void 0)
                    }
                    ))
                }
            }
            k.d(E, {
                "Z": function() {
                    return _asyncToGenerator
                }
            })
        },
        "8361": function(v, E, k) {
            "use strict";
            k.d(E, {
                "Z": function() {
                    return _callSuper
                }
            });
            var R = k(1120);
            function _isNativeReflectConstruct() {
                try {
                    var v = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}
                    )))
                } catch (v) {}
                return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
                    return !!v
                }
                )()
            }
            var U = k(1002);
            function _possibleConstructorReturn(v, E) {
                if (E && ("object" == (0,
                U.Z)(E) || "function" == typeof E))
                    return E;
                if (void 0 !== E)
                    throw new TypeError("Derived constructors may only return object or undefined");
                return function _assertThisInitialized(v) {
                    if (void 0 === v)
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return v
                }(v)
            }
            function _callSuper(v, E, k) {
                return E = (0,
                R.Z)(E),
                _possibleConstructorReturn(v, _isNativeReflectConstruct() ? Reflect.construct(E, k || [], (0,
                R.Z)(v).constructor) : E.apply(v, k))
            }
        },
        "5671": function(v, E, k) {
            "use strict";
            function _classCallCheck(v, E) {
                if (!(v instanceof E))
                    throw new TypeError("Cannot call a class as a function")
            }
            k.d(E, {
                "Z": function() {
                    return _classCallCheck
                }
            })
        },
        "3144": function(v, E, k) {
            "use strict";
            k.d(E, {
                "Z": function() {
                    return _createClass
                }
            });
            var R = k(9142);
            function _defineProperties(v, E) {
                for (var k = 0; k < E.length; k++) {
                    var U = E[k];
                    U.enumerable = U.enumerable || !1,
                    U.configurable = !0,
                    "value"in U && (U.writable = !0),
                    Object.defineProperty(v, (0,
                    R.Z)(U.key), U)
                }
            }
            function _createClass(v, E, k) {
                return E && _defineProperties(v.prototype, E),
                k && _defineProperties(v, k),
                Object.defineProperty(v, "prototype", {
                    "writable": !1
                }),
                v
            }
        },
        "7762": function(v, E, k) {
            "use strict";
            k.d(E, {
                "Z": function() {
                    return _createForOfIteratorHelper
                }
            });
            var R = k(181);
            function _createForOfIteratorHelper(v, E) {
                var k = "undefined" != typeof Symbol && v[Symbol.iterator] || v["@@iterator"];
                if (!k) {
                    if (Array.isArray(v) || (k = (0,
                    R.Z)(v)) || E && v && "number" == typeof v.length) {
                        k && (v = k);
                        var U = 0
                          , H = function F() {};
                        return {
                            "s": H,
                            "n": function n() {
                                return U >= v.length ? {
                                    "done": !0
                                } : {
                                    "done": !1,
                                    "value": v[U++]
                                }
                            },
                            "e": function e(v) {
                                throw v
                            },
                            "f": H
                        }
                    }
                    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }
                var G, W = !0, Z = !1;
                return {
                    "s": function s() {
                        k = k.call(v)
                    },
                    "n": function n() {
                        var v = k.next();
                        return W = v.done,
                        v
                    },
                    "e": function e(v) {
                        Z = !0,
                        G = v
                    },
                    "f": function f() {
                        try {
                            W || null == k.return || k.return()
                        } finally {
                            if (Z)
                                throw G
                        }
                    }
                }
            }
        },
        "4942": function(v, E, k) {
            "use strict";
            k.d(E, {
                "Z": function() {
                    return _defineProperty
                }
            });
            var R = k(9142);
            function _defineProperty(v, E, k) {
                return (E = (0,
                R.Z)(E))in v ? Object.defineProperty(v, E, {
                    "value": k,
                    "enumerable": !0,
                    "configurable": !0,
                    "writable": !0
                }) : v[E] = k,
                v
            }
        },
        "1752": function(v, E, k) {
            "use strict";
            k.d(E, {
                "Z": function() {
                    return _get
                }
            });
            var R = k(1120);
            function _get() {
                return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(v, E, k) {
                    var U = function _superPropBase(v, E) {
                        for (; !{}.hasOwnProperty.call(v, E) && null !== (v = (0,
                        R.Z)(v)); )
                            ;
                        return v
                    }(v, E);
                    if (U) {
                        var H = Object.getOwnPropertyDescriptor(U, E);
                        return H.get ? H.get.call(arguments.length < 3 ? v : k) : H.value
                    }
                }
                ,
                _get.apply(null, arguments)
            }
        },
        "1120": function(v, E, k) {
            "use strict";
            function _getPrototypeOf(v) {
                return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(v) {
                    return v.__proto__ || Object.getPrototypeOf(v)
                }
                ,
                _getPrototypeOf(v)
            }
            k.d(E, {
                "Z": function() {
                    return _getPrototypeOf
                }
            })
        },
        "9340": function(v, E, k) {
            "use strict";
            function _setPrototypeOf(v, E) {
                return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(v, E) {
                    return v.__proto__ = E,
                    v
                }
                ,
                _setPrototypeOf(v, E)
            }
            function _inherits(v, E) {
                if ("function" != typeof E && null !== E)
                    throw new TypeError("Super expression must either be null or a function");
                v.prototype = Object.create(E && E.prototype, {
                    "constructor": {
                        "value": v,
                        "writable": !0,
                        "configurable": !0
                    }
                }),
                Object.defineProperty(v, "prototype", {
                    "writable": !1
                }),
                E && _setPrototypeOf(v, E)
            }
            k.d(E, {
                "Z": function() {
                    return _inherits
                }
            })
        },
        "1413": function(v, E, k) {
            "use strict";
            k.d(E, {
                "Z": function() {
                    return _objectSpread2
                }
            });
            var R = k(4942);
            function ownKeys(v, E) {
                var k = Object.keys(v);
                if (Object.getOwnPropertySymbols) {
                    var R = Object.getOwnPropertySymbols(v);
                    E && (R = R.filter((function(E) {
                        return Object.getOwnPropertyDescriptor(v, E).enumerable
                    }
                    ))),
                    k.push.apply(k, R)
                }
                return k
            }
            function _objectSpread2(v) {
                for (var E = 1; E < arguments.length; E++) {
                    var k = null != arguments[E] ? arguments[E] : {};
                    E % 2 ? ownKeys(Object(k), !0).forEach((function(E) {
                        (0,
                        R.Z)(v, E, k[E])
                    }
                    )) : Object.getOwnPropertyDescriptors ? Object.defineProperties(v, Object.getOwnPropertyDescriptors(k)) : ownKeys(Object(k)).forEach((function(E) {
                        Object.defineProperty(v, E, Object.getOwnPropertyDescriptor(k, E))
                    }
                    ))
                }
                return v
            }
        },
        "4165": function(v, E, k) {
            "use strict";
            k.d(E, {
                "Z": function() {
                    return _regeneratorRuntime
                }
            });
            var R = k(1002);
            function _regeneratorRuntime() {
                _regeneratorRuntime = function _regeneratorRuntime() {
                    return E
                }
                ;
                var v, E = {}, k = Object.prototype, U = k.hasOwnProperty, H = Object.defineProperty || function(v, E, k) {
                    v[E] = k.value
                }
                , G = "function" == typeof Symbol ? Symbol : {}, W = G.iterator || "@@iterator", Z = G.asyncIterator || "@@asyncIterator", Y = G.toStringTag || "@@toStringTag";
                function define(v, E, k) {
                    return Object.defineProperty(v, E, {
                        "value": k,
                        "enumerable": !0,
                        "configurable": !0,
                        "writable": !0
                    }),
                    v[E]
                }
                try {
                    define({}, "")
                } catch (v) {
                    define = function define(v, E, k) {
                        return v[E] = k
                    }
                }
                function wrap(v, E, k, R) {
                    var U = E && E.prototype instanceof Generator ? E : Generator
                      , G = Object.create(U.prototype)
                      , W = new Context(R || []);
                    return H(G, "_invoke", {
                        "value": makeInvokeMethod(v, k, W)
                    }),
                    G
                }
                function tryCatch(v, E, k) {
                    try {
                        return {
                            "type": "normal",
                            "arg": v.call(E, k)
                        }
                    } catch (v) {
                        return {
                            "type": "throw",
                            "arg": v
                        }
                    }
                }
                E.wrap = wrap;
                var J = "suspendedStart"
                  , K = "suspendedYield"
                  , X = "executing"
                  , Q = "completed"
                  , ee = {};
                function Generator() {}
                function GeneratorFunction() {}
                function GeneratorFunctionPrototype() {}
                var te = {};
                define(te, W, (function() {
                    return this
                }
                ));
                var ne = Object.getPrototypeOf
                  , re = ne && ne(ne(values([])));
                re && re !== k && U.call(re, W) && (te = re);
                var oe = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(te);
                function defineIteratorMethods(v) {
                    ["next", "throw", "return"].forEach((function(E) {
                        define(v, E, (function(v) {
                            return this._invoke(E, v)
                        }
                        ))
                    }
                    ))
                }
                function AsyncIterator(v, E) {
                    function invoke(k, H, G, W) {
                        var Z = tryCatch(v[k], v, H);
                        if ("throw" !== Z.type) {
                            var Y = Z.arg
                              , J = Y.value;
                            return J && "object" == (0,
                            R.Z)(J) && U.call(J, "__await") ? E.resolve(J.__await).then((function(v) {
                                invoke("next", v, G, W)
                            }
                            ), (function(v) {
                                invoke("throw", v, G, W)
                            }
                            )) : E.resolve(J).then((function(v) {
                                Y.value = v,
                                G(Y)
                            }
                            ), (function(v) {
                                return invoke("throw", v, G, W)
                            }
                            ))
                        }
                        W(Z.arg)
                    }
                    var k;
                    H(this, "_invoke", {
                        "value": function value(v, R) {
                            function callInvokeWithMethodAndArg() {
                                return new E((function(E, k) {
                                    invoke(v, R, E, k)
                                }
                                ))
                            }
                            return k = k ? k.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg()
                        }
                    })
                }
                function makeInvokeMethod(E, k, R) {
                    var U = J;
                    return function(H, G) {
                        if (U === X)
                            throw Error("Generator is already running");
                        if (U === Q) {
                            if ("throw" === H)
                                throw G;
                            return {
                                "value": v,
                                "done": !0
                            }
                        }
                        for (R.method = H,
                        R.arg = G; ; ) {
                            var W = R.delegate;
                            if (W) {
                                var Z = maybeInvokeDelegate(W, R);
                                if (Z) {
                                    if (Z === ee)
                                        continue;
                                    return Z
                                }
                            }
                            if ("next" === R.method)
                                R.sent = R._sent = R.arg;
                            else if ("throw" === R.method) {
                                if (U === J)
                                    throw U = Q,
                                    R.arg;
                                R.dispatchException(R.arg)
                            } else
                                "return" === R.method && R.abrupt("return", R.arg);
                            U = X;
                            var Y = tryCatch(E, k, R);
                            if ("normal" === Y.type) {
                                if (U = R.done ? Q : K,
                                Y.arg === ee)
                                    continue;
                                return {
                                    "value": Y.arg,
                                    "done": R.done
                                }
                            }
                            "throw" === Y.type && (U = Q,
                            R.method = "throw",
                            R.arg = Y.arg)
                        }
                    }
                }
                function maybeInvokeDelegate(E, k) {
                    var R = k.method
                      , U = E.iterator[R];
                    if (U === v)
                        return k.delegate = null,
                        "throw" === R && E.iterator.return && (k.method = "return",
                        k.arg = v,
                        maybeInvokeDelegate(E, k),
                        "throw" === k.method) || "return" !== R && (k.method = "throw",
                        k.arg = new TypeError("The iterator does not provide a '" + R + "' method")),
                        ee;
                    var H = tryCatch(U, E.iterator, k.arg);
                    if ("throw" === H.type)
                        return k.method = "throw",
                        k.arg = H.arg,
                        k.delegate = null,
                        ee;
                    var G = H.arg;
                    return G ? G.done ? (k[E.resultName] = G.value,
                    k.next = E.nextLoc,
                    "return" !== k.method && (k.method = "next",
                    k.arg = v),
                    k.delegate = null,
                    ee) : G : (k.method = "throw",
                    k.arg = new TypeError("iterator result is not an object"),
                    k.delegate = null,
                    ee)
                }
                function pushTryEntry(v) {
                    var E = {
                        "tryLoc": v[0]
                    };
                    1 in v && (E.catchLoc = v[1]),
                    2 in v && (E.finallyLoc = v[2],
                    E.afterLoc = v[3]),
                    this.tryEntries.push(E)
                }
                function resetTryEntry(v) {
                    var E = v.completion || {};
                    E.type = "normal",
                    delete E.arg,
                    v.completion = E
                }
                function Context(v) {
                    this.tryEntries = [{
                        "tryLoc": "root"
                    }],
                    v.forEach(pushTryEntry, this),
                    this.reset(!0)
                }
                function values(E) {
                    if (E || "" === E) {
                        var k = E[W];
                        if (k)
                            return k.call(E);
                        if ("function" == typeof E.next)
                            return E;
                        if (!isNaN(E.length)) {
                            var H = -1
                              , G = function next() {
                                for (; ++H < E.length; )
                                    if (U.call(E, H))
                                        return next.value = E[H],
                                        next.done = !1,
                                        next;
                                return next.value = v,
                                next.done = !0,
                                next
                            };
                            return G.next = G
                        }
                    }
                    throw new TypeError((0,
                    R.Z)(E) + " is not iterable")
                }
                return GeneratorFunction.prototype = GeneratorFunctionPrototype,
                H(oe, "constructor", {
                    "value": GeneratorFunctionPrototype,
                    "configurable": !0
                }),
                H(GeneratorFunctionPrototype, "constructor", {
                    "value": GeneratorFunction,
                    "configurable": !0
                }),
                GeneratorFunction.displayName = define(GeneratorFunctionPrototype, Y, "GeneratorFunction"),
                E.isGeneratorFunction = function(v) {
                    var E = "function" == typeof v && v.constructor;
                    return !!E && (E === GeneratorFunction || "GeneratorFunction" === (E.displayName || E.name))
                }
                ,
                E.mark = function(v) {
                    return Object.setPrototypeOf ? Object.setPrototypeOf(v, GeneratorFunctionPrototype) : (v.__proto__ = GeneratorFunctionPrototype,
                    define(v, Y, "GeneratorFunction")),
                    v.prototype = Object.create(oe),
                    v
                }
                ,
                E.awrap = function(v) {
                    return {
                        "__await": v
                    }
                }
                ,
                defineIteratorMethods(AsyncIterator.prototype),
                define(AsyncIterator.prototype, Z, (function() {
                    return this
                }
                )),
                E.AsyncIterator = AsyncIterator,
                E.async = function(v, k, R, U, H) {
                    void 0 === H && (H = Promise);
                    var G = new AsyncIterator(wrap(v, k, R, U),H);
                    return E.isGeneratorFunction(k) ? G : G.next().then((function(v) {
                        return v.done ? v.value : G.next()
                    }
                    ))
                }
                ,
                defineIteratorMethods(oe),
                define(oe, Y, "Generator"),
                define(oe, W, (function() {
                    return this
                }
                )),
                define(oe, "toString", (function() {
                    return "[object Generator]"
                }
                )),
                E.keys = function(v) {
                    var E = Object(v)
                      , k = [];
                    for (var R in E)
                        k.push(R);
                    return k.reverse(),
                    function next() {
                        for (; k.length; ) {
                            var v = k.pop();
                            if (v in E)
                                return next.value = v,
                                next.done = !1,
                                next
                        }
                        return next.done = !0,
                        next
                    }
                }
                ,
                E.values = values,
                Context.prototype = {
                    "constructor": Context,
                    "reset": function reset(E) {
                        if (this.prev = 0,
                        this.next = 0,
                        this.sent = this._sent = v,
                        this.done = !1,
                        this.delegate = null,
                        this.method = "next",
                        this.arg = v,
                        this.tryEntries.forEach(resetTryEntry),
                        !E)
                            for (var k in this)
                                "t" === k.charAt(0) && U.call(this, k) && !isNaN(+k.slice(1)) && (this[k] = v)
                    },
                    "stop": function stop() {
                        this.done = !0;
                        var v = this.tryEntries[0].completion;
                        if ("throw" === v.type)
                            throw v.arg;
                        return this.rval
                    },
                    "dispatchException": function dispatchException(E) {
                        if (this.done)
                            throw E;
                        var k = this;
                        function handle(R, U) {
                            return G.type = "throw",
                            G.arg = E,
                            k.next = R,
                            U && (k.method = "next",
                            k.arg = v),
                            !!U
                        }
                        for (var R = this.tryEntries.length - 1; R >= 0; --R) {
                            var H = this.tryEntries[R]
                              , G = H.completion;
                            if ("root" === H.tryLoc)
                                return handle("end");
                            if (H.tryLoc <= this.prev) {
                                var W = U.call(H, "catchLoc")
                                  , Z = U.call(H, "finallyLoc");
                                if (W && Z) {
                                    if (this.prev < H.catchLoc)
                                        return handle(H.catchLoc, !0);
                                    if (this.prev < H.finallyLoc)
                                        return handle(H.finallyLoc)
                                } else if (W) {
                                    if (this.prev < H.catchLoc)
                                        return handle(H.catchLoc, !0)
                                } else {
                                    if (!Z)
                                        throw Error("try statement without catch or finally");
                                    if (this.prev < H.finallyLoc)
                                        return handle(H.finallyLoc)
                                }
                            }
                        }
                    },
                    "abrupt": function abrupt(v, E) {
                        for (var k = this.tryEntries.length - 1; k >= 0; --k) {
                            var R = this.tryEntries[k];
                            if (R.tryLoc <= this.prev && U.call(R, "finallyLoc") && this.prev < R.finallyLoc) {
                                var H = R;
                                break
                            }
                        }
                        H && ("break" === v || "continue" === v) && H.tryLoc <= E && E <= H.finallyLoc && (H = null);
                        var G = H ? H.completion : {};
                        return G.type = v,
                        G.arg = E,
                        H ? (this.method = "next",
                        this.next = H.finallyLoc,
                        ee) : this.complete(G)
                    },
                    "complete": function complete(v, E) {
                        if ("throw" === v.type)
                            throw v.arg;
                        return "break" === v.type || "continue" === v.type ? this.next = v.arg : "return" === v.type ? (this.rval = this.arg = v.arg,
                        this.method = "return",
                        this.next = "end") : "normal" === v.type && E && (this.next = E),
                        ee
                    },
                    "finish": function finish(v) {
                        for (var E = this.tryEntries.length - 1; E >= 0; --E) {
                            var k = this.tryEntries[E];
                            if (k.finallyLoc === v)
                                return this.complete(k.completion, k.afterLoc),
                                resetTryEntry(k),
                                ee
                        }
                    },
                    "catch": function _catch(v) {
                        for (var E = this.tryEntries.length - 1; E >= 0; --E) {
                            var k = this.tryEntries[E];
                            if (k.tryLoc === v) {
                                var R = k.completion;
                                if ("throw" === R.type) {
                                    var U = R.arg;
                                    resetTryEntry(k)
                                }
                                return U
                            }
                        }
                        throw Error("illegal catch attempt")
                    },
                    "delegateYield": function delegateYield(E, k, R) {
                        return this.delegate = {
                            "iterator": values(E),
                            "resultName": k,
                            "nextLoc": R
                        },
                        "next" === this.method && (this.arg = v),
                        ee
                    }
                },
                E
            }
        },
        "885": function(v, E, k) {
            "use strict";
            k.d(E, {
                "Z": function() {
                    return _slicedToArray
                }
            });
            var R = k(181);
            function _slicedToArray(v, E) {
                return function _arrayWithHoles(v) {
                    if (Array.isArray(v))
                        return v
                }(v) || function _iterableToArrayLimit(v, E) {
                    var k = null == v ? null : "undefined" != typeof Symbol && v[Symbol.iterator] || v["@@iterator"];
                    if (null != k) {
                        var R, U, H, G, W = [], Z = !0, Y = !1;
                        try {
                            if (H = (k = k.call(v)).next,
                            0 === E) {
                                if (Object(k) !== k)
                                    return;
                                Z = !1
                            } else
                                for (; !(Z = (R = H.call(k)).done) && (W.push(R.value),
                                W.length !== E); Z = !0)
                                    ;
                        } catch (v) {
                            Y = !0,
                            U = v
                        } finally {
                            try {
                                if (!Z && null != k.return && (G = k.return(),
                                Object(G) !== G))
                                    return
                            } finally {
                                if (Y)
                                    throw U
                            }
                        }
                        return W
                    }
                }(v, E) || (0,
                R.Z)(v, E) || function _nonIterableRest() {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }()
            }
        },
        "2982": function(v, E, k) {
            "use strict";
            k.d(E, {
                "Z": function() {
                    return _toConsumableArray
                }
            });
            var R = k(907);
            var U = k(181);
            function _toConsumableArray(v) {
                return function _arrayWithoutHoles(v) {
                    if (Array.isArray(v))
                        return (0,
                        R.Z)(v)
                }(v) || function _iterableToArray(v) {
                    if ("undefined" != typeof Symbol && null != v[Symbol.iterator] || null != v["@@iterator"])
                        return Array.from(v)
                }(v) || (0,
                U.Z)(v) || function _nonIterableSpread() {
                    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }()
            }
        },
        "9142": function(v, E, k) {
            "use strict";
            k.d(E, {
                "Z": function() {
                    return toPropertyKey
                }
            });
            var R = k(1002);
            function toPropertyKey(v) {
                var E = function toPrimitive(v, E) {
                    if ("object" != (0,
                    R.Z)(v) || !v)
                        return v;
                    var k = v[Symbol.toPrimitive];
                    if (void 0 !== k) {
                        var U = k.call(v, E || "default");
                        if ("object" != (0,
                        R.Z)(U))
                            return U;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return ("string" === E ? String : Number)(v)
                }(v, "string");
                return "symbol" == (0,
                R.Z)(E) ? E : E + ""
            }
        },
        "1002": function(v, E, k) {
            "use strict";
            function _typeof(v) {
                return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(v) {
                    return typeof v
                }
                : function(v) {
                    return v && "function" == typeof Symbol && v.constructor === Symbol && v !== Symbol.prototype ? "symbol" : typeof v
                }
                ,
                _typeof(v)
            }
            k.d(E, {
                "Z": function() {
                    return _typeof
                }
            })
        },
        "181": function(v, E, k) {
            "use strict";
            k.d(E, {
                "Z": function() {
                    return _unsupportedIterableToArray
                }
            });
            var R = k(907);
            function _unsupportedIterableToArray(v, E) {
                if (v) {
                    if ("string" == typeof v)
                        return (0,
                        R.Z)(v, E);
                    var k = {}.toString.call(v).slice(8, -1);
                    return "Object" === k && v.constructor && (k = v.constructor.name),
                    "Map" === k || "Set" === k ? Array.from(v) : "Arguments" === k || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(k) ? (0,
                    R.Z)(v, E) : void 0
                }
            }
        },
        "238": function(v, E, k) {
            "use strict";
            k.d(E, {
                "Z": function() {
                    return ft
                }
            });
            var R = {};
            function bind(v, E) {
                return function wrap() {
                    return v.apply(E, arguments)
                }
            }
            k.r(R),
            k.d(R, {
                "hasBrowserEnv": function() {
                    return Oe
                },
                "hasStandardBrowserEnv": function() {
                    return Pe
                },
                "hasStandardBrowserWebWorkerEnv": function() {
                    return Me
                },
                "origin": function() {
                    return Ne
                }
            });
            const {"toString": U} = Object.prototype
              , {"getPrototypeOf": H} = Object
              , G = (W = Object.create(null),
            v => {
                const E = U.call(v);
                return W[E] || (W[E] = E.slice(8, -1).toLowerCase())
            }
            );
            var W;
            const kindOfTest = v => (v = v.toLowerCase(),
            E => G(E) === v)
              , typeOfTest = v => E => typeof E === v
              , {"isArray": Z} = Array
              , Y = typeOfTest("undefined");
            const J = kindOfTest("ArrayBuffer");
            const K = typeOfTest("string")
              , X = typeOfTest("function")
              , Q = typeOfTest("number")
              , isObject = v => null !== v && "object" == typeof v
              , isPlainObject = v => {
                if ("object" !== G(v))
                    return !1;
                const E = H(v);
                return !(null !== E && E !== Object.prototype && null !== Object.getPrototypeOf(E) || Symbol.toStringTag in v || Symbol.iterator in v)
            }
              , ee = kindOfTest("Date")
              , te = kindOfTest("File")
              , ne = kindOfTest("Blob")
              , re = kindOfTest("FileList")
              , oe = kindOfTest("URLSearchParams")
              , [ie,ae,se,ce] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
            function forEach(v, E, {"allOwnKeys": k=!1}={}) {
                if (null == v)
                    return;
                let R, U;
                if ("object" != typeof v && (v = [v]),
                Z(v))
                    for (R = 0,
                    U = v.length; R < U; R++)
                        E.call(null, v[R], R, v);
                else {
                    const U = k ? Object.getOwnPropertyNames(v) : Object.keys(v)
                      , H = U.length;
                    let G;
                    for (R = 0; R < H; R++)
                        G = U[R],
                        E.call(null, v[G], G, v)
                }
            }
            function findKey(v, E) {
                E = E.toLowerCase();
                const k = Object.keys(v);
                let R, U = k.length;
                for (; U-- > 0; )
                    if (R = k[U],
                    E === R.toLowerCase())
                        return R;
                return null
            }
            const le = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : global
              , isContextDefined = v => !Y(v) && v !== le;
            const ue = (de = "undefined" != typeof Uint8Array && H(Uint8Array),
            v => de && v instanceof de);
            var de;
            const pe = kindOfTest("HTMLFormElement")
              , fe = ( ({"hasOwnProperty": v}) => (E, k) => v.call(E, k))(Object.prototype)
              , he = kindOfTest("RegExp")
              , reduceDescriptors = (v, E) => {
                const k = Object.getOwnPropertyDescriptors(v)
                  , R = {};
                forEach(k, ( (k, U) => {
                    let H;
                    !1 !== (H = E(k, U, v)) && (R[U] = H || k)
                }
                )),
                Object.defineProperties(v, R)
            }
              , me = "abcdefghijklmnopqrstuvwxyz"
              , ge = "0123456789"
              , _e = {
                "DIGIT": ge,
                "ALPHA": me,
                "ALPHA_DIGIT": me + me.toUpperCase() + ge
            };
            const ve = kindOfTest("AsyncFunction");
            var ye = {
                "isArray": Z,
                "isArrayBuffer": J,
                "isBuffer": function isBuffer(v) {
                    return null !== v && !Y(v) && null !== v.constructor && !Y(v.constructor) && X(v.constructor.isBuffer) && v.constructor.isBuffer(v)
                },
                "isFormData": v => {
                    let E;
                    return v && ("function" == typeof FormData && v instanceof FormData || X(v.append) && ("formdata" === (E = G(v)) || "object" === E && X(v.toString) && "[object FormData]" === v.toString()))
                }
                ,
                "isArrayBufferView": function isArrayBufferView(v) {
                    let E;
                    return E = "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(v) : v && v.buffer && J(v.buffer),
                    E
                },
                "isString": K,
                "isNumber": Q,
                "isBoolean": v => !0 === v || !1 === v,
                "isObject": isObject,
                "isPlainObject": isPlainObject,
                "isReadableStream": ie,
                "isRequest": ae,
                "isResponse": se,
                "isHeaders": ce,
                "isUndefined": Y,
                "isDate": ee,
                "isFile": te,
                "isBlob": ne,
                "isRegExp": he,
                "isFunction": X,
                "isStream": v => isObject(v) && X(v.pipe),
                "isURLSearchParams": oe,
                "isTypedArray": ue,
                "isFileList": re,
                "forEach": forEach,
                "merge": function merge() {
                    const {"caseless": v} = isContextDefined(this) && this || {}
                      , E = {}
                      , assignValue = (k, R) => {
                        const U = v && findKey(E, R) || R;
                        isPlainObject(E[U]) && isPlainObject(k) ? E[U] = merge(E[U], k) : isPlainObject(k) ? E[U] = merge({}, k) : Z(k) ? E[U] = k.slice() : E[U] = k
                    }
                    ;
                    for (let v = 0, E = arguments.length; v < E; v++)
                        arguments[v] && forEach(arguments[v], assignValue);
                    return E
                },
                "extend": (v, E, k, {"allOwnKeys": R}={}) => (forEach(E, ( (E, R) => {
                    k && X(E) ? v[R] = bind(E, k) : v[R] = E
                }
                ), {
                    "allOwnKeys": R
                }),
                v),
                "trim": v => v.trim ? v.trim() : v.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""),
                "stripBOM": v => (65279 === v.charCodeAt(0) && (v = v.slice(1)),
                v),
                "inherits": (v, E, k, R) => {
                    v.prototype = Object.create(E.prototype, R),
                    v.prototype.constructor = v,
                    Object.defineProperty(v, "super", {
                        "value": E.prototype
                    }),
                    k && Object.assign(v.prototype, k)
                }
                ,
                "toFlatObject": (v, E, k, R) => {
                    let U, G, W;
                    const Z = {};
                    if (E = E || {},
                    null == v)
                        return E;
                    do {
                        for (U = Object.getOwnPropertyNames(v),
                        G = U.length; G-- > 0; )
                            W = U[G],
                            R && !R(W, v, E) || Z[W] || (E[W] = v[W],
                            Z[W] = !0);
                        v = !1 !== k && H(v)
                    } while (v && (!k || k(v, E)) && v !== Object.prototype);
                    return E
                }
                ,
                "kindOf": G,
                "kindOfTest": kindOfTest,
                "endsWith": (v, E, k) => {
                    v = String(v),
                    (void 0 === k || k > v.length) && (k = v.length),
                    k -= E.length;
                    const R = v.indexOf(E, k);
                    return -1 !== R && R === k
                }
                ,
                "toArray": v => {
                    if (!v)
                        return null;
                    if (Z(v))
                        return v;
                    let E = v.length;
                    if (!Q(E))
                        return null;
                    const k = new Array(E);
                    for (; E-- > 0; )
                        k[E] = v[E];
                    return k
                }
                ,
                "forEachEntry": (v, E) => {
                    const k = (v && v[Symbol.iterator]).call(v);
                    let R;
                    for (; (R = k.next()) && !R.done; ) {
                        const k = R.value;
                        E.call(v, k[0], k[1])
                    }
                }
                ,
                "matchAll": (v, E) => {
                    let k;
                    const R = [];
                    for (; null !== (k = v.exec(E)); )
                        R.push(k);
                    return R
                }
                ,
                "isHTMLForm": pe,
                "hasOwnProperty": fe,
                "hasOwnProp": fe,
                "reduceDescriptors": reduceDescriptors,
                "freezeMethods": v => {
                    reduceDescriptors(v, ( (E, k) => {
                        if (X(v) && -1 !== ["arguments", "caller", "callee"].indexOf(k))
                            return !1;
                        const R = v[k];
                        X(R) && (E.enumerable = !1,
                        "writable"in E ? E.writable = !1 : E.set || (E.set = () => {
                            throw Error("Can not rewrite read-only method '" + k + "'")
                        }
                        ))
                    }
                    ))
                }
                ,
                "toObjectSet": (v, E) => {
                    const k = {}
                      , define = v => {
                        v.forEach((v => {
                            k[v] = !0
                        }
                        ))
                    }
                    ;
                    return Z(v) ? define(v) : define(String(v).split(E)),
                    k
                }
                ,
                "toCamelCase": v => v.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, (function replacer(v, E, k) {
                    return E.toUpperCase() + k
                }
                )),
                "noop": () => {}
                ,
                "toFiniteNumber": (v, E) => null != v && Number.isFinite(v = +v) ? v : E,
                "findKey": findKey,
                "global": le,
                "isContextDefined": isContextDefined,
                "ALPHABET": _e,
                "generateString": (v=16, E=_e.ALPHA_DIGIT) => {
                    let k = "";
                    const {"length": R} = E;
                    for (; v--; )
                        k += E[Math.random() * R | 0];
                    return k
                }
                ,
                "isSpecCompliantForm": function isSpecCompliantForm(v) {
                    return !!(v && X(v.append) && "FormData" === v[Symbol.toStringTag] && v[Symbol.iterator])
                },
                "toJSONObject": v => {
                    const E = new Array(10)
                      , visit = (v, k) => {
                        if (isObject(v)) {
                            if (E.indexOf(v) >= 0)
                                return;
                            if (!("toJSON"in v)) {
                                E[k] = v;
                                const R = Z(v) ? [] : {};
                                return forEach(v, ( (v, E) => {
                                    const U = visit(v, k + 1);
                                    !Y(U) && (R[E] = U)
                                }
                                )),
                                E[k] = void 0,
                                R
                            }
                        }
                        return v
                    }
                    ;
                    return visit(v, 0)
                }
                ,
                "isAsyncFn": ve,
                "isThenable": v => v && (isObject(v) || X(v)) && X(v.then) && X(v.catch)
            };
            function AxiosError(v, E, k, R, U) {
                Error.call(this),
                Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = (new Error).stack,
                this.message = v,
                this.name = "AxiosError",
                E && (this.code = E),
                k && (this.config = k),
                R && (this.request = R),
                U && (this.response = U)
            }
            ye.inherits(AxiosError, Error, {
                "toJSON": function toJSON() {
                    return {
                        "message": this.message,
                        "name": this.name,
                        "description": this.description,
                        "number": this.number,
                        "fileName": this.fileName,
                        "lineNumber": this.lineNumber,
                        "columnNumber": this.columnNumber,
                        "stack": this.stack,
                        "config": ye.toJSONObject(this.config),
                        "code": this.code,
                        "status": this.response && this.response.status ? this.response.status : null
                    }
                }
            });
            const be = AxiosError.prototype
              , Se = {};
            ["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach((v => {
                Se[v] = {
                    "value": v
                }
            }
            )),
            Object.defineProperties(AxiosError, Se),
            Object.defineProperty(be, "isAxiosError", {
                "value": !0
            }),
            AxiosError.from = (v, E, k, R, U, H) => {
                const G = Object.create(be);
                return ye.toFlatObject(v, G, (function filter(v) {
                    return v !== Error.prototype
                }
                ), (v => "isAxiosError" !== v)),
                AxiosError.call(G, v.message, E, k, R, U),
                G.cause = v,
                G.name = v.name,
                H && Object.assign(G, H),
                G
            }
            ;
            var we = AxiosError;
            function isVisitable(v) {
                return ye.isPlainObject(v) || ye.isArray(v)
            }
            function removeBrackets(v) {
                return ye.endsWith(v, "[]") ? v.slice(0, -2) : v
            }
            function renderKey(v, E, k) {
                return v ? v.concat(E).map((function each(v, E) {
                    return v = removeBrackets(v),
                    !k && E ? "[" + v + "]" : v
                }
                )).join(k ? "." : "") : E
            }
            const Ee = ye.toFlatObject(ye, {}, null, (function filter(v) {
                return /^is[A-Z]/.test(v)
            }
            ));
            var Ce = function toFormData(v, E, k) {
                if (!ye.isObject(v))
                    throw new TypeError("target must be an object");
                E = E || new FormData;
                const R = (k = ye.toFlatObject(k, {
                    "metaTokens": !0,
                    "dots": !1,
                    "indexes": !1
                }, !1, (function defined(v, E) {
                    return !ye.isUndefined(E[v])
                }
                ))).metaTokens
                  , U = k.visitor || defaultVisitor
                  , H = k.dots
                  , G = k.indexes
                  , W = (k.Blob || "undefined" != typeof Blob && Blob) && ye.isSpecCompliantForm(E);
                if (!ye.isFunction(U))
                    throw new TypeError("visitor must be a function");
                function convertValue(v) {
                    if (null === v)
                        return "";
                    if (ye.isDate(v))
                        return v.toISOString();
                    if (!W && ye.isBlob(v))
                        throw new we("Blob is not supported. Use a Buffer instead.");
                    return ye.isArrayBuffer(v) || ye.isTypedArray(v) ? W && "function" == typeof Blob ? new Blob([v]) : Buffer.from(v) : v
                }
                function defaultVisitor(v, k, U) {
                    let W = v;
                    if (v && !U && "object" == typeof v)
                        if (ye.endsWith(k, "{}"))
                            k = R ? k : k.slice(0, -2),
                            v = JSON.stringify(v);
                        else if (ye.isArray(v) && function isFlatArray(v) {
                            return ye.isArray(v) && !v.some(isVisitable)
                        }(v) || (ye.isFileList(v) || ye.endsWith(k, "[]")) && (W = ye.toArray(v)))
                            return k = removeBrackets(k),
                            W.forEach((function each(v, R) {
                                !ye.isUndefined(v) && null !== v && E.append(!0 === G ? renderKey([k], R, H) : null === G ? k : k + "[]", convertValue(v))
                            }
                            )),
                            !1;
                    return !!isVisitable(v) || (E.append(renderKey(U, k, H), convertValue(v)),
                    !1)
                }
                const Z = []
                  , Y = Object.assign(Ee, {
                    "defaultVisitor": defaultVisitor,
                    "convertValue": convertValue,
                    "isVisitable": isVisitable
                });
                if (!ye.isObject(v))
                    throw new TypeError("data must be an object");
                return function build(v, k) {
                    if (!ye.isUndefined(v)) {
                        if (-1 !== Z.indexOf(v))
                            throw Error("Circular reference detected in " + k.join("."));
                        Z.push(v),
                        ye.forEach(v, (function each(v, R) {
                            !0 === (!(ye.isUndefined(v) || null === v) && U.call(E, v, ye.isString(R) ? R.trim() : R, k, Y)) && build(v, k ? k.concat(R) : [R])
                        }
                        )),
                        Z.pop()
                    }
                }(v),
                E
            };
            function encode(v) {
                const E = {
                    "!": "%21",
                    "'": "%27",
                    "(": "%28",
                    ")": "%29",
                    "~": "%7E",
                    "%20": "+",
                    "%00": "\0"
                };
                return encodeURIComponent(v).replace(/[!'()~]|%20|%00/g, (function replacer(v) {
                    return E[v]
                }
                ))
            }
            function AxiosURLSearchParams(v, E) {
                this._pairs = [],
                v && Ce(v, this, E)
            }
            const Te = AxiosURLSearchParams.prototype;
            Te.append = function append(v, E) {
                this._pairs.push([v, E])
            }
            ,
            Te.toString = function toString(v) {
                const E = v ? function(E) {
                    return v.call(this, E, encode)
                }
                : encode;
                return this._pairs.map((function each(v) {
                    return E(v[0]) + "=" + E(v[1])
                }
                ), "").join("&")
            }
            ;
            var xe = AxiosURLSearchParams;
            function buildURL_encode(v) {
                return encodeURIComponent(v).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
            }
            function buildURL(v, E, k) {
                if (!E)
                    return v;
                const R = k && k.encode || buildURL_encode
                  , U = k && k.serialize;
                let H;
                if (H = U ? U(E, k) : ye.isURLSearchParams(E) ? E.toString() : new xe(E,k).toString(R),
                H) {
                    const E = v.indexOf("#");
                    -1 !== E && (v = v.slice(0, E)),
                    v += (-1 === v.indexOf("?") ? "?" : "&") + H
                }
                return v
            }
            var Ae = class InterceptorManager {
                "constructor"() {
                    this.handlers = []
                }
                "use"(v, E, k) {
                    return this.handlers.push({
                        "fulfilled": v,
                        "rejected": E,
                        "synchronous": !!k && k.synchronous,
                        "runWhen": k ? k.runWhen : null
                    }),
                    this.handlers.length - 1
                }
                "eject"(v) {
                    this.handlers[v] && (this.handlers[v] = null)
                }
                "clear"() {
                    this.handlers && (this.handlers = [])
                }
                "forEach"(v) {
                    ye.forEach(this.handlers, (function forEachHandler(E) {
                        null !== E && v(E)
                    }
                    ))
                }
            }
              , Ie = {
                "silentJSONParsing": !0,
                "forcedJSONParsing": !0,
                "clarifyTimeoutError": !1
            }
              , ke = {
                "isBrowser": !0,
                "classes": {
                    "URLSearchParams": "undefined" != typeof URLSearchParams ? URLSearchParams : xe,
                    "FormData": "undefined" != typeof FormData ? FormData : null,
                    "Blob": "undefined" != typeof Blob ? Blob : null
                },
                "protocols": ["http", "https", "file", "blob", "url", "data"]
            };
            const Oe = "undefined" != typeof window && "undefined" != typeof document
              , Pe = (Re = "undefined" != typeof navigator && navigator.product,
            Oe && ["ReactNative", "NativeScript", "NS"].indexOf(Re) < 0);
            var Re;
            const Me = "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && "function" == typeof self.importScripts
              , Ne = Oe && window.location.href || "http://localhost";
            var De = {
                ...R,
                ...ke
            };
            var $e = function formDataToJSON(v) {
                function buildPath(v, E, k, R) {
                    let U = v[R++];
                    if ("__proto__" === U)
                        return !0;
                    const H = Number.isFinite(+U)
                      , G = R >= v.length;
                    if (U = !U && ye.isArray(k) ? k.length : U,
                    G)
                        return ye.hasOwnProp(k, U) ? k[U] = [k[U], E] : k[U] = E,
                        !H;
                    k[U] && ye.isObject(k[U]) || (k[U] = []);
                    return buildPath(v, E, k[U], R) && ye.isArray(k[U]) && (k[U] = function arrayToObject(v) {
                        const E = {}
                          , k = Object.keys(v);
                        let R;
                        const U = k.length;
                        let H;
                        for (R = 0; R < U; R++)
                            H = k[R],
                            E[H] = v[H];
                        return E
                    }(k[U])),
                    !H
                }
                if (ye.isFormData(v) && ye.isFunction(v.entries)) {
                    const E = {};
                    return ye.forEachEntry(v, ( (v, k) => {
                        buildPath(function parsePropPath(v) {
                            return ye.matchAll(/\w+|\[(\w*)]/g, v).map((v => "[]" === v[0] ? "" : v[1] || v[0]))
                        }(v), k, E, 0)
                    }
                    )),
                    E
                }
                return null
            };
            const Le = {
                "transitional": Ie,
                "adapter": ["xhr", "http", "fetch"],
                "transformRequest": [function transformRequest(v, E) {
                    const k = E.getContentType() || ""
                      , R = k.indexOf("application/json") > -1
                      , U = ye.isObject(v);
                    U && ye.isHTMLForm(v) && (v = new FormData(v));
                    if (ye.isFormData(v))
                        return R ? JSON.stringify($e(v)) : v;
                    if (ye.isArrayBuffer(v) || ye.isBuffer(v) || ye.isStream(v) || ye.isFile(v) || ye.isBlob(v) || ye.isReadableStream(v))
                        return v;
                    if (ye.isArrayBufferView(v))
                        return v.buffer;
                    if (ye.isURLSearchParams(v))
                        return E.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1),
                        v.toString();
                    let H;
                    if (U) {
                        if (k.indexOf("application/x-www-form-urlencoded") > -1)
                            return function toURLEncodedForm(v, E) {
                                return Ce(v, new De.classes.URLSearchParams, Object.assign({
                                    "visitor": function(v, E, k, R) {
                                        return De.isNode && ye.isBuffer(v) ? (this.append(E, v.toString("base64")),
                                        !1) : R.defaultVisitor.apply(this, arguments)
                                    }
                                }, E))
                            }(v, this.formSerializer).toString();
                        if ((H = ye.isFileList(v)) || k.indexOf("multipart/form-data") > -1) {
                            const E = this.env && this.env.FormData;
                            return Ce(H ? {
                                "files[]": v
                            } : v, E && new E, this.formSerializer)
                        }
                    }
                    return U || R ? (E.setContentType("application/json", !1),
                    function stringifySafely(v, E, k) {
                        if (ye.isString(v))
                            try {
                                return (E || JSON.parse)(v),
                                ye.trim(v)
                            } catch (v) {
                                if ("SyntaxError" !== v.name)
                                    throw v
                            }
                        return (k || JSON.stringify)(v)
                    }(v)) : v
                }
                ],
                "transformResponse": [function transformResponse(v) {
                    const E = this.transitional || Le.transitional
                      , k = E && E.forcedJSONParsing
                      , R = "json" === this.responseType;
                    if (ye.isResponse(v) || ye.isReadableStream(v))
                        return v;
                    if (v && ye.isString(v) && (k && !this.responseType || R)) {
                        const k = !(E && E.silentJSONParsing) && R;
                        try {
                            return JSON.parse(v)
                        } catch (v) {
                            if (k) {
                                if ("SyntaxError" === v.name)
                                    throw we.from(v, we.ERR_BAD_RESPONSE, this, null, this.response);
                                throw v
                            }
                        }
                    }
                    return v
                }
                ],
                "timeout": 0,
                "xsrfCookieName": "XSRF-TOKEN",
                "xsrfHeaderName": "X-XSRF-TOKEN",
                "maxContentLength": -1,
                "maxBodyLength": -1,
                "env": {
                    "FormData": De.classes.FormData,
                    "Blob": De.classes.Blob
                },
                "validateStatus": function validateStatus(v) {
                    return v >= 200 && v < 300
                },
                "headers": {
                    "common": {
                        "Accept": "application/json, text/plain, */*",
                        "Content-Type": void 0
                    }
                }
            };
            ye.forEach(["delete", "get", "head", "post", "put", "patch"], (v => {
                Le.headers[v] = {}
            }
            ));
            var Fe = Le;
            const je = ye.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]);
            const Be = Symbol("internals");
            function normalizeHeader(v) {
                return v && String(v).trim().toLowerCase()
            }
            function normalizeValue(v) {
                return !1 === v || null == v ? v : ye.isArray(v) ? v.map(normalizeValue) : String(v)
            }
            function matchHeaderValue(v, E, k, R, U) {
                return ye.isFunction(R) ? R.call(this, E, k) : (U && (E = k),
                ye.isString(E) ? ye.isString(R) ? -1 !== E.indexOf(R) : ye.isRegExp(R) ? R.test(E) : void 0 : void 0)
            }
            class AxiosHeaders {
                "constructor"(v) {
                    v && this.set(v)
                }
                "set"(v, E, k) {
                    const R = this;
                    function setHeader(v, E, k) {
                        const U = normalizeHeader(E);
                        if (!U)
                            throw new Error("header name must be a non-empty string");
                        const H = ye.findKey(R, U);
                        (!H || void 0 === R[H] || !0 === k || void 0 === k && !1 !== R[H]) && (R[H || E] = normalizeValue(v))
                    }
                    const setHeaders = (v, E) => ye.forEach(v, ( (v, k) => setHeader(v, k, E)));
                    if (ye.isPlainObject(v) || v instanceof this.constructor)
                        setHeaders(v, E);
                    else if (ye.isString(v) && (v = v.trim()) && !/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(v.trim()))
                        setHeaders((v => {
                            const E = {};
                            let k, R, U;
                            return v && v.split("\n").forEach((function parser(v) {
                                U = v.indexOf(":"),
                                k = v.substring(0, U).trim().toLowerCase(),
                                R = v.substring(U + 1).trim(),
                                !k || E[k] && je[k] || ("set-cookie" === k ? E[k] ? E[k].push(R) : E[k] = [R] : E[k] = E[k] ? E[k] + ", " + R : R)
                            }
                            )),
                            E
                        }
                        )(v), E);
                    else if (ye.isHeaders(v))
                        for (const [E,R] of v.entries())
                            setHeader(R, E, k);
                    else
                        null != v && setHeader(E, v, k);
                    return this
                }
                "get"(v, E) {
                    if (v = normalizeHeader(v)) {
                        const k = ye.findKey(this, v);
                        if (k) {
                            const v = this[k];
                            if (!E)
                                return v;
                            if (!0 === E)
                                return function parseTokens(v) {
                                    const E = Object.create(null)
                                      , k = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
                                    let R;
                                    for (; R = k.exec(v); )
                                        E[R[1]] = R[2];
                                    return E
                                }(v);
                            if (ye.isFunction(E))
                                return E.call(this, v, k);
                            if (ye.isRegExp(E))
                                return E.exec(v);
                            throw new TypeError("parser must be boolean|regexp|function")
                        }
                    }
                }
                "has"(v, E) {
                    if (v = normalizeHeader(v)) {
                        const k = ye.findKey(this, v);
                        return !(!k || void 0 === this[k] || E && !matchHeaderValue(0, this[k], k, E))
                    }
                    return !1
                }
                "delete"(v, E) {
                    const k = this;
                    let R = !1;
                    function deleteHeader(v) {
                        if (v = normalizeHeader(v)) {
                            const U = ye.findKey(k, v);
                            !U || E && !matchHeaderValue(0, k[U], U, E) || (delete k[U],
                            R = !0)
                        }
                    }
                    return ye.isArray(v) ? v.forEach(deleteHeader) : deleteHeader(v),
                    R
                }
                "clear"(v) {
                    const E = Object.keys(this);
                    let k = E.length
                      , R = !1;
                    for (; k--; ) {
                        const U = E[k];
                        v && !matchHeaderValue(0, this[U], U, v, !0) || (delete this[U],
                        R = !0)
                    }
                    return R
                }
                "normalize"(v) {
                    const E = this
                      , k = {};
                    return ye.forEach(this, ( (R, U) => {
                        const H = ye.findKey(k, U);
                        if (H)
                            return E[H] = normalizeValue(R),
                            void delete E[U];
                        const G = v ? function formatHeader(v) {
                            return v.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, ( (v, E, k) => E.toUpperCase() + k))
                        }(U) : String(U).trim();
                        G !== U && delete E[U],
                        E[G] = normalizeValue(R),
                        k[G] = !0
                    }
                    )),
                    this
                }
                "concat"(...v) {
                    return this.constructor.concat(this, ...v)
                }
                "toJSON"(v) {
                    const E = Object.create(null);
                    return ye.forEach(this, ( (k, R) => {
                        null != k && !1 !== k && (E[R] = v && ye.isArray(k) ? k.join(", ") : k)
                    }
                    )),
                    E
                }
                [Symbol.iterator]() {
                    return Object.entries(this.toJSON())[Symbol.iterator]()
                }
                "toString"() {
                    return Object.entries(this.toJSON()).map(( ([v,E]) => v + ": " + E)).join("\n")
                }
                get[Symbol.toStringTag]() {
                    return "AxiosHeaders"
                }
                static "from"(v) {
                    return v instanceof this ? v : new this(v)
                }
                static "concat"(v, ...E) {
                    const k = new this(v);
                    return E.forEach((v => k.set(v))),
                    k
                }
                static "accessor"(v) {
                    const E = (this[Be] = this[Be] = {
                        "accessors": {}
                    }).accessors
                      , k = this.prototype;
                    function defineAccessor(v) {
                        const R = normalizeHeader(v);
                        E[R] || (!function buildAccessors(v, E) {
                            const k = ye.toCamelCase(" " + E);
                            ["get", "set", "has"].forEach((R => {
                                Object.defineProperty(v, R + k, {
                                    "value": function(v, k, U) {
                                        return this[R].call(this, E, v, k, U)
                                    },
                                    "configurable": !0
                                })
                            }
                            ))
                        }(k, v),
                        E[R] = !0)
                    }
                    return ye.isArray(v) ? v.forEach(defineAccessor) : defineAccessor(v),
                    this
                }
            }
            AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]),
            ye.reduceDescriptors(AxiosHeaders.prototype, ( ({"value": v}, E) => {
                let k = E[0].toUpperCase() + E.slice(1);
                return {
                    "get": () => v,
                    "set"(v) {
                        this[k] = v
                    }
                }
            }
            )),
            ye.freezeMethods(AxiosHeaders);
            var Ue = AxiosHeaders;
            function transformData(v, E) {
                const k = this || Fe
                  , R = E || k
                  , U = Ue.from(R.headers);
                let H = R.data;
                return ye.forEach(v, (function transform(v) {
                    H = v.call(k, H, U.normalize(), E ? E.status : void 0)
                }
                )),
                U.normalize(),
                H
            }
            function isCancel(v) {
                return !(!v || !v.__CANCEL__)
            }
            function CanceledError(v, E, k) {
                we.call(this, null == v ? "canceled" : v, we.ERR_CANCELED, E, k),
                this.name = "CanceledError"
            }
            ye.inherits(CanceledError, we, {
                "__CANCEL__": !0
            });
            var He = CanceledError;
            function settle(v, E, k) {
                const R = k.config.validateStatus;
                k.status && R && !R(k.status) ? E(new we("Request failed with status code " + k.status,[we.ERR_BAD_REQUEST, we.ERR_BAD_RESPONSE][Math.floor(k.status / 100) - 4],k.config,k.request,k)) : v(k)
            }
            var ze = function speedometer(v, E) {
                v = v || 10;
                const k = new Array(v)
                  , R = new Array(v);
                let U, H = 0, G = 0;
                return E = void 0 !== E ? E : 1e3,
                function push(W) {
                    const Z = Date.now()
                      , Y = R[G];
                    U || (U = Z),
                    k[H] = W,
                    R[H] = Z;
                    let J = G
                      , K = 0;
                    for (; J !== H; )
                        K += k[J++],
                        J %= v;
                    if (H = (H + 1) % v,
                    H === G && (G = (G + 1) % v),
                    Z - U < E)
                        return;
                    const X = Y && Z - Y;
                    return X ? Math.round(1e3 * K / X) : void 0
                }
            };
            var qe = function throttle(v, E) {
                let k = 0;
                const R = 1e3 / E;
                let U = null;
                return function throttled() {
                    const E = !0 === this
                      , H = Date.now();
                    if (E || H - k > R)
                        return U && (clearTimeout(U),
                        U = null),
                        k = H,
                        v.apply(null, arguments);
                    U || (U = setTimeout(( () => (U = null,
                    k = Date.now(),
                    v.apply(null, arguments))), R - (H - k)))
                }
            }
              , progressEventReducer = (v, E, k=3) => {
                let R = 0;
                const U = ze(50, 250);
                return qe((k => {
                    const H = k.loaded
                      , G = k.lengthComputable ? k.total : void 0
                      , W = H - R
                      , Z = U(W);
                    R = H;
                    const Y = {
                        "loaded": H,
                        "total": G,
                        "progress": G ? H / G : void 0,
                        "bytes": W,
                        "rate": Z || void 0,
                        "estimated": Z && G && H <= G ? (G - H) / Z : void 0,
                        "event": k,
                        "lengthComputable": null != G
                    };
                    Y[E ? "download" : "upload"] = !0,
                    v(Y)
                }
                ), k)
            }
              , Ge = De.hasStandardBrowserEnv ? function standardBrowserEnv() {
                const v = /(msie|trident)/i.test(navigator.userAgent)
                  , E = document.createElement("a");
                let k;
                function resolveURL(k) {
                    let R = k;
                    return v && (E.setAttribute("href", R),
                    R = E.href),
                    E.setAttribute("href", R),
                    {
                        "href": E.href,
                        "protocol": E.protocol ? E.protocol.replace(/:$/, "") : "",
                        "host": E.host,
                        "search": E.search ? E.search.replace(/^\?/, "") : "",
                        "hash": E.hash ? E.hash.replace(/^#/, "") : "",
                        "hostname": E.hostname,
                        "port": E.port,
                        "pathname": "/" === E.pathname.charAt(0) ? E.pathname : "/" + E.pathname
                    }
                }
                return k = resolveURL(window.location.href),
                function isURLSameOrigin(v) {
                    const E = ye.isString(v) ? resolveURL(v) : v;
                    return E.protocol === k.protocol && E.host === k.host
                }
            }() : function isURLSameOrigin() {
                return !0
            }
              , Ve = De.hasStandardBrowserEnv ? {
                "write"(v, E, k, R, U, H) {
                    const G = [v + "=" + encodeURIComponent(E)];
                    ye.isNumber(k) && G.push("expires=" + new Date(k).toGMTString()),
                    ye.isString(R) && G.push("path=" + R),
                    ye.isString(U) && G.push("domain=" + U),
                    !0 === H && G.push("secure"),
                    document.cookie = G.join("; ")
                },
                "read"(v) {
                    const E = document.cookie.match(new RegExp("(^|;\\s*)(" + v + ")=([^;]*)"));
                    return E ? decodeURIComponent(E[3]) : null
                },
                "remove"(v) {
                    this.write(v, "", Date.now() - 864e5)
                }
            } : {
                "write"() {},
                "read"() {
                    return null
                },
                "remove"() {}
            };
            function buildFullPath(v, E) {
                return v && !function isAbsoluteURL(v) {
                    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(v)
                }(E) ? function combineURLs(v, E) {
                    return E ? v.replace(/\/?\/$/, "") + "/" + E.replace(/^\/+/, "") : v
                }(v, E) : E
            }
            const headersToObject = v => v instanceof Ue ? {
                ...v
            } : v;
            function mergeConfig(v, E) {
                E = E || {};
                const k = {};
                function getMergedValue(v, E, k) {
                    return ye.isPlainObject(v) && ye.isPlainObject(E) ? ye.merge.call({
                        "caseless": k
                    }, v, E) : ye.isPlainObject(E) ? ye.merge({}, E) : ye.isArray(E) ? E.slice() : E
                }
                function mergeDeepProperties(v, E, k) {
                    return ye.isUndefined(E) ? ye.isUndefined(v) ? void 0 : getMergedValue(void 0, v, k) : getMergedValue(v, E, k)
                }
                function valueFromConfig2(v, E) {
                    if (!ye.isUndefined(E))
                        return getMergedValue(void 0, E)
                }
                function defaultToConfig2(v, E) {
                    return ye.isUndefined(E) ? ye.isUndefined(v) ? void 0 : getMergedValue(void 0, v) : getMergedValue(void 0, E)
                }
                function mergeDirectKeys(k, R, U) {
                    return U in E ? getMergedValue(k, R) : U in v ? getMergedValue(void 0, k) : void 0
                }
                const R = {
                    "url": valueFromConfig2,
                    "method": valueFromConfig2,
                    "data": valueFromConfig2,
                    "baseURL": defaultToConfig2,
                    "transformRequest": defaultToConfig2,
                    "transformResponse": defaultToConfig2,
                    "paramsSerializer": defaultToConfig2,
                    "timeout": defaultToConfig2,
                    "timeoutMessage": defaultToConfig2,
                    "withCredentials": defaultToConfig2,
                    "withXSRFToken": defaultToConfig2,
                    "adapter": defaultToConfig2,
                    "responseType": defaultToConfig2,
                    "xsrfCookieName": defaultToConfig2,
                    "xsrfHeaderName": defaultToConfig2,
                    "onUploadProgress": defaultToConfig2,
                    "onDownloadProgress": defaultToConfig2,
                    "decompress": defaultToConfig2,
                    "maxContentLength": defaultToConfig2,
                    "maxBodyLength": defaultToConfig2,
                    "beforeRedirect": defaultToConfig2,
                    "transport": defaultToConfig2,
                    "httpAgent": defaultToConfig2,
                    "httpsAgent": defaultToConfig2,
                    "cancelToken": defaultToConfig2,
                    "socketPath": defaultToConfig2,
                    "responseEncoding": defaultToConfig2,
                    "validateStatus": mergeDirectKeys,
                    "headers": (v, E) => mergeDeepProperties(headersToObject(v), headersToObject(E), !0)
                };
                return ye.forEach(Object.keys(Object.assign({}, v, E)), (function computeConfigValue(U) {
                    const H = R[U] || mergeDeepProperties
                      , G = H(v[U], E[U], U);
                    ye.isUndefined(G) && H !== mergeDirectKeys || (k[U] = G)
                }
                )),
                k
            }
            var resolveConfig = v => {
                const E = mergeConfig({}, v);
                let k, {"data": R, "withXSRFToken": U, "xsrfHeaderName": H, "xsrfCookieName": G, "headers": W, "auth": Z} = E;
                if (E.headers = W = Ue.from(W),
                E.url = buildURL(buildFullPath(E.baseURL, E.url), v.params, v.paramsSerializer),
                Z && W.set("Authorization", "Basic " + btoa((Z.username || "") + ":" + (Z.password ? unescape(encodeURIComponent(Z.password)) : ""))),
                ye.isFormData(R))
                    if (De.hasStandardBrowserEnv || De.hasStandardBrowserWebWorkerEnv)
                        W.setContentType(void 0);
                    else if (!1 !== (k = W.getContentType())) {
                        const [v,...E] = k ? k.split(";").map((v => v.trim())).filter(Boolean) : [];
                        W.setContentType([v || "multipart/form-data", ...E].join("; "))
                    }
                if (De.hasStandardBrowserEnv && (U && ye.isFunction(U) && (U = U(E)),
                U || !1 !== U && Ge(E.url))) {
                    const v = H && G && Ve.read(G);
                    v && W.set(H, v)
                }
                return E
            }
            ;
            var We = "undefined" != typeof XMLHttpRequest && function(v) {
                return new Promise((function dispatchXhrRequest(E, k) {
                    const R = resolveConfig(v);
                    let U = R.data;
                    const H = Ue.from(R.headers).normalize();
                    let G, {"responseType": W} = R;
                    function done() {
                        R.cancelToken && R.cancelToken.unsubscribe(G),
                        R.signal && R.signal.removeEventListener("abort", G)
                    }
                    let Z = new XMLHttpRequest;
                    function onloadend() {
                        if (!Z)
                            return;
                        const R = Ue.from("getAllResponseHeaders"in Z && Z.getAllResponseHeaders());
                        settle((function _resolve(v) {
                            E(v),
                            done()
                        }
                        ), (function _reject(v) {
                            k(v),
                            done()
                        }
                        ), {
                            "data": W && "text" !== W && "json" !== W ? Z.response : Z.responseText,
                            "status": Z.status,
                            "statusText": Z.statusText,
                            "headers": R,
                            "config": v,
                            "request": Z
                        }),
                        Z = null
                    }
                    Z.open(R.method.toUpperCase(), R.url, !0),
                    Z.timeout = R.timeout,
                    "onloadend"in Z ? Z.onloadend = onloadend : Z.onreadystatechange = function handleLoad() {
                        Z && 4 === Z.readyState && (0 !== Z.status || Z.responseURL && 0 === Z.responseURL.indexOf("file:")) && setTimeout(onloadend)
                    }
                    ,
                    Z.onabort = function handleAbort() {
                        Z && (k(new we("Request aborted",we.ECONNABORTED,R,Z)),
                        Z = null)
                    }
                    ,
                    Z.onerror = function handleError() {
                        k(new we("Network Error",we.ERR_NETWORK,R,Z)),
                        Z = null
                    }
                    ,
                    Z.ontimeout = function handleTimeout() {
                        let v = R.timeout ? "timeout of " + R.timeout + "ms exceeded" : "timeout exceeded";
                        const E = R.transitional || Ie;
                        R.timeoutErrorMessage && (v = R.timeoutErrorMessage),
                        k(new we(v,E.clarifyTimeoutError ? we.ETIMEDOUT : we.ECONNABORTED,R,Z)),
                        Z = null
                    }
                    ,
                    void 0 === U && H.setContentType(null),
                    "setRequestHeader"in Z && ye.forEach(H.toJSON(), (function setRequestHeader(v, E) {
                        Z.setRequestHeader(E, v)
                    }
                    )),
                    ye.isUndefined(R.withCredentials) || (Z.withCredentials = !!R.withCredentials),
                    W && "json" !== W && (Z.responseType = R.responseType),
                    "function" == typeof R.onDownloadProgress && Z.addEventListener("progress", progressEventReducer(R.onDownloadProgress, !0)),
                    "function" == typeof R.onUploadProgress && Z.upload && Z.upload.addEventListener("progress", progressEventReducer(R.onUploadProgress)),
                    (R.cancelToken || R.signal) && (G = E => {
                        Z && (k(!E || E.type ? new He(null,v,Z) : E),
                        Z.abort(),
                        Z = null)
                    }
                    ,
                    R.cancelToken && R.cancelToken.subscribe(G),
                    R.signal && (R.signal.aborted ? G() : R.signal.addEventListener("abort", G)));
                    const Y = function parseProtocol(v) {
                        const E = /^([-+\w]{1,25})(:?\/\/|:)/.exec(v);
                        return E && E[1] || ""
                    }(R.url);
                    Y && -1 === De.protocols.indexOf(Y) ? k(new we("Unsupported protocol " + Y + ":",we.ERR_BAD_REQUEST,v)) : Z.send(U || null)
                }
                ))
            }
            ;
            var helpers_composeSignals = (v, E) => {
                let k, R = new AbortController;
                const onabort = function(v) {
                    if (!k) {
                        k = !0,
                        unsubscribe();
                        const E = v instanceof Error ? v : this.reason;
                        R.abort(E instanceof we ? E : new He(E instanceof Error ? E.message : E))
                    }
                };
                let U = E && setTimeout(( () => {
                    onabort(new we(`timeout ${E} of ms exceeded`,we.ETIMEDOUT))
                }
                ), E);
                const unsubscribe = () => {
                    v && (U && clearTimeout(U),
                    U = null,
                    v.forEach((v => {
                        v && (v.removeEventListener ? v.removeEventListener("abort", onabort) : v.unsubscribe(onabort))
                    }
                    )),
                    v = null)
                }
                ;
                v.forEach((v => v && v.addEventListener && v.addEventListener("abort", onabort)));
                const {"signal": H} = R;
                return H.unsubscribe = unsubscribe,
                [H, () => {
                    U && clearTimeout(U),
                    U = null
                }
                ]
            }
            ;
            const streamChunk = function*(v, E) {
                let k = v.byteLength;
                if (!E || k < E)
                    return void (yield v);
                let R, U = 0;
                for (; U < k; )
                    R = U + E,
                    yield v.slice(U, R),
                    U = R
            }
              , trackStream = (v, E, k, R, U) => {
                const H = async function*(v, E, k) {
                    for await(const R of v)
                        yield*streamChunk(ArrayBuffer.isView(R) ? R : await k(String(R)), E)
                }(v, E, U);
                let G = 0;
                return new ReadableStream({
                    "type": "bytes",
                    async "pull"(v) {
                        const {"done": E, "value": U} = await H.next();
                        if (E)
                            return v.close(),
                            void R();
                        let W = U.byteLength;
                        k && k(G += W),
                        v.enqueue(new Uint8Array(U))
                    },
                    "cancel"(v) {
                        return R(v),
                        H.return()
                    }
                },{
                    "highWaterMark": 2
                })
            }
              , fetchProgressDecorator = (v, E) => {
                const k = null != v;
                return R => setTimeout(( () => E({
                    "lengthComputable": k,
                    "total": v,
                    "loaded": R
                })))
            }
              , Ze = "function" == typeof fetch && "function" == typeof Request && "function" == typeof Response
              , Ye = Ze && "function" == typeof ReadableStream
              , Je = Ze && ("function" == typeof TextEncoder ? (Ke = new TextEncoder,
            v => Ke.encode(v)) : async v => new Uint8Array(await new Response(v).arrayBuffer()));
            var Ke;
            const Xe = Ye && ( () => {
                let v = !1;
                const E = new Request(De.origin,{
                    "body": new ReadableStream,
                    "method": "POST",
                    get "duplex"() {
                        return v = !0,
                        "half"
                    }
                }).headers.has("Content-Type");
                return v && !E
            }
            )()
              , Qe = Ye && !!( () => {
                try {
                    return ye.isReadableStream(new Response("").body)
                } catch (v) {}
            }
            )()
              , et = {
                "stream": Qe && (v => v.body)
            };
            var tt;
            Ze && (tt = new Response,
            ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((v => {
                !et[v] && (et[v] = ye.isFunction(tt[v]) ? E => E[v]() : (E, k) => {
                    throw new we(`Response type '${v}' is not supported`,we.ERR_NOT_SUPPORT,k)
                }
                )
            }
            )));
            const resolveBodyLength = async (v, E) => {
                const k = ye.toFiniteNumber(v.getContentLength());
                return null == k ? (async v => null == v ? 0 : ye.isBlob(v) ? v.size : ye.isSpecCompliantForm(v) ? (await new Request(v).arrayBuffer()).byteLength : ye.isArrayBufferView(v) ? v.byteLength : (ye.isURLSearchParams(v) && (v += ""),
                ye.isString(v) ? (await Je(v)).byteLength : void 0))(E) : k
            }
            ;
            const nt = {
                "http": null,
                "xhr": We,
                "fetch": Ze && (async v => {
                    let {"url": E, "method": k, "data": R, "signal": U, "cancelToken": H, "timeout": G, "onDownloadProgress": W, "onUploadProgress": Z, "responseType": Y, "headers": J, "withCredentials": K="same-origin", "fetchOptions": X} = resolveConfig(v);
                    Y = Y ? (Y + "").toLowerCase() : "text";
                    let Q, ee, [te,ne] = U || H || G ? helpers_composeSignals([U, H], G) : [];
                    const onFinish = () => {
                        !Q && setTimeout(( () => {
                            te && te.unsubscribe()
                        }
                        )),
                        Q = !0
                    }
                    ;
                    let re;
                    try {
                        if (Z && Xe && "get" !== k && "head" !== k && 0 !== (re = await resolveBodyLength(J, R))) {
                            let v, k = new Request(E,{
                                "method": "POST",
                                "body": R,
                                "duplex": "half"
                            });
                            ye.isFormData(R) && (v = k.headers.get("content-type")) && J.setContentType(v),
                            k.body && (R = trackStream(k.body, 65536, fetchProgressDecorator(re, progressEventReducer(Z)), null, Je))
                        }
                        ye.isString(K) || (K = K ? "cors" : "omit"),
                        ee = new Request(E,{
                            ...X,
                            "signal": te,
                            "method": k.toUpperCase(),
                            "headers": J.normalize().toJSON(),
                            "body": R,
                            "duplex": "half",
                            "withCredentials": K
                        });
                        let U = await fetch(ee);
                        const H = Qe && ("stream" === Y || "response" === Y);
                        if (Qe && (W || H)) {
                            const v = {};
                            ["status", "statusText", "headers"].forEach((E => {
                                v[E] = U[E]
                            }
                            ));
                            const E = ye.toFiniteNumber(U.headers.get("content-length"));
                            U = new Response(trackStream(U.body, 65536, W && fetchProgressDecorator(E, progressEventReducer(W, !0)), H && onFinish, Je),v)
                        }
                        Y = Y || "text";
                        let G = await et[ye.findKey(et, Y) || "text"](U, v);
                        return !H && onFinish(),
                        ne && ne(),
                        await new Promise(( (E, k) => {
                            settle(E, k, {
                                "data": G,
                                "headers": Ue.from(U.headers),
                                "status": U.status,
                                "statusText": U.statusText,
                                "config": v,
                                "request": ee
                            })
                        }
                        ))
                    } catch (E) {
                        if (onFinish(),
                        E && "TypeError" === E.name && /fetch/i.test(E.message))
                            throw Object.assign(new we("Network Error",we.ERR_NETWORK,v,ee), {
                                "cause": E.cause || E
                            });
                        throw we.from(E, E && E.code, v, ee)
                    }
                }
                )
            };
            ye.forEach(nt, ( (v, E) => {
                if (v) {
                    try {
                        Object.defineProperty(v, "name", {
                            "value": E
                        })
                    } catch (v) {}
                    Object.defineProperty(v, "adapterName", {
                        "value": E
                    })
                }
            }
            ));
            const renderReason = v => `- ${v}`
              , isResolvedHandle = v => ye.isFunction(v) || null === v || !1 === v;
            var adapters_getAdapter = v => {
                v = ye.isArray(v) ? v : [v];
                const {"length": E} = v;
                let k, R;
                const U = {};
                for (let H = 0; H < E; H++) {
                    let E;
                    if (k = v[H],
                    R = k,
                    !isResolvedHandle(k) && (R = nt[(E = String(k)).toLowerCase()],
                    void 0 === R))
                        throw new we(`Unknown adapter '${E}'`);
                    if (R)
                        break;
                    U[E || "#" + H] = R
                }
                if (!R) {
                    const v = Object.entries(U).map(( ([v,E]) => `adapter ${v} ` + (!1 === E ? "is not supported by the environment" : "is not available in the build")));
                    let k = E ? v.length > 1 ? "since :\n" + v.map(renderReason).join("\n") : " " + renderReason(v[0]) : "as no adapter specified";
                    throw new we("There is no suitable adapter to dispatch the request " + k,"ERR_NOT_SUPPORT")
                }
                return R
            }
            ;
            function throwIfCancellationRequested(v) {
                if (v.cancelToken && v.cancelToken.throwIfRequested(),
                v.signal && v.signal.aborted)
                    throw new He(null,v)
            }
            function dispatchRequest(v) {
                throwIfCancellationRequested(v),
                v.headers = Ue.from(v.headers),
                v.data = transformData.call(v, v.transformRequest),
                -1 !== ["post", "put", "patch"].indexOf(v.method) && v.headers.setContentType("application/x-www-form-urlencoded", !1);
                return adapters_getAdapter(v.adapter || Fe.adapter)(v).then((function onAdapterResolution(E) {
                    return throwIfCancellationRequested(v),
                    E.data = transformData.call(v, v.transformResponse, E),
                    E.headers = Ue.from(E.headers),
                    E
                }
                ), (function onAdapterRejection(E) {
                    return isCancel(E) || (throwIfCancellationRequested(v),
                    E && E.response && (E.response.data = transformData.call(v, v.transformResponse, E.response),
                    E.response.headers = Ue.from(E.response.headers))),
                    Promise.reject(E)
                }
                ))
            }
            const rt = "1.7.2"
              , ot = {};
            ["object", "boolean", "number", "function", "string", "symbol"].forEach(( (v, E) => {
                ot[v] = function validator(k) {
                    return typeof k === v || "a" + (E < 1 ? "n " : " ") + v
                }
            }
            ));
            const it = {};
            ot.transitional = function transitional(v, E, k) {
                function formatMessage(v, E) {
                    return "[Axios v1.7.2] Transitional option '" + v + "'" + E + (k ? ". " + k : "")
                }
                return (k, R, U) => {
                    if (!1 === v)
                        throw new we(formatMessage(R, " has been removed" + (E ? " in " + E : "")),we.ERR_DEPRECATED);
                    return E && !it[R] && (it[R] = !0,
                    console.warn(formatMessage(R, " has been deprecated since v" + E + " and will be removed in the near future"))),
                    !v || v(k, R, U)
                }
            }
            ;
            var at = {
                "assertOptions": function assertOptions(v, E, k) {
                    if ("object" != typeof v)
                        throw new we("options must be an object",we.ERR_BAD_OPTION_VALUE);
                    const R = Object.keys(v);
                    let U = R.length;
                    for (; U-- > 0; ) {
                        const H = R[U]
                          , G = E[H];
                        if (G) {
                            const E = v[H]
                              , k = void 0 === E || G(E, H, v);
                            if (!0 !== k)
                                throw new we("option " + H + " must be " + k,we.ERR_BAD_OPTION_VALUE)
                        } else if (!0 !== k)
                            throw new we("Unknown option " + H,we.ERR_BAD_OPTION)
                    }
                },
                "validators": ot
            };
            const st = at.validators;
            class Axios {
                "constructor"(v) {
                    this.defaults = v,
                    this.interceptors = {
                        "request": new Ae,
                        "response": new Ae
                    }
                }
                async "request"(v, E) {
                    try {
                        return await this._request(v, E)
                    } catch (v) {
                        if (v instanceof Error) {
                            let E;
                            Error.captureStackTrace ? Error.captureStackTrace(E = {}) : E = new Error;
                            const k = E.stack ? E.stack.replace(/^.+\n/, "") : "";
                            try {
                                v.stack ? k && !String(v.stack).endsWith(k.replace(/^.+\n.+\n/, "")) && (v.stack += "\n" + k) : v.stack = k
                            } catch (v) {}
                        }
                        throw v
                    }
                }
                "_request"(v, E) {
                    "string" == typeof v ? (E = E || {}).url = v : E = v || {},
                    E = mergeConfig(this.defaults, E);
                    const {"transitional": k, "paramsSerializer": R, "headers": U} = E;
                    void 0 !== k && at.assertOptions(k, {
                        "silentJSONParsing": st.transitional(st.boolean),
                        "forcedJSONParsing": st.transitional(st.boolean),
                        "clarifyTimeoutError": st.transitional(st.boolean)
                    }, !1),
                    null != R && (ye.isFunction(R) ? E.paramsSerializer = {
                        "serialize": R
                    } : at.assertOptions(R, {
                        "encode": st.function,
                        "serialize": st.function
                    }, !0)),
                    E.method = (E.method || this.defaults.method || "get").toLowerCase();
                    let H = U && ye.merge(U.common, U[E.method]);
                    U && ye.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (v => {
                        delete U[v]
                    }
                    )),
                    E.headers = Ue.concat(H, U);
                    const G = [];
                    let W = !0;
                    this.interceptors.request.forEach((function unshiftRequestInterceptors(v) {
                        "function" == typeof v.runWhen && !1 === v.runWhen(E) || (W = W && v.synchronous,
                        G.unshift(v.fulfilled, v.rejected))
                    }
                    ));
                    const Z = [];
                    let Y;
                    this.interceptors.response.forEach((function pushResponseInterceptors(v) {
                        Z.push(v.fulfilled, v.rejected)
                    }
                    ));
                    let J, K = 0;
                    if (!W) {
                        const v = [dispatchRequest.bind(this), void 0];
                        for (v.unshift.apply(v, G),
                        v.push.apply(v, Z),
                        J = v.length,
                        Y = Promise.resolve(E); K < J; )
                            Y = Y.then(v[K++], v[K++]);
                        return Y
                    }
                    J = G.length;
                    let X = E;
                    for (K = 0; K < J; ) {
                        const v = G[K++]
                          , E = G[K++];
                        try {
                            X = v(X)
                        } catch (v) {
                            E.call(this, v);
                            break
                        }
                    }
                    try {
                        Y = dispatchRequest.call(this, X)
                    } catch (v) {
                        return Promise.reject(v)
                    }
                    for (K = 0,
                    J = Z.length; K < J; )
                        Y = Y.then(Z[K++], Z[K++]);
                    return Y
                }
                "getUri"(v) {
                    return buildURL(buildFullPath((v = mergeConfig(this.defaults, v)).baseURL, v.url), v.params, v.paramsSerializer)
                }
            }
            ye.forEach(["delete", "get", "head", "options"], (function forEachMethodNoData(v) {
                Axios.prototype[v] = function(E, k) {
                    return this.request(mergeConfig(k || {}, {
                        "method": v,
                        "url": E,
                        "data": (k || {}).data
                    }))
                }
            }
            )),
            ye.forEach(["post", "put", "patch"], (function forEachMethodWithData(v) {
                function generateHTTPMethod(E) {
                    return function httpMethod(k, R, U) {
                        return this.request(mergeConfig(U || {}, {
                            "method": v,
                            "headers": E ? {
                                "Content-Type": "multipart/form-data"
                            } : {},
                            "url": k,
                            "data": R
                        }))
                    }
                }
                Axios.prototype[v] = generateHTTPMethod(),
                Axios.prototype[v + "Form"] = generateHTTPMethod(!0)
            }
            ));
            var ct = Axios;
            class CancelToken {
                "constructor"(v) {
                    if ("function" != typeof v)
                        throw new TypeError("executor must be a function.");
                    let E;
                    this.promise = new Promise((function promiseExecutor(v) {
                        E = v
                    }
                    ));
                    const k = this;
                    this.promise.then((v => {
                        if (!k._listeners)
                            return;
                        let E = k._listeners.length;
                        for (; E-- > 0; )
                            k._listeners[E](v);
                        k._listeners = null
                    }
                    )),
                    this.promise.then = v => {
                        let E;
                        const R = new Promise((v => {
                            k.subscribe(v),
                            E = v
                        }
                        )).then(v);
                        return R.cancel = function reject() {
                            k.unsubscribe(E)
                        }
                        ,
                        R
                    }
                    ,
                    v((function cancel(v, R, U) {
                        k.reason || (k.reason = new He(v,R,U),
                        E(k.reason))
                    }
                    ))
                }
                "throwIfRequested"() {
                    if (this.reason)
                        throw this.reason
                }
                "subscribe"(v) {
                    this.reason ? v(this.reason) : this._listeners ? this._listeners.push(v) : this._listeners = [v]
                }
                "unsubscribe"(v) {
                    if (!this._listeners)
                        return;
                    const E = this._listeners.indexOf(v);
                    -1 !== E && this._listeners.splice(E, 1)
                }
                static "source"() {
                    let v;
                    return {
                        "token": new CancelToken((function executor(E) {
                            v = E
                        }
                        )),
                        "cancel": v
                    }
                }
            }
            var lt = CancelToken;
            const ut = {
                "Continue": 100,
                "SwitchingProtocols": 101,
                "Processing": 102,
                "EarlyHints": 103,
                "Ok": 200,
                "Created": 201,
                "Accepted": 202,
                "NonAuthoritativeInformation": 203,
                "NoContent": 204,
                "ResetContent": 205,
                "PartialContent": 206,
                "MultiStatus": 207,
                "AlreadyReported": 208,
                "ImUsed": 226,
                "MultipleChoices": 300,
                "MovedPermanently": 301,
                "Found": 302,
                "SeeOther": 303,
                "NotModified": 304,
                "UseProxy": 305,
                "Unused": 306,
                "TemporaryRedirect": 307,
                "PermanentRedirect": 308,
                "BadRequest": 400,
                "Unauthorized": 401,
                "PaymentRequired": 402,
                "Forbidden": 403,
                "NotFound": 404,
                "MethodNotAllowed": 405,
                "NotAcceptable": 406,
                "ProxyAuthenticationRequired": 407,
                "RequestTimeout": 408,
                "Conflict": 409,
                "Gone": 410,
                "LengthRequired": 411,
                "PreconditionFailed": 412,
                "PayloadTooLarge": 413,
                "UriTooLong": 414,
                "UnsupportedMediaType": 415,
                "RangeNotSatisfiable": 416,
                "ExpectationFailed": 417,
                "ImATeapot": 418,
                "MisdirectedRequest": 421,
                "UnprocessableEntity": 422,
                "Locked": 423,
                "FailedDependency": 424,
                "TooEarly": 425,
                "UpgradeRequired": 426,
                "PreconditionRequired": 428,
                "TooManyRequests": 429,
                "RequestHeaderFieldsTooLarge": 431,
                "UnavailableForLegalReasons": 451,
                "InternalServerError": 500,
                "NotImplemented": 501,
                "BadGateway": 502,
                "ServiceUnavailable": 503,
                "GatewayTimeout": 504,
                "HttpVersionNotSupported": 505,
                "VariantAlsoNegotiates": 506,
                "InsufficientStorage": 507,
                "LoopDetected": 508,
                "NotExtended": 510,
                "NetworkAuthenticationRequired": 511
            };
            Object.entries(ut).forEach(( ([v,E]) => {
                ut[E] = v
            }
            ));
            var dt = ut;
            const pt = function createInstance(v) {
                const E = new ct(v)
                  , k = bind(ct.prototype.request, E);
                return ye.extend(k, ct.prototype, E, {
                    "allOwnKeys": !0
                }),
                ye.extend(k, E, null, {
                    "allOwnKeys": !0
                }),
                k.create = function create(E) {
                    return createInstance(mergeConfig(v, E))
                }
                ,
                k
            }(Fe);
            pt.Axios = ct,
            pt.CanceledError = He,
            pt.CancelToken = lt,
            pt.isCancel = isCancel,
            pt.VERSION = rt,
            pt.toFormData = Ce,
            pt.AxiosError = we,
            pt.Cancel = pt.CanceledError,
            pt.all = function all(v) {
                return Promise.all(v)
            }
            ,
            pt.spread = function spread(v) {
                return function wrap(E) {
                    return v.apply(null, E)
                }
            }
            ,
            pt.isAxiosError = function isAxiosError(v) {
                return ye.isObject(v) && !0 === v.isAxiosError
            }
            ,
            pt.mergeConfig = mergeConfig,
            pt.AxiosHeaders = Ue,
            pt.formToJSON = v => $e(ye.isHTMLForm(v) ? new FormData(v) : v),
            pt.getAdapter = adapters_getAdapter,
            pt.HttpStatusCode = dt,
            pt.default = pt;
            var ft = pt
        },
        "7601": function(v, E) {
            "use strict";
            E.Z = function isNil(v) {
                return null == v
            }
        },
        "7950": function(v, E, k) {
            "use strict";
            k.d(E, {
                "Z": function() {
                    return _e
                }
            });
            var R = function isObject(v) {
                var E = typeof v;
                return null != v && ("object" == E || "function" == E)
            }
              , U = "object" == typeof global && global && global.Object === Object && global
              , H = "object" == typeof self && self && self.Object === Object && self
              , G = U || H || Function("return this")()
              , lodash_es_now = function() {
                return G.Date.now()
            }
              , W = /\s/;
            var Z = function trimmedEndIndex(v) {
                for (var E = v.length; E-- && W.test(v.charAt(E)); )
                    ;
                return E
            }
              , Y = /^\s+/;
            var J = function baseTrim(v) {
                return v ? v.slice(0, Z(v) + 1).replace(Y, "") : v
            }
              , K = G.Symbol
              , X = Object.prototype
              , Q = X.hasOwnProperty
              , ee = X.toString
              , te = K ? K.toStringTag : void 0;
            var ne = function getRawTag(v) {
                var E = Q.call(v, te)
                  , k = v[te];
                try {
                    v[te] = void 0;
                    var R = !0
                } catch (v) {}
                var U = ee.call(v);
                return R && (E ? v[te] = k : delete v[te]),
                U
            }
              , re = Object.prototype.toString;
            var oe = function objectToString(v) {
                return re.call(v)
            }
              , ie = K ? K.toStringTag : void 0;
            var ae = function baseGetTag(v) {
                return null == v ? void 0 === v ? "[object Undefined]" : "[object Null]" : ie && ie in Object(v) ? ne(v) : oe(v)
            };
            var se = function isObjectLike(v) {
                return null != v && "object" == typeof v
            };
            var ce = function isSymbol(v) {
                return "symbol" == typeof v || se(v) && "[object Symbol]" == ae(v)
            }
              , le = /^[-+]0x[0-9a-f]+$/i
              , ue = /^0b[01]+$/i
              , de = /^0o[0-7]+$/i
              , pe = parseInt;
            var fe = function toNumber(v) {
                if ("number" == typeof v)
                    return v;
                if (ce(v))
                    return NaN;
                if (R(v)) {
                    var E = "function" == typeof v.valueOf ? v.valueOf() : v;
                    v = R(E) ? E + "" : E
                }
                if ("string" != typeof v)
                    return 0 === v ? v : +v;
                v = J(v);
                var k = ue.test(v);
                return k || de.test(v) ? pe(v.slice(2), k ? 2 : 8) : le.test(v) ? NaN : +v
            }
              , he = Math.max
              , me = Math.min;
            var ge = function debounce(v, E, k) {
                var U, H, G, W, Z, Y, J = 0, K = !1, X = !1, Q = !0;
                if ("function" != typeof v)
                    throw new TypeError("Expected a function");
                function invokeFunc(E) {
                    var k = U
                      , R = H;
                    return U = H = void 0,
                    J = E,
                    W = v.apply(R, k)
                }
                function shouldInvoke(v) {
                    var k = v - Y;
                    return void 0 === Y || k >= E || k < 0 || X && v - J >= G
                }
                function timerExpired() {
                    var v = lodash_es_now();
                    if (shouldInvoke(v))
                        return trailingEdge(v);
                    Z = setTimeout(timerExpired, function remainingWait(v) {
                        var k = E - (v - Y);
                        return X ? me(k, G - (v - J)) : k
                    }(v))
                }
                function trailingEdge(v) {
                    return Z = void 0,
                    Q && U ? invokeFunc(v) : (U = H = void 0,
                    W)
                }
                function debounced() {
                    var v = lodash_es_now()
                      , k = shouldInvoke(v);
                    if (U = arguments,
                    H = this,
                    Y = v,
                    k) {
                        if (void 0 === Z)
                            return function leadingEdge(v) {
                                return J = v,
                                Z = setTimeout(timerExpired, E),
                                K ? invokeFunc(v) : W
                            }(Y);
                        if (X)
                            return clearTimeout(Z),
                            Z = setTimeout(timerExpired, E),
                            invokeFunc(Y)
                    }
                    return void 0 === Z && (Z = setTimeout(timerExpired, E)),
                    W
                }
                return E = fe(E) || 0,
                R(k) && (K = !!k.leading,
                G = (X = "maxWait"in k) ? he(fe(k.maxWait) || 0, E) : G,
                Q = "trailing"in k ? !!k.trailing : Q),
                debounced.cancel = function cancel() {
                    void 0 !== Z && clearTimeout(Z),
                    J = 0,
                    U = Y = H = Z = void 0
                }
                ,
                debounced.flush = function flush() {
                    return void 0 === Z ? W : trailingEdge(lodash_es_now())
                }
                ,
                debounced
            };
            var _e = function throttle(v, E, k) {
                var U = !0
                  , H = !0;
                if ("function" != typeof v)
                    throw new TypeError("Expected a function");
                return R(k) && (U = "leading"in k ? !!k.leading : U,
                H = "trailing"in k ? !!k.trailing : H),
                ge(v, E, {
                    "leading": U,
                    "maxWait": E,
                    "trailing": H
                })
            }
        },
        "4296": function(v, E, k) {
            "use strict";
            k.r(E),
            k.d(E, {
                "customAlphabet": function() {
                    return customAlphabet
                },
                "customRandom": function() {
                    return customRandom
                },
                "nanoid": function() {
                    return nanoid
                },
                "random": function() {
                    return random
                },
                "urlAlphabet": function() {
                    return R
                }
            });
            let R = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict"
              , random = v => crypto.getRandomValues(new Uint8Array(v))
              , customRandom = (v, E, k) => {
                let R = (2 << Math.log(v.length - 1) / Math.LN2) - 1
                  , U = -~(1.6 * R * E / v.length);
                return (H=E) => {
                    let G = "";
                    for (; ; ) {
                        let E = k(U)
                          , W = U;
                        for (; W--; )
                            if (G += v[E[W] & R] || "",
                            G.length === H)
                                return G
                    }
                }
            }
              , customAlphabet = (v, E=21) => customRandom(v, E, random)
              , nanoid = (v=21) => crypto.getRandomValues(new Uint8Array(v)).reduce(( (v, E) => v += (E &= 63) < 36 ? E.toString(36) : E < 62 ? (E - 26).toString(36).toUpperCase() : E > 62 ? "-" : "_"), "")
        },
        "7582": function(v, E, k) {
            "use strict";
            k.d(E, {
                "Q_": function() {
                    return __classPrivateFieldGet
                },
                "YH": function() {
                    return __classPrivateFieldSet
                },
                "_T": function() {
                    return __rest
                },
                "mG": function() {
                    return __awaiter
                }
            });
            function __rest(v, E) {
                var k = {};
                for (var R in v)
                    Object.prototype.hasOwnProperty.call(v, R) && E.indexOf(R) < 0 && (k[R] = v[R]);
                if (null != v && "function" == typeof Object.getOwnPropertySymbols) {
                    var U = 0;
                    for (R = Object.getOwnPropertySymbols(v); U < R.length; U++)
                        E.indexOf(R[U]) < 0 && Object.prototype.propertyIsEnumerable.call(v, R[U]) && (k[R[U]] = v[R[U]])
                }
                return k
            }
            function __awaiter(v, E, k, R) {
                return new (k || (k = Promise))((function(U, H) {
                    function fulfilled(v) {
                        try {
                            step(R.next(v))
                        } catch (v) {
                            H(v)
                        }
                    }
                    function rejected(v) {
                        try {
                            step(R.throw(v))
                        } catch (v) {
                            H(v)
                        }
                    }
                    function step(v) {
                        v.done ? U(v.value) : function adopt(v) {
                            return v instanceof k ? v : new k((function(E) {
                                E(v)
                            }
                            ))
                        }(v.value).then(fulfilled, rejected)
                    }
                    step((R = R.apply(v, E || [])).next())
                }
                ))
            }
            Object.create;
            Object.create;
            function __classPrivateFieldGet(v, E, k, R) {
                if ("a" === k && !R)
                    throw new TypeError("Private accessor was defined without a getter");
                if ("function" == typeof E ? v !== E || !R : !E.has(v))
                    throw new TypeError("Cannot read private member from an object whose class did not declare it");
                return "m" === k ? R : "a" === k ? R.call(v) : R ? R.value : E.get(v)
            }
            function __classPrivateFieldSet(v, E, k, R, U) {
                if ("m" === R)
                    throw new TypeError("Private method is not writable");
                if ("a" === R && !U)
                    throw new TypeError("Private accessor was defined without a setter");
                if ("function" == typeof E ? v !== E || !U : !E.has(v))
                    throw new TypeError("Cannot write private member to an object whose class did not declare it");
                return "a" === R ? U.call(v, k) : U ? U.value = k : E.set(v, k),
                k
            }
            "function" == typeof SuppressedError && SuppressedError
        }
    }, G = {};
    function __webpack_require__(v) {
        var E = G[v];
        if (void 0 !== E)
            return E.exports;
        var k = G[v] = {
            "id": v,
            "loaded": !1,
            "exports": {}
        };
        return H[v].call(k.exports, k, k.exports, __webpack_require__),
        k.loaded = !0,
        k.exports
    }
    __webpack_require__.m = H,
    v = [],
    __webpack_require__.O = function(E, k, R, U) {
        if (!k) {
            var H = 1 / 0;
            for (Y = 0; Y < v.length; Y++) {
                k = v[Y][0],
                R = v[Y][1],
                U = v[Y][2];
                for (var G = !0, W = 0; W < k.length; W++)
                    (!1 & U || H >= U) && Object.keys(__webpack_require__.O).every((function(v) {
                        return __webpack_require__.O[v](k[W])
                    }
                    )) ? k.splice(W--, 1) : (G = !1,
                    U < H && (H = U));
                if (G) {
                    v.splice(Y--, 1);
                    var Z = R();
                    void 0 !== Z && (E = Z)
                }
            }
            return E
        }
        U = U || 0;
        for (var Y = v.length; Y > 0 && v[Y - 1][2] > U; Y--)
            v[Y] = v[Y - 1];
        v[Y] = [k, R, U]
    }
    ,
    __webpack_require__.n = function(v) {
        var E = v && v.__esModule ? function() {
            return v.default
        }
        : function() {
            return v
        }
        ;
        return __webpack_require__.d(E, {
            "a": E
        }),
        E
    }
    ,
    __webpack_require__.d = function(v, E) {
        for (var k in E)
            __webpack_require__.o(E, k) && !__webpack_require__.o(v, k) && Object.defineProperty(v, k, {
                "enumerable": !0,
                "get": E[k]
            })
    }
    ,
    __webpack_require__.f = {},
    __webpack_require__.e = function(v) {
        return Promise.all(Object.keys(__webpack_require__.f).reduce((function(E, k) {
            return __webpack_require__.f[k](v, E),
            E
        }
        ), []))
    }
    ,
    __webpack_require__.u = function(v) {
        return "js/" + v + "." + {
            "25": "5436ae87d16fb4675271",
            "41": "28f2c3a8c792c6bb2e00",
            "73": "3fea8ec43400224b11ee",
            "78": "e85ca4df86009b579a6c",
            "109": "893e1b4c36a36e08972b",
            "118": "c270a45b6fed3c120dab",
            "152": "77afa678aaccfd374e87",
            "235": "d63f63a0f28b93513a1b",
            "239": "db643e01fcd0bbc39753",
            "242": "6d564fecb116c3ca31a9",
            "258": "cec8bc65dfa3c62949bf",
            "260": "964c8a705b5bb9bd8749",
            "279": "dbdec3acac216648e72d",
            "294": "6da8d2399e272d78a93c",
            "322": "d61eaa416340a063f8c8",
            "368": "a6908f43933c012045f6",
            "544": "e3007c2e562b168ce8be",
            "570": "3a34bad0a6c51e469c56",
            "576": "53b90b8c03bec390bcf0",
            "661": "5c7c6113658b43b831d9",
            "665": "364c769c03c8ac772a2a",
            "730": "1a9d8f0195b98cd4e9cf",
            "737": "6d12bbd5d419713c08ef",
            "767": "0b43a3c3933829f3cbef",
            "791": "06b5d232a0624274317a",
            "862": "07268cc5efa988d000c2",
            "904": "b89b5ddb6aafe09b12ab",
            "920": "6228930d3fb4aa690ce4",
            "940": "3fd7fd88a936e2fff50e",
            "959": "dee6b916cb7a48f10395",
            "977": "deaf5a12bad675afc82b"
        }[v] + ".js"
    }
    ,
    __webpack_require__.miniCssF = function(v) {
        return "css/" + v + "." + {
            "25": "5436ae87d16fb4675271",
            "73": "3fea8ec43400224b11ee",
            "78": "e85ca4df86009b579a6c",
            "109": "893e1b4c36a36e08972b",
            "118": "c270a45b6fed3c120dab",
            "152": "77afa678aaccfd374e87",
            "235": "d63f63a0f28b93513a1b",
            "239": "db643e01fcd0bbc39753",
            "242": "6d564fecb116c3ca31a9",
            "258": "cec8bc65dfa3c62949bf",
            "260": "964c8a705b5bb9bd8749",
            "279": "dbdec3acac216648e72d",
            "294": "6da8d2399e272d78a93c",
            "322": "d61eaa416340a063f8c8",
            "368": "a6908f43933c012045f6",
            "544": "e3007c2e562b168ce8be",
            "570": "3a34bad0a6c51e469c56",
            "661": "5c7c6113658b43b831d9",
            "665": "364c769c03c8ac772a2a",
            "730": "1a9d8f0195b98cd4e9cf",
            "737": "6d12bbd5d419713c08ef",
            "767": "0b43a3c3933829f3cbef",
            "791": "06b5d232a0624274317a",
            "862": "07268cc5efa988d000c2",
            "904": "b89b5ddb6aafe09b12ab",
            "920": "6228930d3fb4aa690ce4",
            "940": "3fd7fd88a936e2fff50e",
            "959": "dee6b916cb7a48f10395",
            "977": "deaf5a12bad675afc82b"
        }[v] + ".css"
    }
    ,
    __webpack_require__.g = function() {
        if ("object" == typeof globalThis)
            return globalThis;
        try {
            return this || new Function("return this")()
        } catch (v) {
            if ("object" == typeof window)
                return window
        }
    }(),
    __webpack_require__.o = function(v, E) {
        return Object.prototype.hasOwnProperty.call(v, E)
    }
    ,
    E = {},
    k = "ai-community-applet-uni:",
    __webpack_require__.l = function(v, R, U, H) {
        if (E[v])
            E[v].push(R);
        else {
            var G, W;
            if (void 0 !== U)
                for (var Z = document.getElementsByTagName("script"), Y = 0; Y < Z.length; Y++) {
                    var J = Z[Y];
                    if (J.getAttribute("src") == v || J.getAttribute("data-webpack") == k + U) {
                        G = J;
                        break
                    }
                }
            G || (W = !0,
            (G = document.createElement("script")).charset = "utf-8",
            G.timeout = 120,
            __webpack_require__.nc && G.setAttribute("nonce", __webpack_require__.nc),
            G.setAttribute("data-webpack", k + U),
            G.src = v),
            E[v] = [R];
            var onScriptComplete = function(k, R) {
                G.onerror = G.onload = null,
                clearTimeout(K);
                var U = E[v];
                if (delete E[v],
                G.parentNode && G.parentNode.removeChild(G),
                U && U.forEach((function(v) {
                    return v(R)
                }
                )),
                k)
                    return k(R)
            }
              , K = setTimeout(onScriptComplete.bind(null, void 0, {
                "type": "timeout",
                "target": G
            }), 12e4);
            G.onerror = onScriptComplete.bind(null, G.onerror),
            G.onload = onScriptComplete.bind(null, G.onload),
            W && document.head.appendChild(G)
        }
    }
    ,
    __webpack_require__.r = function(v) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(v, Symbol.toStringTag, {
            "value": "Module"
        }),
        Object.defineProperty(v, "__esModule", {
            "value": !0
        })
    }
    ,
    __webpack_require__.nmd = function(v) {
        return v.paths = [],
        v.children || (v.children = []),
        v
    }
    ,
    __webpack_require__.p = "https://g1.itc.cn/aife-easyai-pre/202412121731/assets/",
    R = function(v) {
        return new Promise((function(E, k) {
            var R = __webpack_require__.miniCssF(v)
              , U = __webpack_require__.p + R;
            if (function(v, E) {
                for (var k = document.getElementsByTagName("link"), R = 0; R < k.length; R++) {
                    var U = (G = k[R]).getAttribute("data-href") || G.getAttribute("href");
                    if ("stylesheet" === G.rel && (U === v || U === E))
                        return G
                }
                var H = document.getElementsByTagName("style");
                for (R = 0; R < H.length; R++) {
                    var G;
                    if ((U = (G = H[R]).getAttribute("data-href")) === v || U === E)
                        return G
                }
            }(R, U))
                return E();
            !function(v, E, k, R) {
                var U = document.createElement("link");
                U.rel = "stylesheet",
                U.type = "text/css",
                U.onerror = U.onload = function(H) {
                    if (U.onerror = U.onload = null,
                    "load" === H.type)
                        k();
                    else {
                        var G = H && ("load" === H.type ? "missing" : H.type)
                          , W = H && H.target && H.target.href || E
                          , Z = new Error("Loading CSS chunk " + v + " failed.\n(" + W + ")");
                        Z.code = "CSS_CHUNK_LOAD_FAILED",
                        Z.type = G,
                        Z.request = W,
                        U.parentNode.removeChild(U),
                        R(Z)
                    }
                }
                ,
                U.href = E,
                document.head.appendChild(U)
            }(v, U, E, k)
        }
        ))
    }
    ,
    U = {
        "143": 0
    },
    __webpack_require__.f.miniCss = function(v, E) {
        U[v] ? E.push(U[v]) : 0 !== U[v] && {
            "25": 1,
            "73": 1,
            "78": 1,
            "109": 1,
            "118": 1,
            "152": 1,
            "235": 1,
            "239": 1,
            "242": 1,
            "258": 1,
            "260": 1,
            "279": 1,
            "294": 1,
            "322": 1,
            "368": 1,
            "544": 1,
            "570": 1,
            "661": 1,
            "665": 1,
            "730": 1,
            "737": 1,
            "767": 1,
            "791": 1,
            "862": 1,
            "904": 1,
            "920": 1,
            "940": 1,
            "959": 1,
            "977": 1
        }[v] && E.push(U[v] = R(v).then((function() {
            U[v] = 0
        }
        ), (function(E) {
            throw delete U[v],
            E
        }
        )))
    }
    ,
    function() {
        __webpack_require__.b = document.baseURI || self.location.href;
        var v = {
            "143": 0
        };
        __webpack_require__.f.j = function(E, k) {
            var R = __webpack_require__.o(v, E) ? v[E] : void 0;
            if (0 !== R)
                if (R)
                    k.push(R[2]);
                else {
                    var U = new Promise((function(k, U) {
                        R = v[E] = [k, U]
                    }
                    ));
                    k.push(R[2] = U);
                    var H = __webpack_require__.p + __webpack_require__.u(E)
                      , G = new Error;
                    __webpack_require__.l(H, (function(k) {
                        if (__webpack_require__.o(v, E) && (0 !== (R = v[E]) && (v[E] = void 0),
                        R)) {
                            var U = k && ("load" === k.type ? "missing" : k.type)
                              , H = k && k.target && k.target.src;
                            G.message = "Loading chunk " + E + " failed.\n(" + U + ": " + H + ")",
                            G.name = "ChunkLoadError",
                            G.type = U,
                            G.request = H,
                            R[1](G)
                        }
                    }
                    ), "chunk-" + E, E)
                }
        }
        ,
        __webpack_require__.O.j = function(E) {
            return 0 === v[E]
        }
        ;
        var webpackJsonpCallback = function(E, k) {
            var R, U, H = k[0], G = k[1], W = k[2], Z = 0;
            if (H.some((function(E) {
                return 0 !== v[E]
            }
            ))) {
                for (R in G)
                    __webpack_require__.o(G, R) && (__webpack_require__.m[R] = G[R]);
                if (W)
                    var Y = W(__webpack_require__)
            }
            for (E && E(k); Z < H.length; Z++)
                U = H[Z],
                __webpack_require__.o(v, U) && v[U] && v[U][0](),
                v[U] = 0;
            return __webpack_require__.O(Y)
        }
          , E = self.webpackJsonp = self.webpackJsonp || [];
        E.forEach(webpackJsonpCallback.bind(null, 0)),
        E.push = webpackJsonpCallback.bind(null, E.push.bind(E))
    }(),
    __webpack_require__.nc = void 0;
    var W = __webpack_require__.O(void 0, [585], (function() {
        return __webpack_require__(5276)
    }
    ));
    W = __webpack_require__.O(W)
}();
