/*! For license information please see app.9a8a6d39adc9702a4111.js.LICENSE.txt */
!function () { var c, u, d, v, E, k = { "7210": function (c, u, d) { "use strict"; d.d(u, { "mv": function () { return Ot }, "AA": function () { return vt }, "yM": function () { return createEvent }, "h": function () { return h }, "GH": function () { return proxyCustomElement } }); const v = !1, E = !0, k = !1, R = !0, U = !0, H = !0, G = !0, W = !0, Z = !0, Y = !0, J = !0, K = !0, X = !0, Q = !0, ee = !0, te = !1, ne = !0, re = !0, oe = !0, ie = !0, ae = !0, se = !0, ce = !0, le = !0, ue = !0, de = !0, pe = !0, fe = !0, he = !0, me = !0, ge = !0, _e = !0, ve = !0, ye = !0, be = !0, Se = !0, we = !0, Ee = !0, Ce = !0, Te = !0, xe = !0, Ae = !0, Ie = !0, ke = !0, Oe = !1, Pe = !1, Re = !1, Me = !1, Ne = !1, De = !1, $e = !1, Le = !1, Fe = !1, je = !0, Be = !1, Ue = !0, He = !1, ze = !0, qe = !0, Ge = !0, Ve = !1, We = !0, Ze = !0, Ye = !0, Je = !1, Ke = !1, Xe = !1, Qe = !0, et = "app"; let tt, nt, rt, ot, it = 0, at = !1, st = !1, ct = !1, lt = !1, ut = null, dt = 0, pt = !1; const createTime = (c, u = "") => { if (Fe && performance.mark) { const d = `st:${c}:${u}:${it++}`; return performance.mark(d), () => performance.measure(`[Stencil] ${c}() <${u}>`, d) } return () => { } }, ft = "s-id", ht = "sty-id", mt = "c-id", gt = "http://www.w3.org/1999/xlink", _t = {}, isComplexType = c => "object" === (c = typeof c) || "function" === c; function queryNonceMetaTagContent(c) { var u, d, v; return null !== (v = null === (d = null === (u = c.head) || void 0 === u ? void 0 : u.querySelector('meta[name="csp-nonce"]')) || void 0 === d ? void 0 : d.getAttribute("content")) && void 0 !== v ? v : void 0 } const h = (c, u, ...d) => { let v = null, E = null, k = null, R = !1, U = !1; const H = [], walk = u => { for (let d = 0; d < u.length; d++)v = u[d], Array.isArray(v) ? walk(v) : null != v && "boolean" != typeof v && ((R = "function" != typeof c && !isComplexType(v)) ? v = String(v) : Re && "function" != typeof c && void 0 === v.$flags$ && consoleDevError("vNode passed as children has unexpected type.\nMake sure it's using the correct h() function.\nEmpty objects can also be the cause, look for JSX comments that became objects."), R && U ? H[H.length - 1].$text$ += v : H.push(R ? newVNode(null, v) : v), U = R) }; if (walk(d), u && (Re && "input" === c && validateInputProperties(u), Se && u.key && (E = u.key), je && u.name && (k = u.name), ye)) { const c = u.className || u.class; c && (u.class = "object" != typeof c ? c : Object.keys(c).filter((u => c[u])).join(" ")) } if (Re && H.some(isHost) && consoleDevError("The <Host> must be the single root component. Make sure:\n- You are NOT using hostData() and <Host> in the same component.\n- <Host> is used once, and it's the single root component of the render() function."), be && "function" == typeof c) return c(null === u ? {} : u, H, yt); const G = newVNode(c, null); return G.$attrs$ = u, H.length > 0 && (G.$children$ = H), Se && (G.$key$ = E), je && (G.$name$ = k), G }, newVNode = (c, u) => { const d = { "$flags$": 0, "$tag$": c, "$text$": u, "$elm$": null, "$children$": null }; return _e && (d.$attrs$ = null), Se && (d.$key$ = null), je && (d.$name$ = null), d }, vt = {}, isHost = c => c && c.$tag$ === vt, yt = { "forEach": (c, u) => c.map(convertToPublic).forEach(u), "map": (c, u) => c.map(convertToPublic).map(u).map(convertToPrivate) }, convertToPublic = c => ({ "vattrs": c.$attrs$, "vchildren": c.$children$, "vkey": c.$key$, "vname": c.$name$, "vtag": c.$tag$, "vtext": c.$text$ }), convertToPrivate = c => { if ("function" == typeof c.vtag) { const u = Object.assign({}, c.vattrs); return c.vkey && (u.key = c.vkey), c.vname && (u.name = c.vname), h(c.vtag, u, ...c.vchildren || []) } const u = newVNode(c.vtag, c.vtext); return u.$attrs$ = c.vattrs, u.$children$ = c.vchildren, u.$key$ = c.vkey, u.$name$ = c.vname, u }, validateInputProperties = c => { const u = Object.keys(c), d = u.indexOf("value"); if (-1 === d) return; const v = u.indexOf("type"), E = u.indexOf("min"), k = u.indexOf("max"), R = u.indexOf("step"); (d < v || d < E || d < k || d < R) && consoleDevWarn('The "value" prop of <input> should be set after "min", "max", "type" and "step"') }, clientHydrate = (c, u, d, v, E, k, R) => { let U, H, G, W; if (1 === k.nodeType) { for (U = k.getAttribute(mt), U && (H = U.split("."), H[0] !== R && "0" !== H[0] || (G = { "$flags$": 0, "$hostId$": H[0], "$nodeId$": H[1], "$depth$": H[2], "$index$": H[3], "$tag$": k.tagName.toLowerCase(), "$elm$": k, "$attrs$": null, "$children$": null, "$key$": null, "$name$": null, "$text$": null }, u.push(G), k.removeAttribute(mt), c.$children$ || (c.$children$ = []), c.$children$[G.$index$] = G, c = G, v && "0" === G.$depth$ && (v[G.$index$] = G.$elm$))), W = k.childNodes.length - 1; W >= 0; W--)clientHydrate(c, u, d, v, E, k.childNodes[W], R); if (k.shadowRoot) for (W = k.shadowRoot.childNodes.length - 1; W >= 0; W--)clientHydrate(c, u, d, v, E, k.shadowRoot.childNodes[W], R) } else if (8 === k.nodeType) H = k.nodeValue.split("."), H[1] !== R && "0" !== H[1] || (U = H[0], G = { "$flags$": 0, "$hostId$": H[1], "$nodeId$": H[2], "$depth$": H[3], "$index$": H[4], "$elm$": k, "$attrs$": null, "$children$": null, "$key$": null, "$name$": null, "$tag$": null, "$text$": null }, "t" === U ? (G.$elm$ = k.nextSibling, G.$elm$ && 3 === G.$elm$.nodeType && (G.$text$ = G.$elm$.textContent, u.push(G), k.remove(), c.$children$ || (c.$children$ = []), c.$children$[G.$index$] = G, v && "0" === G.$depth$ && (v[G.$index$] = G.$elm$))) : G.$hostId$ === R && ("s" === U ? (G.$tag$ = "slot", H[5] ? k["s-sn"] = G.$name$ = H[5] : k["s-sn"] = "", k["s-sr"] = !0, ue && v && (G.$elm$ = kt.createElement(G.$tag$), G.$name$ && G.$elm$.setAttribute("name", G.$name$), k.parentNode.insertBefore(G.$elm$, k), k.remove(), "0" === G.$depth$ && (v[G.$index$] = G.$elm$)), d.push(G), c.$children$ || (c.$children$ = []), c.$children$[G.$index$] = G) : "r" === U && (ue && v ? k.remove() : je && (E["s-cr"] = k, k["s-cn"] = !0)))); else if (c && "style" === c.$tag$) { const u = newVNode(null, k.textContent); u.$elm$ = k, u.$index$ = "0", c.$children$ = [u] } }, initializeDocumentHydrate = (c, u) => { if (1 === c.nodeType) { let d = 0; for (; d < c.childNodes.length; d++)initializeDocumentHydrate(c.childNodes[d], u); if (c.shadowRoot) for (d = 0; d < c.shadowRoot.childNodes.length; d++)initializeDocumentHydrate(c.shadowRoot.childNodes[d], u) } else if (8 === c.nodeType) { const d = c.nodeValue.split("."); "o" === d[0] && (u.set(d[1] + "." + d[2], c), c.nodeValue = "", c["s-en"] = d[3]) } }, computeMode = c => At.map((u => u(c))).find((c => !!c)), createEvent = (c, u, d) => { const v = (c => Le ? getHostRef(c).$hostElement$ : c)(c); return { "emit": c => (Re && !v.isConnected && consoleDevWarn(`The "${u}" event was emitted, but the dispatcher node is no longer connected to the dom.`), emitEvent(v, u, { "bubbles": !!(4 & d), "composed": !!(2 & d), "cancelable": !!(1 & d), "detail": c })) } }, emitEvent = (c, u, d) => { const v = Pt.ce(u, d); return c.dispatchEvent(v), v }, bt = new WeakMap, registerStyle = (c, u, d) => { let v = xt.get(c); Nt && d ? (v = v || new CSSStyleSheet, "string" == typeof v ? v = u : v.replaceSync(u)) : v = u, xt.set(c, v) }, addStyle = (c, u, d, v) => { var E; let k = getScopeId(u, d); const R = xt.get(k); if (!Qe) return k; if (c = 11 === c.nodeType ? c : kt, R) if ("string" == typeof R) { c = c.head || c; let d, U = bt.get(c); if (U || bt.set(c, U = new Set), !U.has(k)) { if (De && c.host && (d = c.querySelector(`[${ht}="${k}"]`))) d.innerHTML = R; else { if (Ve && Pt.$cssShim$) { d = Pt.$cssShim$.createHostStyle(v, k, R, !!(10 & u.$flags$)); const c = d["s-sc"]; c && (k = c, U = null) } else d = kt.createElement("style"), d.innerHTML = R; const H = null !== (E = Pt.$nonce$) && void 0 !== E ? E : queryNonceMetaTagContent(kt); null != H && d.setAttribute("nonce", H), (Ne || Oe) && d.setAttribute(ht, k), c.insertBefore(d, c.querySelector("link")) } U && U.add(k) } } else We && !c.adoptedStyleSheets.includes(R) && (c.adoptedStyleSheets = [...c.adoptedStyleSheets, R]); return k }, attachStyles = c => { const u = c.$cmpMeta$, d = c.$hostElement$, v = u.$flags$, E = createTime("attachStyles", u.$tagName$), k = addStyle(ue && Rt && d.shadowRoot ? d.shadowRoot : d.getRootNode(), u, c.$modeName$, d); (ue || le) && pe && 10 & v && (d["s-sc"] = k, d.classList.add(k + "-h"), le && 2 & v && d.classList.add(k + "-s")), E() }, getScopeId = (c, u) => "sc-" + (ie && u && 32 & c.$flags$ ? c.$tagName$ + "-" + u : c.$tagName$), setAccessor = (c, u, d, v, E, k) => { if (d !== v) { let R = isMemberInElement(c, u), U = u.toLowerCase(); if (ye && "class" === u) { const u = c.classList, E = parseClassList(d), k = parseClassList(v); u.remove(...E.filter((c => c && !k.includes(c)))), u.add(...k.filter((c => c && !E.includes(c)))) } else if (xe && "style" === u) { if (ge) for (const u in d) v && null != v[u] || (!Ne && u.includes("-") ? c.style.removeProperty(u) : c.style[u] = ""); for (const u in v) d && v[u] === d[u] || (!Ne && u.includes("-") ? c.style.setProperty(u, v[u]) : c.style[u] = v[u]) } else if (Se && "key" === u); else if (Ee && "ref" === u) v && v(c); else if (!we || (Le ? R : c.__lookupSetter__(u)) || "o" !== u[0] || "n" !== u[1]) { if (Ce) { const H = isComplexType(v); if ((R || H && null !== v) && !E) try { if (c.tagName.includes("-")) c[u] = v; else { const E = null == v ? "" : v; "list" === u ? R = !1 : null != d && c[u] == E || (c[u] = E) } } catch (c) { } let G = !1; ve && U !== (U = U.replace(/^xlink\:?/, "")) && (u = U, G = !0), null == v || !1 === v ? !1 === v && "" !== c.getAttribute(u) || (ve && G ? c.removeAttributeNS(gt, u) : c.removeAttribute(u)) : (!R || 4 & k || E) && !H && (v = !0 === v ? "" : v, ve && G ? c.setAttributeNS(gt, u, v) : c.setAttribute(u, v)) } } else u = "-" === u[2] ? u.slice(3) : isMemberInElement(It, U) ? U.slice(2) : U[2] + u.slice(3), d && Pt.rel(c, u, d, !1), v && Pt.ael(c, u, v, !1) } }, St = /\s/, parseClassList = c => c ? c.split(St) : [], updateElement = (c, u, d, v) => { const E = 11 === u.$elm$.nodeType && u.$elm$.host ? u.$elm$.host : u.$elm$, k = c && c.$attrs$ || _t, R = u.$attrs$ || _t; if (ge) for (v in k) v in R || setAccessor(E, v, k[v], void 0, d, u.$flags$); for (v in R) setAccessor(E, v, k[v], R[v], d, u.$flags$) }, createElm = (c, u, d, v) => { const E = u.$children$[d]; let k, R, U, H = 0; if (je && !at && (ct = !0, "slot" === E.$tag$ && (tt && v.classList.add(tt + "-s"), E.$flags$ |= E.$children$ ? 2 : 1)), Re && E.$elm$ && consoleDevError(`The JSX ${null !== E.$text$ ? `"${E.$text$}" text` : `"${E.$tag$}" element`} node should not be shared within the same renderer. The renderer caches element lookups in order to improve performance. However, a side effect from this is that the exact same JSX node should not be reused. For more information please see https://stenciljs.com/docs/templating-jsx#avoid-shared-jsx-nodes`), Ae && null !== E.$text$) k = E.$elm$ = kt.createTextNode(E.$text$); else if (je && 1 & E.$flags$) k = E.$elm$ = Pe || Ne ? slotReferenceDebugNode(E) : kt.createTextNode(""); else { if (me && !lt && (lt = "svg" === E.$tag$), k = E.$elm$ = me ? kt.createElementNS(lt ? "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml", je && 2 & E.$flags$ ? "slot-fb" : E.$tag$) : kt.createElement(je && 2 & E.$flags$ ? "slot-fb" : E.$tag$), me && lt && "foreignObject" === E.$tag$ && (lt = !1), _e && updateElement(null, E, lt), (ue || le) && null != tt && k["s-si"] !== tt && k.classList.add(k["s-si"] = tt), E.$children$) for (H = 0; H < E.$children$.length; ++H)R = createElm(c, E, H, k), R && k.appendChild(R); me && ("svg" === E.$tag$ ? lt = !1 : "foreignObject" === k.tagName && (lt = !0)) } return je && (k["s-hn"] = rt, 3 & E.$flags$ && (k["s-sr"] = !0, k["s-cr"] = nt, k["s-sn"] = E.$name$ || "", U = c && c.$children$ && c.$children$[d], U && U.$tag$ === E.$tag$ && c.$elm$ && putBackInOriginalLocation(c.$elm$, !1))), k }, putBackInOriginalLocation = (c, u) => { Pt.$flags$ |= 1; const d = c.childNodes; for (let c = d.length - 1; c >= 0; c--) { const v = d[c]; v["s-hn"] !== rt && v["s-ol"] && (parentReferenceNode(v).insertBefore(v, referenceNode(v)), v["s-ol"].remove(), v["s-ol"] = void 0, ct = !0), u && putBackInOriginalLocation(v, u) } Pt.$flags$ &= -2 }, addVnodes = (c, u, d, v, E, k) => { let R, U = je && c["s-cr"] && c["s-cr"].parentNode || c; for (ue && U.shadowRoot && U.tagName === rt && (U = U.shadowRoot); E <= k; ++E)v[E] && (R = createElm(null, d, E, c), R && (v[E].$elm$ = R, U.insertBefore(R, je ? referenceNode(u) : u))) }, removeVnodes = (c, u, d, v, E) => { for (; u <= d; ++u)(v = c[u]) && (E = v.$elm$, callNodeRefs(v), je && (st = !0, E["s-ol"] ? E["s-ol"].remove() : putBackInOriginalLocation(E, !0)), E.remove()) }, isSameVnode = (c, u) => c.$tag$ === u.$tag$ && (je && "slot" === c.$tag$ ? c.$name$ === u.$name$ : !Se || c.$key$ === u.$key$), referenceNode = c => c && c["s-ol"] || c, parentReferenceNode = c => (c["s-ol"] ? c["s-ol"] : c).parentNode, patch = (c, u) => { const d = u.$elm$ = c.$elm$, v = c.$children$, E = u.$children$, k = u.$tag$, R = u.$text$; let U; Ae && null !== R ? Ae && je && (U = d["s-cr"]) ? U.parentNode.textContent = R : Ae && c.$text$ !== R && (d.data = R) : (me && (lt = "svg" === k || "foreignObject" !== k && lt), (_e || ce) && (de && "slot" === k || updateElement(c, u, lt)), ge && null !== v && null !== E ? ((c, u, d, v) => { let E, k, R = 0, U = 0, H = 0, G = 0, W = u.length - 1, Z = u[0], Y = u[W], J = v.length - 1, K = v[0], X = v[J]; for (; R <= W && U <= J;)if (null == Z) Z = u[++R]; else if (null == Y) Y = u[--W]; else if (null == K) K = v[++U]; else if (null == X) X = v[--J]; else if (isSameVnode(Z, K)) patch(Z, K), Z = u[++R], K = v[++U]; else if (isSameVnode(Y, X)) patch(Y, X), Y = u[--W], X = v[--J]; else if (isSameVnode(Z, X)) !je || "slot" !== Z.$tag$ && "slot" !== X.$tag$ || putBackInOriginalLocation(Z.$elm$.parentNode, !1), patch(Z, X), c.insertBefore(Z.$elm$, Y.$elm$.nextSibling), Z = u[++R], X = v[--J]; else if (isSameVnode(Y, K)) !je || "slot" !== Z.$tag$ && "slot" !== X.$tag$ || putBackInOriginalLocation(Y.$elm$.parentNode, !1), patch(Y, K), c.insertBefore(Y.$elm$, Z.$elm$), Y = u[--W], K = v[++U]; else { if (H = -1, Se) for (G = R; G <= W; ++G)if (u[G] && null !== u[G].$key$ && u[G].$key$ === K.$key$) { H = G; break } Se && H >= 0 ? (k = u[H], k.$tag$ !== K.$tag$ ? E = createElm(u && u[U], d, H, c) : (patch(k, K), u[H] = void 0, E = k.$elm$), K = v[++U]) : (E = createElm(u && u[U], d, U, c), K = v[++U]), E && (je ? parentReferenceNode(Z.$elm$).insertBefore(E, referenceNode(Z.$elm$)) : Z.$elm$.parentNode.insertBefore(E, Z.$elm$)) } R > W ? addVnodes(c, null == v[J + 1] ? null : v[J + 1].$elm$, d, v, U, J) : ge && U > J && removeVnodes(u, R, W) })(d, v, u, E) : null !== E ? (ge && Ae && null !== c.$text$ && (d.textContent = ""), addVnodes(d, null, u, E, 0, E.length - 1)) : ge && null !== v && removeVnodes(v, 0, v.length - 1), me && lt && "svg" === k && (lt = !1)) }, updateFallbackSlotVisibility = c => { const u = c.childNodes; let d, v, E, k, R, U; for (v = 0, E = u.length; v < E; v++)if (d = u[v], 1 === d.nodeType) { if (d["s-sr"]) for (R = d["s-sn"], d.hidden = !1, k = 0; k < E; k++)if (U = u[k].nodeType, u[k]["s-hn"] !== d["s-hn"] || "" !== R) { if (1 === U && R === u[k].getAttribute("slot")) { d.hidden = !0; break } } else if (1 === U || 3 === U && "" !== u[k].textContent.trim()) { d.hidden = !0; break } updateFallbackSlotVisibility(d) } }, wt = [], relocateSlotContent = c => { let u, d, v, E, k, R, U = 0; const H = c.childNodes, G = H.length; for (; U < G; U++) { if (u = H[U], u["s-sr"] && (d = u["s-cr"]) && d.parentNode) for (v = d.parentNode.childNodes, E = u["s-sn"], R = v.length - 1; R >= 0; R--)d = v[R], d["s-cn"] || d["s-nr"] || d["s-hn"] === u["s-hn"] || (isNodeLocatedInSlot(d, E) ? (k = wt.find((c => c.$nodeToRelocate$ === d)), st = !0, d["s-sn"] = d["s-sn"] || E, k ? k.$slotRefNode$ = u : wt.push({ "$slotRefNode$": u, "$nodeToRelocate$": d }), d["s-sr"] && wt.map((c => { isNodeLocatedInSlot(c.$nodeToRelocate$, d["s-sn"]) && (k = wt.find((c => c.$nodeToRelocate$ === d)), k && !c.$slotRefNode$ && (c.$slotRefNode$ = k.$slotRefNode$)) }))) : wt.some((c => c.$nodeToRelocate$ === d)) || wt.push({ "$nodeToRelocate$": d })); 1 === u.nodeType && relocateSlotContent(u) } }, isNodeLocatedInSlot = (c, u) => 1 === c.nodeType ? null === c.getAttribute("slot") && "" === u || c.getAttribute("slot") === u : c["s-sn"] === u || "" === u, callNodeRefs = c => { Ee && (c.$attrs$ && c.$attrs$.ref && c.$attrs$.ref(null), c.$children$ && c.$children$.map(callNodeRefs)) }, renderVdom = (c, u) => { const d = c.$hostElement$, v = c.$cmpMeta$, E = c.$vnode$ || newVNode(null, null), k = isHost(u) ? u : h(null, null, u); if (rt = d.tagName, Re && Array.isArray(u) && u.some(isHost)) throw new Error(`The <Host> must be the single root component.\nLooks like the render() function of "${rt.toLowerCase()}" is returning an array that contains the <Host>.\n\nThe render() function should look like this instead:\n\nrender() {\n  // Do not return an array\n  return (\n    <Host>{content}</Host>\n  );\n}\n  `); if (ce && v.$attrsToReflect$ && (k.$attrs$ = k.$attrs$ || {}, v.$attrsToReflect$.map((([c, u]) => k.$attrs$[u] = d[c]))), k.$tag$ = null, k.$flags$ |= 4, c.$vnode$ = k, k.$elm$ = E.$elm$ = ue && d.shadowRoot || d, (le || ue) && (tt = d["s-sc"]), je && (nt = d["s-cr"], at = Rt && !!(1 & v.$flags$), st = !1), patch(E, k), je) { if (Pt.$flags$ |= 1, ct) { let c, u, d, v, E, R; relocateSlotContent(k.$elm$); let U = 0; for (; U < wt.length; U++)c = wt[U], u = c.$nodeToRelocate$, u["s-ol"] || (d = Pe || Ne ? originalLocationDebugNode(u) : kt.createTextNode(""), d["s-nr"] = u, u.parentNode.insertBefore(u["s-ol"] = d, u)); for (U = 0; U < wt.length; U++)if (c = wt[U], u = c.$nodeToRelocate$, c.$slotRefNode$) { for (v = c.$slotRefNode$.parentNode, E = c.$slotRefNode$.nextSibling, d = u["s-ol"]; d = d.previousSibling;)if (R = d["s-nr"], R && R["s-sn"] === u["s-sn"] && v === R.parentNode && (R = R.nextSibling, !R || !R["s-nr"])) { E = R; break } (!E && v !== u.parentNode || u.nextSibling !== E) && u !== E && (!u["s-hn"] && u["s-ol"] && (u["s-hn"] = u["s-ol"].parentNode.nodeName), v.insertBefore(u, E)) } else 1 === u.nodeType && (u.hidden = !0) } st && updateFallbackSlotVisibility(k.$elm$), Pt.$flags$ &= -2, wt.length = 0 } }, slotReferenceDebugNode = c => kt.createComment(`<slot${c.$name$ ? ' name="' + c.$name$ + '"' : ""}> (host=${rt.toLowerCase()})`), originalLocationDebugNode = c => kt.createComment("org-location for " + (c.localName ? `<${c.localName}> (host=${c["s-hn"]})` : `[${c.textContent}]`)), attachToAncestor = (c, u) => { Ke && u && !c.$onRenderResolve$ && u["s-p"] && u["s-p"].push(new Promise((u => c.$onRenderResolve$ = u))) }, scheduleUpdate = (c, u) => { if (ke && ge && (c.$flags$ |= 16), Ke && 4 & c.$flags$) return void (c.$flags$ |= 512); attachToAncestor(c, c.$ancestorComponent$); const dispatch = () => dispatchHooks(c, u); return ke ? Ft(dispatch) : dispatch() }, dispatchHooks = (c, u) => { const d = c.$hostElement$, v = createTime("scheduleUpdate", c.$cmpMeta$.$tagName$), E = Le ? c.$lazyInstance$ : d; let k; return u ? (Le && K && (c.$flags$ |= 256, c.$queuedListeners$ && (c.$queuedListeners$.map((([c, u]) => safeCall(E, c, u))), c.$queuedListeners$ = null)), emitLifecycleEvent(d, "componentWillLoad"), H && (k = safeCall(E, "componentWillLoad"))) : (emitLifecycleEvent(d, "componentWillUpdate"), G && (k = safeCall(E, "componentWillUpdate"))), emitLifecycleEvent(d, "componentWillRender"), W && (k = then(k, (() => safeCall(E, "componentWillRender")))), v(), then(k, (() => updateComponent(c, E, u))) }, updateComponent = async (c, u, d) => { const v = c.$hostElement$, E = createTime("update", c.$cmpMeta$.$tagName$), k = v["s-rc"]; he && d && attachStyles(c); const R = createTime("render", c.$cmpMeta$.$tagName$); if (Re && (c.$flags$ |= 1024), Ne ? await callRender(c, u, v) : callRender(c, u, v), Ve && Pt.$cssShim$ && Pt.$cssShim$.updateHost(v), Re && (c.$renderCount$++, c.$flags$ &= -1025), Ne) try { serverSideConnected(v), d && (1 & c.$cmpMeta$.$flags$ ? v["s-en"] = "" : 2 & c.$cmpMeta$.$flags$ && (v["s-en"] = "c")) } catch (c) { consoleError(c, v) } if (Ke && k && (k.map((c => c())), v["s-rc"] = void 0), R(), E(), Ke) { const u = v["s-p"], postUpdate = () => postUpdateComponent(c); 0 === u.length ? postUpdate() : (Promise.all(u).then(postUpdate), c.$flags$ |= 4, u.length = 0) } else postUpdateComponent(c) }, callRender = (c, u, d) => { const E = !!v, k = !!Le, R = !!ke, U = !!ge; try { if (ut = u, u = (E || u.render) && u.render(), U && R && (c.$flags$ &= -17), (U || k) && (c.$flags$ |= 2), J || ce) if (Te || ce) { if (Ne) return Promise.resolve(u).then((u => renderVdom(c, u))); renderVdom(c, u) } else d.textContent = u } catch (u) { consoleError(u, c.$hostElement$) } return ut = null, null }, postUpdateComponent = c => { const u = c.$cmpMeta$.$tagName$, d = c.$hostElement$, v = createTime("postUpdate", u), k = Le ? c.$lazyInstance$ : d, H = c.$ancestorComponent$; U && (Re && (c.$flags$ |= 1024), safeCall(k, "componentDidRender"), Re && (c.$flags$ &= -1025)), emitLifecycleEvent(d, "componentDidRender"), 64 & c.$flags$ ? (R && (Re && (c.$flags$ |= 1024), safeCall(k, "componentDidUpdate"), Re && (c.$flags$ &= -1025)), emitLifecycleEvent(d, "componentDidUpdate"), v()) : (c.$flags$ |= 64, Ke && pe && addHydratedFlag(d), E && (Re && (c.$flags$ |= 2048), safeCall(k, "componentDidLoad"), Re && (c.$flags$ &= -2049)), emitLifecycleEvent(d, "componentDidLoad"), v(), Ke && (c.$onReadyResolve$(d), H || appDidLoad(u))), Oe && d["s-hmr-load"] && d["s-hmr-load"](), oe && Le && c.$onInstanceResolve$(d), Ke && (c.$onRenderResolve$ && (c.$onRenderResolve$(), c.$onRenderResolve$ = void 0), 512 & c.$flags$ && nextTick((() => scheduleUpdate(c, !1))), c.$flags$ &= -517) }, appDidLoad = c => { pe && addHydratedFlag(kt.documentElement), Xe && (Pt.$flags$ |= 2), nextTick((() => emitEvent(It, "appload", { "detail": { "namespace": et } }))), Fe && performance.measure && performance.measure(`[Stencil] ${et} initial load (by ${c})`, "st:app:start") }, safeCall = (c, u, d) => { if (c && c[u]) try { return c[u](d) } catch (c) { consoleError(c) } }, then = (c, u) => c && c.then ? c.then(u) : u(), emitLifecycleEvent = (c, u) => { $e && emitEvent(c, "stencil_" + u, { "bubbles": !0, "composed": !0, "detail": { "namespace": et } }) }, addHydratedFlag = c => Ue ? c.classList.add("hydrated") : Be ? c.setAttribute("hydrated", "") : void 0, serverSideConnected = c => { const u = c.children; if (null != u) for (let c = 0, d = u.length; c < d; c++) { const d = u[c]; "function" == typeof d.connectedCallback && d.connectedCallback(), serverSideConnected(d) } }, setValue = (c, u, d, v) => { const E = getHostRef(c), k = Le ? E.$hostElement$ : c, R = E.$instanceValues$.get(u), U = E.$flags$, H = Le ? E.$lazyInstance$ : k; var G, W; G = d, W = v.$members$[u][0], d = null == G || isComplexType(G) ? G : ze && 4 & W ? "false" !== G && ("" === G || !!G) : qe && 2 & W ? parseFloat(G) : Ge && 1 & W ? String(G) : G; const Z = Number.isNaN(R) && Number.isNaN(d); if ((!Le || !(8 & U) || void 0 === R) && (d !== R && !Z) && (E.$instanceValues$.set(u, d), Re && (1024 & E.$flags$ ? consoleDevWarn(`The state/prop "${u}" changed during rendering. This can potentially lead to infinite-loops and other bugs.`, "\nElement", k, "\nNew value", d, "\nOld value", R) : 2048 & E.$flags$ && consoleDevWarn(`The state/prop "${u}" changed during "componentDidLoad()", this triggers extra re-renders, try to setup on "componentWillLoad()"`, "\nElement", k, "\nNew value", d, "\nOld value", R)), !Le || H)) { if (Ie && v.$watchers$ && 128 & U) { const c = v.$watchers$[u]; c && c.map((c => { try { H[c](d, R, u) } catch (c) { consoleError(c, k) } })) } if (ge && 2 == (18 & U)) { if (Ze && H.componentShouldUpdate && !1 === H.componentShouldUpdate(d, R, u)) return; scheduleUpdate(E, !1) } } }, proxyComponent = (c, u, d) => { if (re && u.$members$) { Ie && c.watchers && (u.$watchers$ = c.watchers); const v = Object.entries(u.$members$), E = c.prototype; if (v.map((([c, [v]]) => { (se || fe) && (31 & v || (!Le || 2 & d) && 32 & v) ? Object.defineProperty(E, c, { "get"() { return ((c, u) => getHostRef(c).$instanceValues$.get(u))(this, c) }, "set"(E) { if (Re) { const E = getHostRef(this); 1 & d || 8 & E.$flags$ || !(31 & v) || 1024 & v || consoleDevWarn(`@Prop() "${c}" on <${u.$tagName$}> is immutable but was modified from within the component.\nMore information: https://stenciljs.com/docs/properties#prop-mutability`) } setValue(this, c, E, u) }, "configurable": !0, "enumerable": !0 }) : Le && oe && 1 & d && 64 & v && Object.defineProperty(E, c, { "value"(...u) { const d = getHostRef(this); return d.$onInstancePromise$.then((() => d.$lazyInstance$[c](...u))) } }) })), ae && (!Le || 1 & d)) { const d = new Map; E.attributeChangedCallback = function (c, u, v) { Pt.jmp((() => { const u = d.get(c); if (this.hasOwnProperty(u)) v = this[u], delete this[u]; else if (E.hasOwnProperty(u) && "number" == typeof this[u] && this[u] == v) return; this[u] = (null !== v || "boolean" != typeof this[u]) && v })) }, c.observedAttributes = v.filter((([c, u]) => 15 & u[0])).map((([c, v]) => { const E = v[1] || c; return d.set(E, c), ce && 512 & v[0] && u.$attrsToReflect$.push([c, E]), E })) } } return c }, initializeComponent = async (c, u, v, E, k) => { if ((Le || Ne || he) && !(32 & u.$flags$)) { if (Le || De) { if (u.$flags$ |= 32, (k = loadModule(v, u, E)).then) { const c = (R = `st:load:${v.$tagName$}:${u.$modeName$}`, U = `[Stencil] Load module for <${v.$tagName$}>`, Fe && performance.mark ? (0 === performance.getEntriesByName(R, "mark").length && performance.mark(R), () => { 0 === performance.getEntriesByName(U, "measure").length && performance.measure(U, R) }) : () => { }); k = await k, c() } if ((Re || Pe) && !k) throw new Error(`Constructor for "${v.$tagName$}#${u.$modeName$}" was not found`); re && !k.isProxied && (Ie && (v.$watchers$ = k.watchers), proxyComponent(k, v, 2), k.isProxied = !0); const c = createTime("createInstance", v.$tagName$); re && (u.$flags$ |= 8); try { new k(u) } catch (c) { consoleError(c) } re && (u.$flags$ &= -9), Ie && (u.$flags$ |= 128), c(), fireConnectedCallback(u.$lazyInstance$) } else k = c.constructor, u.$flags$ |= 32, customElements.whenDefined(v.$tagName$).then((() => u.$flags$ |= 128)); if (he && k.style) { let E = k.style; ie && "string" != typeof E && (E = E[u.$modeName$ = computeMode(c)], Ne && u.$modeName$ && c.setAttribute("s-mode", u.$modeName$)); const R = getScopeId(v, u.$modeName$); if (!xt.has(R)) { const c = createTime("registerStyles", v.$tagName$); !Ne && ue && He && 8 & v.$flags$ && (E = await d.e(576).then(d.bind(d, 576)).then((c => c.scopeCss(E, R, !1)))), registerStyle(R, E, !!(1 & v.$flags$)), c() } } } var R, U; const H = u.$ancestorComponent$, schedule = () => scheduleUpdate(u, !0); Ke && H && H["s-rc"] ? H["s-rc"].push(schedule) : schedule() }, fireConnectedCallback = c => { Le && Z && safeCall(c, "connectedCallback") }, connectedCallback = c => { if (!(1 & Pt.$flags$)) { const u = getHostRef(c), d = u.$cmpMeta$, v = createTime("connectedCallback", d.$tagName$); if (te && addHostEventListeners(c, u, d.$listeners$, !0), 1 & u.$flags$) addHostEventListeners(c, u, d.$listeners$, !1), fireConnectedCallback(u.$lazyInstance$); else { let v; if (u.$flags$ |= 1, De && (v = c.getAttribute(ft), v)) { if (ue && Rt && 1 & d.$flags$) { const u = ie ? addStyle(c.shadowRoot, d, c.getAttribute("s-mode")) : addStyle(c.shadowRoot, d); c.classList.remove(u + "-h", u + "-s") } ((c, u, d, v) => { const E = createTime("hydrateClient", u), k = c.shadowRoot, R = [], U = ue && k ? [] : null, H = v.$vnode$ = newVNode(u, null); Pt.$orgLocNodes$ || initializeDocumentHydrate(kt.body, Pt.$orgLocNodes$ = new Map), c[ft] = d, c.removeAttribute(ft), clientHydrate(H, R, [], U, c, c, d), R.map((c => { const d = c.$hostId$ + "." + c.$nodeId$, v = Pt.$orgLocNodes$.get(d), E = c.$elm$; v && Rt && "" === v["s-en"] && v.parentNode.insertBefore(E, v.nextSibling), k || (E["s-hn"] = u, v && (E["s-ol"] = v, E["s-ol"]["s-nr"] = E)), Pt.$orgLocNodes$.delete(d) })), ue && k && U.map((c => { c && k.appendChild(c) })), E() })(c, d.$tagName$, v, u) } if (je && !v && (Ne || (de || ue) && 12 & d.$flags$) && setContentReference(c), Ke) { let d = c; for (; d = d.parentNode || d.host;)if (De && 1 === d.nodeType && d.hasAttribute("s-id") && d["s-p"] || d["s-p"]) { attachToAncestor(u, u.$ancestorComponent$ = d); break } } se && !Ne && d.$members$ && Object.entries(d.$members$).map((([u, [d]]) => { if (31 & d && c.hasOwnProperty(u)) { const d = c[u]; delete c[u], c[u] = d } })), Je ? nextTick((() => initializeComponent(c, u, d))) : initializeComponent(c, u, d) } v() } }, setContentReference = c => { const u = c["s-cr"] = kt.createComment(Pe ? `content-ref (host=${c.localName})` : ""); u["s-cn"] = !0, c.insertBefore(u, c.firstChild) }, disconnectedCallback = c => { if (!(1 & Pt.$flags$)) { const u = getHostRef(c), d = Le ? u.$lazyInstance$ : c; K && u.$rmListeners$ && (u.$rmListeners$.map((c => c())), u.$rmListeners$ = void 0), Ve && Pt.$cssShim$ && Pt.$cssShim$.removeHost(c), Le && Y && safeCall(d, "disconnectedCallback"), k && safeCall(d, "componentDidUnload") } }, proxyCustomElement = (c, u) => { const d = { "$flags$": u[0], "$tagName$": u[1] }; re && (d.$members$ = u[2]), K && (d.$listeners$ = u[3]), Ie && (d.$watchers$ = c.$watchers$), ce && (d.$attrsToReflect$ = []), ue && !Rt && 1 & d.$flags$ && (d.$flags$ |= 8); const v = c.prototype.connectedCallback, E = c.prototype.disconnectedCallback; return Object.assign(c.prototype, { "__registerHost"() { registerHost(this, d) }, "connectedCallback"() { connectedCallback(this), Z && v && v.call(this) }, "disconnectedCallback"() { disconnectedCallback(this), Y && E && E.call(this) }, "__attachShadow"() { Rt ? Ye ? this.attachShadow({ "mode": "open", "delegatesFocus": !!(16 & d.$flags$) }) : this.attachShadow({ "mode": "open" }) : this.shadowRoot = this } }), c.is = d.$tagName$, proxyComponent(c, d, 3) }, addHostEventListeners = (c, u, d, v) => { K && d && (te && (d = v ? d.filter((([c]) => 32 & c)) : d.filter((([c]) => !(32 & c)))), d.map((([d, v, E]) => { const k = ne ? getHostListenerTarget(c, d) : c, R = hostListenerProxy(u, E), U = hostListenerOpts(d); Pt.ael(k, v, R, U), (u.$rmListeners$ = u.$rmListeners$ || []).push((() => Pt.rel(k, v, R, U))) }))) }, hostListenerProxy = (c, u) => d => { try { Le ? 256 & c.$flags$ ? c.$lazyInstance$[u](d) : (c.$queuedListeners$ = c.$queuedListeners$ || []).push([u, d]) : c.$hostElement$[u](d) } catch (c) { consoleError(c) } }, getHostListenerTarget = (c, u) => Q && 4 & u ? kt : X && 8 & u ? It : ee && 16 & u ? kt.body : te && 32 & u ? c.parentElement : c, hostListenerOpts = c => Mt ? { "passive": !!(1 & c), "capture": !!(2 & c) } : !!(2 & c), Et = new WeakMap, getHostRef = c => Et.get(c), registerHost = (c, u) => { const d = { "$flags$": 0, "$hostElement$": c, "$cmpMeta$": u, "$instanceValues$": new Map }; return Re && (d.$renderCount$ = 0), oe && Le && (d.$onInstancePromise$ = new Promise((c => d.$onInstanceResolve$ = c))), Ke && (d.$onReadyPromise$ = new Promise((c => d.$onReadyResolve$ = c)), c["s-p"] = [], c["s-rc"] = []), addHostEventListeners(c, d, u.$listeners$, !1), Et.set(c, d) }, isMemberInElement = (c, u) => u in c, consoleError = (c, u) => (ot || console.error)(c, u), Ct = Me ? ["STENCIL:"] : ["%cstencil", "color: white;background:#4c47ff;font-weight: bold; font-size:10px; padding:2px 6px; border-radius: 5px"], consoleDevError = (...c) => console.error(...Ct, ...c), consoleDevWarn = (...c) => console.warn(...Ct, ...c), Tt = new Map, loadModule = (c, u, v) => { const E = c.$tagName$.replace(/-/g, "_"), k = c.$lazyBundleId$; if (Re && "string" != typeof k) return void consoleDevError(`Trying to lazily load component <${c.$tagName$}> with style mode "${u.$modeName$}", but it does not exist.`); const R = !Oe && Tt.get(k); return R ? R[E] : d(1993)(`./${k}.entry.js${Oe && v ? "?s-hmr=" + v : ""}`).then((c => (Oe || Tt.set(k, c), c[E])), consoleError) }, xt = new Map, At = [], It = "undefined" != typeof window ? window : {}, kt = (Ve && It.CSS, It.document || { "head": {} }), Ot = It.HTMLElement || class { }, Pt = { "$flags$": 0, "$resourcesUrl$": "", "jmp": c => c(), "raf": c => requestAnimationFrame(c), "ael": (c, u, d, v) => c.addEventListener(u, d, v), "rel": (c, u, d, v) => c.removeEventListener(u, d, v), "ce": (c, u) => new CustomEvent(c, u) }, Rt = !He || !ue || (() => (kt.head.attachShadow + "").indexOf("[native") > -1)(), Mt = (() => { let c = !1; try { kt.addEventListener("e", null, Object.defineProperty({}, "passive", { "get"() { c = !0 } })) } catch (c) { } return c })(), Nt = !!We && (() => { try { return new CSSStyleSheet, "function" == typeof (new CSSStyleSheet).replaceSync } catch (c) { } return !1 })(), Dt = [], $t = [], Lt = [], queueTask = (c, u) => d => { c.push(d), pt || (pt = !0, u && 4 & Pt.$flags$ ? nextTick(flush) : Pt.raf(flush)) }, consume = c => { for (let u = 0; u < c.length; u++)try { c[u](performance.now()) } catch (c) { consoleError(c) } c.length = 0 }, consumeTimeout = (c, u) => { let d = 0, v = 0; for (; d < c.length && (v = performance.now()) < u;)try { c[d++](v) } catch (c) { consoleError(c) } d === c.length ? c.length = 0 : 0 !== d && c.splice(0, d) }, flush = () => { if (Xe && dt++, consume(Dt), Xe) { const c = 2 == (6 & Pt.$flags$) ? performance.now() + 14 * Math.ceil(.1 * dt) : 1 / 0; consumeTimeout($t, c), consumeTimeout(Lt, c), $t.length > 0 && (Lt.push(...$t), $t.length = 0), (pt = Dt.length + $t.length + Lt.length > 0) ? Pt.raf(flush) : dt = 0 } else consume($t), (pt = Dt.length > 0) && Pt.raf(flush) }, nextTick = c => { return Promise.resolve(u).then(c); var u }, Ft = queueTask($t, !0) }, "1993": function (c) { function webpackEmptyAsyncContext(c) { return Promise.resolve().then((function () { var u = new Error("Cannot find module '" + c + "'"); throw u.code = "MODULE_NOT_FOUND", u })) } webpackEmptyAsyncContext.keys = function () { return [] }, webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext, webpackEmptyAsyncContext.id = 1993, c.exports = webpackEmptyAsyncContext }, "2723": function (c, u, d) { "use strict"; var v = {}; d.r(v), d.d(v, { "BrowserClient": function () { return BrowserClient }, "SDK_VERSION": function () { return ie }, "SEMANTIC_ATTRIBUTE_SENTRY_OP": function () { return Fe }, "SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN": function () { return je }, "SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE": function () { return Le }, "SEMANTIC_ATTRIBUTE_SENTRY_SOURCE": function () { return $e }, "Scope": function () { return be }, "WINDOW": function () { return bt }, "addBreadcrumb": function () { return addBreadcrumb }, "addEventProcessor": function () { return addEventProcessor }, "addIntegration": function () { return addIntegration }, "addTracingExtensions": function () { return addTracingExtensions }, "attachErrorHandler": function () { return attachErrorHandler }, "breadcrumbsIntegration": function () { return breadcrumbsIntegration }, "browserApiErrorsIntegration": function () { return browserApiErrorsIntegration }, "browserProfilingIntegration": function () { return browserProfilingIntegration }, "browserTracingIntegration": function () { return browserTracingIntegration_browserTracingIntegration }, "captureConsoleIntegration": function () { return captureConsoleIntegration }, "captureEvent": function () { return captureEvent }, "captureException": function () { return captureException }, "captureFeedback": function () { return captureFeedback }, "captureMessage": function () { return captureMessage }, "captureSession": function () { return captureSession }, "captureUserFeedback": function () { return captureUserFeedback }, "chromeStackLineParser": function () { return Ht }, "close": function () { return exports_close }, "contextLinesIntegration": function () { return contextLinesIntegration }, "continueTrace": function () { return continueTrace }, "createTracingMixins": function () { return createTracingMixins }, "createTransport": function () { return createTransport }, "createUserFeedbackEnvelope": function () { return createUserFeedbackEnvelope }, "debugIntegration": function () { return debugIntegration }, "dedupeIntegration": function () { return dedupeIntegration }, "defaultRequestInstrumentationOptions": function () { return wa }, "defaultStackLineParsers": function () { return Xt }, "defaultStackParser": function () { return Qt }, "endSession": function () { return endSession }, "eventFromException": function () { return eventFromException }, "eventFromMessage": function () { return eventFromMessage }, "exceptionFromError": function () { return exceptionFromError }, "extraErrorDataIntegration": function () { return extraErrorDataIntegration }, "feedbackAsyncIntegration": function () { return ua }, "feedbackIntegration": function () { return da }, "feedbackSyncIntegration": function () { return da }, "flush": function () { return flush }, "forceLoad": function () { return forceLoad }, "functionToStringIntegration": function () { return functionToStringIntegration }, "geckoStackLineParser": function () { return Gt }, "getActiveSpan": function () { return getActiveSpan }, "getClient": function () { return currentScopes_getClient }, "getCurrentHub": function () { return On }, "getCurrentScope": function () { return currentScopes_getCurrentScope }, "getDefaultIntegrations": function () { return getDefaultIntegrations }, "getFeedback": function () { return getFeedback }, "getGlobalScope": function () { return currentScopes_getGlobalScope }, "getIsolationScope": function () { return currentScopes_getIsolationScope }, "getReplay": function () { return getReplay }, "getRootSpan": function () { return getRootSpan }, "getSpanDescendants": function () { return getSpanDescendants }, "getSpanStatusFromHttpCode": function () { return getSpanStatusFromHttpCode }, "globalHandlersIntegration": function () { return globalHandlersIntegration }, "httpClientIntegration": function () { return httpClientIntegration }, "httpContextIntegration": function () { return httpContextIntegration }, "inboundFiltersIntegration": function () { return inboundFiltersIntegration }, "init": function () { return sdk_init }, "instrumentOutgoingRequests": function () { return instrumentOutgoingRequests }, "isInitialized": function () { return isInitialized }, "lastEventId": function () { return lastEventId }, "lazyLoadIntegration": function () { return lazyLoadIntegration }, "linkedErrorsIntegration": function () { return linkedErrorsIntegration }, "makeBrowserOfflineTransport": function () { return makeBrowserOfflineTransport }, "makeFetchTransport": function () { return makeFetchTransport }, "makeMultiplexedTransport": function () { return makeMultiplexedTransport }, "metrics": function () { return ya }, "moduleMetadataIntegration": function () { return moduleMetadataIntegration }, "onLoad": function () { return onLoad }, "opera10StackLineParser": function () { return Yt }, "opera11StackLineParser": function () { return Kt }, "parameterize": function () { return parameterize }, "registerSpanErrorInstrumentation": function () { return registerSpanErrorInstrumentation }, "replayCanvasIntegration": function () { return replayCanvasIntegration }, "replayIntegration": function () { return replayIntegration }, "reportingObserverIntegration": function () { return reportingObserverIntegration }, "rewriteFramesIntegration": function () { return rewriteFramesIntegration }, "sendFeedback": function () { return sendFeedback }, "sessionTimingIntegration": function () { return sessionTimingIntegration }, "setContext": function () { return setContext }, "setCurrentClient": function () { return setCurrentClient }, "setExtra": function () { return setExtra }, "setExtras": function () { return setExtras }, "setHttpStatus": function () { return setHttpStatus }, "setMeasurement": function () { return setMeasurement }, "setTag": function () { return setTag }, "setTags": function () { return setTags }, "setUser": function () { return setUser }, "showReportDialog": function () { return showReportDialog }, "spanToBaggageHeader": function () { return spanToBaggageHeader }, "spanToJSON": function () { return spanUtils_spanToJSON }, "spanToTraceHeader": function () { return spanToTraceHeader }, "startBrowserTracingNavigationSpan": function () { return startBrowserTracingNavigationSpan }, "startBrowserTracingPageLoadSpan": function () { return startBrowserTracingPageLoadSpan }, "startInactiveSpan": function () { return startInactiveSpan }, "startNewTrace": function () { return startNewTrace }, "startSession": function () { return startSession }, "startSpan": function () { return startSpan }, "startSpanManual": function () { return startSpanManual }, "thirdPartyErrorFilterIntegration": function () { return thirdPartyErrorFilterIntegration }, "vueIntegration": function () { return vueIntegration }, "winjsStackLineParser": function () { return Wt }, "withActiveSpan": function () { return withActiveSpan }, "withIsolationScope": function () { return currentScopes_withIsolationScope }, "withScope": function () { return currentScopes_withScope }, "zodErrorsIntegration": function () { return zodErrorsIntegration } }); d(7889), d(5808); var E = d(5325), k = d(1682), R = d(8682), U = d(8591), H = d(1413), G = d(9963), W = d(1490), Z = d(1724), Y = d(3096), J = d(2762), K = d(989), X = d(2474), Q = d(6908), ee = d(5210), te = d(5660), ne = d(9400), re = d(3244), oe = d(606); const ie = "8.30.0", ae = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__, se = globalThis; function worldwide_getGlobalSingleton(c, u, d) { const v = d || se, E = v.__SENTRY__ = v.__SENTRY__ || {}, k = E[ie] = E[ie] || {}; return k[c] || (k[c] = u()) } const ce = ["debug", "info", "warn", "error", "log", "assert", "trace"], le = {}; function logger_consoleSandbox(c) { if (!("console" in se)) return c(); const u = se.console, d = {}, v = Object.keys(le); v.forEach((c => { const v = le[c]; d[c] = u[c], u[c] = v })); try { return c() } finally { v.forEach((c => { u[c] = d[c] })) } } const ue = worldwide_getGlobalSingleton("logger", (function makeLogger() { let c = !1; const u = { "enable": () => { c = !0 }, "disable": () => { c = !1 }, "isEnabled": () => c }; return ae ? ce.forEach((d => { u[d] = (...u) => { c && logger_consoleSandbox((() => { se.console[d](`Sentry Logger [${d}]:`, ...u) })) } })) : ce.forEach((c => { u[c] = () => { } })), u })), de = Object.prototype.toString; function is_isError(c) { switch (de.call(c)) { case "[object Error]": case "[object Exception]": case "[object DOMException]": return !0; default: return is_isInstanceOf(c, Error) } } function isBuiltin(c, u) { return de.call(c) === `[object ${u}]` } function isErrorEvent(c) { return isBuiltin(c, "ErrorEvent") } function isDOMError(c) { return isBuiltin(c, "DOMError") } function is_isString(c) { return isBuiltin(c, "String") } function isParameterizedString(c) { return "object" == typeof c && null !== c && "__sentry_template_string__" in c && "__sentry_template_values__" in c } function is_isPrimitive(c) { return null === c || isParameterizedString(c) || "object" != typeof c && "function" != typeof c } function isPlainObject(c) { return isBuiltin(c, "Object") } function is_isEvent(c) { return "undefined" != typeof Event && is_isInstanceOf(c, Event) } function is_isThenable(c) { return Boolean(c && c.then && "function" == typeof c.then) } function is_isInstanceOf(c, u) { try { return c instanceof u } catch (c) { return !1 } } function is_isVueViewModel(c) { return !("object" != typeof c || null === c || !c.__isVue && !c._isVue) } const pe = se, fe = 80; function browser_htmlTreeAsString(c, u = {}) { if (!c) return "<unknown>"; try { let d = c; const v = 5, E = []; let k = 0, R = 0; const U = " > ", H = U.length; let G; const W = Array.isArray(u) ? u : u.keyAttrs, Z = !Array.isArray(u) && u.maxStringLength || fe; for (; d && k++ < v && (G = _htmlElementAsString(d, W), !("html" === G || k > 1 && R + E.length * H + G.length >= Z));)E.push(G), R += G.length, d = d.parentNode; return E.reverse().join(U) } catch (c) { return "<unknown>" } } function _htmlElementAsString(c, u) { const d = c, v = []; if (!d || !d.tagName) return ""; if (pe.HTMLElement && d instanceof HTMLElement && d.dataset) { if (d.dataset.sentryComponent) return d.dataset.sentryComponent; if (d.dataset.sentryElement) return d.dataset.sentryElement } v.push(d.tagName.toLowerCase()); const E = u && u.length ? u.filter((c => d.getAttribute(c))).map((c => [c, d.getAttribute(c)])) : null; if (E && E.length) E.forEach((c => { v.push(`[${c[0]}="${c[1]}"]`) })); else { d.id && v.push(`#${d.id}`); const c = d.className; if (c && is_isString(c)) { const u = c.split(/\s+/); for (const c of u) v.push(`.${c}`) } } const k = ["aria-label", "type", "name", "title", "alt"]; for (const c of k) { const u = d.getAttribute(c); u && v.push(`[${c}="${u}"]`) } return v.join("") } function string_truncate(c, u = 0) { return "string" != typeof c || 0 === u || c.length <= u ? c : `${c.slice(0, u)}...` } function string_snipLine(c, u) { let d = c; const v = d.length; if (v <= 150) return d; u > v && (u = v); let E = Math.max(u - 60, 0); E < 5 && (E = 0); let k = Math.min(E + 140, v); return k > v - 5 && (k = v), k === v && (E = Math.max(k - 140, 0)), d = d.slice(E, k), E > 0 && (d = `'{snip} ${d}`), k < v && (d += " {snip}"), d } function safeJoin(c, u) { if (!Array.isArray(c)) return ""; const d = []; for (let u = 0; u < c.length; u++) { const v = c[u]; try { is_isVueViewModel(v) ? d.push("[VueViewModel]") : d.push(String(v)) } catch (c) { d.push("[value cannot be serialized]") } } return d.join(u) } function isMatchingPattern(c, u, d = !1) { return !!is_isString(c) && (function isRegExp(c) { return isBuiltin(c, "RegExp") }(u) ? u.test(c) : !!is_isString(u) && (d ? c === u : c.includes(u))) } function stringMatchesSomePattern(c, u = [], d = !1) { return u.some((u => isMatchingPattern(c, u, d))) } function fill(c, u, d) { if (!(u in c)) return; const v = c[u], E = d(v); "function" == typeof E && markFunctionWrapped(E, v), c[u] = E } function object_addNonEnumerableProperty(c, u, d) { try { Object.defineProperty(c, u, { "value": d, "writable": !0, "configurable": !0 }) } catch (d) { ae && ue.log(`Failed to add non-enumerable property "${u}" to object`, c) } } function markFunctionWrapped(c, u) { try { const d = u.prototype || {}; c.prototype = u.prototype = d, object_addNonEnumerableProperty(c, "__sentry_original__", u) } catch (c) { } } function getOriginalFunction(c) { return c.__sentry_original__ } function convertToPlainObject(c) { if (is_isError(c)) return { "message": c.message, "name": c.name, "stack": c.stack, ...getOwnProperties(c) }; if (is_isEvent(c)) { const u = { "type": c.type, "target": serializeEventTarget(c.target), "currentTarget": serializeEventTarget(c.currentTarget), ...getOwnProperties(c) }; return "undefined" != typeof CustomEvent && is_isInstanceOf(c, CustomEvent) && (u.detail = c.detail), u } return c } function serializeEventTarget(c) { try { return function is_isElement(c) { return "undefined" != typeof Element && is_isInstanceOf(c, Element) }(c) ? browser_htmlTreeAsString(c) : Object.prototype.toString.call(c) } catch (c) { return "<unknown>" } } function getOwnProperties(c) { if ("object" == typeof c && null !== c) { const u = {}; for (const d in c) Object.prototype.hasOwnProperty.call(c, d) && (u[d] = c[d]); return u } return {} } function object_dropUndefinedKeys(c) { return _dropUndefinedKeys(c, new Map) } function _dropUndefinedKeys(c, u) { if (function isPojo(c) { if (!isPlainObject(c)) return !1; try { const u = Object.getPrototypeOf(c).constructor.name; return !u || "Object" === u } catch (c) { return !0 } }(c)) { const d = u.get(c); if (void 0 !== d) return d; const v = {}; u.set(c, v); for (const d of Object.keys(c)) void 0 !== c[d] && (v[d] = _dropUndefinedKeys(c[d], u)); return v } if (Array.isArray(c)) { const d = u.get(c); if (void 0 !== d) return d; const v = []; return u.set(c, v), c.forEach((c => { v.push(_dropUndefinedKeys(c, u)) })), v } return c } function misc_uuid4() { const c = se, u = c.crypto || c.msCrypto; let getRandomByte = () => 16 * Math.random(); try { if (u && u.randomUUID) return u.randomUUID().replace(/-/g, ""); u && u.getRandomValues && (getRandomByte = () => { const c = new Uint8Array(1); return u.getRandomValues(c), c[0] }) } catch (c) { } return ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, (c => (c ^ (15 & getRandomByte()) >> c / 4).toString(16))) } function getFirstException(c) { return c.exception && c.exception.values ? c.exception.values[0] : void 0 } function getEventDescription(c) { const { "message": u, "event_id": d } = c; if (u) return u; const v = getFirstException(c); return v ? v.type && v.value ? `${v.type}: ${v.value}` : v.type || v.value || d || "<unknown>" : d || "<unknown>" } function addExceptionTypeValue(c, u, d) { const v = c.exception = c.exception || {}, E = v.values = v.values || [], k = E[0] = E[0] || {}; k.value || (k.value = u || ""), k.type || (k.type = d || "Error") } function misc_addExceptionMechanism(c, u) { const d = getFirstException(c); if (!d) return; const v = d.mechanism; if (d.mechanism = { "type": "generic", "handled": !0, ...v, ...u }, u && "data" in u) { const c = { ...v && v.data, ...u.data }; d.mechanism.data = c } } function checkOrSetAlreadyCaught(c) { if (c && c.__sentry_captured__) return !0; try { object_addNonEnumerableProperty(c, "__sentry_captured__", !0) } catch (c) { } return !1 } function misc_arrayify(c) { return Array.isArray(c) ? c : [c] } const he = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__; function carrier_getMainCarrier() { return carrier_getSentryCarrier(se), se } function carrier_getSentryCarrier(c) { const u = c.__SENTRY__ = c.__SENTRY__ || {}; return u.version = u.version || ie, u[ie] = u[ie] || {} } function propagationContext_generatePropagationContext() { return { "traceId": misc_uuid4(), "spanId": misc_uuid4().substring(16) } } const me = 1e3; function time_dateTimestampInSeconds() { return Date.now() / me } const ge = function createUnixTimestampInSecondsFunc() { const { "performance": c } = se; if (!c || !c.now) return time_dateTimestampInSeconds; const u = Date.now() - c.now(), d = null == c.timeOrigin ? u : c.timeOrigin; return () => (d + c.now()) / me }(); let _e; const ve = (() => { const { "performance": c } = se; if (!c || !c.now) return void (_e = "none"); const u = 36e5, d = c.now(), v = Date.now(), E = c.timeOrigin ? Math.abs(c.timeOrigin + d - v) : u, k = E < u, R = c.timing && c.timing.navigationStart, U = "number" == typeof R ? Math.abs(R + d - v) : u; return k || U < u ? E <= U ? (_e = "timeOrigin", c.timeOrigin) : (_e = "navigationStart", R) : (_e = "dateNow", v) })(); function session_makeSession(c) { const u = ge(), d = { "sid": misc_uuid4(), "init": !0, "timestamp": u, "started": u, "duration": 0, "status": "ok", "errors": 0, "ignoreDuration": !1, "toJSON": () => function sessionToJSON(c) { return object_dropUndefinedKeys({ "sid": `${c.sid}`, "init": c.init, "started": new Date(1e3 * c.started).toISOString(), "timestamp": new Date(1e3 * c.timestamp).toISOString(), "status": c.status, "errors": c.errors, "did": "number" == typeof c.did || "string" == typeof c.did ? `${c.did}` : void 0, "duration": c.duration, "abnormal_mechanism": c.abnormal_mechanism, "attrs": { "release": c.release, "environment": c.environment, "ip_address": c.ipAddress, "user_agent": c.userAgent } }) }(d) }; return c && session_updateSession(d, c), d } function session_updateSession(c, u = {}) { if (u.user && (!c.ipAddress && u.user.ip_address && (c.ipAddress = u.user.ip_address), c.did || u.did || (c.did = u.user.id || u.user.email || u.user.username)), c.timestamp = u.timestamp || ge(), u.abnormal_mechanism && (c.abnormal_mechanism = u.abnormal_mechanism), u.ignoreDuration && (c.ignoreDuration = u.ignoreDuration), u.sid && (c.sid = 32 === u.sid.length ? u.sid : misc_uuid4()), void 0 !== u.init && (c.init = u.init), !c.did && u.did && (c.did = `${u.did}`), "number" == typeof u.started && (c.started = u.started), c.ignoreDuration) c.duration = void 0; else if ("number" == typeof u.duration) c.duration = u.duration; else { const u = c.timestamp - c.started; c.duration = u >= 0 ? u : 0 } u.release && (c.release = u.release), u.environment && (c.environment = u.environment), !c.ipAddress && u.ipAddress && (c.ipAddress = u.ipAddress), !c.userAgent && u.userAgent && (c.userAgent = u.userAgent), "number" == typeof u.errors && (c.errors = u.errors), u.status && (c.status = u.status) } const ye = "_sentrySpan"; function spanOnScope_setSpanForScope(c, u) { u ? object_addNonEnumerableProperty(c, ye, u) : delete c[ye] } function _getSpanForScope(c) { return c[ye] } class ScopeClass { "constructor"() { this._notifyingListeners = !1, this._scopeListeners = [], this._eventProcessors = [], this._breadcrumbs = [], this._attachments = [], this._user = {}, this._tags = {}, this._extra = {}, this._contexts = {}, this._sdkProcessingMetadata = {}, this._propagationContext = propagationContext_generatePropagationContext() } "clone"() { const c = new ScopeClass; return c._breadcrumbs = [...this._breadcrumbs], c._tags = { ...this._tags }, c._extra = { ...this._extra }, c._contexts = { ...this._contexts }, c._user = this._user, c._level = this._level, c._session = this._session, c._transactionName = this._transactionName, c._fingerprint = this._fingerprint, c._eventProcessors = [...this._eventProcessors], c._requestSession = this._requestSession, c._attachments = [...this._attachments], c._sdkProcessingMetadata = { ...this._sdkProcessingMetadata }, c._propagationContext = { ...this._propagationContext }, c._client = this._client, c._lastEventId = this._lastEventId, spanOnScope_setSpanForScope(c, _getSpanForScope(this)), c } "setClient"(c) { this._client = c } "setLastEventId"(c) { this._lastEventId = c } "getClient"() { return this._client } "lastEventId"() { return this._lastEventId } "addScopeListener"(c) { this._scopeListeners.push(c) } "addEventProcessor"(c) { return this._eventProcessors.push(c), this } "setUser"(c) { return this._user = c || { "email": void 0, "id": void 0, "ip_address": void 0, "username": void 0 }, this._session && session_updateSession(this._session, { "user": c }), this._notifyScopeListeners(), this } "getUser"() { return this._user } "getRequestSession"() { return this._requestSession } "setRequestSession"(c) { return this._requestSession = c, this } "setTags"(c) { return this._tags = { ...this._tags, ...c }, this._notifyScopeListeners(), this } "setTag"(c, u) { return this._tags = { ...this._tags, [c]: u }, this._notifyScopeListeners(), this } "setExtras"(c) { return this._extra = { ...this._extra, ...c }, this._notifyScopeListeners(), this } "setExtra"(c, u) { return this._extra = { ...this._extra, [c]: u }, this._notifyScopeListeners(), this } "setFingerprint"(c) { return this._fingerprint = c, this._notifyScopeListeners(), this } "setLevel"(c) { return this._level = c, this._notifyScopeListeners(), this } "setTransactionName"(c) { return this._transactionName = c, this._notifyScopeListeners(), this } "setContext"(c, u) { return null === u ? delete this._contexts[c] : this._contexts[c] = u, this._notifyScopeListeners(), this } "setSession"(c) { return c ? this._session = c : delete this._session, this._notifyScopeListeners(), this } "getSession"() { return this._session } "update"(c) { if (!c) return this; const u = "function" == typeof c ? c(this) : c, [d, v] = u instanceof be ? [u.getScopeData(), u.getRequestSession()] : isPlainObject(u) ? [c, c.requestSession] : [], { "tags": E, "extra": k, "user": R, "contexts": U, "level": H, "fingerprint": G = [], "propagationContext": W } = d || {}; return this._tags = { ...this._tags, ...E }, this._extra = { ...this._extra, ...k }, this._contexts = { ...this._contexts, ...U }, R && Object.keys(R).length && (this._user = R), H && (this._level = H), G.length && (this._fingerprint = G), W && (this._propagationContext = W), v && (this._requestSession = v), this } "clear"() { return this._breadcrumbs = [], this._tags = {}, this._extra = {}, this._user = {}, this._contexts = {}, this._level = void 0, this._transactionName = void 0, this._fingerprint = void 0, this._requestSession = void 0, this._session = void 0, spanOnScope_setSpanForScope(this, void 0), this._attachments = [], this._propagationContext = propagationContext_generatePropagationContext(), this._notifyScopeListeners(), this } "addBreadcrumb"(c, u) { const d = "number" == typeof u ? u : 100; if (d <= 0) return this; const v = { "timestamp": time_dateTimestampInSeconds(), ...c }, E = this._breadcrumbs; return E.push(v), this._breadcrumbs = E.length > d ? E.slice(-d) : E, this._notifyScopeListeners(), this } "getLastBreadcrumb"() { return this._breadcrumbs[this._breadcrumbs.length - 1] } "clearBreadcrumbs"() { return this._breadcrumbs = [], this._notifyScopeListeners(), this } "addAttachment"(c) { return this._attachments.push(c), this } "clearAttachments"() { return this._attachments = [], this } "getScopeData"() { return { "breadcrumbs": this._breadcrumbs, "attachments": this._attachments, "contexts": this._contexts, "tags": this._tags, "extra": this._extra, "user": this._user, "level": this._level, "fingerprint": this._fingerprint || [], "eventProcessors": this._eventProcessors, "propagationContext": this._propagationContext, "sdkProcessingMetadata": this._sdkProcessingMetadata, "transactionName": this._transactionName, "span": _getSpanForScope(this) } } "setSDKProcessingMetadata"(c) { return this._sdkProcessingMetadata = { ...this._sdkProcessingMetadata, ...c }, this } "setPropagationContext"(c) { return this._propagationContext = c, this } "getPropagationContext"() { return this._propagationContext } "captureException"(c, u) { const d = u && u.event_id ? u.event_id : misc_uuid4(); if (!this._client) return ue.warn("No client configured on scope - will not capture exception!"), d; const v = new Error("Sentry syntheticException"); return this._client.captureException(c, { "originalException": c, "syntheticException": v, ...u, "event_id": d }, this), d } "captureMessage"(c, u, d) { const v = d && d.event_id ? d.event_id : misc_uuid4(); if (!this._client) return ue.warn("No client configured on scope - will not capture message!"), v; const E = new Error(c); return this._client.captureMessage(c, u, { "originalException": c, "syntheticException": E, ...d, "event_id": v }, this), v } "captureEvent"(c, u) { const d = u && u.event_id ? u.event_id : misc_uuid4(); return this._client ? (this._client.captureEvent(c, { ...u, "event_id": d }, this), d) : (ue.warn("No client configured on scope - will not capture event!"), d) } "_notifyScopeListeners"() { this._notifyingListeners || (this._notifyingListeners = !0, this._scopeListeners.forEach((c => { c(this) })), this._notifyingListeners = !1) } } const be = ScopeClass; class AsyncContextStack { "constructor"(c, u) { let d, v; d = c || new be, v = u || new be, this._stack = [{ "scope": d }], this._isolationScope = v } "withScope"(c) { const u = this._pushScope(); let d; try { d = c(u) } catch (c) { throw this._popScope(), c } return is_isThenable(d) ? d.then((c => (this._popScope(), c)), (c => { throw this._popScope(), c })) : (this._popScope(), d) } "getClient"() { return this.getStackTop().client } "getScope"() { return this.getStackTop().scope } "getIsolationScope"() { return this._isolationScope } "getStackTop"() { return this._stack[this._stack.length - 1] } "_pushScope"() { const c = this.getScope().clone(); return this._stack.push({ "client": this.getClient(), "scope": c }), c } "_popScope"() { return !(this._stack.length <= 1) && !!this._stack.pop() } } function getAsyncContextStack() { const c = carrier_getSentryCarrier(carrier_getMainCarrier()); return c.stack = c.stack || new AsyncContextStack(function getDefaultCurrentScope() { return worldwide_getGlobalSingleton("defaultCurrentScope", (() => new be)) }(), function getDefaultIsolationScope() { return worldwide_getGlobalSingleton("defaultIsolationScope", (() => new be)) }()) } function stackStrategy_withScope(c) { return getAsyncContextStack().withScope(c) } function withSetScope(c, u) { const d = getAsyncContextStack(); return d.withScope((() => (d.getStackTop().scope = c, u(c)))) } function stackStrategy_withIsolationScope(c) { return getAsyncContextStack().withScope((() => c(getAsyncContextStack().getIsolationScope()))) } function asyncContext_getAsyncContextStrategy(c) { const u = carrier_getSentryCarrier(c); return u.acs ? u.acs : function getStackAsyncContextStrategy() { return { "withIsolationScope": stackStrategy_withIsolationScope, "withScope": stackStrategy_withScope, "withSetScope": withSetScope, "withSetIsolationScope": (c, u) => stackStrategy_withIsolationScope(u), "getCurrentScope": () => getAsyncContextStack().getScope(), "getIsolationScope": () => getAsyncContextStack().getIsolationScope() } }() } function currentScopes_getCurrentScope() { return asyncContext_getAsyncContextStrategy(carrier_getMainCarrier()).getCurrentScope() } function currentScopes_getIsolationScope() { return asyncContext_getAsyncContextStrategy(carrier_getMainCarrier()).getIsolationScope() } function currentScopes_getGlobalScope() { return worldwide_getGlobalSingleton("globalScope", (() => new be)) } function currentScopes_withScope(...c) { const u = asyncContext_getAsyncContextStrategy(carrier_getMainCarrier()); if (2 === c.length) { const [d, v] = c; return d ? u.withSetScope(d, v) : u.withScope(v) } return u.withScope(c[0]) } function currentScopes_withIsolationScope(...c) { const u = asyncContext_getAsyncContextStrategy(carrier_getMainCarrier()); if (2 === c.length) { const [d, v] = c; return d ? u.withSetIsolationScope(d, v) : u.withIsolationScope(v) } return u.withIsolationScope(c[0]) } function currentScopes_getClient() { return currentScopes_getCurrentScope().getClient() } const Se = []; function getIntegrationsToSetup(c) { const u = c.defaultIntegrations || [], d = c.integrations; let v; u.forEach((c => { c.isDefaultInstance = !0 })), v = Array.isArray(d) ? [...u, ...d] : "function" == typeof d ? misc_arrayify(d(u)) : u; const E = function filterDuplicates(c) { const u = {}; return c.forEach((c => { const { "name": d } = c, v = u[d]; v && !v.isDefaultInstance && c.isDefaultInstance || (u[d] = c) })), Object.values(u) }(v), k = E.findIndex((c => "Debug" === c.name)); if (k > -1) { const [c] = E.splice(k, 1); E.push(c) } return E } function afterSetupIntegrations(c, u) { for (const d of u) d && d.afterAllSetup && d.afterAllSetup(c) } function setupIntegration(c, u, d) { if (d[u.name]) he && ue.log(`Integration skipped because it was already installed: ${u.name}`); else { if (d[u.name] = u, -1 === Se.indexOf(u.name) && "function" == typeof u.setupOnce && (u.setupOnce(), Se.push(u.name)), u.setup && "function" == typeof u.setup && u.setup(c), "function" == typeof u.preprocessEvent) { const d = u.preprocessEvent.bind(u); c.on("preprocessEvent", ((u, v) => d(u, v, c))) } if ("function" == typeof u.processEvent) { const d = u.processEvent.bind(u), v = Object.assign(((u, v) => d(u, v, c)), { "id": u.name }); c.addEventProcessor(v) } he && ue.log(`Integration installed: ${u.name}`) } } function addIntegration(c) { const u = currentScopes_getClient(); u ? u.addIntegration(c) : he && ue.warn(`Cannot add integration "${c.name}" because no SDK Client is available.`) } const we = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/, /^ResizeObserver loop completed with undelivered notifications.$/, /^Cannot redefine property: googletag$/, "undefined is not an object (evaluating 'a.L')", 'can\'t redefine non-configurable property "solana"', "vv().getRestrictions is not a function. (In 'vv().getRestrictions(1,a)', 'vv().getRestrictions' is undefined)", "Can't find variable: _AutofillCallbackHandler"], inboundFiltersIntegration = (c = {}) => ({ "name": "InboundFilters", "processEvent"(u, d, v) { const E = v.getOptions(), k = function _mergeOptions(c = {}, u = {}) { return { "allowUrls": [...c.allowUrls || [], ...u.allowUrls || []], "denyUrls": [...c.denyUrls || [], ...u.denyUrls || []], "ignoreErrors": [...c.ignoreErrors || [], ...u.ignoreErrors || [], ...c.disableErrorDefaults ? [] : we], "ignoreTransactions": [...c.ignoreTransactions || [], ...u.ignoreTransactions || []], "ignoreInternal": void 0 === c.ignoreInternal || c.ignoreInternal } }(c, E); return function _shouldDropEvent(c, u) { if (u.ignoreInternal && function _isSentryError(c) { try { return "SentryError" === c.exception.values[0].type } catch (c) { } return !1 }(c)) return he && ue.warn(`Event dropped due to being internal Sentry Error.\nEvent: ${getEventDescription(c)}`), !0; if (function _isIgnoredError(c, u) { if (c.type || !u || !u.length) return !1; return function _getPossibleEventMessages(c) { const u = []; c.message && u.push(c.message); let d; try { d = c.exception.values[c.exception.values.length - 1] } catch (c) { } d && d.value && (u.push(d.value), d.type && u.push(`${d.type}: ${d.value}`)); return u }(c).some((c => stringMatchesSomePattern(c, u))) }(c, u.ignoreErrors)) return he && ue.warn(`Event dropped due to being matched by \`ignoreErrors\` option.\nEvent: ${getEventDescription(c)}`), !0; if (function _isUselessError(c) { if (c.type) return !1; if (!c.exception || !c.exception.values || 0 === c.exception.values.length) return !1; return !c.message && !c.exception.values.some((c => c.stacktrace || c.type && "Error" !== c.type || c.value)) }(c)) return he && ue.warn(`Event dropped due to not having an error message, error type or stacktrace.\nEvent: ${getEventDescription(c)}`), !0; if (function _isIgnoredTransaction(c, u) { if ("transaction" !== c.type || !u || !u.length) return !1; const d = c.transaction; return !!d && stringMatchesSomePattern(d, u) }(c, u.ignoreTransactions)) return he && ue.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.\nEvent: ${getEventDescription(c)}`), !0; if (function _isDeniedUrl(c, u) { if (!u || !u.length) return !1; const d = _getEventFilterUrl(c); return !!d && stringMatchesSomePattern(d, u) }(c, u.denyUrls)) return he && ue.warn(`Event dropped due to being matched by \`denyUrls\` option.\nEvent: ${getEventDescription(c)}.\nUrl: ${_getEventFilterUrl(c)}`), !0; if (!function _isAllowedUrl(c, u) { if (!u || !u.length) return !0; const d = _getEventFilterUrl(c); return !d || stringMatchesSomePattern(d, u) }(c, u.allowUrls)) return he && ue.warn(`Event dropped due to not being matched by \`allowUrls\` option.\nEvent: ${getEventDescription(c)}.\nUrl: ${_getEventFilterUrl(c)}`), !0; return !1 }(u, k) ? null : u } }); function _getEventFilterUrl(c) { try { let u; try { u = c.exception.values[0].stacktrace.frames } catch (c) { } return u ? function _getLastValidUrl(c = []) { for (let u = c.length - 1; u >= 0; u--) { const d = c[u]; if (d && "<anonymous>" !== d.filename && "[native code]" !== d.filename) return d.filename || null } return null }(u) : null } catch (u) { return he && ue.error(`Cannot extract url for event ${getEventDescription(c)}`), null } } let Ee; const Ce = new WeakMap, functionToStringIntegration = () => ({ "name": "FunctionToString", "setupOnce"() { Ee = Function.prototype.toString; try { Function.prototype.toString = function (...c) { const u = getOriginalFunction(this), d = Ce.has(currentScopes_getClient()) && void 0 !== u ? u : this; return Ee.apply(d, c) } } catch (c) { } }, "setup"(c) { Ce.set(c, !0) } }), Te = 50, xe = "?", Ae = /\(error: (.*)\)/, Ie = /captureMessage|captureException/; function createStackParser(...c) { const u = c.sort(((c, u) => c[0] - u[0])).map((c => c[1])); return (c, d = 0, v = 0) => { const E = [], k = c.split("\n"); for (let c = d; c < k.length; c++) { const d = k[c]; if (d.length > 1024) continue; const R = Ae.test(d) ? d.replace(Ae, "$1") : d; if (!R.match(/\S*Error: /)) { for (const c of u) { const u = c(R); if (u) { E.push(u); break } } if (E.length >= Te + v) break } } return function stripSentryFramesAndReverse(c) { if (!c.length) return []; const u = Array.from(c); /sentryWrapped/.test(getLastStackFrame(u).function || "") && u.pop(); u.reverse(), Ie.test(getLastStackFrame(u).function || "") && (u.pop(), Ie.test(getLastStackFrame(u).function || "") && u.pop()); return u.slice(0, Te).map((c => ({ ...c, "filename": c.filename || getLastStackFrame(u).filename, "function": c.function || xe }))) }(E.slice(v)) } } function getLastStackFrame(c) { return c[c.length - 1] || {} } const ke = "<anonymous>"; function getFunctionName(c) { try { return c && "function" == typeof c && c.name || ke } catch (c) { return ke } } function getFramesFromEvent(c) { const u = c.exception; if (u) { const c = []; try { return u.values.forEach((u => { u.stacktrace.frames && c.push(...u.stacktrace.frames) })), c } catch (c) { return } } } const dedupeIntegration = () => { let c; return { "name": "Dedupe", "processEvent"(u) { if (u.type) return u; try { if (function dedupe_shouldDropEvent(c, u) { if (!u) return !1; if (function _isSameMessageEvent(c, u) { const d = c.message, v = u.message; if (!d && !v) return !1; if (d && !v || !d && v) return !1; if (d !== v) return !1; if (!_isSameFingerprint(c, u)) return !1; if (!_isSameStacktrace(c, u)) return !1; return !0 }(c, u)) return !0; if (function _isSameExceptionEvent(c, u) { const d = _getExceptionFromEvent(u), v = _getExceptionFromEvent(c); if (!d || !v) return !1; if (d.type !== v.type || d.value !== v.value) return !1; if (!_isSameFingerprint(c, u)) return !1; if (!_isSameStacktrace(c, u)) return !1; return !0 }(c, u)) return !0; return !1 }(u, c)) return he && ue.warn("Event dropped due to being a duplicate of previously captured event."), null } catch (c) { } return c = u } } }; function _isSameStacktrace(c, u) { let d = getFramesFromEvent(c), v = getFramesFromEvent(u); if (!d && !v) return !0; if (d && !v || !d && v) return !1; if (v.length !== d.length) return !1; for (let c = 0; c < v.length; c++) { const u = v[c], E = d[c]; if (u.filename !== E.filename || u.lineno !== E.lineno || u.colno !== E.colno || u.function !== E.function) return !1 } return !0 } function _isSameFingerprint(c, u) { let d = c.fingerprint, v = u.fingerprint; if (!d && !v) return !0; if (d && !v || !d && v) return !1; try { return !(d.join("") !== v.join("")) } catch (c) { return !1 } } function _getExceptionFromEvent(c) { return c.exception && c.exception.values && c.exception.values[0] } function setCurrentClient(c) { currentScopes_getCurrentScope().setClient(c) } const Oe = "production"; function normalize_normalize(c, u = 100, d = 1 / 0) { try { return visit("", c, u, d) } catch (c) { return { "ERROR": `**non-serializable** (${c})` } } } function normalizeToSize(c, u = 3, d = 102400) { const v = normalize_normalize(c, u); return function jsonSize(c) { return function utf8Length(c) { return ~-encodeURI(c).split(/%..|./).length }(JSON.stringify(c)) }(v) > d ? normalizeToSize(c, u - 1, d) : v } function visit(c, u, d = 1 / 0, v = 1 / 0, E = function memoBuilder() { const c = "function" == typeof WeakSet, u = c ? new WeakSet : []; return [function memoize(d) { if (c) return !!u.has(d) || (u.add(d), !1); for (let c = 0; c < u.length; c++)if (u[c] === d) return !0; return u.push(d), !1 }, function unmemoize(d) { if (c) u.delete(d); else for (let c = 0; c < u.length; c++)if (u[c] === d) { u.splice(c, 1); break } }] }()) { const [k, R] = E; if (null == u || ["number", "boolean", "string"].includes(typeof u) && !Number.isNaN(u)) return u; const U = function stringifyValue(c, u) { try { if ("domain" === c && u && "object" == typeof u && u._events) return "[Domain]"; if ("domainEmitter" === c) return "[DomainEmitter]"; if ("undefined" != typeof global && u === global) return "[Global]"; if ("undefined" != typeof window && u === window) return "[Window]"; if ("undefined" != typeof document && u === document) return "[Document]"; if (is_isVueViewModel(u)) return "[VueViewModel]"; if (function isSyntheticEvent(c) { return isPlainObject(c) && "nativeEvent" in c && "preventDefault" in c && "stopPropagation" in c }(u)) return "[SyntheticEvent]"; if ("number" == typeof u && u != u) return "[NaN]"; if ("function" == typeof u) return `[Function: ${getFunctionName(u)}]`; if ("symbol" == typeof u) return `[${String(u)}]`; if ("bigint" == typeof u) return `[BigInt: ${String(u)}]`; const d = function getConstructorName(c) { const u = Object.getPrototypeOf(c); return u ? u.constructor.name : "null prototype" }(u); return /^HTML(\w*)Element$/.test(d) ? `[HTMLElement: ${d}]` : `[object ${d}]` } catch (c) { return `**non-serializable** (${c})` } }(c, u); if (!U.startsWith("[object ")) return U; if (u.__sentry_skip_normalization__) return u; const H = "number" == typeof u.__sentry_override_normalization_depth__ ? u.__sentry_override_normalization_depth__ : d; if (0 === H) return U.replace("object ", ""); if (k(u)) return "[Circular ~]"; const G = u; if (G && "function" == typeof G.toJSON) try { return visit("", G.toJSON(), H - 1, v, E) } catch (c) { } const W = Array.isArray(u) ? [] : {}; let Z = 0; const Y = convertToPlainObject(u); for (const c in Y) { if (!Object.prototype.hasOwnProperty.call(Y, c)) continue; if (Z >= v) { W[c] = "[MaxProperties ~]"; break } const u = Y[c]; W[c] = visit(c, u, H - 1, v, E), Z++ } return R(u), W } var Pe; function resolvedSyncPromise(c) { return new SyncPromise((u => { u(c) })) } function rejectedSyncPromise(c) { return new SyncPromise(((u, d) => { d(c) })) } !function (c) { c[c.PENDING = 0] = "PENDING"; c[c.RESOLVED = 1] = "RESOLVED"; c[c.REJECTED = 2] = "REJECTED" }(Pe || (Pe = {})); class SyncPromise { "constructor"(c) { SyncPromise.prototype.__init.call(this), SyncPromise.prototype.__init2.call(this), SyncPromise.prototype.__init3.call(this), SyncPromise.prototype.__init4.call(this), this._state = Pe.PENDING, this._handlers = []; try { c(this._resolve, this._reject) } catch (c) { this._reject(c) } } "then"(c, u) { return new SyncPromise(((d, v) => { this._handlers.push([!1, u => { if (c) try { d(c(u)) } catch (c) { v(c) } else d(u) }, c => { if (u) try { d(u(c)) } catch (c) { v(c) } else v(c) }]), this._executeHandlers() })) } "catch"(c) { return this.then((c => c), c) } "finally"(c) { return new SyncPromise(((u, d) => { let v, E; return this.then((u => { E = !1, v = u, c && c() }), (u => { E = !0, v = u, c && c() })).then((() => { E ? d(v) : u(v) })) })) } "__init"() { this._resolve = c => { this._setResult(Pe.RESOLVED, c) } } "__init2"() { this._reject = c => { this._setResult(Pe.REJECTED, c) } } "__init3"() { this._setResult = (c, u) => { this._state === Pe.PENDING && (is_isThenable(u) ? u.then(this._resolve, this._reject) : (this._state = c, this._value = u, this._executeHandlers())) } } "__init4"() { this._executeHandlers = () => { if (this._state === Pe.PENDING) return; const c = this._handlers.slice(); this._handlers = [], c.forEach((c => { c[0] || (this._state === Pe.RESOLVED && c[1](this._value), this._state === Pe.REJECTED && c[2](this._value), c[0] = !0) })) } } } function eventProcessors_notifyEventProcessors(c, u, d, v = 0) { return new SyncPromise(((E, k) => { const R = c[v]; if (null === u || "function" != typeof R) E(u); else { const U = R({ ...u }, d); he && R.id && null === U && ue.log(`Event processor "${R.id}" dropped event`), is_isThenable(U) ? U.then((u => eventProcessors_notifyEventProcessors(c, u, d, v + 1).then(E))).then(null, k) : eventProcessors_notifyEventProcessors(c, U, d, v + 1).then(E).then(null, k) } })) } const Re = "baggage", Me = "sentry-", Ne = /^sentry-/, De = 8192; function baggageHeaderToDynamicSamplingContext(c) { const u = function parseBaggageHeader(c) { if (!c || !is_isString(c) && !Array.isArray(c)) return; if (Array.isArray(c)) return c.reduce(((c, u) => { const d = baggageHeaderToObject(u); return Object.entries(d).forEach((([u, d]) => { c[u] = d })), c }), {}); return baggageHeaderToObject(c) }(c); if (!u) return; const d = Object.entries(u).reduce(((c, [u, d]) => { if (u.match(Ne)) { c[u.slice(Me.length)] = d } return c }), {}); return Object.keys(d).length > 0 ? d : void 0 } function baggage_dynamicSamplingContextToSentryBaggageHeader(c) { if (!c) return; return function objectToBaggageHeader(c) { if (0 === Object.keys(c).length) return; return Object.entries(c).reduce(((c, [u, d], v) => { const E = `${encodeURIComponent(u)}=${encodeURIComponent(d)}`, k = 0 === v ? E : `${c},${E}`; return k.length > De ? (ae && ue.warn(`Not adding key: ${u} with val: ${d} to baggage header due to exceeding baggage size limits.`), c) : k }), "") }(Object.entries(c).reduce(((c, [u, d]) => (d && (c[`${Me}${u}`] = d), c)), {})) } function baggageHeaderToObject(c) { return c.split(",").map((c => c.split("=").map((c => decodeURIComponent(c.trim()))))).reduce(((c, [u, d]) => (u && d && (c[u] = d), c)), {}) } const $e = "sentry.source", Le = "sentry.sample_rate", Fe = "sentry.op", je = "sentry.origin", Be = "sentry.idle_span_finish_reason", Ue = "sentry.measurement_unit", He = "sentry.measurement_value", ze = new RegExp("^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$"); function tracing_propagationContextFromHeaders(c, u) { const d = function extractTraceparentData(c) { if (!c) return; const u = c.match(ze); if (!u) return; let d; return "1" === u[3] ? d = !0 : "0" === u[3] && (d = !1), { "traceId": u[1], "parentSampled": d, "parentSpanId": u[2] } }(c), v = baggageHeaderToDynamicSamplingContext(u), { "traceId": E, "parentSpanId": k, "parentSampled": R } = d || {}; return d ? { "traceId": E || misc_uuid4(), "parentSpanId": k || misc_uuid4().substring(16), "spanId": misc_uuid4().substring(16), "sampled": R, "dsc": v || {} } : { "traceId": E || misc_uuid4(), "spanId": misc_uuid4().substring(16) } } function tracing_generateSentryTraceHeader(c = misc_uuid4(), u = misc_uuid4().substring(16), d) { let v = ""; return void 0 !== d && (v = d ? "-1" : "-0"), `${c}-${u}${v}` } const qe = "_sentryMetrics"; function getMetricSummaryJsonForSpan(c) { const u = c[qe]; if (!u) return; const d = {}; for (const [, [c, v]] of u) { (d[c] || (d[c] = [])).push(object_dropUndefinedKeys(v)) } return d } const Ge = 0, Ve = 1, We = 2; function getSpanStatusFromHttpCode(c) { if (c < 400 && c >= 100) return { "code": Ve }; if (c >= 400 && c < 500) switch (c) { case 401: return { "code": We, "message": "unauthenticated" }; case 403: return { "code": We, "message": "permission_denied" }; case 404: return { "code": We, "message": "not_found" }; case 409: return { "code": We, "message": "already_exists" }; case 413: return { "code": We, "message": "failed_precondition" }; case 429: return { "code": We, "message": "resource_exhausted" }; case 499: return { "code": We, "message": "cancelled" }; default: return { "code": We, "message": "invalid_argument" } }if (c >= 500 && c < 600) switch (c) { case 501: return { "code": We, "message": "unimplemented" }; case 503: return { "code": We, "message": "unavailable" }; case 504: return { "code": We, "message": "deadline_exceeded" }; default: return { "code": We, "message": "internal_error" } }return { "code": We, "message": "unknown_error" } } function setHttpStatus(c, u) { c.setAttribute("http.response.status_code", u); const d = getSpanStatusFromHttpCode(u); "unknown_error" !== d.message && c.setStatus(d) } const Ze = 1; function spanToTransactionTraceContext(c) { const { "spanId": u, "traceId": d } = c.spanContext(), { "data": v, "op": E, "parent_span_id": k, "status": R, "origin": U } = spanUtils_spanToJSON(c); return object_dropUndefinedKeys({ "parent_span_id": k, "span_id": u, "trace_id": d, "data": v, "op": E, "status": R, "origin": U }) } function spanToTraceContext(c) { const { "spanId": u, "traceId": d } = c.spanContext(), { "parent_span_id": v } = spanUtils_spanToJSON(c); return object_dropUndefinedKeys({ "parent_span_id": v, "span_id": u, "trace_id": d }) } function spanToTraceHeader(c) { const { "traceId": u, "spanId": d } = c.spanContext(); return tracing_generateSentryTraceHeader(u, d, spanIsSampled(c)) } function spanTimeInputToSeconds(c) { return "number" == typeof c ? ensureTimestampInSeconds(c) : Array.isArray(c) ? c[0] + c[1] / 1e9 : c instanceof Date ? ensureTimestampInSeconds(c.getTime()) : ge() } function ensureTimestampInSeconds(c) { return c > 9999999999 ? c / 1e3 : c } function spanUtils_spanToJSON(c) { if (function spanIsSentrySpan(c) { return "function" == typeof c.getSpanJSON }(c)) return c.getSpanJSON(); try { const { "spanId": u, "traceId": d } = c.spanContext(); if (function spanIsOpenTelemetrySdkTraceBaseSpan(c) { const u = c; return !!(u.attributes && u.startTime && u.name && u.endTime && u.status) }(c)) { const { "attributes": v, "startTime": E, "name": k, "endTime": R, "parentSpanId": U, "status": H } = c; return object_dropUndefinedKeys({ "span_id": u, "trace_id": d, "data": v, "description": k, "parent_span_id": U, "start_timestamp": spanTimeInputToSeconds(E), "timestamp": spanTimeInputToSeconds(R) || void 0, "status": getStatusMessage(H), "op": v[Fe], "origin": v[je], "_metrics_summary": getMetricSummaryJsonForSpan(c) }) } return { "span_id": u, "trace_id": d } } catch (c) { return {} } } function spanIsSampled(c) { const { "traceFlags": u } = c.spanContext(); return u === Ze } function getStatusMessage(c) { if (c && c.code !== Ge) return c.code === Ve ? "ok" : c.message || "unknown_error" } const Ye = "_sentryChildSpans", Je = "_sentryRootSpan"; function addChildSpanToSpan(c, u) { const d = c[Je] || c; object_addNonEnumerableProperty(u, Je, d), c[Ye] ? c[Ye].add(u) : object_addNonEnumerableProperty(c, Ye, new Set([u])) } function getSpanDescendants(c) { const u = new Set; return function addSpanChildren(c) { if (!u.has(c) && spanIsSampled(c)) { u.add(c); const d = c[Ye] ? Array.from(c[Ye]) : []; for (const c of d) addSpanChildren(c) } }(c), Array.from(u) } function getRootSpan(c) { return c[Je] || c } function getActiveSpan() { const c = asyncContext_getAsyncContextStrategy(carrier_getMainCarrier()); return c.getActiveSpan ? c.getActiveSpan() : _getSpanForScope(currentScopes_getCurrentScope()) } function updateMetricSummaryOnActiveSpan(c, u, d, v, E, k) { const R = getActiveSpan(); R && function metric_summary_updateMetricSummaryOnSpan(c, u, d, v, E, k, R) { const U = c[qe] || (c[qe] = new Map), H = `${u}:${d}@${E}`, G = U.get(R); if (G) { const [, c] = G; U.set(R, [H, { "min": Math.min(c.min, v), "max": Math.max(c.max, v), "count": c.count += 1, "sum": c.sum += v, "tags": c.tags }]) } else U.set(R, [H, { "min": v, "max": v, "count": 1, "sum": v, "tags": k }]) }(R, c, u, d, v, E, k) } const Ke = "_frozenDsc"; function freezeDscOnSpan(c, u) { object_addNonEnumerableProperty(c, Ke, u) } function getDynamicSamplingContextFromClient(c, u) { const d = u.getOptions(), { "publicKey": v } = u.getDsn() || {}, E = object_dropUndefinedKeys({ "environment": d.environment || Oe, "release": d.release, "public_key": v, "trace_id": c }); return u.emit("createDsc", E), E } function getDynamicSamplingContextFromSpan(c) { const u = currentScopes_getClient(); if (!u) return {}; const d = getDynamicSamplingContextFromClient(spanUtils_spanToJSON(c).trace_id || "", u), v = getRootSpan(c), E = v[Ke]; if (E) return E; const k = v.spanContext().traceState, R = k && k.get("sentry.dsc"), U = R && baggageHeaderToDynamicSamplingContext(R); if (U) return U; const H = spanUtils_spanToJSON(v), G = H.data || {}, W = G[Le]; null != W && (d.sample_rate = `${W}`); const Z = G[$e], Y = H.description; return "url" !== Z && Y && (d.transaction = Y), d.sampled = String(spanIsSampled(v)), u.emit("createDsc", d, v), d } function spanToBaggageHeader(c) { return baggage_dynamicSamplingContextToSentryBaggageHeader(getDynamicSamplingContextFromSpan(c)) } function applyScopeDataToEvent_applyScopeDataToEvent(c, u) { const { "fingerprint": d, "span": v, "breadcrumbs": E, "sdkProcessingMetadata": k } = u; !function applyDataToEvent(c, u) { const { "extra": d, "tags": v, "user": E, "contexts": k, "level": R, "transactionName": U } = u, H = object_dropUndefinedKeys(d); H && Object.keys(H).length && (c.extra = { ...H, ...c.extra }); const G = object_dropUndefinedKeys(v); G && Object.keys(G).length && (c.tags = { ...G, ...c.tags }); const W = object_dropUndefinedKeys(E); W && Object.keys(W).length && (c.user = { ...W, ...c.user }); const Z = object_dropUndefinedKeys(k); Z && Object.keys(Z).length && (c.contexts = { ...Z, ...c.contexts }); R && (c.level = R); U && "transaction" !== c.type && (c.transaction = U) }(c, u), v && function applySpanToEvent(c, u) { c.contexts = { "trace": spanToTraceContext(u), ...c.contexts }, c.sdkProcessingMetadata = { "dynamicSamplingContext": getDynamicSamplingContextFromSpan(u), ...c.sdkProcessingMetadata }; const d = getRootSpan(u), v = spanUtils_spanToJSON(d).description; v && !c.transaction && "transaction" === c.type && (c.transaction = v) }(c, v), function applyFingerprintToEvent(c, u) { c.fingerprint = c.fingerprint ? misc_arrayify(c.fingerprint) : [], u && (c.fingerprint = c.fingerprint.concat(u)); c.fingerprint && !c.fingerprint.length && delete c.fingerprint }(c, d), function applyBreadcrumbsToEvent(c, u) { const d = [...c.breadcrumbs || [], ...u]; c.breadcrumbs = d.length ? d : void 0 }(c, E), function applySdkMetadataToEvent(c, u) { c.sdkProcessingMetadata = { ...c.sdkProcessingMetadata, ...u } }(c, k) } function applyScopeDataToEvent_mergeScopeData(c, u) { const { "extra": d, "tags": v, "user": E, "contexts": k, "level": R, "sdkProcessingMetadata": U, "breadcrumbs": H, "fingerprint": G, "eventProcessors": W, "attachments": Z, "propagationContext": Y, "transactionName": J, "span": K } = u; mergeAndOverwriteScopeData(c, "extra", d), mergeAndOverwriteScopeData(c, "tags", v), mergeAndOverwriteScopeData(c, "user", E), mergeAndOverwriteScopeData(c, "contexts", k), mergeAndOverwriteScopeData(c, "sdkProcessingMetadata", U), R && (c.level = R), J && (c.transactionName = J), K && (c.span = K), H.length && (c.breadcrumbs = [...c.breadcrumbs, ...H]), G.length && (c.fingerprint = [...c.fingerprint, ...G]), W.length && (c.eventProcessors = [...c.eventProcessors, ...W]), Z.length && (c.attachments = [...c.attachments, ...Z]), c.propagationContext = { ...c.propagationContext, ...Y } } function mergeAndOverwriteScopeData(c, u, d) { if (d && Object.keys(d).length) { c[u] = { ...c[u] }; for (const v in d) Object.prototype.hasOwnProperty.call(d, v) && (c[u][v] = d[v]) } } function prepareEvent(c, u, d, v, E, k) { const { "normalizeDepth": R = 3, "normalizeMaxBreadth": U = 1e3 } = c, H = { ...u, "event_id": u.event_id || d.event_id || misc_uuid4(), "timestamp": u.timestamp || time_dateTimestampInSeconds() }, G = d.integrations || c.integrations.map((c => c.name)); !function applyClientOptions(c, u) { const { "environment": d, "release": v, "dist": E, "maxValueLength": k = 250 } = u; "environment" in c || (c.environment = "environment" in u ? d : Oe); void 0 === c.release && void 0 !== v && (c.release = v); void 0 === c.dist && void 0 !== E && (c.dist = E); c.message && (c.message = string_truncate(c.message, k)); const R = c.exception && c.exception.values && c.exception.values[0]; R && R.value && (R.value = string_truncate(R.value, k)); const U = c.request; U && U.url && (U.url = string_truncate(U.url, k)) }(H, c), function applyIntegrationsMetadata(c, u) { u.length > 0 && (c.sdk = c.sdk || {}, c.sdk.integrations = [...c.sdk.integrations || [], ...u]) }(H, G), E && E.emit("applyFrameMetadata", u), void 0 === u.type && function applyDebugIds(c, u) { const d = se._sentryDebugIds; if (!d) return; let v; const E = Xe.get(u); E ? v = E : (v = new Map, Xe.set(u, v)); const k = Object.entries(d).reduce(((c, [d, E]) => { let k; const R = v.get(d); R ? k = R : (k = u(d), v.set(d, k)); for (let u = k.length - 1; u >= 0; u--) { const d = k[u]; if (d.filename) { c[d.filename] = E; break } } return c }), {}); try { c.exception.values.forEach((c => { c.stacktrace.frames.forEach((c => { c.filename && (c.debug_id = k[c.filename]) })) })) } catch (c) { } }(H, c.stackParser); const W = function getFinalScope(c, u) { if (!u) return c; const d = c ? c.clone() : new be; return d.update(u), d }(v, d.captureContext); d.mechanism && misc_addExceptionMechanism(H, d.mechanism); const Z = E ? E.getEventProcessors() : [], Y = currentScopes_getGlobalScope().getScopeData(); if (k) { applyScopeDataToEvent_mergeScopeData(Y, k.getScopeData()) } if (W) { applyScopeDataToEvent_mergeScopeData(Y, W.getScopeData()) } const J = [...d.attachments || [], ...Y.attachments]; J.length && (d.attachments = J), applyScopeDataToEvent_applyScopeDataToEvent(H, Y); return eventProcessors_notifyEventProcessors([...Z, ...Y.eventProcessors], H, d).then((c => (c && function applyDebugMeta(c) { const u = {}; try { c.exception.values.forEach((c => { c.stacktrace.frames.forEach((c => { c.debug_id && (c.abs_path ? u[c.abs_path] = c.debug_id : c.filename && (u[c.filename] = c.debug_id), delete c.debug_id) })) })) } catch (c) { } if (0 === Object.keys(u).length) return; c.debug_meta = c.debug_meta || {}, c.debug_meta.images = c.debug_meta.images || []; const d = c.debug_meta.images; Object.entries(u).forEach((([c, u]) => { d.push({ "type": "sourcemap", "code_file": c, "debug_id": u }) })) }(c), "number" == typeof R && R > 0 ? function normalizeEvent(c, u, d) { if (!c) return null; const v = { ...c, ...c.breadcrumbs && { "breadcrumbs": c.breadcrumbs.map((c => ({ ...c, ...c.data && { "data": normalize_normalize(c.data, u, d) } }))) }, ...c.user && { "user": normalize_normalize(c.user, u, d) }, ...c.contexts && { "contexts": normalize_normalize(c.contexts, u, d) }, ...c.extra && { "extra": normalize_normalize(c.extra, u, d) } }; c.contexts && c.contexts.trace && v.contexts && (v.contexts.trace = c.contexts.trace, c.contexts.trace.data && (v.contexts.trace.data = normalize_normalize(c.contexts.trace.data, u, d))); c.spans && (v.spans = c.spans.map((c => ({ ...c, ...c.data && { "data": normalize_normalize(c.data, u, d) } })))); return v }(c, R, U) : c))) } const Xe = new WeakMap; function parseEventHintOrCaptureContext(c) { if (c) return function hintIsScopeOrFunction(c) { return c instanceof be || "function" == typeof c }(c) || function hintIsScopeContext(c) { return Object.keys(c).some((c => Qe.includes(c))) }(c) ? { "captureContext": c } : c } const Qe = ["user", "level", "extra", "contexts", "tags", "fingerprint", "requestSession", "propagationContext"]; function captureException(c, u) { return currentScopes_getCurrentScope().captureException(c, parseEventHintOrCaptureContext(u)) } function captureMessage(c, u) { const d = "string" == typeof u ? u : void 0, v = "string" != typeof u ? { "captureContext": u } : void 0; return currentScopes_getCurrentScope().captureMessage(c, d, v) } function captureEvent(c, u) { return currentScopes_getCurrentScope().captureEvent(c, u) } function setContext(c, u) { currentScopes_getIsolationScope().setContext(c, u) } function setExtras(c) { currentScopes_getIsolationScope().setExtras(c) } function setExtra(c, u) { currentScopes_getIsolationScope().setExtra(c, u) } function setTags(c) { currentScopes_getIsolationScope().setTags(c) } function setTag(c, u) { currentScopes_getIsolationScope().setTag(c, u) } function setUser(c) { currentScopes_getIsolationScope().setUser(c) } function lastEventId() { return currentScopes_getIsolationScope().lastEventId() } async function flush(c) { const u = currentScopes_getClient(); return u ? u.flush(c) : (he && ue.warn("Cannot flush events. No client defined."), Promise.resolve(!1)) } async function exports_close(c) { const u = currentScopes_getClient(); return u ? u.close(c) : (he && ue.warn("Cannot flush events and disable SDK. No client defined."), Promise.resolve(!1)) } function isInitialized() { return !!currentScopes_getClient() } function addEventProcessor(c) { currentScopes_getIsolationScope().addEventProcessor(c) } function startSession(c) { const u = currentScopes_getClient(), d = currentScopes_getIsolationScope(), v = currentScopes_getCurrentScope(), { "release": E, "environment": k = Oe } = u && u.getOptions() || {}, { "userAgent": R } = se.navigator || {}, U = session_makeSession({ "release": E, "environment": k, "user": v.getUser() || d.getUser(), ...R && { "userAgent": R }, ...c }), H = d.getSession(); return H && "ok" === H.status && session_updateSession(H, { "status": "exited" }), endSession(), d.setSession(U), v.setSession(U), U } function endSession() { const c = currentScopes_getIsolationScope(), u = currentScopes_getCurrentScope(), d = u.getSession() || c.getSession(); d && function session_closeSession(c, u) { let d = {}; u ? d = { "status": u } : "ok" === c.status && (d = { "status": "exited" }), session_updateSession(c, d) }(d), _sendSessionUpdate(), c.setSession(), u.setSession() } function _sendSessionUpdate() { const c = currentScopes_getIsolationScope(), u = currentScopes_getCurrentScope(), d = currentScopes_getClient(), v = u.getSession() || c.getSession(); v && d && d.captureSession(v) } function captureSession(c = !1) { c ? endSession() : _sendSessionUpdate() } const et = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/; function dsn_dsnToString(c, u = !1) { const { "host": d, "path": v, "pass": E, "port": k, "projectId": R, "protocol": U, "publicKey": H } = c; return `${U}://${H}${u && E ? `:${E}` : ""}@${d}${k ? `:${k}` : ""}/${v ? `${v}/` : v}${R}` } function dsnFromString(c) { const u = et.exec(c); if (!u) return void logger_consoleSandbox((() => { console.error(`Invalid Sentry Dsn: ${c}`) })); const [d, v, E = "", k = "", R = "", U = ""] = u.slice(1); let H = "", G = U; const W = G.split("/"); if (W.length > 1 && (H = W.slice(0, -1).join("/"), G = W.pop()), G) { const c = G.match(/^\d+/); c && (G = c[0]) } return dsnFromComponents({ "host": k, "pass": E, "path": H, "projectId": G, "port": R, "protocol": d, "publicKey": v }) } function dsnFromComponents(c) { return { "protocol": c.protocol, "publicKey": c.publicKey || "", "pass": c.pass || "", "host": c.host, "port": c.port || "", "path": c.path || "", "projectId": c.projectId } } function makeDsn(c) { const u = "string" == typeof c ? dsnFromString(c) : dsnFromComponents(c); if (u && function validateDsn(c) { if (!ae) return !0; const { "port": u, "projectId": d, "protocol": v } = c; return !(["protocol", "publicKey", "host", "projectId"].find((u => !c[u] && (ue.error(`Invalid Sentry Dsn: ${u} missing`), !0))) || (d.match(/^\d+$/) ? function isValidProtocol(c) { return "http" === c || "https" === c }(v) ? u && isNaN(parseInt(u, 10)) && (ue.error(`Invalid Sentry Dsn: Invalid port ${u}`), 1) : (ue.error(`Invalid Sentry Dsn: Invalid protocol ${v}`), 1) : (ue.error(`Invalid Sentry Dsn: Invalid projectId ${d}`), 1))) }(u)) return u } const tt = "7"; function getBaseApiEndpoint(c) { const u = c.protocol ? `${c.protocol}:` : "", d = c.port ? `:${c.port}` : ""; return `${u}//${c.host}${d}${c.path ? `/${c.path}` : ""}/api/` } function _encodedAuth(c, u) { return function urlEncode(c) { return Object.keys(c).map((u => `${encodeURIComponent(u)}=${encodeURIComponent(c[u])}`)).join("&") }({ "sentry_key": c.publicKey, "sentry_version": tt, ...u && { "sentry_client": `${u.name}/${u.version}` } }) } function getEnvelopeEndpointWithUrlEncodedAuth(c, u, d) { return u || `${function _getIngestEndpoint(c) { return `${getBaseApiEndpoint(c)}${c.projectId}/envelope/` }(c)}?${_encodedAuth(c, d)}` } const nt = se; function supportsFetch() { if (!("fetch" in nt)) return !1; try { return new Headers, new Request("http://www.example.com"), new Response, !0 } catch (c) { return !1 } } function isNativeFunction(c) { return c && /^function\s+\w+\(\)\s+\{\s+\[native code\]\s+\}$/.test(c.toString()) } function supportsNativeFetch() { if ("string" == typeof EdgeRuntime) return !0; if (!supportsFetch()) return !1; if (isNativeFunction(nt.fetch)) return !0; let c = !1; const u = nt.document; if (u && "function" == typeof u.createElement) try { const d = u.createElement("iframe"); d.hidden = !0, u.head.appendChild(d), d.contentWindow && d.contentWindow.fetch && (c = isNativeFunction(d.contentWindow.fetch)), u.head.removeChild(d) } catch (c) { ae && ue.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", c) } return c } const rt = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__, ot = "8.30.0", it = globalThis; function esm_worldwide_getGlobalSingleton(c, u, d) { const v = d || it, E = v.__SENTRY__ = v.__SENTRY__ || {}, k = E[ot] = E[ot] || {}; return k[c] || (k[c] = u()) } const at = ["debug", "info", "warn", "error", "log", "assert", "trace"], st = {}; const ct = esm_worldwide_getGlobalSingleton("logger", (function logger_makeLogger() { let c = !1; const u = { "enable": () => { c = !0 }, "disable": () => { c = !1 }, "isEnabled": () => c }; return rt ? at.forEach((d => { u[d] = (...u) => { c && function esm_logger_consoleSandbox(c) { if (!("console" in it)) return c(); const u = it.console, d = {}, v = Object.keys(st); v.forEach((c => { const v = st[c]; d[c] = u[c], u[c] = v })); try { return c() } finally { v.forEach((c => { u[c] = d[c] })) } }((() => { it.console[d](`Sentry Logger [${d}]:`, ...u) })) } })) : at.forEach((c => { u[c] = () => { } })), u })); const lt = "<anonymous>"; function stacktrace_getFunctionName(c) { try { return c && "function" == typeof c && c.name || lt } catch (c) { return lt } } const ut = {}, dt = {}; function addHandler(c, u) { ut[c] = ut[c] || [], ut[c].push(u) } function maybeInstrument(c, u) { dt[c] || (u(), dt[c] = !0) } function triggerHandlers(c, u) { const d = c && ut[c]; if (d) for (const v of d) try { v(u) } catch (u) { rt && ct.error(`Error while triggering instrumentation handler.\nType: ${c}\nName: ${stacktrace_getFunctionName(v)}\nError:`, u) } } const pt = it; const ft = Object.prototype.toString; function is_isBuiltin(c, u) { return ft.call(c) === `[object ${u}]` } function esm_is_isString(c) { return is_isBuiltin(c, "String") } function is_isPlainObject(c) { return is_isBuiltin(c, "Object") } function object_fill(c, u, d) { if (!(u in c)) return; const v = c[u], E = d(v); "function" == typeof E && function object_markFunctionWrapped(c, u) { try { const d = u.prototype || {}; c.prototype = u.prototype = d, esm_object_addNonEnumerableProperty(c, "__sentry_original__", u) } catch (c) { } }(E, v), c[u] = E } function esm_object_addNonEnumerableProperty(c, u, d) { try { Object.defineProperty(c, u, { "value": d, "writable": !0, "configurable": !0 }) } catch (d) { rt && ct.log(`Failed to add non-enumerable property "${u}" to object`, c) } } function esm_object_dropUndefinedKeys(c) { return build_esm_object_dropUndefinedKeys(c, new Map) } function build_esm_object_dropUndefinedKeys(c, u) { if (function object_isPojo(c) { if (!is_isPlainObject(c)) return !1; try { const u = Object.getPrototypeOf(c).constructor.name; return !u || "Object" === u } catch (c) { return !0 } }(c)) { const d = u.get(c); if (void 0 !== d) return d; const v = {}; u.set(c, v); for (const d of Object.keys(c)) void 0 !== c[d] && (v[d] = build_esm_object_dropUndefinedKeys(c[d], u)); return v } if (Array.isArray(c)) { const d = u.get(c); if (void 0 !== d) return d; const v = []; return u.set(c, v), c.forEach((c => { v.push(build_esm_object_dropUndefinedKeys(c, u)) })), v } return c } const ht = it; let mt; function addHistoryInstrumentationHandler(c) { const u = "history"; addHandler(u, c), maybeInstrument(u, instrumentHistory) } function instrumentHistory() { if (!function supportsHistory() { const c = pt.chrome, u = c && c.app && c.app.runtime, d = "history" in pt && !!pt.history.pushState && !!pt.history.replaceState; return !u && d }()) return; const c = ht.onpopstate; function historyReplacementFunction(c) { return function (...u) { const d = u.length > 2 ? u[2] : void 0; if (d) { const c = mt, u = String(d); mt = u; triggerHandlers("history", { "from": c, "to": u }) } return c.apply(this, u) } } ht.onpopstate = function (...u) { const d = ht.location.href, v = mt; mt = d; if (triggerHandlers("history", { "from": v, "to": d }), c) try { return c.apply(this, u) } catch (c) { } }, object_fill(ht.history, "pushState", historyReplacementFunction), object_fill(ht.history, "replaceState", historyReplacementFunction) } function envelope_createEnvelope(c, u = []) { return [c, u] } function addItemToEnvelope(c, u) { const [d, v] = c; return [d, [...v, u]] } function forEachEnvelopeItem(c, u) { const d = c[1]; for (const c of d) { if (u(c, c[0].type)) return !0 } return !1 } function envelopeContainsItemType(c, u) { return forEachEnvelopeItem(c, ((c, d) => u.includes(d))) } function encodeUTF8(c) { return se.__SENTRY__ && se.__SENTRY__.encodePolyfill ? se.__SENTRY__.encodePolyfill(c) : (new TextEncoder).encode(c) } function serializeEnvelope(c) { const [u, d] = c; let v = JSON.stringify(u); function append(c) { "string" == typeof v ? v = "string" == typeof c ? v + c : [encodeUTF8(v), c] : v.push("string" == typeof c ? encodeUTF8(c) : c) } for (const c of d) { const [u, d] = c; if (append(`\n${JSON.stringify(u)}\n`), "string" == typeof d || d instanceof Uint8Array) append(d); else { let c; try { c = JSON.stringify(d) } catch (u) { c = JSON.stringify(normalize_normalize(d)) } append(c) } } return "string" == typeof v ? v : function concatBuffers(c) { const u = c.reduce(((c, u) => c + u.length), 0), d = new Uint8Array(u); let v = 0; for (const u of c) d.set(u, v), v += u.length; return d }(v) } function parseEnvelope(c) { let u = "string" == typeof c ? encodeUTF8(c) : c; function readBinary(c) { const d = u.subarray(0, c); return u = u.subarray(c + 1), d } function readJson() { let c = u.indexOf(10); return c < 0 && (c = u.length), JSON.parse(function decodeUTF8(c) { return se.__SENTRY__ && se.__SENTRY__.decodePolyfill ? se.__SENTRY__.decodePolyfill(c) : (new TextDecoder).decode(c) }(readBinary(c))) } const d = readJson(), v = []; for (; u.length;) { const c = readJson(), u = "number" == typeof c.length ? c.length : void 0; v.push([c, u ? readBinary(u) : readJson()]) } return [d, v] } function createSpanEnvelopeItem(c) { return [{ "type": "span" }, c] } function createAttachmentEnvelopeItem(c) { const u = "string" == typeof c.data ? encodeUTF8(c.data) : c.data; return [object_dropUndefinedKeys({ "type": "attachment", "length": u.length, "filename": c.filename, "content_type": c.contentType, "attachment_type": c.attachmentType }), u] } const gt = { "session": "session", "sessions": "session", "attachment": "attachment", "transaction": "transaction", "event": "error", "client_report": "internal", "user_report": "default", "profile": "profile", "profile_chunk": "profile", "replay_event": "replay", "replay_recording": "replay", "check_in": "monitor", "feedback": "feedback", "span": "span", "statsd": "metric_bucket" }; function envelopeItemTypeToDataCategory(c) { return gt[c] } function envelope_getSdkMetadataForEnvelopeHeader(c) { if (!c || !c.sdk) return; const { "name": u, "version": d } = c.sdk; return { "name": u, "version": d } } class SentryError extends Error { "constructor"(c, u = "warn") { super(c), this.message = c, this.name = new.target.prototype.constructor.name, Object.setPrototypeOf(this, new.target.prototype), this.logLevel = u } } function createEventEnvelope(c, u, d, v) { const E = envelope_getSdkMetadataForEnvelopeHeader(d), k = c.type && "replay_event" !== c.type ? c.type : "event"; !function enhanceEventWithSdkInfo(c, u) { return u ? (c.sdk = c.sdk || {}, c.sdk.name = c.sdk.name || u.name, c.sdk.version = c.sdk.version || u.version, c.sdk.integrations = [...c.sdk.integrations || [], ...u.integrations || []], c.sdk.packages = [...c.sdk.packages || [], ...u.packages || []], c) : c }(c, d && d.sdk); const R = function envelope_createEventEnvelopeHeaders(c, u, d, v) { const E = c.sdkProcessingMetadata && c.sdkProcessingMetadata.dynamicSamplingContext; return { "event_id": c.event_id, "sent_at": (new Date).toISOString(), ...u && { "sdk": u }, ...!!d && v && { "dsn": dsn_dsnToString(v) }, ...E && { "trace": object_dropUndefinedKeys({ ...E }) } } }(c, E, v, u); delete c.sdkProcessingMetadata; return envelope_createEnvelope(R, [[{ "type": k }, c]]) } function parseSampleRate(c) { if ("boolean" == typeof c) return Number(c); const u = "string" == typeof c ? parseFloat(c) : c; if (!("number" != typeof u || isNaN(u) || u < 0 || u > 1)) return u; he && ue.warn(`[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(c)} of type ${JSON.stringify(typeof c)}.`) } const _t = "Not capturing exception because it's already been captured."; class BaseClient { "constructor"(c) { if (this._options = c, this._integrations = {}, this._numProcessing = 0, this._outcomes = {}, this._hooks = {}, this._eventProcessors = [], c.dsn ? this._dsn = makeDsn(c.dsn) : he && ue.warn("No DSN provided, client will not send events."), this._dsn) { const u = getEnvelopeEndpointWithUrlEncodedAuth(this._dsn, c.tunnel, c._metadata ? c._metadata.sdk : void 0); this._transport = c.transport({ "tunnel": this._options.tunnel, "recordDroppedEvent": this.recordDroppedEvent.bind(this), ...c.transportOptions, "url": u }) } } "captureException"(c, u, d) { const v = misc_uuid4(); if (checkOrSetAlreadyCaught(c)) return he && ue.log(_t), v; const E = { "event_id": v, ...u }; return this._process(this.eventFromException(c, E).then((c => this._captureEvent(c, E, d)))), E.event_id } "captureMessage"(c, u, d, v) { const E = { "event_id": misc_uuid4(), ...d }, k = isParameterizedString(c) ? c : String(c), R = is_isPrimitive(c) ? this.eventFromMessage(k, u, E) : this.eventFromException(c, E); return this._process(R.then((c => this._captureEvent(c, E, v)))), E.event_id } "captureEvent"(c, u, d) { const v = misc_uuid4(); if (u && u.originalException && checkOrSetAlreadyCaught(u.originalException)) return he && ue.log(_t), v; const E = { "event_id": v, ...u }, k = (c.sdkProcessingMetadata || {}).capturedSpanScope; return this._process(this._captureEvent(c, E, k || d)), E.event_id } "captureSession"(c) { "string" != typeof c.release ? he && ue.warn("Discarded session because of missing or non-string release") : (this.sendSession(c), session_updateSession(c, { "init": !1 })) } "getDsn"() { return this._dsn } "getOptions"() { return this._options } "getSdkMetadata"() { return this._options._metadata } "getTransport"() { return this._transport } "flush"(c) { const u = this._transport; return u ? (this.emit("flush"), this._isClientDoneProcessing(c).then((d => u.flush(c).then((c => d && c))))) : resolvedSyncPromise(!0) } "close"(c) { return this.flush(c).then((c => (this.getOptions().enabled = !1, this.emit("close"), c))) } "getEventProcessors"() { return this._eventProcessors } "addEventProcessor"(c) { this._eventProcessors.push(c) } "init"() { (this._isEnabled() || this._options.integrations.some((({ "name": c }) => c.startsWith("Spotlight")))) && this._setupIntegrations() } "getIntegrationByName"(c) { return this._integrations[c] } "addIntegration"(c) { const u = this._integrations[c.name]; setupIntegration(this, c, this._integrations), u || afterSetupIntegrations(this, [c]) } "sendEvent"(c, u = {}) { this.emit("beforeSendEvent", c, u); let d = createEventEnvelope(c, this._dsn, this._options._metadata, this._options.tunnel); for (const c of u.attachments || []) d = addItemToEnvelope(d, createAttachmentEnvelopeItem(c)); const v = this.sendEnvelope(d); v && v.then((u => this.emit("afterSendEvent", c, u)), null) } "sendSession"(c) { const u = function createSessionEnvelope(c, u, d, v) { const E = envelope_getSdkMetadataForEnvelopeHeader(d); return envelope_createEnvelope({ "sent_at": (new Date).toISOString(), ...E && { "sdk": E }, ...!!v && u && { "dsn": dsn_dsnToString(u) } }, ["aggregates" in c ? [{ "type": "sessions" }, c] : [{ "type": "session" }, c.toJSON()]]) }(c, this._dsn, this._options._metadata, this._options.tunnel); this.sendEnvelope(u) } "recordDroppedEvent"(c, u, d) { if (this._options.sendClientReports) { const v = "number" == typeof d ? d : 1, E = `${c}:${u}`; he && ue.log(`Recording outcome: "${E}"${v > 1 ? ` (${v} times)` : ""}`), this._outcomes[E] = (this._outcomes[E] || 0) + v } } "on"(c, u) { const d = this._hooks[c] = this._hooks[c] || []; return d.push(u), () => { const c = d.indexOf(u); c > -1 && d.splice(c, 1) } } "emit"(c, ...u) { const d = this._hooks[c]; d && d.forEach((c => c(...u))) } "sendEnvelope"(c) { return this.emit("beforeEnvelope", c), this._isEnabled() && this._transport ? this._transport.send(c).then(null, (c => (he && ue.error("Error while sending event:", c), c))) : (he && ue.error("Transport disabled"), resolvedSyncPromise({})) } "_setupIntegrations"() { const { "integrations": c } = this._options; this._integrations = function setupIntegrations(c, u) { const d = {}; return u.forEach((u => { u && setupIntegration(c, u, d) })), d }(this, c), afterSetupIntegrations(this, c) } "_updateSessionFromEvent"(c, u) { let d = !1, v = !1; const E = u.exception && u.exception.values; if (E) { v = !0; for (const c of E) { const u = c.mechanism; if (u && !1 === u.handled) { d = !0; break } } } const k = "ok" === c.status; (k && 0 === c.errors || k && d) && (session_updateSession(c, { ...d && { "status": "crashed" }, "errors": c.errors || Number(v || d) }), this.captureSession(c)) } "_isClientDoneProcessing"(c) { return new SyncPromise((u => { let d = 0; const v = setInterval((() => { 0 == this._numProcessing ? (clearInterval(v), u(!0)) : (d += 1, c && d >= c && (clearInterval(v), u(!1))) }), 1) })) } "_isEnabled"() { return !1 !== this.getOptions().enabled && void 0 !== this._transport } "_prepareEvent"(c, u, d, v = currentScopes_getIsolationScope()) { const E = this.getOptions(), k = Object.keys(this._integrations); return !u.integrations && k.length > 0 && (u.integrations = k), this.emit("preprocessEvent", c, u), c.type || v.setLastEventId(c.event_id || u.event_id), prepareEvent(E, c, u, d, this, v).then((c => { if (null === c) return c; const u = { ...v.getPropagationContext(), ...d ? d.getPropagationContext() : void 0 }; if (!(c.contexts && c.contexts.trace) && u) { const { "traceId": d, "spanId": v, "parentSpanId": E, "dsc": k } = u; c.contexts = { "trace": object_dropUndefinedKeys({ "trace_id": d, "span_id": v, "parent_span_id": E }), ...c.contexts }; const R = k || getDynamicSamplingContextFromClient(d, this); c.sdkProcessingMetadata = { "dynamicSamplingContext": R, ...c.sdkProcessingMetadata } } return c })) } "_captureEvent"(c, u = {}, d) { return this._processEvent(c, u, d).then((c => c.event_id), (c => { if (he) { const u = c; "log" === u.logLevel ? ue.log(u.message) : ue.warn(u) } })) } "_processEvent"(c, u, d) { const v = this.getOptions(), { "sampleRate": E } = v, k = isTransactionEvent(c), R = baseclient_isErrorEvent(c), U = c.type || "error", H = `before send for type \`${U}\``, G = void 0 === E ? void 0 : parseSampleRate(E); if (R && "number" == typeof G && Math.random() > G) return this.recordDroppedEvent("sample_rate", "error", c), rejectedSyncPromise(new SentryError(`Discarding event because it's not included in the random sample (sampling rate = ${E})`, "log")); const W = "replay_event" === U ? "replay" : U, Z = (c.sdkProcessingMetadata || {}).capturedSpanIsolationScope; return this._prepareEvent(c, u, d, Z).then((d => { if (null === d) throw this.recordDroppedEvent("event_processor", W, c), new SentryError("An event processor returned `null`, will not send event.", "log"); if (u.data && !0 === u.data.__sentry__) return d; const E = function processBeforeSend(c, u, d, v) { const { "beforeSend": E, "beforeSendTransaction": k, "beforeSendSpan": R } = u; if (baseclient_isErrorEvent(d) && E) return E(d, v); if (isTransactionEvent(d)) { if (d.spans && R) { const u = []; for (const v of d.spans) { const d = R(v); d ? u.push(d) : c.recordDroppedEvent("before_send", "span") } d.spans = u } if (k) { if (d.spans) { const c = d.spans.length; d.sdkProcessingMetadata = { ...d.sdkProcessingMetadata, "spanCountBeforeProcessing": c } } return k(d, v) } } return d }(this, v, d, u); return function _validateBeforeSendResult(c, u) { const d = `${u} must return \`null\` or a valid event.`; if (is_isThenable(c)) return c.then((c => { if (!isPlainObject(c) && null !== c) throw new SentryError(d); return c }), (c => { throw new SentryError(`${u} rejected with ${c}`) })); if (!isPlainObject(c) && null !== c) throw new SentryError(d); return c }(E, H) })).then((v => { if (null === v) { if (this.recordDroppedEvent("before_send", W, c), k) { const u = 1 + (c.spans || []).length; this.recordDroppedEvent("before_send", "span", u) } throw new SentryError(`${H} returned \`null\`, will not send event.`, "log") } const E = d && d.getSession(); if (!k && E && this._updateSessionFromEvent(E, v), k) { const c = (v.sdkProcessingMetadata && v.sdkProcessingMetadata.spanCountBeforeProcessing || 0) - (v.spans ? v.spans.length : 0); c > 0 && this.recordDroppedEvent("before_send", "span", c) } const R = v.transaction_info; if (k && R && v.transaction !== c.transaction) { const c = "custom"; v.transaction_info = { ...R, "source": c } } return this.sendEvent(v, u), v })).then(null, (c => { if (c instanceof SentryError) throw c; throw this.captureException(c, { "data": { "__sentry__": !0 }, "originalException": c }), new SentryError(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\nReason: ${c}`) })) } "_process"(c) { this._numProcessing++, c.then((c => (this._numProcessing--, c)), (c => (this._numProcessing--, c))) } "_clearOutcomes"() { const c = this._outcomes; return this._outcomes = {}, Object.entries(c).map((([c, u]) => { const [d, v] = c.split(":"); return { "reason": d, "category": v, "quantity": u } })) } "_flushOutcomes"() { he && ue.log("Flushing outcomes..."); const c = this._clearOutcomes(); if (0 === c.length) return void (he && ue.log("No outcomes to send")); if (!this._dsn) return void (he && ue.log("No dsn provided, will not send outcomes")); he && ue.log("Sending outcomes:", c); const u = function createClientReportEnvelope(c, u, d) { return envelope_createEnvelope(u ? { "dsn": u } : {}, [[{ "type": "client_report" }, { "timestamp": d || time_dateTimestampInSeconds(), "discarded_events": c }]]) }(c, this._options.tunnel && dsn_dsnToString(this._dsn)); this.sendEnvelope(u) } } function baseclient_isErrorEvent(c) { return void 0 === c.type } function isTransactionEvent(c) { return "transaction" === c.type } const vt = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__; function exceptionFromError(c, u) { const d = parseStackFrames(c, u), v = { "type": u && u.name, "value": extractMessage(u) }; return d.length && (v.stacktrace = { "frames": d }), void 0 === v.type && "" === v.value && (v.value = "Unrecoverable error caught"), v } function eventFromPlainObject(c, u, d, v) { const E = currentScopes_getClient(), k = E && E.getOptions().normalizeDepth, R = function getErrorPropertyFromObject(c) { for (const u in c) if (Object.prototype.hasOwnProperty.call(c, u)) { const d = c[u]; if (d instanceof Error) return d } return }(u), U = { "__serialized__": normalizeToSize(u, k) }; if (R) return { "exception": { "values": [exceptionFromError(c, R)] }, "extra": U }; const H = { "exception": { "values": [{ "type": is_isEvent(u) ? u.constructor.name : v ? "UnhandledRejection" : "Error", "value": getNonErrorObjectExceptionValue(u, { "isUnhandledRejection": v }) }] }, "extra": U }; if (d) { const u = parseStackFrames(c, d); u.length && (H.exception.values[0].stacktrace = { "frames": u }) } return H } function eventFromError(c, u) { return { "exception": { "values": [exceptionFromError(c, u)] } } } function parseStackFrames(c, u) { const d = u.stacktrace || u.stack || "", v = function getSkipFirstStackStringLines(c) { if (c && yt.test(c.message)) return 1; return 0 }(u), E = function getPopFirstTopFrames(c) { if ("number" == typeof c.framesToPop) return c.framesToPop; return 0 }(u); try { return c(d, v, E) } catch (c) { } return [] } const yt = /Minified React error #\d+;/i; function extractMessage(c) { const u = c && c.message; return u ? u.error && "string" == typeof u.error.message ? u.error.message : u : "No error message" } function eventFromException(c, u, d, v) { const E = eventFromUnknownInput(c, u, d && d.syntheticException || void 0, v); return misc_addExceptionMechanism(E), E.level = "error", d && d.event_id && (E.event_id = d.event_id), resolvedSyncPromise(E) } function eventFromMessage(c, u, d = "info", v, E) { const k = eventFromString(c, u, v && v.syntheticException || void 0, E); return k.level = d, v && v.event_id && (k.event_id = v.event_id), resolvedSyncPromise(k) } function eventFromUnknownInput(c, u, d, v, E) { let k; if (isErrorEvent(u) && u.error) { return eventFromError(c, u.error) } if (isDOMError(u) || function isDOMException(c) { return isBuiltin(c, "DOMException") }(u)) { const E = u; if ("stack" in u) k = eventFromError(c, u); else { const u = E.name || (isDOMError(E) ? "DOMError" : "DOMException"), R = E.message ? `${u}: ${E.message}` : u; k = eventFromString(c, R, d, v), addExceptionTypeValue(k, R) } return "code" in E && (k.tags = { ...k.tags, "DOMException.code": `${E.code}` }), k } if (is_isError(u)) return eventFromError(c, u); if (isPlainObject(u) || is_isEvent(u)) { return k = eventFromPlainObject(c, u, d, E), misc_addExceptionMechanism(k, { "synthetic": !0 }), k } return k = eventFromString(c, u, d, v), addExceptionTypeValue(k, `${u}`, void 0), misc_addExceptionMechanism(k, { "synthetic": !0 }), k } function eventFromString(c, u, d, v) { const E = {}; if (v && d) { const v = parseStackFrames(c, d); v.length && (E.exception = { "values": [{ "value": u, "stacktrace": { "frames": v } }] }) } if (isParameterizedString(u)) { const { "__sentry_template_string__": c, "__sentry_template_values__": d } = u; return E.logentry = { "message": c, "params": d }, E } return E.message = u, E } function getNonErrorObjectExceptionValue(c, { "isUnhandledRejection": u }) { const d = function extractExceptionKeysForMessage(c, u = 40) { const d = Object.keys(convertToPlainObject(c)); d.sort(); const v = d[0]; if (!v) return "[object has no keys]"; if (v.length >= u) return string_truncate(v, u); for (let c = d.length; c > 0; c--) { const v = d.slice(0, c).join(", "); if (!(v.length > u)) return c === d.length ? v : string_truncate(v, u) } return "" }(c), v = u ? "promise rejection" : "exception"; if (isErrorEvent(c)) return `Event \`ErrorEvent\` captured as ${v} with message \`${c.message}\``; if (is_isEvent(c)) { return `Event \`${function getObjectClassName(c) { try { const u = Object.getPrototypeOf(c); return u ? u.constructor.name : void 0 } catch (c) { } }(c)}\` (type=${c.type}) captured as ${v}` } return `Object captured as ${v} with keys: ${d}` } const bt = se; let St = 0; function shouldIgnoreOnError() { return St > 0 } function wrap(c, u = {}, d) { if ("function" != typeof c) return c; try { const u = c.__sentry_wrapped__; if (u) return u; if (getOriginalFunction(c)) return c } catch (u) { return c } const sentryWrapped = function () { const v = Array.prototype.slice.call(arguments); try { d && "function" == typeof d && d.apply(this, arguments); const E = v.map((c => wrap(c, u))); return c.apply(this, E) } catch (c) { throw function ignoreNextOnError() { St++, setTimeout((() => { St-- })) }(), currentScopes_withScope((d => { d.addEventProcessor((c => (u.mechanism && (addExceptionTypeValue(c, void 0, void 0), misc_addExceptionMechanism(c, u.mechanism)), c.extra = { ...c.extra, "arguments": v }, c))), captureException(c) })), c } }; try { for (const u in c) Object.prototype.hasOwnProperty.call(c, u) && (sentryWrapped[u] = c[u]) } catch (c) { } markFunctionWrapped(sentryWrapped, c), object_addNonEnumerableProperty(c, "__sentry_wrapped__", sentryWrapped); try { Object.getOwnPropertyDescriptor(sentryWrapped, "name").configurable && Object.defineProperty(sentryWrapped, "name", { "get"() { return c.name } }) } catch (c) { } return sentryWrapped } function createUserFeedbackEnvelope(c, { "metadata": u, "tunnel": d, "dsn": v }) { const E = { "event_id": c.event_id, "sent_at": (new Date).toISOString(), ...u && u.sdk && { "sdk": { "name": u.sdk.name, "version": u.sdk.version } }, ...!!d && !!v && { "dsn": dsn_dsnToString(v) } }, k = function createUserFeedbackEnvelopeItem(c) { return [{ "type": "user_report" }, c] }(c); return envelope_createEnvelope(E, [k]) } class BrowserClient extends BaseClient { "constructor"(c) { const u = { "parentSpanIsAlwaysRootSpan": !0, ...c }; !function applySdkMetadata(c, u, d = [u], v = "npm") { const E = c._metadata || {}; E.sdk || (E.sdk = { "name": `sentry.javascript.${u}`, "packages": d.map((c => ({ "name": `${v}:@sentry/${c}`, "version": ie }))), "version": ie }), c._metadata = E }(u, "browser", ["browser"], bt.SENTRY_SDK_SOURCE || "npm"), super(u), u.sendClientReports && bt.document && bt.document.addEventListener("visibilitychange", (() => { "hidden" === bt.document.visibilityState && this._flushOutcomes() })) } "eventFromException"(c, u) { return eventFromException(this._options.stackParser, c, u, this._options.attachStacktrace) } "eventFromMessage"(c, u = "info", d) { return eventFromMessage(this._options.stackParser, c, u, d, this._options.attachStacktrace) } "captureUserFeedback"(c) { if (!this._isEnabled()) return void (vt && ue.warn("SDK not enabled, will not capture user feedback.")); const u = createUserFeedbackEnvelope(c, { "metadata": this.getSdkMetadata(), "dsn": this.getDsn(), "tunnel": this.getOptions().tunnel }); this.sendEnvelope(u) } "_prepareEvent"(c, u, d) { return c.platform = c.platform || "javascript", super._prepareEvent(c, u, d) } } function esm_misc_uuid4() { const c = it, u = c.crypto || c.msCrypto; let getRandomByte = () => 16 * Math.random(); try { if (u && u.randomUUID) return u.randomUUID().replace(/-/g, ""); u && u.getRandomValues && (getRandomByte = () => { const c = new Uint8Array(1); return u.getRandomValues(c), c[0] }) } catch (c) { } return ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, (c => (c ^ (15 & getRandomByte()) >> c / 4).toString(16))) } const wt = 1e3; let Et, Ct, Tt; function addClickKeypressInstrumentationHandler(c) { addHandler("dom", c), maybeInstrument("dom", instrumentDOM) } function instrumentDOM() { if (!ht.document) return; const c = triggerHandlers.bind(null, "dom"), u = makeDOMEventHandler(c, !0); ht.document.addEventListener("click", u, !1), ht.document.addEventListener("keypress", u, !1), ["EventTarget", "Node"].forEach((u => { const d = ht[u] && ht[u].prototype; d && d.hasOwnProperty && d.hasOwnProperty("addEventListener") && (object_fill(d, "addEventListener", (function (u) { return function (d, v, E) { if ("click" === d || "keypress" == d) try { const v = this, k = v.__sentry_instrumentation_handlers__ = v.__sentry_instrumentation_handlers__ || {}, R = k[d] = k[d] || { "refCount": 0 }; if (!R.handler) { const v = makeDOMEventHandler(c); R.handler = v, u.call(this, d, v, E) } R.refCount++ } catch (c) { } return u.call(this, d, v, E) } })), object_fill(d, "removeEventListener", (function (c) { return function (u, d, v) { if ("click" === u || "keypress" == u) try { const d = this, E = d.__sentry_instrumentation_handlers__ || {}, k = E[u]; k && (k.refCount--, k.refCount <= 0 && (c.call(this, u, k.handler, v), k.handler = void 0, delete E[u]), 0 === Object.keys(E).length && delete d.__sentry_instrumentation_handlers__) } catch (c) { } return c.call(this, u, d, v) } }))) })) } function makeDOMEventHandler(c, u = !1) { return d => { if (!d || d._sentryCaptured) return; const v = function getEventTarget(c) { try { return c.target } catch (c) { return null } }(d); if (function shouldSkipDOMEvent(c, u) { return "keypress" === c && (!u || !u.tagName || "INPUT" !== u.tagName && "TEXTAREA" !== u.tagName && !u.isContentEditable) }(d.type, v)) return; esm_object_addNonEnumerableProperty(d, "_sentryCaptured", !0), v && !v._sentryId && esm_object_addNonEnumerableProperty(v, "_sentryId", esm_misc_uuid4()); const E = "keypress" === d.type ? "input" : d.type; if (!function isSimilarToLastCapturedEvent(c) { if (c.type !== Ct) return !1; try { if (!c.target || c.target._sentryId !== Tt) return !1 } catch (c) { } return !0 }(d)) { c({ "event": d, "name": E, "global": u }), Ct = d.type, Tt = v ? v._sentryId : void 0 } clearTimeout(Et), Et = ht.setTimeout((() => { Tt = void 0, Ct = void 0 }), wt) } } const xt = 1e3; function esm_time_dateTimestampInSeconds() { return Date.now() / xt } const At = function time_createUnixTimestampInSecondsFunc() { const { "performance": c } = it; if (!c || !c.now) return esm_time_dateTimestampInSeconds; const u = Date.now() - c.now(), d = null == c.timeOrigin ? u : c.timeOrigin; return () => (d + c.now()) / xt }(); let It; const kt = (() => { const { "performance": c } = it; if (!c || !c.now) return void (It = "none"); const u = 36e5, d = c.now(), v = Date.now(), E = c.timeOrigin ? Math.abs(c.timeOrigin + d - v) : u, k = E < u, R = c.timing && c.timing.navigationStart, U = "number" == typeof R ? Math.abs(R + d - v) : u; return k || U < u ? E <= U ? (It = "timeOrigin", c.timeOrigin) : (It = "navigationStart", R) : (It = "dateNow", v) })(), Ot = "__sentry_xhr_v3__"; function addXhrInstrumentationHandler(c) { addHandler("xhr", c), maybeInstrument("xhr", instrumentXHR) } function instrumentXHR() { if (!ht.XMLHttpRequest) return; const c = XMLHttpRequest.prototype; c.open = new Proxy(c.open, { "apply"(c, u, d) { const v = 1e3 * At(), E = esm_is_isString(d[0]) ? d[0].toUpperCase() : void 0, k = function parseUrl(c) { if (esm_is_isString(c)) return c; try { return c.toString() } catch (c) { } return }(d[1]); if (!E || !k) return c.apply(u, d); u[Ot] = { "method": E, "url": k, "request_headers": {} }, "POST" === E && k.match(/sentry_key/) && (u.__sentry_own_request__ = !0); const onreadystatechangeHandler = () => { const c = u[Ot]; if (c && 4 === u.readyState) { try { c.status_code = u.status } catch (c) { } triggerHandlers("xhr", { "endTimestamp": 1e3 * At(), "startTimestamp": v, "xhr": u }) } }; return "onreadystatechange" in u && "function" == typeof u.onreadystatechange ? u.onreadystatechange = new Proxy(u.onreadystatechange, { "apply"(c, u, d) { return onreadystatechangeHandler(), c.apply(u, d) } }) : u.addEventListener("readystatechange", onreadystatechangeHandler), u.setRequestHeader = new Proxy(u.setRequestHeader, { "apply"(c, u, d) { const [v, E] = d, k = u[Ot]; return k && esm_is_isString(v) && esm_is_isString(E) && (k.request_headers[v.toLowerCase()] = E), c.apply(u, d) } }), c.apply(u, d) } }), c.send = new Proxy(c.send, { "apply"(c, u, d) { const v = u[Ot]; if (!v) return c.apply(u, d); void 0 !== d[0] && (v.body = d[0]); return triggerHandlers("xhr", { "startTimestamp": 1e3 * At(), "xhr": u }), c.apply(u, d) } }) } const Pt = 100; function addBreadcrumb(c, u) { const d = currentScopes_getClient(), v = currentScopes_getIsolationScope(); if (!d) return; const { "beforeBreadcrumb": E = null, "maxBreadcrumbs": k = Pt } = d.getOptions(); if (k <= 0) return; const R = { "timestamp": time_dateTimestampInSeconds(), ...c }, U = E ? logger_consoleSandbox((() => E(R, u))) : R; null !== U && (d.emit && d.emit("beforeAddBreadcrumb", U, u), v.addBreadcrumb(U, k)) } const Rt = {}, Mt = {}; function handlers_addHandler(c, u) { Rt[c] = Rt[c] || [], Rt[c].push(u) } function handlers_maybeInstrument(c, u) { Mt[c] || (u(), Mt[c] = !0) } function handlers_triggerHandlers(c, u) { const d = c && Rt[c]; if (d) for (const v of d) try { v(u) } catch (u) { ae && ue.error(`Error while triggering instrumentation handler.\nType: ${c}\nName: ${getFunctionName(v)}\nError:`, u) } } function addConsoleInstrumentationHandler(c) { const u = "console"; handlers_addHandler(u, c), handlers_maybeInstrument(u, instrumentConsole) } function instrumentConsole() { "console" in se && ce.forEach((function (c) { c in se.console && fill(se.console, c, (function (u) { return le[c] = u, function (...u) { handlers_triggerHandlers("console", { "args": u, "level": c }); const d = le[c]; d && d.apply(se.console, u) } })) })) } function addFetchInstrumentationHandler(c, u) { const d = "fetch"; handlers_addHandler(d, c), handlers_maybeInstrument(d, (() => instrumentFetch(void 0, u))) } function instrumentFetch(c, u = !1) { u && !supportsNativeFetch() || fill(se, "fetch", (function (u) { return function (...d) { const { "method": v, "url": E } = function parseFetchArgs(c) { if (0 === c.length) return { "method": "GET", "url": "" }; if (2 === c.length) { const [u, d] = c; return { "url": getUrlFromResource(u), "method": hasProp(d, "method") ? String(d.method).toUpperCase() : "GET" } } const u = c[0]; return { "url": getUrlFromResource(u), "method": hasProp(u, "method") ? String(u.method).toUpperCase() : "GET" } }(d), k = { "args": d, "fetchData": { "method": v, "url": E }, "startTimestamp": 1e3 * ge() }; c || handlers_triggerHandlers("fetch", { ...k }); const R = (new Error).stack; return u.apply(se, d).then((async u => (c ? c(u) : handlers_triggerHandlers("fetch", { ...k, "endTimestamp": 1e3 * ge(), "response": u }), u)), (c => { throw handlers_triggerHandlers("fetch", { ...k, "endTimestamp": 1e3 * ge(), "error": c }), is_isError(c) && void 0 === c.stack && (c.stack = R, object_addNonEnumerableProperty(c, "framesToPop", 1)), c })) } })) } async function streamHandler(c) { let u; try { u = c.clone() } catch (c) { return } await async function resolveResponse(c, u) { if (c && c.body && c.body.getReader) { const d = c.body.getReader(); async function consumeChunks({ "done": c }) { if (c) return Promise.resolve(); try { const c = await Promise.race([d.read(), new Promise((c => { setTimeout((() => { c({ "done": !0 }) }), 5e3) }))]); await consumeChunks(c) } catch (c) { } } return d.read().then(consumeChunks).then(u).catch((() => { })) } }(u, (() => { handlers_triggerHandlers("fetch-body-resolved", { "endTimestamp": 1e3 * ge(), "response": c }) })) } function hasProp(c, u) { return !!c && "object" == typeof c && !!c[u] } function getUrlFromResource(c) { return "string" == typeof c ? c : c ? hasProp(c, "url") ? c.url : c.toString ? c.toString() : "" : "" } const Nt = ["fatal", "error", "warning", "log", "info", "debug"]; function severityLevelFromString(c) { return "warn" === c ? "warning" : Nt.includes(c) ? c : "log" } function url_parseUrl(c) { if (!c) return {}; const u = c.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/); if (!u) return {}; const d = u[6] || "", v = u[8] || ""; return { "host": u[4], "path": u[5], "protocol": u[2], "search": d, "hash": v, "relative": u[5] + d + v } } const Dt = 1024, breadcrumbsIntegration = (c = {}) => { const u = { "console": !0, "dom": !0, "fetch": !0, "history": !0, "sentry": !0, "xhr": !0, ...c }; return { "name": "Breadcrumbs", "setup"(c) { u.console && addConsoleInstrumentationHandler(function _getConsoleBreadcrumbHandler(c) { return function _consoleBreadcrumb(u) { if (currentScopes_getClient() !== c) return; const d = { "category": "console", "data": { "arguments": u.args, "logger": "console" }, "level": severityLevelFromString(u.level), "message": safeJoin(u.args, " ") }; if ("assert" === u.level) { if (!1 !== u.args[0]) return; d.message = `Assertion failed: ${safeJoin(u.args.slice(1), " ") || "console.assert"}`, d.data.arguments = u.args.slice(1) } addBreadcrumb(d, { "input": u.args, "level": u.level }) } }(c)), u.dom && addClickKeypressInstrumentationHandler(function _getDomBreadcrumbHandler(c, u) { return function _innerDomBreadcrumb(d) { if (currentScopes_getClient() !== c) return; let v, E, k = "object" == typeof u ? u.serializeAttribute : void 0, R = "object" == typeof u && "number" == typeof u.maxStringLength ? u.maxStringLength : void 0; R && R > Dt && (vt && ue.warn(`\`dom.maxStringLength\` cannot exceed 1024, but a value of ${R} was configured. Sentry will use 1024 instead.`), R = Dt), "string" == typeof k && (k = [k]); try { const c = d.event, u = function _isEvent(c) { return !!c && !!c.target }(c) ? c.target : c; v = browser_htmlTreeAsString(u, { "keyAttrs": k, "maxStringLength": R }), E = function getComponentName(c) { if (!pe.HTMLElement) return null; let u = c; for (let c = 0; c < 5; c++) { if (!u) return null; if (u instanceof HTMLElement) { if (u.dataset.sentryComponent) return u.dataset.sentryComponent; if (u.dataset.sentryElement) return u.dataset.sentryElement } u = u.parentNode } return null }(u) } catch (c) { v = "<unknown>" } if (0 === v.length) return; const U = { "category": `ui.${d.name}`, "message": v }; E && (U.data = { "ui.component_name": E }), addBreadcrumb(U, { "event": d.event, "name": d.name, "global": d.global }) } }(c, u.dom)), u.xhr && addXhrInstrumentationHandler(function _getXhrBreadcrumbHandler(c) { return function _xhrBreadcrumb(u) { if (currentScopes_getClient() !== c) return; const { "startTimestamp": d, "endTimestamp": v } = u, E = u.xhr[Ot]; if (!d || !v || !E) return; const { "method": k, "url": R, "status_code": U, "body": H } = E; addBreadcrumb({ "category": "xhr", "data": { "method": k, "url": R, "status_code": U }, "type": "http" }, { "xhr": u.xhr, "input": H, "startTimestamp": d, "endTimestamp": v }) } }(c)), u.fetch && addFetchInstrumentationHandler(function _getFetchBreadcrumbHandler(c) { return function _fetchBreadcrumb(u) { if (currentScopes_getClient() !== c) return; const { "startTimestamp": d, "endTimestamp": v } = u; if (v && (!u.fetchData.url.match(/sentry_key/) || "POST" !== u.fetchData.method)) if (u.error) { addBreadcrumb({ "category": "fetch", "data": u.fetchData, "level": "error", "type": "http" }, { "data": u.error, "input": u.args, "startTimestamp": d, "endTimestamp": v }) } else { const c = u.response; addBreadcrumb({ "category": "fetch", "data": { ...u.fetchData, "status_code": c && c.status }, "type": "http" }, { "input": u.args, "response": c, "startTimestamp": d, "endTimestamp": v }) } } }(c)), u.history && addHistoryInstrumentationHandler(function _getHistoryBreadcrumbHandler(c) { return function _historyBreadcrumb(u) { if (currentScopes_getClient() !== c) return; let d = u.from, v = u.to; const E = url_parseUrl(bt.location.href); let k = d ? url_parseUrl(d) : void 0; const R = url_parseUrl(v); k && k.path || (k = E), E.protocol === R.protocol && E.host === R.host && (v = R.relative), E.protocol === k.protocol && E.host === k.host && (d = k.relative), addBreadcrumb({ "category": "navigation", "data": { "from": d, "to": v } }) } }(c)), u.sentry && c.on("beforeSendEvent", function _getSentryBreadcrumbHandler(c) { return function addSentryBreadcrumb(u) { currentScopes_getClient() === c && addBreadcrumb({ "category": "sentry." + ("transaction" === u.type ? "transaction" : "event"), "event_id": u.event_id, "level": u.level, "message": getEventDescription(u) }, { "event": u }) } }(c)) } } }; const $t = ["EventTarget", "Window", "Node", "ApplicationCache", "AudioTrackList", "BroadcastChannel", "ChannelMergerNode", "CryptoOperation", "EventSource", "FileReader", "HTMLUnknownElement", "IDBDatabase", "IDBRequest", "IDBTransaction", "KeyOperation", "MediaController", "MessagePort", "ModalWindow", "Notification", "SVGElementInstance", "Screen", "SharedWorker", "TextTrack", "TextTrackCue", "TextTrackList", "WebSocket", "WebSocketWorker", "Worker", "XMLHttpRequest", "XMLHttpRequestEventTarget", "XMLHttpRequestUpload"], browserApiErrorsIntegration = (c = {}) => { const u = { "XMLHttpRequest": !0, "eventTarget": !0, "requestAnimationFrame": !0, "setInterval": !0, "setTimeout": !0, ...c }; return { "name": "BrowserApiErrors", "setupOnce"() { u.setTimeout && fill(bt, "setTimeout", _wrapTimeFunction), u.setInterval && fill(bt, "setInterval", _wrapTimeFunction), u.requestAnimationFrame && fill(bt, "requestAnimationFrame", _wrapRAF), u.XMLHttpRequest && "XMLHttpRequest" in bt && fill(XMLHttpRequest.prototype, "send", _wrapXHR); const c = u.eventTarget; if (c) { (Array.isArray(c) ? c : $t).forEach(_wrapEventTarget) } } } }; function _wrapTimeFunction(c) { return function (...u) { const d = u[0]; return u[0] = wrap(d, { "mechanism": { "data": { "function": getFunctionName(c) }, "handled": !1, "type": "instrument" } }), c.apply(this, u) } } function _wrapRAF(c) { return function (u) { return c.apply(this, [wrap(u, { "mechanism": { "data": { "function": "requestAnimationFrame", "handler": getFunctionName(c) }, "handled": !1, "type": "instrument" } })]) } } function _wrapXHR(c) { return function (...u) { const d = this; return ["onload", "onerror", "onprogress", "onreadystatechange"].forEach((c => { c in d && "function" == typeof d[c] && fill(d, c, (function (u) { const d = { "mechanism": { "data": { "function": c, "handler": getFunctionName(u) }, "handled": !1, "type": "instrument" } }, v = getOriginalFunction(u); return v && (d.mechanism.data.handler = getFunctionName(v)), wrap(u, d) })) })), c.apply(this, u) } } function _wrapEventTarget(c) { const u = bt, d = u[c] && u[c].prototype; d && d.hasOwnProperty && d.hasOwnProperty("addEventListener") && (fill(d, "addEventListener", (function (u) { return function (d, v, E) { try { "function" == typeof v.handleEvent && (v.handleEvent = wrap(v.handleEvent, { "mechanism": { "data": { "function": "handleEvent", "handler": getFunctionName(v), "target": c }, "handled": !1, "type": "instrument" } })) } catch (c) { } return u.apply(this, [d, wrap(v, { "mechanism": { "data": { "function": "addEventListener", "handler": getFunctionName(v), "target": c }, "handled": !1, "type": "instrument" } }), E]) } })), fill(d, "removeEventListener", (function (c) { return function (u, d, v) { const E = d; try { const d = E && E.__sentry_wrapped__; d && c.call(this, u, d, v) } catch (c) { } return c.call(this, u, E, v) } }))) } let Lt = null; function addGlobalErrorInstrumentationHandler(c) { const u = "error"; handlers_addHandler(u, c), handlers_maybeInstrument(u, instrumentError) } function instrumentError() { Lt = se.onerror, se.onerror = function (c, u, d, v, E) { return handlers_triggerHandlers("error", { "column": v, "error": E, "line": d, "msg": c, "url": u }), !(!Lt || Lt.__SENTRY_LOADER__) && Lt.apply(this, arguments) }, se.onerror.__SENTRY_INSTRUMENTED__ = !0 } let Ft = null; function addGlobalUnhandledRejectionInstrumentationHandler(c) { const u = "unhandledrejection"; handlers_addHandler(u, c), handlers_maybeInstrument(u, instrumentUnhandledRejection) } function instrumentUnhandledRejection() { Ft = se.onunhandledrejection, se.onunhandledrejection = function (c) { return handlers_triggerHandlers("unhandledrejection", c), !(Ft && !Ft.__SENTRY_LOADER__) || Ft.apply(this, arguments) }, se.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0 } const globalHandlersIntegration = (c = {}) => { const u = { "onerror": !0, "onunhandledrejection": !0, ...c }; return { "name": "GlobalHandlers", "setupOnce"() { Error.stackTraceLimit = 50 }, "setup"(c) { u.onerror && (!function _installGlobalOnErrorHandler(c) { addGlobalErrorInstrumentationHandler((u => { const { "stackParser": d, "attachStacktrace": v } = getOptions(); if (currentScopes_getClient() !== c || shouldIgnoreOnError()) return; const { "msg": E, "url": k, "line": R, "column": U, "error": H } = u, G = function _enhanceEventWithInitialFrame(c, u, d, v) { const E = c.exception = c.exception || {}, k = E.values = E.values || [], R = k[0] = k[0] || {}, U = R.stacktrace = R.stacktrace || {}, H = U.frames = U.frames || [], G = isNaN(parseInt(v, 10)) ? void 0 : v, W = isNaN(parseInt(d, 10)) ? void 0 : d, Z = is_isString(u) && u.length > 0 ? u : function getLocationHref() { try { return pe.document.location.href } catch (c) { return "" } }(); 0 === H.length && H.push({ "colno": G, "filename": Z, "function": xe, "in_app": !0, "lineno": W }); return c }(eventFromUnknownInput(d, H || E, void 0, v, !1), k, R, U); G.level = "error", captureEvent(G, { "originalException": H, "mechanism": { "handled": !1, "type": "onerror" } }) })) }(c), globalHandlerLog("onerror")), u.onunhandledrejection && (!function _installGlobalOnUnhandledRejectionHandler(c) { addGlobalUnhandledRejectionInstrumentationHandler((u => { const { "stackParser": d, "attachStacktrace": v } = getOptions(); if (currentScopes_getClient() !== c || shouldIgnoreOnError()) return; const E = function _getUnhandledRejectionError(c) { if (is_isPrimitive(c)) return c; try { if ("reason" in c) return c.reason; if ("detail" in c && "reason" in c.detail) return c.detail.reason } catch (c) { } return c }(u), k = is_isPrimitive(E) ? function _eventFromRejectionWithPrimitive(c) { return { "exception": { "values": [{ "type": "UnhandledRejection", "value": `Non-Error promise rejection captured with value: ${String(c)}` }] } } }(E) : eventFromUnknownInput(d, E, void 0, v, !0); k.level = "error", captureEvent(k, { "originalException": E, "mechanism": { "handled": !1, "type": "onunhandledrejection" } }) })) }(c), globalHandlerLog("onunhandledrejection")) } } }; function globalHandlerLog(c) { vt && ue.log(`Global Handler attached: ${c}`) } function getOptions() { const c = currentScopes_getClient(); return c && c.getOptions() || { "stackParser": () => [], "attachStacktrace": !1 } } const httpContextIntegration = () => ({ "name": "HttpContext", "preprocessEvent"(c) { if (!bt.navigator && !bt.location && !bt.document) return; const u = c.request && c.request.url || bt.location && bt.location.href, { "referrer": d } = bt.document || {}, { "userAgent": v } = bt.navigator || {}, E = { ...c.request && c.request.headers, ...d && { "Referer": d }, ...v && { "User-Agent": v } }, k = { ...c.request, ...u && { "url": u }, "headers": E }; c.request = k } }); function applyAggregateErrorsToEvent(c, u, d = 250, v, E, k, R) { if (!(k.exception && k.exception.values && R && is_isInstanceOf(R.originalException, Error))) return; const U = k.exception.values.length > 0 ? k.exception.values[k.exception.values.length - 1] : void 0; U && (k.exception.values = function truncateAggregateExceptions(c, u) { return c.map((c => (c.value && (c.value = string_truncate(c.value, u)), c))) }(aggregateExceptionsFromError(c, u, E, R.originalException, v, k.exception.values, U, 0), d)) } function aggregateExceptionsFromError(c, u, d, v, E, k, R, U) { if (k.length >= d + 1) return k; let H = [...k]; if (is_isInstanceOf(v[E], Error)) { applyExceptionGroupFieldsForParentException(R, U); const k = c(u, v[E]), G = H.length; applyExceptionGroupFieldsForChildException(k, E, G, U), H = aggregateExceptionsFromError(c, u, d, v[E], E, [k, ...H], k, G) } return Array.isArray(v.errors) && v.errors.forEach(((v, k) => { if (is_isInstanceOf(v, Error)) { applyExceptionGroupFieldsForParentException(R, U); const G = c(u, v), W = H.length; applyExceptionGroupFieldsForChildException(G, `errors[${k}]`, W, U), H = aggregateExceptionsFromError(c, u, d, v, E, [G, ...H], G, W) } })), H } function applyExceptionGroupFieldsForParentException(c, u) { c.mechanism = c.mechanism || { "type": "generic", "handled": !0 }, c.mechanism = { ...c.mechanism, ..."AggregateError" === c.type && { "is_exception_group": !0 }, "exception_id": u } } function applyExceptionGroupFieldsForChildException(c, u, d, v) { c.mechanism = c.mechanism || { "type": "generic", "handled": !0 }, c.mechanism = { ...c.mechanism, "type": "chained", "source": u, "exception_id": d, "parent_id": v } } const linkedErrorsIntegration = (c = {}) => { const u = c.limit || 5, d = c.key || "cause"; return { "name": "LinkedErrors", "preprocessEvent"(c, v, E) { const k = E.getOptions(); applyAggregateErrorsToEvent(exceptionFromError, k.stackParser, k.maxValueLength, d, u, c, v) } } }; function createFrame(c, u, d, v) { const E = { "filename": c, "function": "<anonymous>" === u ? xe : u, "in_app": !0 }; return void 0 !== d && (E.lineno = d), void 0 !== v && (E.colno = v), E } const jt = /^\s*at (\S+?)(?::(\d+))(?::(\d+))\s*$/i, Bt = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i, Ut = /\((\S*)(?::(\d+))(?::(\d+))\)/, Ht = [30, c => { const u = jt.exec(c); if (u) { const [, c, d, v] = u; return createFrame(c, xe, +d, +v) } const d = Bt.exec(c); if (d) { if (d[2] && 0 === d[2].indexOf("eval")) { const c = Ut.exec(d[2]); c && (d[2] = c[1], d[3] = c[2], d[4] = c[3]) } const [c, u] = extractSafariExtensionDetails(d[1] || xe, d[2]); return createFrame(u, c, d[3] ? +d[3] : void 0, d[4] ? +d[4] : void 0) } }], zt = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i, qt = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i, Gt = [50, c => { const u = zt.exec(c); if (u) { if (u[3] && u[3].indexOf(" > eval") > -1) { const c = qt.exec(u[3]); c && (u[1] = u[1] || "eval", u[3] = c[1], u[4] = c[2], u[5] = "") } let c = u[3], d = u[1] || xe; return [d, c] = extractSafariExtensionDetails(d, c), createFrame(c, d, u[4] ? +u[4] : void 0, u[5] ? +u[5] : void 0) } }], Vt = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:[-a-z]+):.*?):(\d+)(?::(\d+))?\)?\s*$/i, Wt = [40, c => { const u = Vt.exec(c); return u ? createFrame(u[2], u[1] || xe, +u[3], u[4] ? +u[4] : void 0) : void 0 }], Zt = / line (\d+).*script (?:in )?(\S+)(?:: in function (\S+))?$/i, Yt = [10, c => { const u = Zt.exec(c); return u ? createFrame(u[2], u[3] || xe, +u[1]) : void 0 }], Jt = / line (\d+), column (\d+)\s*(?:in (?:<anonymous function: ([^>]+)>|([^)]+))\(.*\))? in (.*):\s*$/i, Kt = [20, c => { const u = Jt.exec(c); return u ? createFrame(u[5], u[3] || u[4] || xe, +u[1], +u[2]) : void 0 }], Xt = [Ht, Gt], Qt = createStackParser(...Xt), extractSafariExtensionDetails = (c, u) => { const d = -1 !== c.indexOf("safari-extension"), v = -1 !== c.indexOf("safari-web-extension"); return d || v ? [-1 !== c.indexOf("@") ? c.split("@")[0] : xe, d ? `safari-extension:${u}` : `safari-web-extension:${u}`] : [c, u] }; function supports_isNativeFunction(c) { return c && /^function\s+\w+\(\)\s+\{\s+\[native code\]\s+\}$/.test(c.toString()) } const en = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__, tn = {}; function getNativeImplementation(c) { const u = tn[c]; if (u) return u; let d = ht[c]; if (supports_isNativeFunction(d)) return tn[c] = d.bind(ht); const v = ht.document; if (v && "function" == typeof v.createElement) try { const u = v.createElement("iframe"); u.hidden = !0, v.head.appendChild(u); const E = u.contentWindow; E && E[c] && (d = E[c]), v.head.removeChild(u) } catch (u) { en && ct.warn(`Could not create sandbox iframe for ${c} check, bailing to window.${c}: `, u) } return d ? tn[c] = d.bind(ht) : d } function clearCachedImplementation(c) { tn[c] = void 0 } function getNativeImplementation_setTimeout(...c) { return getNativeImplementation("setTimeout")(...c) } function makePromiseBuffer(c) { const u = []; function remove(c) { return u.splice(u.indexOf(c), 1)[0] || Promise.resolve(void 0) } return { "$": u, "add": function add(d) { if (!function isReady() { return void 0 === c || u.length < c }()) return rejectedSyncPromise(new SentryError("Not adding Promise because buffer limit was reached.")); const v = d(); return -1 === u.indexOf(v) && u.push(v), v.then((() => remove(v))).then(null, (() => remove(v).then(null, (() => { })))), v }, "drain": function drain(c) { return new SyncPromise(((d, v) => { let E = u.length; if (!E) return d(!0); const k = setTimeout((() => { c && c > 0 && d(!1) }), c); u.forEach((c => { resolvedSyncPromise(c).then((() => { --E || (clearTimeout(k), d(!0)) }), v) })) })) } } } const nn = 6e4; function parseRetryAfterHeader(c, u = Date.now()) { const d = parseInt(`${c}`, 10); if (!isNaN(d)) return 1e3 * d; const v = Date.parse(`${c}`); return isNaN(v) ? nn : v - u } const rn = 64; function createTransport(c, u, d = makePromiseBuffer(c.bufferSize || rn)) { let v = {}; return { "send": function send(E) { const k = []; if (forEachEnvelopeItem(E, ((u, d) => { const E = envelopeItemTypeToDataCategory(d); if (function isRateLimited(c, u, d = Date.now()) { return function disabledUntil(c, u) { return c[u] || c.all || 0 }(c, u) > d }(v, E)) { const v = getEventForEnvelopeItem(u, d); c.recordDroppedEvent("ratelimit_backoff", E, v) } else k.push(u) })), 0 === k.length) return resolvedSyncPromise({}); const R = envelope_createEnvelope(E[0], k), recordEnvelopeLoss = u => { forEachEnvelopeItem(R, ((d, v) => { const E = getEventForEnvelopeItem(d, v); c.recordDroppedEvent(u, envelopeItemTypeToDataCategory(v), E) })) }; return d.add((() => u({ "body": serializeEnvelope(R) }).then((c => (void 0 !== c.statusCode && (c.statusCode < 200 || c.statusCode >= 300) && he && ue.warn(`Sentry responded with status code ${c.statusCode} to sent event.`), v = function updateRateLimits(c, { "statusCode": u, "headers": d }, v = Date.now()) { const E = { ...c }, k = d && d["x-sentry-rate-limits"], R = d && d["retry-after"]; if (k) for (const c of k.trim().split(",")) { const [u, d, , , k] = c.split(":", 5), R = parseInt(u, 10), U = 1e3 * (isNaN(R) ? 60 : R); if (d) for (const c of d.split(";")) "metric_bucket" === c && k && !k.split(";").includes("custom") || (E[c] = v + U); else E.all = v + U } else R ? E.all = v + parseRetryAfterHeader(R, v) : 429 === u && (E.all = v + 6e4); return E }(v, c), c)), (c => { throw recordEnvelopeLoss("network_error"), c })))).then((c => c), (c => { if (c instanceof SentryError) return he && ue.error("Skipped sending event because buffer is full."), recordEnvelopeLoss("queue_overflow"), resolvedSyncPromise({}); throw c })) }, "flush": c => d.drain(c) } } function getEventForEnvelopeItem(c, u) { if ("event" === u || "transaction" === u) return Array.isArray(c) ? c[1] : void 0 } function makeFetchTransport(c, u = getNativeImplementation("fetch")) { let d = 0, v = 0; return createTransport(c, (function makeRequest(E) { const k = E.body.length; d += k, v++; const R = { "body": E.body, "method": "POST", "referrerPolicy": "origin", "headers": c.headers, "keepalive": d <= 6e4 && v < 15, ...c.fetchOptions }; if (!u) return clearCachedImplementation("fetch"), rejectedSyncPromise("No fetch implementation available"); try { return u(c.url, R).then((c => (d -= k, v--, { "statusCode": c.status, "headers": { "x-sentry-rate-limits": c.headers.get("X-Sentry-Rate-Limits"), "retry-after": c.headers.get("Retry-After") } }))) } catch (c) { return clearCachedImplementation("fetch"), d -= k, v--, rejectedSyncPromise(c) } })) } function getDefaultIntegrations(c) { return [inboundFiltersIntegration(), functionToStringIntegration(), browserApiErrorsIntegration(), breadcrumbsIntegration(), globalHandlersIntegration(), linkedErrorsIntegration(), dedupeIntegration(), httpContextIntegration()] } function init(c = {}) { const u = function applyDefaultOptions(c = {}) { const u = { "defaultIntegrations": getDefaultIntegrations(), "release": "string" == typeof __SENTRY_RELEASE__ ? __SENTRY_RELEASE__ : bt.SENTRY_RELEASE && bt.SENTRY_RELEASE.id ? bt.SENTRY_RELEASE.id : void 0, "autoSessionTracking": !0, "sendClientReports": !0 }; return null == c.defaultIntegrations && delete c.defaultIntegrations, { ...u, ...c } }(c); if (function shouldShowBrowserExtensionError() { const c = void 0 !== bt.window && bt; if (!c) return !1; const u = c[c.chrome ? "chrome" : "browser"], d = u && u.runtime && u.runtime.id, v = bt.location && bt.location.href || "", E = !!d && bt === bt.top && ["chrome-extension:", "moz-extension:", "ms-browser-extension:", "safari-web-extension:"].some((c => v.startsWith(`${c}//`))), k = void 0 !== c.nw; return !!d && !E && !k }()) return void logger_consoleSandbox((() => { console.error("[Sentry] You cannot run Sentry this way in a browser extension, check: https://docs.sentry.io/platforms/javascript/best-practices/browser-extensions/") })); vt && (supportsFetch() || ue.warn("No Fetch API detected. The Sentry SDK requires a Fetch API compatible environment to send events. Please add a Fetch API polyfill.")); const d = { ...u, "stackParser": (v = u.stackParser || Qt, Array.isArray(v) ? createStackParser(...v) : v), "integrations": getIntegrationsToSetup(u), "transport": u.transport || makeFetchTransport }; var v; const E = function initAndBind(c, u) { !0 === u.debug && (he ? ue.enable() : logger_consoleSandbox((() => { console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.") }))), currentScopes_getCurrentScope().update(u.initialScope); const d = new c(u); return setCurrentClient(d), d.init(), d }(BrowserClient, d); return u.autoSessionTracking && function startSessionTracking() { if (void 0 === bt.document) return void (vt && ue.warn("Session tracking in non-browser environment with @sentry/browser is not supported.")); startSession({ "ignoreDuration": !0 }), captureSession(), addHistoryInstrumentationHandler((({ "from": c, "to": u }) => { void 0 !== c && c !== u && (startSession({ "ignoreDuration": !0 }), captureSession()) })) }(), E } function showReportDialog(c = {}) { if (!bt.document) return void (vt && ue.error("Global document not defined in showReportDialog call")); const u = currentScopes_getCurrentScope(), d = u.getClient(), v = d && d.getDsn(); if (!v) return void (vt && ue.error("DSN not configured for showReportDialog call")); if (u && (c.user = { ...u.getUser(), ...c.user }), !c.eventId) { const u = lastEventId(); u && (c.eventId = u) } const E = bt.document.createElement("script"); E.async = !0, E.crossOrigin = "anonymous", E.src = function getReportDialogEndpoint(c, u) { const d = makeDsn(c); if (!d) return ""; const v = `${getBaseApiEndpoint(d)}embed/error-page/`; let E = `dsn=${dsn_dsnToString(d)}`; for (const c in u) if ("dsn" !== c && "onClose" !== c) if ("user" === c) { const c = u.user; if (!c) continue; c.name && (E += `&name=${encodeURIComponent(c.name)}`), c.email && (E += `&email=${encodeURIComponent(c.email)}`) } else E += `&${encodeURIComponent(c)}=${encodeURIComponent(u[c])}`; return `${v}?${E}` }(v, c), c.onLoad && (E.onload = c.onLoad); const { "onClose": k } = c; if (k) { const reportDialogClosedMessageHandler = c => { if ("__sentry_reportdialog_closed__" === c.data) try { k() } finally { bt.removeEventListener("message", reportDialogClosedMessageHandler) } }; bt.addEventListener("message", reportDialogClosedMessageHandler) } const R = bt.document.head || bt.document.body; R ? R.appendChild(E) : vt && ue.error("Not injecting report dialog. No injection point found in HTML") } function forceLoad() { } function onLoad(c) { c() } function captureUserFeedback(c) { const u = currentScopes_getClient(); u && u.captureUserFeedback(c) } const an = "8.30.0", sn = globalThis; function build_esm_worldwide_getGlobalSingleton(c, u, d) { const v = d || sn, E = v.__SENTRY__ = v.__SENTRY__ || {}, k = E[an] = E[an] || {}; return k[c] || (k[c] = u()) } function esm_carrier_getMainCarrier() { return esm_carrier_getSentryCarrier(sn), sn } function esm_carrier_getSentryCarrier(c) { const u = c.__SENTRY__ = c.__SENTRY__ || {}; return u.version = u.version || an, u[an] = u[an] || {} } const cn = Object.prototype.toString; function esm_is_isBuiltin(c, u) { return cn.call(c) === `[object ${u}]` } function esm_is_isPlainObject(c) { return esm_is_isBuiltin(c, "Object") } function build_esm_misc_uuid4() { const c = sn, u = c.crypto || c.msCrypto; let getRandomByte = () => 16 * Math.random(); try { if (u && u.randomUUID) return u.randomUUID().replace(/-/g, ""); u && u.getRandomValues && (getRandomByte = () => { const c = new Uint8Array(1); return u.getRandomValues(c), c[0] }) } catch (c) { } return ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, (c => (c ^ (15 & getRandomByte()) >> c / 4).toString(16))) } function esm_propagationContext_generatePropagationContext() { return { "traceId": build_esm_misc_uuid4(), "spanId": build_esm_misc_uuid4().substring(16) } } const ln = 1e3; function build_esm_time_dateTimestampInSeconds() { return Date.now() / ln } const un = function esm_time_createUnixTimestampInSecondsFunc() { const { "performance": c } = sn; if (!c || !c.now) return build_esm_time_dateTimestampInSeconds; const u = Date.now() - c.now(), d = null == c.timeOrigin ? u : c.timeOrigin; return () => (d + c.now()) / ln }(); let dn; (() => { const { "performance": c } = sn; if (!c || !c.now) return void (dn = "none"); const u = 36e5, d = c.now(), v = Date.now(), E = c.timeOrigin ? Math.abs(c.timeOrigin + d - v) : u, k = E < u, R = c.timing && c.timing.navigationStart, U = "number" == typeof R ? Math.abs(R + d - v) : u; k || U < u ? E <= U ? (dn = "timeOrigin", c.timeOrigin) : dn = "navigationStart" : dn = "dateNow" })(); const pn = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__, fn = ["debug", "info", "warn", "error", "log", "assert", "trace"], hn = {}; function build_esm_logger_consoleSandbox(c) { if (!("console" in sn)) return c(); const u = sn.console, d = {}, v = Object.keys(hn); v.forEach((c => { const v = hn[c]; d[c] = u[c], u[c] = v })); try { return c() } finally { v.forEach((c => { u[c] = d[c] })) } } const mn = build_esm_worldwide_getGlobalSingleton("logger", (function esm_logger_makeLogger() { let c = !1; const u = { "enable": () => { c = !0 }, "disable": () => { c = !1 }, "isEnabled": () => c }; return pn ? fn.forEach((d => { u[d] = (...u) => { c && build_esm_logger_consoleSandbox((() => { sn.console[d](`Sentry Logger [${d}]:`, ...u) })) } })) : fn.forEach((c => { u[c] = () => { } })), u })); function esm_session_updateSession(c, u = {}) { if (u.user && (!c.ipAddress && u.user.ip_address && (c.ipAddress = u.user.ip_address), c.did || u.did || (c.did = u.user.id || u.user.email || u.user.username)), c.timestamp = u.timestamp || un(), u.abnormal_mechanism && (c.abnormal_mechanism = u.abnormal_mechanism), u.ignoreDuration && (c.ignoreDuration = u.ignoreDuration), u.sid && (c.sid = 32 === u.sid.length ? u.sid : build_esm_misc_uuid4()), void 0 !== u.init && (c.init = u.init), !c.did && u.did && (c.did = `${u.did}`), "number" == typeof u.started && (c.started = u.started), c.ignoreDuration) c.duration = void 0; else if ("number" == typeof u.duration) c.duration = u.duration; else { const u = c.timestamp - c.started; c.duration = u >= 0 ? u : 0 } u.release && (c.release = u.release), u.environment && (c.environment = u.environment), !c.ipAddress && u.ipAddress && (c.ipAddress = u.ipAddress), !c.userAgent && u.userAgent && (c.userAgent = u.userAgent), "number" == typeof u.errors && (c.errors = u.errors), u.status && (c.status = u.status) } function build_esm_object_addNonEnumerableProperty(c, u, d) { try { Object.defineProperty(c, u, { "value": d, "writable": !0, "configurable": !0 }) } catch (d) { pn && mn.log(`Failed to add non-enumerable property "${u}" to object`, c) } } function utils_build_esm_object_dropUndefinedKeys(c) { return _sentry_utils_build_esm_object_dropUndefinedKeys(c, new Map) } function _sentry_utils_build_esm_object_dropUndefinedKeys(c, u) { if (function esm_object_isPojo(c) { if (!esm_is_isPlainObject(c)) return !1; try { const u = Object.getPrototypeOf(c).constructor.name; return !u || "Object" === u } catch (c) { return !0 } }(c)) { const d = u.get(c); if (void 0 !== d) return d; const v = {}; u.set(c, v); for (const d of Object.keys(c)) void 0 !== c[d] && (v[d] = _sentry_utils_build_esm_object_dropUndefinedKeys(c[d], u)); return v } if (Array.isArray(c)) { const d = u.get(c); if (void 0 !== d) return d; const v = []; return u.set(c, v), c.forEach((c => { v.push(_sentry_utils_build_esm_object_dropUndefinedKeys(c, u)) })), v } return c } const gn = "_sentrySpan"; function utils_spanOnScope_setSpanForScope(c, u) { u ? build_esm_object_addNonEnumerableProperty(c, gn, u) : delete c[gn] } function spanOnScope_getSpanForScope(c) { return c[gn] } class scope_ScopeClass { "constructor"() { this._notifyingListeners = !1, this._scopeListeners = [], this._eventProcessors = [], this._breadcrumbs = [], this._attachments = [], this._user = {}, this._tags = {}, this._extra = {}, this._contexts = {}, this._sdkProcessingMetadata = {}, this._propagationContext = esm_propagationContext_generatePropagationContext() } "clone"() { const c = new scope_ScopeClass; return c._breadcrumbs = [...this._breadcrumbs], c._tags = { ...this._tags }, c._extra = { ...this._extra }, c._contexts = { ...this._contexts }, c._user = this._user, c._level = this._level, c._session = this._session, c._transactionName = this._transactionName, c._fingerprint = this._fingerprint, c._eventProcessors = [...this._eventProcessors], c._requestSession = this._requestSession, c._attachments = [...this._attachments], c._sdkProcessingMetadata = { ...this._sdkProcessingMetadata }, c._propagationContext = { ...this._propagationContext }, c._client = this._client, c._lastEventId = this._lastEventId, utils_spanOnScope_setSpanForScope(c, spanOnScope_getSpanForScope(this)), c } "setClient"(c) { this._client = c } "setLastEventId"(c) { this._lastEventId = c } "getClient"() { return this._client } "lastEventId"() { return this._lastEventId } "addScopeListener"(c) { this._scopeListeners.push(c) } "addEventProcessor"(c) { return this._eventProcessors.push(c), this } "setUser"(c) { return this._user = c || { "email": void 0, "id": void 0, "ip_address": void 0, "username": void 0 }, this._session && esm_session_updateSession(this._session, { "user": c }), this._notifyScopeListeners(), this } "getUser"() { return this._user } "getRequestSession"() { return this._requestSession } "setRequestSession"(c) { return this._requestSession = c, this } "setTags"(c) { return this._tags = { ...this._tags, ...c }, this._notifyScopeListeners(), this } "setTag"(c, u) { return this._tags = { ...this._tags, [c]: u }, this._notifyScopeListeners(), this } "setExtras"(c) { return this._extra = { ...this._extra, ...c }, this._notifyScopeListeners(), this } "setExtra"(c, u) { return this._extra = { ...this._extra, [c]: u }, this._notifyScopeListeners(), this } "setFingerprint"(c) { return this._fingerprint = c, this._notifyScopeListeners(), this } "setLevel"(c) { return this._level = c, this._notifyScopeListeners(), this } "setTransactionName"(c) { return this._transactionName = c, this._notifyScopeListeners(), this } "setContext"(c, u) { return null === u ? delete this._contexts[c] : this._contexts[c] = u, this._notifyScopeListeners(), this } "setSession"(c) { return c ? this._session = c : delete this._session, this._notifyScopeListeners(), this } "getSession"() { return this._session } "update"(c) { if (!c) return this; const u = "function" == typeof c ? c(this) : c, [d, v] = u instanceof _n ? [u.getScopeData(), u.getRequestSession()] : esm_is_isPlainObject(u) ? [c, c.requestSession] : [], { "tags": E, "extra": k, "user": R, "contexts": U, "level": H, "fingerprint": G = [], "propagationContext": W } = d || {}; return this._tags = { ...this._tags, ...E }, this._extra = { ...this._extra, ...k }, this._contexts = { ...this._contexts, ...U }, R && Object.keys(R).length && (this._user = R), H && (this._level = H), G.length && (this._fingerprint = G), W && (this._propagationContext = W), v && (this._requestSession = v), this } "clear"() { return this._breadcrumbs = [], this._tags = {}, this._extra = {}, this._user = {}, this._contexts = {}, this._level = void 0, this._transactionName = void 0, this._fingerprint = void 0, this._requestSession = void 0, this._session = void 0, utils_spanOnScope_setSpanForScope(this, void 0), this._attachments = [], this._propagationContext = esm_propagationContext_generatePropagationContext(), this._notifyScopeListeners(), this } "addBreadcrumb"(c, u) { const d = "number" == typeof u ? u : 100; if (d <= 0) return this; const v = { "timestamp": build_esm_time_dateTimestampInSeconds(), ...c }, E = this._breadcrumbs; return E.push(v), this._breadcrumbs = E.length > d ? E.slice(-d) : E, this._notifyScopeListeners(), this } "getLastBreadcrumb"() { return this._breadcrumbs[this._breadcrumbs.length - 1] } "clearBreadcrumbs"() { return this._breadcrumbs = [], this._notifyScopeListeners(), this } "addAttachment"(c) { return this._attachments.push(c), this } "clearAttachments"() { return this._attachments = [], this } "getScopeData"() { return { "breadcrumbs": this._breadcrumbs, "attachments": this._attachments, "contexts": this._contexts, "tags": this._tags, "extra": this._extra, "user": this._user, "level": this._level, "fingerprint": this._fingerprint || [], "eventProcessors": this._eventProcessors, "propagationContext": this._propagationContext, "sdkProcessingMetadata": this._sdkProcessingMetadata, "transactionName": this._transactionName, "span": spanOnScope_getSpanForScope(this) } } "setSDKProcessingMetadata"(c) { return this._sdkProcessingMetadata = { ...this._sdkProcessingMetadata, ...c }, this } "setPropagationContext"(c) { return this._propagationContext = c, this } "getPropagationContext"() { return this._propagationContext } "captureException"(c, u) { const d = u && u.event_id ? u.event_id : build_esm_misc_uuid4(); if (!this._client) return mn.warn("No client configured on scope - will not capture exception!"), d; const v = new Error("Sentry syntheticException"); return this._client.captureException(c, { "originalException": c, "syntheticException": v, ...u, "event_id": d }, this), d } "captureMessage"(c, u, d) { const v = d && d.event_id ? d.event_id : build_esm_misc_uuid4(); if (!this._client) return mn.warn("No client configured on scope - will not capture message!"), v; const E = new Error(c); return this._client.captureMessage(c, u, { "originalException": c, "syntheticException": E, ...d, "event_id": v }, this), v } "captureEvent"(c, u) { const d = u && u.event_id ? u.event_id : build_esm_misc_uuid4(); return this._client ? (this._client.captureEvent(c, { ...u, "event_id": d }, this), d) : (mn.warn("No client configured on scope - will not capture event!"), d) } "_notifyScopeListeners"() { this._notifyingListeners || (this._notifyingListeners = !0, this._scopeListeners.forEach((c => { c(this) })), this._notifyingListeners = !1) } } const _n = scope_ScopeClass; class stackStrategy_AsyncContextStack { "constructor"(c, u) { let d, v; d = c || new _n, v = u || new _n, this._stack = [{ "scope": d }], this._isolationScope = v } "withScope"(c) { const u = this._pushScope(); let d; try { d = c(u) } catch (c) { throw this._popScope(), c } return function build_esm_is_isThenable(c) { return Boolean(c && c.then && "function" == typeof c.then) }(d) ? d.then((c => (this._popScope(), c)), (c => { throw this._popScope(), c })) : (this._popScope(), d) } "getClient"() { return this.getStackTop().client } "getScope"() { return this.getStackTop().scope } "getIsolationScope"() { return this._isolationScope } "getStackTop"() { return this._stack[this._stack.length - 1] } "_pushScope"() { const c = this.getScope().clone(); return this._stack.push({ "client": this.getClient(), "scope": c }), c } "_popScope"() { return !(this._stack.length <= 1) && !!this._stack.pop() } } function stackStrategy_getAsyncContextStack() { const c = esm_carrier_getSentryCarrier(esm_carrier_getMainCarrier()); return c.stack = c.stack || new stackStrategy_AsyncContextStack(function defaultScopes_getDefaultCurrentScope() { return build_esm_worldwide_getGlobalSingleton("defaultCurrentScope", (() => new _n)) }(), function defaultScopes_getDefaultIsolationScope() { return build_esm_worldwide_getGlobalSingleton("defaultIsolationScope", (() => new _n)) }()) } function asyncContext_stackStrategy_withScope(c) { return stackStrategy_getAsyncContextStack().withScope(c) } function stackStrategy_withSetScope(c, u) { const d = stackStrategy_getAsyncContextStack(); return d.withScope((() => (d.getStackTop().scope = c, u(c)))) } function asyncContext_stackStrategy_withIsolationScope(c) { return stackStrategy_getAsyncContextStack().withScope((() => c(stackStrategy_getAsyncContextStack().getIsolationScope()))) } function esm_asyncContext_getAsyncContextStrategy(c) { const u = esm_carrier_getSentryCarrier(c); return u.acs ? u.acs : function stackStrategy_getStackAsyncContextStrategy() { return { "withIsolationScope": asyncContext_stackStrategy_withIsolationScope, "withScope": asyncContext_stackStrategy_withScope, "withSetScope": stackStrategy_withSetScope, "withSetIsolationScope": (c, u) => asyncContext_stackStrategy_withIsolationScope(u), "getCurrentScope": () => stackStrategy_getAsyncContextStack().getScope(), "getIsolationScope": () => stackStrategy_getAsyncContextStack().getIsolationScope() } }() } function esm_currentScopes_getCurrentScope() { return esm_asyncContext_getAsyncContextStrategy(esm_carrier_getMainCarrier()).getCurrentScope() } function hasTracingEnabled(c) { if ("boolean" == typeof __SENTRY_TRACING__ && !__SENTRY_TRACING__) return !1; const u = function esm_currentScopes_getClient() { return esm_currentScopes_getCurrentScope().getClient() }(), d = c || u && u.getOptions(); return !!d && (d.enableTracing || "tracesSampleRate" in d || "tracesSampler" in d) } const vn = ["activate", "mount", "update"], yn = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__; new WeakMap; function prepareEvent_parseEventHintOrCaptureContext(c) { if (c) return function prepareEvent_hintIsScopeOrFunction(c) { return c instanceof _n || "function" == typeof c }(c) || function prepareEvent_hintIsScopeContext(c) { return Object.keys(c).some((c => bn.includes(c))) }(c) ? { "captureContext": c } : c } const bn = ["user", "level", "extra", "contexts", "tags", "fingerprint", "requestSession", "propagationContext"]; const Sn = /(?:^|[-_])(\w)/g, wn = "<Anonymous>", formatComponentName = (c, u) => { if (!c) return wn; if (c.$root === c) return "<Root>"; if (!c.$options) return wn; const d = c.$options; let v = d.name || d._componentTag || d.__name; const E = d.__file; if (!v && E) { const c = E.match(/([^/\\]+)\.vue$/); c && (v = c[1]) } return (v ? `<${k = v, k.replace(Sn, (c => c.toUpperCase())).replace(/[-_]/g, "")}>` : wn) + (E && !1 !== u ? ` at ${E}` : ""); var k }, attachErrorHandler = (c, u) => { const { "errorHandler": d, "warnHandler": v, "silent": E } = c.config; c.config.errorHandler = (k, R, U) => { const H = formatComponentName(R, !1), G = R ? (c => { if (c && (c._isVue || c.__isVue) && c.$parent) { const u = []; let d = 0; for (; c;) { if (u.length > 0) { const v = u[u.length - 1]; if (v.constructor === c.constructor) { d++, c = c.$parent; continue } d > 0 && (u[u.length - 1] = [v, d], d = 0) } u.push(c), c = c.$parent } const v = u.map(((c, u) => `${(0 === u ? "---\x3e " : ((c, u) => " ".repeat(u))(0, 5 + 2 * u)) + (Array.isArray(c) ? `${formatComponentName(c[0])}... (${c[1]} recursive calls)` : formatComponentName(c))}`)).join("\n"); return `\n\nfound in\n\n${v}` } return `\n\n(found in ${formatComponentName(c)})` })(R) : "", W = { "componentName": H, "lifecycleHook": U, "trace": G }; if (u.attachProps && R && (R.$options && R.$options.propsData ? W.propsData = R.$options.propsData : R.$props && (W.propsData = R.$props)), setTimeout((() => { !function exports_captureException(c, u) { return esm_currentScopes_getCurrentScope().captureException(c, prepareEvent_parseEventHintOrCaptureContext(u)) }(k, { "captureContext": { "contexts": { "vue": W } }, "mechanism": { "handled": !1 } }) })), "function" == typeof d && d.call(c, k, R, U), u.logErrors) { const c = "undefined" != typeof console, u = `Error in ${U}: "${k && k.toString()}"`; v ? v.call(null, u, R, G) : c && !E && build_esm_logger_consoleSandbox((() => { console.error(`[Vue warn]: ${u}${G}`) })) } } }; function handleCallbackErrors_handleCallbackErrors(c, u, d = (() => { })) { let v; try { v = c() } catch (c) { throw u(c), d(), c } return function maybeHandlePromiseRejection(c, u, d) { if (is_isThenable(c)) return c.then((c => (d(), c)), (c => { throw u(c), d(), c })); return d(), c }(v, u, d) } function hasTracingEnabled_hasTracingEnabled(c) { if ("boolean" == typeof __SENTRY_TRACING__ && !__SENTRY_TRACING__) return !1; const u = currentScopes_getClient(), d = c || u && u.getOptions(); return !!d && (d.enableTracing || "tracesSampleRate" in d || "tracesSampler" in d) } class sentryNonRecordingSpan_SentryNonRecordingSpan { "constructor"(c = {}) { this._traceId = c.traceId || misc_uuid4(), this._spanId = c.spanId || misc_uuid4().substring(16) } "spanContext"() { return { "spanId": this._spanId, "traceId": this._traceId, "traceFlags": 0 } } "end"(c) { } "setAttribute"(c, u) { return this } "setAttributes"(c) { return this } "setStatus"(c) { return this } "updateName"(c) { return this } "isRecording"() { return !1 } "addEvent"(c, u, d) { return this } "addLink"(c) { return this } "addLinks"(c) { return this } "recordException"(c, u) { } } function setMeasurement(c, u, d, v = getActiveSpan()) { const E = v && getRootSpan(v); E && E.addEvent(c, { [He]: u, [Ue]: d }) } function timedEventsToMeasurements(c) { if (!c || 0 === c.length) return; const u = {}; return c.forEach((c => { const d = c.attributes || {}, v = d[Ue], E = d[He]; "string" == typeof v && "number" == typeof E && (u[c.name] = { "value": E, "unit": v }) })), u } const En = "_sentryScope", Cn = "_sentryIsolationScope"; function getCapturedScopesOnSpan(c) { return { "scope": c[En], "isolationScope": c[Cn] } } class SentrySpan { "constructor"(c = {}) { this._traceId = c.traceId || misc_uuid4(), this._spanId = c.spanId || misc_uuid4().substring(16), this._startTime = c.startTimestamp || ge(), this._attributes = {}, this.setAttributes({ [je]: "manual", [Fe]: c.op, ...c.attributes }), this._name = c.name, c.parentSpanId && (this._parentSpanId = c.parentSpanId), "sampled" in c && (this._sampled = c.sampled), c.endTimestamp && (this._endTime = c.endTimestamp), this._events = [], this._isStandaloneSpan = c.isStandalone, this._endTime && this._onSpanEnded() } "addLink"(c) { return this } "addLinks"(c) { return this } "recordException"(c, u) { } "spanContext"() { const { "_spanId": c, "_traceId": u, "_sampled": d } = this; return { "spanId": c, "traceId": u, "traceFlags": d ? Ze : 0 } } "setAttribute"(c, u) { return void 0 === u ? delete this._attributes[c] : this._attributes[c] = u, this } "setAttributes"(c) { return Object.keys(c).forEach((u => this.setAttribute(u, c[u]))), this } "updateStartTime"(c) { this._startTime = spanTimeInputToSeconds(c) } "setStatus"(c) { return this._status = c, this } "updateName"(c) { return this._name = c, this } "end"(c) { this._endTime || (this._endTime = spanTimeInputToSeconds(c), function logSpanEnd(c) { if (!he) return; const { "description": u = "< unknown name >", "op": d = "< unknown op >" } = spanUtils_spanToJSON(c), { "spanId": v } = c.spanContext(), E = `[Tracing] Finishing "${d}" ${getRootSpan(c) === c ? "root " : ""}span "${u}" with ID ${v}`; ue.log(E) }(this), this._onSpanEnded()) } "getSpanJSON"() { return object_dropUndefinedKeys({ "data": this._attributes, "description": this._name, "op": this._attributes[Fe], "parent_span_id": this._parentSpanId, "span_id": this._spanId, "start_timestamp": this._startTime, "status": getStatusMessage(this._status), "timestamp": this._endTime, "trace_id": this._traceId, "origin": this._attributes[je], "_metrics_summary": getMetricSummaryJsonForSpan(this), "profile_id": this._attributes["sentry.profile_id"], "exclusive_time": this._attributes["sentry.exclusive_time"], "measurements": timedEventsToMeasurements(this._events), "is_segment": this._isStandaloneSpan && getRootSpan(this) === this || void 0, "segment_id": this._isStandaloneSpan ? getRootSpan(this).spanContext().spanId : void 0 }) } "isRecording"() { return !this._endTime && !!this._sampled } "addEvent"(c, u, d) { he && ue.log("[Tracing] Adding an event to span:", c); const v = isSpanTimeInput(u) ? u : d || ge(), E = isSpanTimeInput(u) ? {} : u || {}, k = { "name": c, "time": spanTimeInputToSeconds(v), "attributes": E }; return this._events.push(k), this } "isStandaloneSpan"() { return !!this._isStandaloneSpan } "_onSpanEnded"() { const c = currentScopes_getClient(); c && c.emit("spanEnd", this); if (!(this._isStandaloneSpan || this === getRootSpan(this))) return; if (this._isStandaloneSpan) return void (this._sampled ? function sendSpanEnvelope(c) { const u = currentScopes_getClient(); if (!u) return; const d = c[1]; if (!d || 0 === d.length) return void u.recordDroppedEvent("before_send", "span"); const v = u.getTransport(); v && v.send(c).then(null, (c => { he && ue.error("Error while sending span:", c) })) }(function createSpanEnvelope(c, u) { const d = getDynamicSamplingContextFromSpan(c[0]), v = u && u.getDsn(), E = u && u.getOptions().tunnel, k = { "sent_at": (new Date).toISOString(), ...function dscHasRequiredProps(c) { return !!c.trace_id && !!c.public_key }(d) && { "trace": d }, ...!!E && v && { "dsn": dsn_dsnToString(v) } }, R = u && u.getOptions().beforeSendSpan, U = R ? c => R(spanUtils_spanToJSON(c)) : c => spanUtils_spanToJSON(c), H = []; for (const u of c) { const c = U(u); c && H.push(createSpanEnvelopeItem(c)) } return envelope_createEnvelope(k, H) }([this], c)) : (he && ue.log("[Tracing] Discarding standalone span because its trace was not chosen to be sampled."), c && c.recordDroppedEvent("sample_rate", "span"))); const u = this._convertSpanToTransaction(); if (u) { (getCapturedScopesOnSpan(this).scope || currentScopes_getCurrentScope()).captureEvent(u) } } "_convertSpanToTransaction"() { if (!isFullFinishedSpan(spanUtils_spanToJSON(this))) return; this._name || (he && ue.warn("Transaction has no name, falling back to `<unlabeled transaction>`."), this._name = "<unlabeled transaction>"); const { "scope": c, "isolationScope": u } = getCapturedScopesOnSpan(this), d = (c || currentScopes_getCurrentScope()).getClient() || currentScopes_getClient(); if (!0 !== this._sampled) return he && ue.log("[Tracing] Discarding transaction because its trace was not chosen to be sampled."), void (d && d.recordDroppedEvent("sample_rate", "transaction")); const v = getSpanDescendants(this).filter((c => c !== this && !function isStandaloneSpan(c) { return c instanceof SentrySpan && c.isStandaloneSpan() }(c))).map((c => spanUtils_spanToJSON(c))).filter(isFullFinishedSpan), E = this._attributes[$e], k = { "contexts": { "trace": spanToTransactionTraceContext(this) }, "spans": v.length > 1e3 ? v.sort(((c, u) => c.start_timestamp - u.start_timestamp)).slice(0, 1e3) : v, "start_timestamp": this._startTime, "timestamp": this._endTime, "transaction": this._name, "type": "transaction", "sdkProcessingMetadata": { "capturedSpanScope": c, "capturedSpanIsolationScope": u, ...object_dropUndefinedKeys({ "dynamicSamplingContext": getDynamicSamplingContextFromSpan(this) }) }, "_metrics_summary": getMetricSummaryJsonForSpan(this), ...E && { "transaction_info": { "source": E } } }, R = timedEventsToMeasurements(this._events); return R && Object.keys(R).length && (he && ue.log("[Measurements] Adding measurements to transaction event", JSON.stringify(R, void 0, 2)), k.measurements = R), k } } function isSpanTimeInput(c) { return c && "number" == typeof c || c instanceof Date || Array.isArray(c) } function isFullFinishedSpan(c) { return !!(c.start_timestamp && c.timestamp && c.span_id && c.trace_id) } const Tn = "__SENTRY_SUPPRESS_TRACING__"; function startSpan(c, u) { const d = getAcs(); if (d.startSpan) return d.startSpan(c, u); const v = parseSentrySpanArguments(c), { "forceTransaction": E, "parentSpan": k } = c; return currentScopes_withScope(c.scope, (() => getActiveSpanWrapper(k)((() => { const d = currentScopes_getCurrentScope(), k = getParentSpan(d), R = c.onlyIfParent && !k ? new sentryNonRecordingSpan_SentryNonRecordingSpan : createChildOrRootSpan({ "parentSpan": k, "spanArguments": v, "forceTransaction": E, "scope": d }); return spanOnScope_setSpanForScope(d, R), handleCallbackErrors_handleCallbackErrors((() => u(R)), (() => { const { "status": c } = spanUtils_spanToJSON(R); !R.isRecording() || c && "ok" !== c || R.setStatus({ "code": We, "message": "internal_error" }) }), (() => R.end())) })))) } function startSpanManual(c, u) { const d = getAcs(); if (d.startSpanManual) return d.startSpanManual(c, u); const v = parseSentrySpanArguments(c), { "forceTransaction": E, "parentSpan": k } = c; return currentScopes_withScope(c.scope, (() => getActiveSpanWrapper(k)((() => { const d = currentScopes_getCurrentScope(), k = getParentSpan(d), R = c.onlyIfParent && !k ? new sentryNonRecordingSpan_SentryNonRecordingSpan : createChildOrRootSpan({ "parentSpan": k, "spanArguments": v, "forceTransaction": E, "scope": d }); function finishAndSetSpan() { R.end() } return spanOnScope_setSpanForScope(d, R), handleCallbackErrors_handleCallbackErrors((() => u(R, finishAndSetSpan)), (() => { const { "status": c } = spanUtils_spanToJSON(R); !R.isRecording() || c && "ok" !== c || R.setStatus({ "code": We, "message": "internal_error" }) })) })))) } function startInactiveSpan(c) { const u = getAcs(); if (u.startInactiveSpan) return u.startInactiveSpan(c); const d = parseSentrySpanArguments(c), { "forceTransaction": v, "parentSpan": E } = c; return (c.scope ? u => currentScopes_withScope(c.scope, u) : void 0 !== E ? c => withActiveSpan(E, c) : c => c())((() => { const u = currentScopes_getCurrentScope(), E = getParentSpan(u); return c.onlyIfParent && !E ? new sentryNonRecordingSpan_SentryNonRecordingSpan : createChildOrRootSpan({ "parentSpan": E, "spanArguments": d, "forceTransaction": v, "scope": u }) })) } const continueTrace = ({ "sentryTrace": c, "baggage": u }, d) => currentScopes_withScope((v => { const E = tracing_propagationContextFromHeaders(c, u); return v.setPropagationContext(E), d() })); function withActiveSpan(c, u) { const d = getAcs(); return d.withActiveSpan ? d.withActiveSpan(c, u) : currentScopes_withScope((d => (spanOnScope_setSpanForScope(d, c || void 0), u(d)))) } function startNewTrace(c) { return currentScopes_withScope((u => (u.setPropagationContext(propagationContext_generatePropagationContext()), he && ue.info(`Starting a new trace with id ${u.getPropagationContext().traceId}`), withActiveSpan(null, c)))) } function createChildOrRootSpan({ "parentSpan": c, "spanArguments": u, "forceTransaction": d, "scope": v }) { if (!hasTracingEnabled_hasTracingEnabled()) return new sentryNonRecordingSpan_SentryNonRecordingSpan; const E = currentScopes_getIsolationScope(); let k; if (c && !d) k = function _startChildSpan(c, u, d) { const { "spanId": v, "traceId": E } = c.spanContext(), k = !u.getScopeData().sdkProcessingMetadata[Tn] && spanIsSampled(c), R = k ? new SentrySpan({ ...d, "parentSpanId": v, "traceId": E, "sampled": k }) : new sentryNonRecordingSpan_SentryNonRecordingSpan({ "traceId": E }); addChildSpanToSpan(c, R); const U = currentScopes_getClient(); U && (U.emit("spanStart", R), d.endTimestamp && U.emit("spanEnd", R)); return R }(c, v, u), addChildSpanToSpan(c, k); else if (c) { const d = getDynamicSamplingContextFromSpan(c), { "traceId": E, "spanId": R } = c.spanContext(), U = spanIsSampled(c); k = _startRootSpan({ "traceId": E, "parentSpanId": R, ...u }, v, U), freezeDscOnSpan(k, d) } else { const { "traceId": c, "dsc": d, "parentSpanId": R, "sampled": U } = { ...E.getPropagationContext(), ...v.getPropagationContext() }; k = _startRootSpan({ "traceId": c, "parentSpanId": R, ...u }, v, U), d && freezeDscOnSpan(k, d) } return function logSpanStart(c) { if (!he) return; const { "description": u = "< unknown name >", "op": d = "< unknown op >", "parent_span_id": v } = spanUtils_spanToJSON(c), { "spanId": E } = c.spanContext(), k = spanIsSampled(c), R = getRootSpan(c), U = R === c, H = `[Tracing] Starting ${k ? "sampled" : "unsampled"} ${U ? "root " : ""}span`, G = [`op: ${d}`, `name: ${u}`, `ID: ${E}`]; if (v && G.push(`parent ID: ${v}`), !U) { const { "op": c, "description": u } = spanUtils_spanToJSON(R); G.push(`root ID: ${R.spanContext().spanId}`), c && G.push(`root op: ${c}`), u && G.push(`root description: ${u}`) } ue.log(`${H}\n  ${G.join("\n  ")}`) }(k), function setCapturedScopesOnSpan(c, u, d) { c && (object_addNonEnumerableProperty(c, Cn, d), object_addNonEnumerableProperty(c, En, u)) }(k, v, E), k } function parseSentrySpanArguments(c) { const u = { "isStandalone": (c.experimental || {}).standalone, ...c }; if (c.startTime) { const d = { ...u }; return d.startTimestamp = spanTimeInputToSeconds(c.startTime), delete d.startTime, d } return u } function getAcs() { return asyncContext_getAsyncContextStrategy(carrier_getMainCarrier()) } function _startRootSpan(c, u, d) { const v = currentScopes_getClient(), E = v && v.getOptions() || {}, { "name": k = "", "attributes": R } = c, [U, H] = u.getScopeData().sdkProcessingMetadata[Tn] ? [!1] : function sampleSpan(c, u) { if (!hasTracingEnabled_hasTracingEnabled(c)) return [!1]; let d; d = "function" == typeof c.tracesSampler ? c.tracesSampler(u) : void 0 !== u.parentSampled ? u.parentSampled : void 0 !== c.tracesSampleRate ? c.tracesSampleRate : 1; const v = parseSampleRate(d); return void 0 === v ? (he && ue.warn("[Tracing] Discarding transaction because of invalid sample rate."), [!1]) : v ? Math.random() < v ? [!0, v] : (he && ue.log(`[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(d)})`), [!1, v]) : (he && ue.log("[Tracing] Discarding transaction because " + ("function" == typeof c.tracesSampler ? "tracesSampler returned 0 or false" : "a negative sampling decision was inherited or tracesSampleRate is set to 0")), [!1, v]) }(E, { "name": k, "parentSampled": d, "attributes": R, "transactionContext": { "name": k, "parentSampled": d } }), G = new SentrySpan({ ...c, "attributes": { [$e]: "custom", ...c.attributes }, "sampled": U }); return void 0 !== H && G.setAttribute(Le, H), v && v.emit("spanStart", G), G } function getParentSpan(c) { const u = _getSpanForScope(c); if (!u) return; const d = currentScopes_getClient(); return (d ? d.getOptions() : {}).parentSpanIsAlwaysRootSpan ? getRootSpan(u) : u } function getActiveSpanWrapper(c) { return void 0 !== c ? u => withActiveSpan(c, u) : c => c() } const xn = "ui.vue", An = { "activate": ["activated", "deactivated"], "create": ["beforeCreate", "created"], "unmount": ["beforeUnmount", "unmounted"], "destroy": ["beforeDestroy", "destroyed"], "mount": ["beforeMount", "mounted"], "update": ["beforeUpdate", "updated"] }; function findTrackComponent(c, u) { function extractComponentName(c) { return c.replace(/^<([^\s]*)>(?: at [^\s]*)?$/, "$1") } return c.some((c => extractComponentName(u) === extractComponentName(c))) } const createTracingMixins = c => { const u = (c.hooks || []).concat(vn).filter(((c, u, d) => d.indexOf(c) === u)), d = {}; for (const v of u) { const u = An[v]; if (u) for (const E of u) d[E] = function () { const d = this.$root === this; if (d) { getActiveSpan() && (this.$_sentryRootSpan = this.$_sentryRootSpan || startInactiveSpan({ "name": "Application Render", "op": `${xn}.render`, "attributes": { [je]: "auto.ui.vue" } })) } const k = formatComponentName(this, !1), R = Array.isArray(c.trackComponents) ? findTrackComponent(c.trackComponents, k) : c.trackComponents; var U, H, G; if (d || R) if (this.$_sentrySpans = this.$_sentrySpans || {}, E == u[0]) { if (this.$root && this.$root.$_sentryRootSpan || getActiveSpan()) { const c = this.$_sentrySpans[v]; c && c.end(), this.$_sentrySpans[v] = startInactiveSpan({ "name": `Vue ${k}`, "op": `${xn}.${v}`, "attributes": { [je]: "auto.ui.vue" }, "onlyIfParent": !0 }) } } else { const u = this.$_sentrySpans[v]; if (!u) return; u.end(), U = this, H = un(), G = c.timeout, U.$_sentryRootSpanTimer && clearTimeout(U.$_sentryRootSpanTimer), U.$_sentryRootSpanTimer = setTimeout((() => { U.$root && U.$root.$_sentryRootSpan && (U.$root.$_sentryRootSpan.end(H), U.$root.$_sentryRootSpan = void 0) }), G) } }; else yn && mn.warn(`Unknown hook: ${v}`) } return d }, In = { "Vue": sn.Vue, "attachProps": !0, "logErrors": !0, "hooks": vn, "timeout": 2e3, "trackComponents": !1 }, vueIntegration = (c = {}) => ({ "name": "Vue", "setup"(u) { !function _setupIntegration(c, u) { const d = { ...In, ...c.getOptions(), ...u }; if (!d.Vue && !d.app) return void build_esm_logger_consoleSandbox((() => { console.warn("[@sentry/vue]: Misconfigured SDK. Vue specific errors will not be captured.\nUpdate your `Sentry.init` call with an appropriate config option:\n`app` (Application Instance - Vue 3) or `Vue` (Vue Constructor - Vue 2).") })); if (d.app) { (function build_esm_misc_arrayify(c) { return Array.isArray(c) ? c : [c] })(d.app).forEach((c => vueInit(c, d))) } else d.Vue && vueInit(d.Vue, d) }(u, c) } }); const vueInit = (c, u) => { if (yn) { const u = c; !0 === (u._instance && u._instance.isMounted) && build_esm_logger_consoleSandbox((() => { console.warn("[@sentry/vue]: Misconfigured SDK. Vue app is already mounted. Make sure to call `app.mount()` after `Sentry.init()`.") })) } attachErrorHandler(c, u), hasTracingEnabled(u) && c.mixin(createTracingMixins({ ...u, ...u.tracingOptions })) }; function sdk_init(c = {}) { return init({ "_metadata": { "sdk": { "name": "sentry.javascript.vue", "packages": [{ "name": "npm:@sentry/vue", "version": ie }], "version": ie } }, "defaultIntegrations": [...getDefaultIntegrations(), vueIntegration()], ...c }) } let kn = !1; function registerSpanErrorInstrumentation() { kn || (kn = !0, addGlobalErrorInstrumentationHandler(errorCallback), addGlobalUnhandledRejectionInstrumentationHandler(errorCallback)) } function errorCallback() { const c = getActiveSpan(), u = c && getRootSpan(c); if (u) { const c = "internal_error"; he && ue.log(`[Tracing] Root span: ${c} -> Global error occured`), u.setStatus({ "code": We, "message": c }) } } function addTracingExtensions() { registerSpanErrorInstrumentation() } errorCallback.tag = "sentry_tracingErrorCallback"; const captureConsoleIntegration = (c = {}) => { const u = c.levels || ce; return { "name": "CaptureConsole", "setup"(c) { "console" in se && addConsoleInstrumentationHandler((({ "args": d, "level": v }) => { currentScopes_getClient() === c && u.includes(v) && function consoleHandler(c, u) { const d = { "level": severityLevelFromString(u), "extra": { "arguments": c } }; currentScopes_withScope((v => { if (v.addEventProcessor((c => (c.logger = "console", misc_addExceptionMechanism(c, { "handled": !1, "type": "console" }), c))), "assert" === u) { if (!c[0]) { const u = `Assertion failed: ${safeJoin(c.slice(1), " ") || "console.assert"}`; v.setExtra("arguments", c.slice(1)), captureMessage(u, d) } return } const E = c.find((c => c instanceof Error)); if (E) return void captureException(E, d); captureMessage(safeJoin(c, " "), d) })) }(d, v) })) } } }; function captureFeedback(c, u = {}, d = currentScopes_getCurrentScope()) { const { "message": v, "name": E, "email": k, "url": R, "source": U, "associatedEventId": H, "tags": G } = c, W = { "contexts": { "feedback": object_dropUndefinedKeys({ "contact_email": k, "name": E, "message": v, "url": R, "source": U, "associated_event_id": H }) }, "type": "feedback", "level": "info", "tags": G }, Z = d && d.getClient() || currentScopes_getClient(); Z && Z.emit("beforeSendFeedback", W, u); return d.captureEvent(W, u) } const debugIntegration = (c = {}) => { const u = { "debugger": !1, "stringify": !1, ...c }; return { "name": "Debug", "setup"(c) { c.on("beforeSendEvent", ((c, d) => { u.debugger, logger_consoleSandbox((() => { u.stringify ? (console.log(JSON.stringify(c, null, 2)), d && Object.keys(d).length && console.log(JSON.stringify(d, null, 2))) : (console.log(c), d && Object.keys(d).length && console.log(d)) })) })) } } }, extraErrorDataIntegration = (c = {}) => { const { "depth": u = 3, "captureErrorCause": d = !0 } = c; return { "name": "ExtraErrorData", "processEvent"(c, v, E) { const { "maxValueLength": k = 250 } = E.getOptions(); return function _enhanceEventWithErrorData(c, u = {}, d, v, E) { if (!u.originalException || !is_isError(u.originalException)) return c; const k = u.originalException.name || u.originalException.constructor.name, R = function _extractErrorData(c, u, d) { try { const v = ["name", "message", "stack", "line", "column", "fileName", "lineNumber", "columnNumber", "toJSON"], E = {}; for (const u of Object.keys(c)) { if (-1 !== v.indexOf(u)) continue; const k = c[u]; E[u] = is_isError(k) || "string" == typeof k ? string_truncate(`${k}`, d) : k } if (u && void 0 !== c.cause && (E.cause = is_isError(c.cause) ? c.cause.toString() : c.cause), "function" == typeof c.toJSON) { const u = c.toJSON(); for (const c of Object.keys(u)) { const d = u[c]; E[c] = is_isError(d) ? d.toString() : d } } return E } catch (c) { he && ue.error("Unable to extract extra data from the Error object:", c) } return null }(u.originalException, v, E); if (R) { const u = { ...c.contexts }, v = normalize_normalize(R, d); return isPlainObject(v) && (object_addNonEnumerableProperty(v, "__sentry_skip_normalization__", !0), u[k] = v), { ...c, "contexts": u } } return c }(c, v, u, d, k) } } }; const On = function getCurrentHubShim() { return { "bindClient"(c) { currentScopes_getCurrentScope().setClient(c) }, "withScope": currentScopes_withScope, "getClient": () => currentScopes_getClient(), "getScope": currentScopes_getCurrentScope, "getIsolationScope": currentScopes_getIsolationScope, "captureException": (c, u) => currentScopes_getCurrentScope().captureException(c, u), "captureMessage": (c, u, d) => currentScopes_getCurrentScope().captureMessage(c, u, d), "captureEvent": captureEvent, "addBreadcrumb": addBreadcrumb, "setUser": setUser, "setTags": setTags, "setTag": setTag, "setExtra": setExtra, "setExtras": setExtras, "setContext": setContext, "getIntegration"(c) { const u = currentScopes_getClient(); return u && u.getIntegrationByName(c.id) || null }, "startSession": startSession, "endSession": endSession, "captureSession"(c) { if (c) return endSession(); !function getCurrentHubShim_sendSessionUpdate() { const c = currentScopes_getCurrentScope(), u = currentScopes_getClient(), d = c.getSession(); u && d && u.captureSession(d) }() } } }; function eventFromEnvelope(c, u) { let d; return forEachEnvelopeItem(c, ((c, v) => (u.includes(v) && (d = Array.isArray(c) ? c[1] : void 0), !!d))), d } function makeMultiplexedTransport(c, u) { return d => { const v = c(d), E = new Map; function getTransport(u, v) { const k = v ? `${u}:${v}` : u; let R = E.get(k); if (!R) { const U = dsnFromString(u); if (!U) return; const H = getEnvelopeEndpointWithUrlEncodedAuth(U, d.tunnel); R = v ? function makeOverrideReleaseTransport(c, u) { return d => { const v = c(d); return { ...v, "send": async c => { const d = eventFromEnvelope(c, ["event", "transaction", "profile", "replay_event"]); return d && (d.release = u), v.send(c) } } } }(c, v)({ ...d, "url": H }) : c({ ...d, "url": H }), E.set(k, R) } return [u, R] } return { "send": async function send(c) { const d = u({ "envelope": c, "getEvent": function getEvent(u) { const d = u && u.length ? u : ["event"]; return eventFromEnvelope(c, d) } }).map((c => "string" == typeof c ? getTransport(c, void 0) : getTransport(c.dsn, c.release))).filter((c => !!c)), E = d.length ? d : [["", v]]; return (await Promise.all(E.map((([u, d]) => d.send(function overrideDsn(c, u) { return envelope_createEnvelope(u ? { ...c[0], "dsn": u } : c[0], c[1]) }(c, u))))))[0] }, "flush": async function flush(c) { const u = [...E.values(), v]; return (await Promise.all(u.map((u => u.flush(c))))).every((c => c)) } } } } const Pn = new Map, Rn = new Set; function getMetadataForUrl(c, u) { return function ensureMetadataStacksAreParsed(c) { if (se._sentryModuleMetadata) for (const u of Object.keys(se._sentryModuleMetadata)) { const d = se._sentryModuleMetadata[u]; if (Rn.has(u)) continue; Rn.add(u); const v = c(u); for (const c of v.reverse()) if (c.filename) { Pn.set(c.filename, d); break } } }(c), Pn.get(u) } function addMetadataToStackFrames(c, u) { try { u.exception.values.forEach((u => { if (u.stacktrace) for (const d of u.stacktrace.frames || []) { if (!d.filename || d.module_metadata) continue; const u = getMetadataForUrl(c, d.filename); u && (d.module_metadata = u) } })) } catch (c) { } } function stripMetadataFromStackFrames(c) { try { c.exception.values.forEach((c => { if (c.stacktrace) for (const u of c.stacktrace.frames || []) delete u.module_metadata })) } catch (c) { } } const moduleMetadataIntegration = () => ({ "name": "ModuleMetadata", "setup"(c) { c.on("beforeEnvelope", (c => { forEachEnvelopeItem(c, ((c, u) => { if ("event" === u) { const u = Array.isArray(c) ? c[1] : void 0; u && (stripMetadataFromStackFrames(u), c[1] = u) } })) })), c.on("applyFrameMetadata", (u => { if (u.type) return; addMetadataToStackFrames(c.getOptions().stackParser, u) })) } }); function parameterize(c, ...u) { const d = new String(String.raw(c, ...u)); return d.__sentry_template_string__ = c.join("\0").replace(/%/g, "%%").replace(/\0/g, "%s"), d.__sentry_template_values__ = u, d } function normalizeArray(c, u) { let d = 0; for (let u = c.length - 1; u >= 0; u--) { const v = c[u]; "." === v ? c.splice(u, 1) : ".." === v ? (c.splice(u, 1), d++) : d && (c.splice(u, 1), d--) } if (u) for (; d--; d)c.unshift(".."); return c } const Mn = /^(\S+:\\|\/?)([\s\S]*?)((?:\.{1,2}|[^/\\]+?|)(\.[^./\\]*|))(?:[/\\]*)$/; function splitPath(c) { const u = c.length > 1024 ? `<truncated>${c.slice(-1024)}` : c, d = Mn.exec(u); return d ? d.slice(1) : [] } function resolve(...c) { let u = "", d = !1; for (let v = c.length - 1; v >= -1 && !d; v--) { const E = v >= 0 ? c[v] : "/"; E && (u = `${E}/${u}`, d = "/" === E.charAt(0)) } return u = normalizeArray(u.split("/").filter((c => !!c)), !d).join("/"), (d ? "/" : "") + u || "." } function trim(c) { let u = 0; for (; u < c.length && "" === c[u]; u++); let d = c.length - 1; for (; d >= 0 && "" === c[d]; d--); return u > d ? [] : c.slice(u, d - u + 1) } const rewriteFramesIntegration = (c = {}) => { const u = c.root, d = c.prefix || "app:///", v = "window" in se && void 0 !== se.window, E = c.iteratee || function generateIteratee({ "isBrowser": c, "root": u, "prefix": d }) { return v => { if (!v.filename) return v; const E = /^[a-zA-Z]:\\/.test(v.filename) || v.filename.includes("\\") && !v.filename.includes("/"), k = /^\//.test(v.filename); if (c) { if (u) { const c = v.filename; 0 === c.indexOf(u) && (v.filename = c.replace(u, d)) } } else if (E || k) { const c = E ? v.filename.replace(/^[a-zA-Z]:/, "").replace(/\\/g, "/") : v.filename, k = u ? function relative(c, u) { c = resolve(c).slice(1), u = resolve(u).slice(1); const d = trim(c.split("/")), v = trim(u.split("/")), E = Math.min(d.length, v.length); let k = E; for (let c = 0; c < E; c++)if (d[c] !== v[c]) { k = c; break } let R = []; for (let c = k; c < d.length; c++)R.push(".."); return R = R.concat(v.slice(k)), R.join("/") }(u, c) : function basename(c, u) { let d = splitPath(c)[2] || ""; return u && d.slice(-1 * u.length) === u && (d = d.slice(0, d.length - u.length)), d }(c); v.filename = `${d}${k}` } return v } }({ "isBrowser": v, "root": u, "prefix": d }); return { "name": "RewriteFrames", "processEvent"(c) { let u = c; return c.exception && Array.isArray(c.exception.values) && (u = function _processExceptionsEvent(c) { try { return { ...c, "exception": { ...c.exception, "values": c.exception.values.map((c => { return { ...c, ...c.stacktrace && { "stacktrace": (u = c.stacktrace, { ...u, "frames": u && u.frames && u.frames.map((c => E(c))) }) } }; var u })) } } } catch (u) { return c } }(u)), u } } }; const sessionTimingIntegration = () => { const c = 1e3 * ge(); return { "name": "SessionTiming", "processEvent"(u) { const d = 1e3 * ge(); return { ...u, "extra": { ...u.extra, "session:start": c, "session:duration": d - c, "session:end": d } } } } }, thirdPartyErrorFilterIntegration = c => ({ "name": "ThirdPartyErrorsFilter", "setup"(c) { c.on("beforeEnvelope", (c => { forEachEnvelopeItem(c, ((c, u) => { if ("event" === u) { const u = Array.isArray(c) ? c[1] : void 0; u && (stripMetadataFromStackFrames(u), c[1] = u) } })) })), c.on("applyFrameMetadata", (u => { if (u.type) return; addMetadataToStackFrames(c.getOptions().stackParser, u) })) }, "processEvent"(u) { const d = function getBundleKeysForAllFramesWithFilenames(c) { const u = getFramesFromEvent(c); if (!u) return; return u.filter((c => !!c.filename)).map((c => c.module_metadata ? Object.keys(c.module_metadata).filter((c => c.startsWith(Nn))).map((c => c.slice(Nn.length))) : [])) }(u); if (d) { const v = d["drop-error-if-contains-third-party-frames" === c.behaviour || "apply-tag-if-contains-third-party-frames" === c.behaviour ? "some" : "every"]((u => !u.some((u => c.filterKeys.includes(u))))); if (v) { if ("drop-error-if-contains-third-party-frames" === c.behaviour || "drop-error-if-exclusively-contains-third-party-frames" === c.behaviour) return null; u.tags = { ...u.tags, "third_party_code": !0 } } } return u } }); const Nn = "_sentryBundlerPluginAppKey:"; function formatIssueTitle(c) { return { ...c, "path": "path" in c && Array.isArray(c.path) ? c.path.join(".") : void 0, "keys": "keys" in c ? JSON.stringify(c.keys) : void 0, "unionErrors": "unionErrors" in c ? JSON.stringify(c.unionErrors) : void 0 } } function formatIssueMessage(c) { const u = new Set; for (const d of c.issues) d.path && d.path[0] && u.add(d.path[0]); return `Failed to validate keys: ${string_truncate(Array.from(u).join(", "), 100)}` } function applyZodErrorsToEvent(c, u, d) { return u.exception && u.exception.values && d && d.originalException && function originalExceptionIsZodError(c) { return is_isError(c) && "ZodError" === c.name && Array.isArray(c.errors) }(d.originalException) && 0 !== d.originalException.issues.length ? { ...u, "exception": { ...u.exception, "values": [{ ...u.exception.values[0], "value": formatIssueMessage(d.originalException) }, ...u.exception.values.slice(1)] }, "extra": { ...u.extra, "zoderror.issues": d.originalException.errors.slice(0, c).map(formatIssueTitle) } } : u } const zodErrorsIntegration = (c = {}) => { const u = c.limit || 10; return { "name": "ZodErrors", "processEvent"(c, d) { return applyZodErrorsToEvent(u, c, d) } } }, Dn = { "replayIntegration": "replay", "replayCanvasIntegration": "replay-canvas", "feedbackIntegration": "feedback", "feedbackModalIntegration": "feedback-modal", "feedbackScreenshotIntegration": "feedback-screenshot", "captureConsoleIntegration": "captureconsole", "contextLinesIntegration": "contextlines", "linkedErrorsIntegration": "linkederrors", "debugIntegration": "debug", "dedupeIntegration": "dedupe", "extraErrorDataIntegration": "extraerrordata", "httpClientIntegration": "httpclient", "reportingObserverIntegration": "reportingobserver", "rewriteFramesIntegration": "rewriteframes", "sessionTimingIntegration": "sessiontiming", "browserProfilingIntegration": "browserprofiling" }, $n = bt; async function lazyLoadIntegration(c, u) { const d = Dn[c], v = $n.Sentry = $n.Sentry || {}; if (!d) throw new Error(`Cannot lazy load integration: ${c}`); const E = v[c]; if ("function" == typeof E && !("_isShim" in E)) return E; const k = function getScriptURL(c) { const u = currentScopes_getClient(), d = u && u.getOptions(), v = d && d.cdnBaseUrl || "https://browser.sentry-cdn.com"; return new URL(`/${ie}/${c}.min.js`, v).toString() }(d), R = bt.document.createElement("script"); R.src = k, R.crossOrigin = "anonymous", R.referrerPolicy = "origin", u && R.setAttribute("nonce", u); const U = new Promise(((c, u) => { R.addEventListener("load", (() => c())), R.addEventListener("error", u) })); bt.document.body.appendChild(R); try { await U } catch (u) { throw new Error(`Error when loading integration: ${c}`) } const H = v[c]; if ("function" != typeof H) throw new Error(`Could not load integration: ${c}`); return H } const Ln = se, Fn = new WeakMap, reportingObserverIntegration = (c = {}) => { const u = c.types || ["crash", "deprecation", "intervention"]; function handler(c) { if (Fn.has(currentScopes_getClient())) for (const u of c) currentScopes_withScope((c => { c.setExtra("url", u.url); const d = `ReportingObserver [${u.type}]`; let v = "No details available"; if (u.body) { const d = {}; for (const c in u.body) d[c] = u.body[c]; if (c.setExtra("body", d), "crash" === u.type) { const c = u.body; v = [c.crashId || "", c.reason || ""].join(" ").trim() || v } else { v = u.body.message || v } } captureMessage(`${d}: ${v}`) })) } return { "name": "ReportingObserver", "setupOnce"() { if (!function supportsReportingObserver() { return "ReportingObserver" in nt }()) return; new Ln.ReportingObserver(handler, { "buffered": !0, "types": u }).observe() }, "setup"(c) { Fn.set(c, !0) } } }; function isSentryRequestUrl(c, u) { const d = u && u.getDsn(), v = u && u.getOptions().tunnel; return function checkDsn(c, u) { return !!u && c.includes(u.host) }(c, d) || function checkTunnel(c, u) { if (!u) return !1; return removeTrailingSlash(c) === removeTrailingSlash(u) }(c, v) } function removeTrailingSlash(c) { return "/" === c[c.length - 1] ? c.slice(0, -1) : c } const httpClientIntegration = (c = {}) => { const u = { "failedRequestStatusCodes": [[500, 599]], "failedRequestTargets": [/.*/], ...c }; return { "name": "HttpClient", "setup"(c) { !function _wrapFetch(c, u) { if (!supportsNativeFetch()) return; addFetchInstrumentationHandler((d => { if (currentScopes_getClient() !== c) return; const { "response": v, "args": E } = d, [k, R] = E; v && function _fetchResponseHandler(c, u, d, v) { if (_shouldCaptureResponse(c, d.status, d.url)) { const c = function _getRequest(c, u) { if (!u && c instanceof Request) return c; if (c instanceof Request && c.bodyUsed) return c; return new Request(c, u) }(u, v); let E, k, R, U; _shouldSendDefaultPii() && ([E, R] = _parseCookieHeaders("Cookie", c), [k, U] = _parseCookieHeaders("Set-Cookie", d)); captureEvent(_createEvent({ "url": c.url, "method": c.method, "status": d.status, "requestHeaders": E, "responseHeaders": k, "requestCookies": R, "responseCookies": U })) } }(u, k, v, R) })) }(c, u), function httpclient_wrapXHR(c, u) { if (!("XMLHttpRequest" in se)) return; addXhrInstrumentationHandler((d => { if (currentScopes_getClient() !== c) return; const v = d.xhr, E = v[Ot]; if (!E) return; const { "method": k, "request_headers": R } = E; try { !function _xhrResponseHandler(c, u, d, v) { if (_shouldCaptureResponse(c, u.status, u.responseURL)) { let c, E, k; if (_shouldSendDefaultPii()) { try { const c = u.getResponseHeader("Set-Cookie") || u.getResponseHeader("set-cookie") || void 0; c && (E = _parseCookieString(c)) } catch (c) { vt && ue.log("Could not extract cookies from response headers") } try { k = function _getXHRResponseHeaders(c) { const u = c.getAllResponseHeaders(); if (!u) return {}; return u.split("\r\n").reduce(((c, u) => { const [d, v] = u.split(": "); return d && v && (c[d] = v), c }), {}) }(u) } catch (c) { vt && ue.log("Could not extract headers from response") } c = v } captureEvent(_createEvent({ "url": u.responseURL, "method": d, "status": u.status, "requestHeaders": c, "responseHeaders": k, "responseCookies": E })) } }(u, v, k, R) } catch (c) { vt && ue.warn("Error while extracting response event form XHR response", c) } })) }(c, u) } } }; function _parseCookieHeaders(c, u) { const d = function _extractFetchHeaders(c) { const u = {}; return c.forEach(((c, d) => { u[d] = c })), u }(u.headers); let v; try { const u = d[c] || d[c.toLowerCase()] || void 0; u && (v = _parseCookieString(u)) } catch (u) { vt && ue.log(`Could not extract cookies from header ${c}`) } return [d, v] } function _getResponseSizeFromHeaders(c) { if (c) { const u = c["Content-Length"] || c["content-length"]; if (u) return parseInt(u, 10) } } function _parseCookieString(c) { return c.split("; ").reduce(((c, u) => { const [d, v] = u.split("="); return d && v && (c[d] = v), c }), {}) } function _shouldCaptureResponse(c, u, d) { return function _isInGivenStatusRanges(c, u) { return c.some((c => "number" == typeof c ? c === u : u >= c[0] && u <= c[1])) }(c.failedRequestStatusCodes, u) && function _isInGivenRequestTargets(c, u) { return c.some((c => "string" == typeof c ? u.includes(c) : c.test(u))) }(c.failedRequestTargets, d) && !isSentryRequestUrl(d, currentScopes_getClient()) } function _createEvent(c) { const u = `HTTP Client Error with status code: ${c.status}`, d = { "message": u, "exception": { "values": [{ "type": "Error", "value": u }] }, "request": { "url": c.url, "method": c.method, "headers": c.requestHeaders, "cookies": c.requestCookies }, "contexts": { "response": { "status_code": c.status, "headers": c.responseHeaders, "cookies": c.responseCookies, "body_size": _getResponseSizeFromHeaders(c.responseHeaders) } } }; return misc_addExceptionMechanism(d, { "type": "http.client", "handled": !1 }), d } function _shouldSendDefaultPii() { const c = currentScopes_getClient(); return !!c && Boolean(c.getOptions().sendDefaultPii) } const jn = se, contextLinesIntegration = (c = {}) => { const u = null != c.frameContextLines ? c.frameContextLines : 7; return { "name": "ContextLines", "processEvent"(c) { return function addSourceContext(c, u) { const d = jn.document, v = jn.location && function stripUrlQueryAndFragment(c) { return c.split(/[?#]/, 1)[0] }(jn.location.href); if (!d || !v) return c; const E = c.exception && c.exception.values; if (!E || !E.length) return c; const k = d.documentElement.innerHTML; if (!k) return c; const R = ["<!DOCTYPE html>", "<html>", ...k.split("\n"), "</html>"]; return E.forEach((c => { const d = c.stacktrace; d && d.frames && (d.frames = d.frames.map((c => function applySourceContextToFrame(c, u, d, v) { if (c.filename !== d || !c.lineno || !u.length) return c; return function addContextToFrame(c, u, d = 5) { if (void 0 === u.lineno) return; const v = c.length, E = Math.max(Math.min(v - 1, u.lineno - 1), 0); u.pre_context = c.slice(Math.max(0, E - d), E).map((c => string_snipLine(c, 0))); const k = Math.min(v - 1, E); u.context_line = string_snipLine(c[k], u.colno || 0), u.post_context = c.slice(Math.min(E + 1, v), E + 1 + d).map((c => string_snipLine(c, 0))) }(u, c, v), c }(c, R, v, u)))) })), c }(c, u) } } }; function _optionalChain(c) { let u, d = c[0], v = 1; for (; v < c.length;) { const E = c[v], k = c[v + 1]; if (v += 2, ("optionalAccess" === E || "optionalCall" === E) && null == d) return; "access" === E || "optionalAccess" === E ? (u = d, d = k(d)) : "call" !== E && "optionalCall" !== E || (d = k(((...c) => d.call(u, ...c))), u = void 0) } return d } const Bn = "8.30.0", Un = globalThis; function utils_build_esm_worldwide_getGlobalSingleton(c, u, d) { const v = d || Un, E = v.__SENTRY__ = v.__SENTRY__ || {}, k = E[Bn] = E[Bn] || {}; return k[c] || (k[c] = u()) } const Hn = 1e3; function utils_build_esm_time_dateTimestampInSeconds() { return Date.now() / Hn } const zn = function build_esm_time_createUnixTimestampInSecondsFunc() { const { "performance": c } = Un; if (!c || !c.now) return utils_build_esm_time_dateTimestampInSeconds; const u = Date.now() - c.now(), d = null == c.timeOrigin ? u : c.timeOrigin; return () => (d + c.now()) / Hn }(); let qn; const Gn = (() => { const { "performance": c } = Un; if (!c || !c.now) return void (qn = "none"); const u = 36e5, d = c.now(), v = Date.now(), E = c.timeOrigin ? Math.abs(c.timeOrigin + d - v) : u, k = E < u, R = c.timing && c.timing.navigationStart, U = "number" == typeof R ? Math.abs(R + d - v) : u; return k || U < u ? E <= U ? (qn = "timeOrigin", c.timeOrigin) : (qn = "navigationStart", R) : (qn = "dateNow", v) })(), Vn = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__, Wn = ["debug", "info", "warn", "error", "log", "assert", "trace"], Zn = {}; function utils_build_esm_logger_consoleSandbox(c) { if (!("console" in Un)) return c(); const u = Un.console, d = {}, v = Object.keys(Zn); v.forEach((c => { const v = Zn[c]; d[c] = u[c], u[c] = v })); try { return c() } finally { v.forEach((c => { u[c] = d[c] })) } } const Yn = utils_build_esm_worldwide_getGlobalSingleton("logger", (function build_esm_logger_makeLogger() { let c = !1; const u = { "enable": () => { c = !0 }, "disable": () => { c = !1 }, "isEnabled": () => c }; return Vn ? Wn.forEach((d => { u[d] = (...u) => { c && utils_build_esm_logger_consoleSandbox((() => { Un.console[d](`Sentry Logger [${d}]:`, ...u) })) } })) : Wn.forEach((c => { u[c] = () => { } })), u })); function build_esm_carrier_getMainCarrier() { return build_esm_carrier_getSentryCarrier(Un), Un } function build_esm_carrier_getSentryCarrier(c) { const u = c.__SENTRY__ = c.__SENTRY__ || {}; return u.version = u.version || Bn, u[Bn] = u[Bn] || {} } const Jn = Object.prototype.toString; function build_esm_is_isBuiltin(c, u) { return Jn.call(c) === `[object ${u}]` } function utils_build_esm_is_isString(c) { return build_esm_is_isBuiltin(c, "String") } function build_esm_is_isPlainObject(c) { return build_esm_is_isBuiltin(c, "Object") } function utils_build_esm_is_isThenable(c) { return Boolean(c && c.then && "function" == typeof c.then) } function utils_build_esm_is_isInstanceOf(c, u) { try { return c instanceof u } catch (c) { return !1 } } function utils_build_esm_misc_uuid4() { const c = Un, u = c.crypto || c.msCrypto; let getRandomByte = () => 16 * Math.random(); try { if (u && u.randomUUID) return u.randomUUID().replace(/-/g, ""); u && u.getRandomValues && (getRandomByte = () => { const c = new Uint8Array(1); return u.getRandomValues(c), c[0] }) } catch (c) { } return ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, (c => (c ^ (15 & getRandomByte()) >> c / 4).toString(16))) } function build_esm_misc_getFirstException(c) { return c.exception && c.exception.values ? c.exception.values[0] : void 0 } function build_esm_propagationContext_generatePropagationContext() { return { "traceId": utils_build_esm_misc_uuid4(), "spanId": utils_build_esm_misc_uuid4().substring(16) } } function build_esm_session_updateSession(c, u = {}) { if (u.user && (!c.ipAddress && u.user.ip_address && (c.ipAddress = u.user.ip_address), c.did || u.did || (c.did = u.user.id || u.user.email || u.user.username)), c.timestamp = u.timestamp || zn(), u.abnormal_mechanism && (c.abnormal_mechanism = u.abnormal_mechanism), u.ignoreDuration && (c.ignoreDuration = u.ignoreDuration), u.sid && (c.sid = 32 === u.sid.length ? u.sid : utils_build_esm_misc_uuid4()), void 0 !== u.init && (c.init = u.init), !c.did && u.did && (c.did = `${u.did}`), "number" == typeof u.started && (c.started = u.started), c.ignoreDuration) c.duration = void 0; else if ("number" == typeof u.duration) c.duration = u.duration; else { const u = c.timestamp - c.started; c.duration = u >= 0 ? u : 0 } u.release && (c.release = u.release), u.environment && (c.environment = u.environment), !c.ipAddress && u.ipAddress && (c.ipAddress = u.ipAddress), !c.userAgent && u.userAgent && (c.userAgent = u.userAgent), "number" == typeof u.errors && (c.errors = u.errors), u.status && (c.status = u.status) } const Kn = Un, Xn = 80; function esm_browser_htmlTreeAsString(c, u = {}) { if (!c) return "<unknown>"; try { let d = c; const v = 5, E = []; let k = 0, R = 0; const U = " > ", H = U.length; let G; const W = Array.isArray(u) ? u : u.keyAttrs, Z = !Array.isArray(u) && u.maxStringLength || Xn; for (; d && k++ < v && (G = browser_htmlElementAsString(d, W), !("html" === G || k > 1 && R + E.length * H + G.length >= Z));)E.push(G), R += G.length, d = d.parentNode; return E.reverse().join(U) } catch (c) { return "<unknown>" } } function browser_htmlElementAsString(c, u) { const d = c, v = []; if (!d || !d.tagName) return ""; if (Kn.HTMLElement && d instanceof HTMLElement && d.dataset) { if (d.dataset.sentryComponent) return d.dataset.sentryComponent; if (d.dataset.sentryElement) return d.dataset.sentryElement } v.push(d.tagName.toLowerCase()); const E = u && u.length ? u.filter((c => d.getAttribute(c))).map((c => [c, d.getAttribute(c)])) : null; if (E && E.length) E.forEach((c => { v.push(`[${c[0]}="${c[1]}"]`) })); else { d.id && v.push(`#${d.id}`); const c = d.className; if (c && utils_build_esm_is_isString(c)) { const u = c.split(/\s+/); for (const c of u) v.push(`.${c}`) } } const k = ["aria-label", "type", "name", "title", "alt"]; for (const c of k) { const u = d.getAttribute(c); u && v.push(`[${c}="${u}"]`) } return v.join("") } function browser_getLocationHref() { try { return Kn.document.location.href } catch (c) { return "" } } function build_esm_object_fill(c, u, d) { if (!(u in c)) return; const v = c[u], E = d(v); "function" == typeof E && function build_esm_object_markFunctionWrapped(c, u) { try { const d = u.prototype || {}; c.prototype = u.prototype = d, utils_build_esm_object_addNonEnumerableProperty(c, "__sentry_original__", u) } catch (c) { } }(E, v), c[u] = E } function utils_build_esm_object_addNonEnumerableProperty(c, u, d) { try { Object.defineProperty(c, u, { "value": d, "writable": !0, "configurable": !0 }) } catch (d) { Vn && Yn.log(`Failed to add non-enumerable property "${u}" to object`, c) } } function build_esm_object_convertToPlainObject(c) { if (function utils_build_esm_is_isError(c) { switch (Jn.call(c)) { case "[object Error]": case "[object Exception]": case "[object DOMException]": return !0; default: return utils_build_esm_is_isInstanceOf(c, Error) } }(c)) return { "message": c.message, "name": c.name, "stack": c.stack, ...build_esm_object_getOwnProperties(c) }; if (function utils_build_esm_is_isEvent(c) { return "undefined" != typeof Event && utils_build_esm_is_isInstanceOf(c, Event) }(c)) { const u = { "type": c.type, "target": build_esm_object_serializeEventTarget(c.target), "currentTarget": build_esm_object_serializeEventTarget(c.currentTarget), ...build_esm_object_getOwnProperties(c) }; return "undefined" != typeof CustomEvent && utils_build_esm_is_isInstanceOf(c, CustomEvent) && (u.detail = c.detail), u } return c } function build_esm_object_serializeEventTarget(c) { try { return function utils_build_esm_is_isElement(c) { return "undefined" != typeof Element && utils_build_esm_is_isInstanceOf(c, Element) }(c) ? esm_browser_htmlTreeAsString(c) : Object.prototype.toString.call(c) } catch (c) { return "<unknown>" } } function build_esm_object_getOwnProperties(c) { if ("object" == typeof c && null !== c) { const u = {}; for (const d in c) Object.prototype.hasOwnProperty.call(c, d) && (u[d] = c[d]); return u } return {} } function node_modules_sentry_utils_build_esm_object_dropUndefinedKeys(c) { return replay_node_modules_sentry_utils_build_esm_object_dropUndefinedKeys(c, new Map) } function replay_node_modules_sentry_utils_build_esm_object_dropUndefinedKeys(c, u) { if (function build_esm_object_isPojo(c) { if (!build_esm_is_isPlainObject(c)) return !1; try { const u = Object.getPrototypeOf(c).constructor.name; return !u || "Object" === u } catch (c) { return !0 } }(c)) { const d = u.get(c); if (void 0 !== d) return d; const v = {}; u.set(c, v); for (const d of Object.keys(c)) void 0 !== c[d] && (v[d] = replay_node_modules_sentry_utils_build_esm_object_dropUndefinedKeys(c[d], u)); return v } if (Array.isArray(c)) { const d = u.get(c); if (void 0 !== d) return d; const v = []; return u.set(c, v), c.forEach((c => { v.push(replay_node_modules_sentry_utils_build_esm_object_dropUndefinedKeys(c, u)) })), v } return c } const Qn = "_sentrySpan"; function esm_utils_spanOnScope_setSpanForScope(c, u) { u ? utils_build_esm_object_addNonEnumerableProperty(c, Qn, u) : delete c[Qn] } function utils_spanOnScope_getSpanForScope(c) { return c[Qn] } class esm_scope_ScopeClass { "constructor"() { this._notifyingListeners = !1, this._scopeListeners = [], this._eventProcessors = [], this._breadcrumbs = [], this._attachments = [], this._user = {}, this._tags = {}, this._extra = {}, this._contexts = {}, this._sdkProcessingMetadata = {}, this._propagationContext = build_esm_propagationContext_generatePropagationContext() } "clone"() { const c = new esm_scope_ScopeClass; return c._breadcrumbs = [...this._breadcrumbs], c._tags = { ...this._tags }, c._extra = { ...this._extra }, c._contexts = { ...this._contexts }, c._user = this._user, c._level = this._level, c._session = this._session, c._transactionName = this._transactionName, c._fingerprint = this._fingerprint, c._eventProcessors = [...this._eventProcessors], c._requestSession = this._requestSession, c._attachments = [...this._attachments], c._sdkProcessingMetadata = { ...this._sdkProcessingMetadata }, c._propagationContext = { ...this._propagationContext }, c._client = this._client, c._lastEventId = this._lastEventId, esm_utils_spanOnScope_setSpanForScope(c, utils_spanOnScope_getSpanForScope(this)), c } "setClient"(c) { this._client = c } "setLastEventId"(c) { this._lastEventId = c } "getClient"() { return this._client } "lastEventId"() { return this._lastEventId } "addScopeListener"(c) { this._scopeListeners.push(c) } "addEventProcessor"(c) { return this._eventProcessors.push(c), this } "setUser"(c) { return this._user = c || { "email": void 0, "id": void 0, "ip_address": void 0, "username": void 0 }, this._session && build_esm_session_updateSession(this._session, { "user": c }), this._notifyScopeListeners(), this } "getUser"() { return this._user } "getRequestSession"() { return this._requestSession } "setRequestSession"(c) { return this._requestSession = c, this } "setTags"(c) { return this._tags = { ...this._tags, ...c }, this._notifyScopeListeners(), this } "setTag"(c, u) { return this._tags = { ...this._tags, [c]: u }, this._notifyScopeListeners(), this } "setExtras"(c) { return this._extra = { ...this._extra, ...c }, this._notifyScopeListeners(), this } "setExtra"(c, u) { return this._extra = { ...this._extra, [c]: u }, this._notifyScopeListeners(), this } "setFingerprint"(c) { return this._fingerprint = c, this._notifyScopeListeners(), this } "setLevel"(c) { return this._level = c, this._notifyScopeListeners(), this } "setTransactionName"(c) { return this._transactionName = c, this._notifyScopeListeners(), this } "setContext"(c, u) { return null === u ? delete this._contexts[c] : this._contexts[c] = u, this._notifyScopeListeners(), this } "setSession"(c) { return c ? this._session = c : delete this._session, this._notifyScopeListeners(), this } "getSession"() { return this._session } "update"(c) { if (!c) return this; const u = "function" == typeof c ? c(this) : c, [d, v] = u instanceof er ? [u.getScopeData(), u.getRequestSession()] : build_esm_is_isPlainObject(u) ? [c, c.requestSession] : [], { "tags": E, "extra": k, "user": R, "contexts": U, "level": H, "fingerprint": G = [], "propagationContext": W } = d || {}; return this._tags = { ...this._tags, ...E }, this._extra = { ...this._extra, ...k }, this._contexts = { ...this._contexts, ...U }, R && Object.keys(R).length && (this._user = R), H && (this._level = H), G.length && (this._fingerprint = G), W && (this._propagationContext = W), v && (this._requestSession = v), this } "clear"() { return this._breadcrumbs = [], this._tags = {}, this._extra = {}, this._user = {}, this._contexts = {}, this._level = void 0, this._transactionName = void 0, this._fingerprint = void 0, this._requestSession = void 0, this._session = void 0, esm_utils_spanOnScope_setSpanForScope(this, void 0), this._attachments = [], this._propagationContext = build_esm_propagationContext_generatePropagationContext(), this._notifyScopeListeners(), this } "addBreadcrumb"(c, u) { const d = "number" == typeof u ? u : 100; if (d <= 0) return this; const v = { "timestamp": utils_build_esm_time_dateTimestampInSeconds(), ...c }, E = this._breadcrumbs; return E.push(v), this._breadcrumbs = E.length > d ? E.slice(-d) : E, this._notifyScopeListeners(), this } "getLastBreadcrumb"() { return this._breadcrumbs[this._breadcrumbs.length - 1] } "clearBreadcrumbs"() { return this._breadcrumbs = [], this._notifyScopeListeners(), this } "addAttachment"(c) { return this._attachments.push(c), this } "clearAttachments"() { return this._attachments = [], this } "getScopeData"() { return { "breadcrumbs": this._breadcrumbs, "attachments": this._attachments, "contexts": this._contexts, "tags": this._tags, "extra": this._extra, "user": this._user, "level": this._level, "fingerprint": this._fingerprint || [], "eventProcessors": this._eventProcessors, "propagationContext": this._propagationContext, "sdkProcessingMetadata": this._sdkProcessingMetadata, "transactionName": this._transactionName, "span": utils_spanOnScope_getSpanForScope(this) } } "setSDKProcessingMetadata"(c) { return this._sdkProcessingMetadata = { ...this._sdkProcessingMetadata, ...c }, this } "setPropagationContext"(c) { return this._propagationContext = c, this } "getPropagationContext"() { return this._propagationContext } "captureException"(c, u) { const d = u && u.event_id ? u.event_id : utils_build_esm_misc_uuid4(); if (!this._client) return Yn.warn("No client configured on scope - will not capture exception!"), d; const v = new Error("Sentry syntheticException"); return this._client.captureException(c, { "originalException": c, "syntheticException": v, ...u, "event_id": d }, this), d } "captureMessage"(c, u, d) { const v = d && d.event_id ? d.event_id : utils_build_esm_misc_uuid4(); if (!this._client) return Yn.warn("No client configured on scope - will not capture message!"), v; const E = new Error(c); return this._client.captureMessage(c, u, { "originalException": c, "syntheticException": E, ...d, "event_id": v }, this), v } "captureEvent"(c, u) { const d = u && u.event_id ? u.event_id : utils_build_esm_misc_uuid4(); return this._client ? (this._client.captureEvent(c, { ...u, "event_id": d }, this), d) : (Yn.warn("No client configured on scope - will not capture event!"), d) } "_notifyScopeListeners"() { this._notifyingListeners || (this._notifyingListeners = !0, this._scopeListeners.forEach((c => { c(this) })), this._notifyingListeners = !1) } } const er = esm_scope_ScopeClass; class asyncContext_stackStrategy_AsyncContextStack { "constructor"(c, u) { let d, v; d = c || new er, v = u || new er, this._stack = [{ "scope": d }], this._isolationScope = v } "withScope"(c) { const u = this._pushScope(); let d; try { d = c(u) } catch (c) { throw this._popScope(), c } return utils_build_esm_is_isThenable(d) ? d.then((c => (this._popScope(), c)), (c => { throw this._popScope(), c })) : (this._popScope(), d) } "getClient"() { return this.getStackTop().client } "getScope"() { return this.getStackTop().scope } "getIsolationScope"() { return this._isolationScope } "getStackTop"() { return this._stack[this._stack.length - 1] } "_pushScope"() { const c = this.getScope().clone(); return this._stack.push({ "client": this.getClient(), "scope": c }), c } "_popScope"() { return !(this._stack.length <= 1) && !!this._stack.pop() } } function asyncContext_stackStrategy_getAsyncContextStack() { const c = build_esm_carrier_getSentryCarrier(build_esm_carrier_getMainCarrier()); return c.stack = c.stack || new asyncContext_stackStrategy_AsyncContextStack(function esm_defaultScopes_getDefaultCurrentScope() { return utils_build_esm_worldwide_getGlobalSingleton("defaultCurrentScope", (() => new er)) }(), function esm_defaultScopes_getDefaultIsolationScope() { return utils_build_esm_worldwide_getGlobalSingleton("defaultIsolationScope", (() => new er)) }()) } function esm_asyncContext_stackStrategy_withScope(c) { return asyncContext_stackStrategy_getAsyncContextStack().withScope(c) } function asyncContext_stackStrategy_withSetScope(c, u) { const d = asyncContext_stackStrategy_getAsyncContextStack(); return d.withScope((() => (d.getStackTop().scope = c, u(c)))) } function esm_asyncContext_stackStrategy_withIsolationScope(c) { return asyncContext_stackStrategy_getAsyncContextStack().withScope((() => c(asyncContext_stackStrategy_getAsyncContextStack().getIsolationScope()))) } function build_esm_asyncContext_getAsyncContextStrategy(c) { const u = build_esm_carrier_getSentryCarrier(c); return u.acs ? u.acs : function asyncContext_stackStrategy_getStackAsyncContextStrategy() { return { "withIsolationScope": esm_asyncContext_stackStrategy_withIsolationScope, "withScope": esm_asyncContext_stackStrategy_withScope, "withSetScope": asyncContext_stackStrategy_withSetScope, "withSetIsolationScope": (c, u) => esm_asyncContext_stackStrategy_withIsolationScope(u), "getCurrentScope": () => asyncContext_stackStrategy_getAsyncContextStack().getScope(), "getIsolationScope": () => asyncContext_stackStrategy_getAsyncContextStack().getIsolationScope() } }() } function build_esm_currentScopes_getCurrentScope() { return build_esm_asyncContext_getAsyncContextStrategy(build_esm_carrier_getMainCarrier()).getCurrentScope() } function build_esm_currentScopes_getIsolationScope() { return build_esm_asyncContext_getAsyncContextStrategy(build_esm_carrier_getMainCarrier()).getIsolationScope() } function build_esm_currentScopes_getClient() { return build_esm_currentScopes_getCurrentScope().getClient() } const tr = 100; function esm_string_truncate(c, u = 0) { return "string" != typeof c || 0 === u || c.length <= u ? c : `${c.slice(0, u)}...` } function string_isMatchingPattern(c, u, d = !1) { return !!utils_build_esm_is_isString(c) && (function build_esm_is_isRegExp(c) { return build_esm_is_isBuiltin(c, "RegExp") }(u) ? u.test(c) : !!utils_build_esm_is_isString(u) && (d ? c === u : c.includes(u))) } const nr = "<anonymous>"; function esm_normalize_normalize(c, u = 100, d = 1 / 0) { try { return normalize_visit("", c, u, d) } catch (c) { return { "ERROR": `**non-serializable** (${c})` } } } function normalize_visit(c, u, d = 1 / 0, v = 1 / 0, E = function memo_memoBuilder() { const c = "function" == typeof WeakSet, u = c ? new WeakSet : []; return [function memoize(d) { if (c) return !!u.has(d) || (u.add(d), !1); for (let c = 0; c < u.length; c++)if (u[c] === d) return !0; return u.push(d), !1 }, function unmemoize(d) { if (c) u.delete(d); else for (let c = 0; c < u.length; c++)if (u[c] === d) { u.splice(c, 1); break } }] }()) { const [k, R] = E; if (null == u || ["number", "boolean", "string"].includes(typeof u) && !Number.isNaN(u)) return u; const U = function normalize_stringifyValue(c, u) { try { if ("domain" === c && u && "object" == typeof u && u._events) return "[Domain]"; if ("domainEmitter" === c) return "[DomainEmitter]"; if ("undefined" != typeof global && u === global) return "[Global]"; if ("undefined" != typeof window && u === window) return "[Window]"; if ("undefined" != typeof document && u === document) return "[Document]"; if (function utils_build_esm_is_isVueViewModel(c) { return !("object" != typeof c || null === c || !c.__isVue && !c._isVue) }(u)) return "[VueViewModel]"; if (function build_esm_is_isSyntheticEvent(c) { return build_esm_is_isPlainObject(c) && "nativeEvent" in c && "preventDefault" in c && "stopPropagation" in c }(u)) return "[SyntheticEvent]"; if ("number" == typeof u && u != u) return "[NaN]"; if ("function" == typeof u) return `[Function: ${function esm_stacktrace_getFunctionName(c) { try { return c && "function" == typeof c && c.name || nr } catch (c) { return nr } }(u)}]`; if ("symbol" == typeof u) return `[${String(u)}]`; if ("bigint" == typeof u) return `[BigInt: ${String(u)}]`; const d = function normalize_getConstructorName(c) { const u = Object.getPrototypeOf(c); return u ? u.constructor.name : "null prototype" }(u); return /^HTML(\w*)Element$/.test(d) ? `[HTMLElement: ${d}]` : `[object ${d}]` } catch (c) { return `**non-serializable** (${c})` } }(c, u); if (!U.startsWith("[object ")) return U; if (u.__sentry_skip_normalization__) return u; const H = "number" == typeof u.__sentry_override_normalization_depth__ ? u.__sentry_override_normalization_depth__ : d; if (0 === H) return U.replace("object ", ""); if (k(u)) return "[Circular ~]"; const G = u; if (G && "function" == typeof G.toJSON) try { return normalize_visit("", G.toJSON(), H - 1, v, E) } catch (c) { } const W = Array.isArray(u) ? [] : {}; let Z = 0; const Y = build_esm_object_convertToPlainObject(u); for (const c in Y) { if (!Object.prototype.hasOwnProperty.call(Y, c)) continue; if (Z >= v) { W[c] = "[MaxProperties ~]"; break } const u = Y[c]; W[c] = normalize_visit(c, u, H - 1, v, E), Z++ } return R(u), W } const rr = "production"; var or; function syncpromise_resolvedSyncPromise(c) { return new syncpromise_SyncPromise((u => { u(c) })) } !function (c) { c[c.PENDING = 0] = "PENDING"; c[c.RESOLVED = 1] = "RESOLVED"; c[c.REJECTED = 2] = "REJECTED" }(or || (or = {})); class syncpromise_SyncPromise { "constructor"(c) { syncpromise_SyncPromise.prototype.__init.call(this), syncpromise_SyncPromise.prototype.__init2.call(this), syncpromise_SyncPromise.prototype.__init3.call(this), syncpromise_SyncPromise.prototype.__init4.call(this), this._state = or.PENDING, this._handlers = []; try { c(this._resolve, this._reject) } catch (c) { this._reject(c) } } "then"(c, u) { return new syncpromise_SyncPromise(((d, v) => { this._handlers.push([!1, u => { if (c) try { d(c(u)) } catch (c) { v(c) } else d(u) }, c => { if (u) try { d(u(c)) } catch (c) { v(c) } else v(c) }]), this._executeHandlers() })) } "catch"(c) { return this.then((c => c), c) } "finally"(c) { return new syncpromise_SyncPromise(((u, d) => { let v, E; return this.then((u => { E = !1, v = u, c && c() }), (u => { E = !0, v = u, c && c() })).then((() => { E ? d(v) : u(v) })) })) } "__init"() { this._resolve = c => { this._setResult(or.RESOLVED, c) } } "__init2"() { this._reject = c => { this._setResult(or.REJECTED, c) } } "__init3"() { this._setResult = (c, u) => { this._state === or.PENDING && (utils_build_esm_is_isThenable(u) ? u.then(this._resolve, this._reject) : (this._state = c, this._value = u, this._executeHandlers())) } } "__init4"() { this._executeHandlers = () => { if (this._state === or.PENDING) return; const c = this._handlers.slice(); this._handlers = [], c.forEach((c => { c[0] || (this._state === or.RESOLVED && c[1](this._value), this._state === or.REJECTED && c[2](this._value), c[0] = !0) })) } } } const ir = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__; function esm_eventProcessors_notifyEventProcessors(c, u, d, v = 0) { return new syncpromise_SyncPromise(((E, k) => { const R = c[v]; if (null === u || "function" != typeof R) E(u); else { const U = R({ ...u }, d); ir && R.id && null === U && Yn.log(`Event processor "${R.id}" dropped event`), utils_build_esm_is_isThenable(U) ? U.then((u => esm_eventProcessors_notifyEventProcessors(c, u, d, v + 1).then(E))).then(null, k) : esm_eventProcessors_notifyEventProcessors(c, U, d, v + 1).then(E).then(null, k) } })) } const ar = "sentry-", sr = /^sentry-/; function baggage_baggageHeaderToDynamicSamplingContext(c) { const u = function baggage_parseBaggageHeader(c) { if (!c || !utils_build_esm_is_isString(c) && !Array.isArray(c)) return; if (Array.isArray(c)) return c.reduce(((c, u) => { const d = baggage_baggageHeaderToObject(u); return Object.entries(d).forEach((([u, d]) => { c[u] = d })), c }), {}); return baggage_baggageHeaderToObject(c) }(c); if (!u) return; const d = Object.entries(u).reduce(((c, [u, d]) => { if (u.match(sr)) { c[u.slice(ar.length)] = d } return c }), {}); return Object.keys(d).length > 0 ? d : void 0 } function baggage_baggageHeaderToObject(c) { return c.split(",").map((c => c.split("=").map((c => decodeURIComponent(c.trim()))))).reduce(((c, [u, d]) => (u && d && (c[u] = d), c)), {}) } const cr = "sentry.source", lr = "sentry.sample_rate", ur = "sentry.op", dr = "sentry.origin", pr = "_sentryMetrics"; function metric_summary_getMetricSummaryJsonForSpan(c) { const u = c[pr]; if (!u) return; const d = {}; for (const [, [c, v]] of u) { (d[c] || (d[c] = [])).push(node_modules_sentry_utils_build_esm_object_dropUndefinedKeys(v)) } return d } const fr = 0, hr = 1; const mr = 1; function spanUtils_spanToTraceContext(c) { const { "spanId": u, "traceId": d } = c.spanContext(), { "parent_span_id": v } = utils_spanUtils_spanToJSON(c); return node_modules_sentry_utils_build_esm_object_dropUndefinedKeys({ "parent_span_id": v, "span_id": u, "trace_id": d }) } function spanUtils_spanTimeInputToSeconds(c) { return "number" == typeof c ? spanUtils_ensureTimestampInSeconds(c) : Array.isArray(c) ? c[0] + c[1] / 1e9 : c instanceof Date ? spanUtils_ensureTimestampInSeconds(c.getTime()) : zn() } function spanUtils_ensureTimestampInSeconds(c) { return c > 9999999999 ? c / 1e3 : c } function utils_spanUtils_spanToJSON(c) { if (function spanUtils_spanIsSentrySpan(c) { return "function" == typeof c.getSpanJSON }(c)) return c.getSpanJSON(); try { const { "spanId": u, "traceId": d } = c.spanContext(); if (function spanUtils_spanIsOpenTelemetrySdkTraceBaseSpan(c) { const u = c; return !!(u.attributes && u.startTime && u.name && u.endTime && u.status) }(c)) { const { "attributes": v, "startTime": E, "name": k, "endTime": R, "parentSpanId": U, "status": H } = c; return node_modules_sentry_utils_build_esm_object_dropUndefinedKeys({ "span_id": u, "trace_id": d, "data": v, "description": k, "parent_span_id": U, "start_timestamp": spanUtils_spanTimeInputToSeconds(E), "timestamp": spanUtils_spanTimeInputToSeconds(R) || void 0, "status": spanUtils_getStatusMessage(H), "op": v[ur], "origin": v[dr], "_metrics_summary": metric_summary_getMetricSummaryJsonForSpan(c) }) } return { "span_id": u, "trace_id": d } } catch (c) { return {} } } function spanUtils_spanIsSampled(c) { const { "traceFlags": u } = c.spanContext(); return u === mr } function spanUtils_getStatusMessage(c) { if (c && c.code !== fr) return c.code === hr ? "ok" : c.message || "unknown_error" } const gr = "_sentryRootSpan"; function spanUtils_getRootSpan(c) { return c[gr] || c } function spanUtils_getActiveSpan() { const c = build_esm_asyncContext_getAsyncContextStrategy(build_esm_carrier_getMainCarrier()); return c.getActiveSpan ? c.getActiveSpan() : utils_spanOnScope_getSpanForScope(build_esm_currentScopes_getCurrentScope()) } const _r = "_frozenDsc"; function dynamicSamplingContext_getDynamicSamplingContextFromSpan(c) { const u = build_esm_currentScopes_getClient(); if (!u) return {}; const d = function dynamicSamplingContext_getDynamicSamplingContextFromClient(c, u) { const d = u.getOptions(), { "publicKey": v } = u.getDsn() || {}, E = node_modules_sentry_utils_build_esm_object_dropUndefinedKeys({ "environment": d.environment || rr, "release": d.release, "public_key": v, "trace_id": c }); return u.emit("createDsc", E), E }(utils_spanUtils_spanToJSON(c).trace_id || "", u), v = spanUtils_getRootSpan(c), E = v[_r]; if (E) return E; const k = v.spanContext().traceState, R = k && k.get("sentry.dsc"), U = R && baggage_baggageHeaderToDynamicSamplingContext(R); if (U) return U; const H = utils_spanUtils_spanToJSON(v), G = H.data || {}, W = G[lr]; null != W && (d.sample_rate = `${W}`); const Z = G[cr], Y = H.description; return "url" !== Z && Y && (d.transaction = Y), d.sampled = String(spanUtils_spanIsSampled(v)), u.emit("createDsc", d, v), d } function utils_applyScopeDataToEvent_applyScopeDataToEvent(c, u) { const { "fingerprint": d, "span": v, "breadcrumbs": E, "sdkProcessingMetadata": k } = u; !function applyScopeDataToEvent_applyDataToEvent(c, u) { const { "extra": d, "tags": v, "user": E, "contexts": k, "level": R, "transactionName": U } = u, H = node_modules_sentry_utils_build_esm_object_dropUndefinedKeys(d); H && Object.keys(H).length && (c.extra = { ...H, ...c.extra }); const G = node_modules_sentry_utils_build_esm_object_dropUndefinedKeys(v); G && Object.keys(G).length && (c.tags = { ...G, ...c.tags }); const W = node_modules_sentry_utils_build_esm_object_dropUndefinedKeys(E); W && Object.keys(W).length && (c.user = { ...W, ...c.user }); const Z = node_modules_sentry_utils_build_esm_object_dropUndefinedKeys(k); Z && Object.keys(Z).length && (c.contexts = { ...Z, ...c.contexts }); R && (c.level = R); U && "transaction" !== c.type && (c.transaction = U) }(c, u), v && function applyScopeDataToEvent_applySpanToEvent(c, u) { c.contexts = { "trace": spanUtils_spanToTraceContext(u), ...c.contexts }, c.sdkProcessingMetadata = { "dynamicSamplingContext": dynamicSamplingContext_getDynamicSamplingContextFromSpan(u), ...c.sdkProcessingMetadata }; const d = spanUtils_getRootSpan(u), v = utils_spanUtils_spanToJSON(d).description; v && !c.transaction && "transaction" === c.type && (c.transaction = v) }(c, v), function applyScopeDataToEvent_applyFingerprintToEvent(c, u) { c.fingerprint = c.fingerprint ? function utils_build_esm_misc_arrayify(c) { return Array.isArray(c) ? c : [c] }(c.fingerprint) : [], u && (c.fingerprint = c.fingerprint.concat(u)); c.fingerprint && !c.fingerprint.length && delete c.fingerprint }(c, d), function applyScopeDataToEvent_applyBreadcrumbsToEvent(c, u) { const d = [...c.breadcrumbs || [], ...u]; c.breadcrumbs = d.length ? d : void 0 }(c, E), function applyScopeDataToEvent_applySdkMetadataToEvent(c, u) { c.sdkProcessingMetadata = { ...c.sdkProcessingMetadata, ...u } }(c, k) } function utils_applyScopeDataToEvent_mergeScopeData(c, u) { const { "extra": d, "tags": v, "user": E, "contexts": k, "level": R, "sdkProcessingMetadata": U, "breadcrumbs": H, "fingerprint": G, "eventProcessors": W, "attachments": Z, "propagationContext": Y, "transactionName": J, "span": K } = u; applyScopeDataToEvent_mergeAndOverwriteScopeData(c, "extra", d), applyScopeDataToEvent_mergeAndOverwriteScopeData(c, "tags", v), applyScopeDataToEvent_mergeAndOverwriteScopeData(c, "user", E), applyScopeDataToEvent_mergeAndOverwriteScopeData(c, "contexts", k), applyScopeDataToEvent_mergeAndOverwriteScopeData(c, "sdkProcessingMetadata", U), R && (c.level = R), J && (c.transactionName = J), K && (c.span = K), H.length && (c.breadcrumbs = [...c.breadcrumbs, ...H]), G.length && (c.fingerprint = [...c.fingerprint, ...G]), W.length && (c.eventProcessors = [...c.eventProcessors, ...W]), Z.length && (c.attachments = [...c.attachments, ...Z]), c.propagationContext = { ...c.propagationContext, ...Y } } function applyScopeDataToEvent_mergeAndOverwriteScopeData(c, u, d) { if (d && Object.keys(d).length) { c[u] = { ...c[u] }; for (const v in d) Object.prototype.hasOwnProperty.call(d, v) && (c[u][v] = d[v]) } } function utils_prepareEvent_prepareEvent(c, u, d, v, E, k) { const { "normalizeDepth": R = 3, "normalizeMaxBreadth": U = 1e3 } = c, H = { ...u, "event_id": u.event_id || d.event_id || utils_build_esm_misc_uuid4(), "timestamp": u.timestamp || utils_build_esm_time_dateTimestampInSeconds() }, G = d.integrations || c.integrations.map((c => c.name)); !function utils_prepareEvent_applyClientOptions(c, u) { const { "environment": d, "release": v, "dist": E, "maxValueLength": k = 250 } = u; "environment" in c || (c.environment = "environment" in u ? d : rr); void 0 === c.release && void 0 !== v && (c.release = v); void 0 === c.dist && void 0 !== E && (c.dist = E); c.message && (c.message = esm_string_truncate(c.message, k)); const R = c.exception && c.exception.values && c.exception.values[0]; R && R.value && (R.value = esm_string_truncate(R.value, k)); const U = c.request; U && U.url && (U.url = esm_string_truncate(U.url, k)) }(H, c), function utils_prepareEvent_applyIntegrationsMetadata(c, u) { u.length > 0 && (c.sdk = c.sdk || {}, c.sdk.integrations = [...c.sdk.integrations || [], ...u]) }(H, G), E && E.emit("applyFrameMetadata", u), void 0 === u.type && function utils_prepareEvent_applyDebugIds(c, u) { const d = Un._sentryDebugIds; if (!d) return; let v; const E = vr.get(u); E ? v = E : (v = new Map, vr.set(u, v)); const k = Object.entries(d).reduce(((c, [d, E]) => { let k; const R = v.get(d); R ? k = R : (k = u(d), v.set(d, k)); for (let u = k.length - 1; u >= 0; u--) { const d = k[u]; if (d.filename) { c[d.filename] = E; break } } return c }), {}); try { c.exception.values.forEach((c => { c.stacktrace.frames.forEach((c => { c.filename && (c.debug_id = k[c.filename]) })) })) } catch (c) { } }(H, c.stackParser); const W = function utils_prepareEvent_getFinalScope(c, u) { if (!u) return c; const d = c ? c.clone() : new er; return d.update(u), d }(v, d.captureContext); d.mechanism && function utils_build_esm_misc_addExceptionMechanism(c, u) { const d = build_esm_misc_getFirstException(c); if (!d) return; const v = d.mechanism; if (d.mechanism = { "type": "generic", "handled": !0, ...v, ...u }, u && "data" in u) { const c = { ...v && v.data, ...u.data }; d.mechanism.data = c } }(H, d.mechanism); const Z = E ? E.getEventProcessors() : [], Y = function build_esm_currentScopes_getGlobalScope() { return utils_build_esm_worldwide_getGlobalSingleton("globalScope", (() => new er)) }().getScopeData(); if (k) { utils_applyScopeDataToEvent_mergeScopeData(Y, k.getScopeData()) } if (W) { utils_applyScopeDataToEvent_mergeScopeData(Y, W.getScopeData()) } const J = [...d.attachments || [], ...Y.attachments]; J.length && (d.attachments = J), utils_applyScopeDataToEvent_applyScopeDataToEvent(H, Y); return esm_eventProcessors_notifyEventProcessors([...Z, ...Y.eventProcessors], H, d).then((c => (c && function utils_prepareEvent_applyDebugMeta(c) { const u = {}; try { c.exception.values.forEach((c => { c.stacktrace.frames.forEach((c => { c.debug_id && (c.abs_path ? u[c.abs_path] = c.debug_id : c.filename && (u[c.filename] = c.debug_id), delete c.debug_id) })) })) } catch (c) { } if (0 === Object.keys(u).length) return; c.debug_meta = c.debug_meta || {}, c.debug_meta.images = c.debug_meta.images || []; const d = c.debug_meta.images; Object.entries(u).forEach((([c, u]) => { d.push({ "type": "sourcemap", "code_file": c, "debug_id": u }) })) }(c), "number" == typeof R && R > 0 ? function utils_prepareEvent_normalizeEvent(c, u, d) { if (!c) return null; const v = { ...c, ...c.breadcrumbs && { "breadcrumbs": c.breadcrumbs.map((c => ({ ...c, ...c.data && { "data": esm_normalize_normalize(c.data, u, d) } }))) }, ...c.user && { "user": esm_normalize_normalize(c.user, u, d) }, ...c.contexts && { "contexts": esm_normalize_normalize(c.contexts, u, d) }, ...c.extra && { "extra": esm_normalize_normalize(c.extra, u, d) } }; c.contexts && c.contexts.trace && v.contexts && (v.contexts.trace = c.contexts.trace, c.contexts.trace.data && (v.contexts.trace.data = esm_normalize_normalize(c.contexts.trace.data, u, d))); c.spans && (v.spans = c.spans.map((c => ({ ...c, ...c.data && { "data": esm_normalize_normalize(c.data, u, d) } })))); return v }(c, R, U) : c))) } const vr = new WeakMap; function utils_prepareEvent_parseEventHintOrCaptureContext(c) { if (c) return function utils_prepareEvent_hintIsScopeOrFunction(c) { return c instanceof er || "function" == typeof c }(c) || function utils_prepareEvent_hintIsScopeContext(c) { return Object.keys(c).some((c => yr.includes(c))) }(c) ? { "captureContext": c } : c } const yr = ["user", "level", "extra", "contexts", "tags", "fingerprint", "requestSession", "propagationContext"]; function esm_exports_captureException(c, u) { return build_esm_currentScopes_getCurrentScope().captureException(c, utils_prepareEvent_parseEventHintOrCaptureContext(u)) } function isSentryRequestUrl_isSentryRequestUrl(c, u) { const d = u && u.getDsn(), v = u && u.getOptions().tunnel; return function isSentryRequestUrl_checkDsn(c, u) { return !!u && c.includes(u.host) }(c, d) || function isSentryRequestUrl_checkTunnel(c, u) { if (!u) return !1; return isSentryRequestUrl_removeTrailingSlash(c) === isSentryRequestUrl_removeTrailingSlash(u) }(c, v) } function isSentryRequestUrl_removeTrailingSlash(c) { return "/" === c[c.length - 1] ? c.slice(0, -1) : c } function parseSampleRate_parseSampleRate(c) { if ("boolean" == typeof c) return Number(c); const u = "string" == typeof c ? parseFloat(c) : c; if (!("number" != typeof u || isNaN(u) || u < 0 || u > 1)) return u; ir && Yn.warn(`[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(c)} of type ${JSON.stringify(typeof c)}.`) } function esm_dsn_dsnToString(c, u = !1) { const { "host": d, "path": v, "pass": E, "port": k, "projectId": R, "protocol": U, "publicKey": H } = c; return `${U}://${H}${u && E ? `:${E}` : ""}@${d}${k ? `:${k}` : ""}/${v ? `${v}/` : v}${R}` } const br = 6e4; function ratelimit_updateRateLimits(c, { "statusCode": u, "headers": d }, v = Date.now()) { const E = { ...c }, k = d && d["x-sentry-rate-limits"], R = d && d["retry-after"]; if (k) for (const c of k.trim().split(",")) { const [u, d, , , k] = c.split(":", 5), R = parseInt(u, 10), U = 1e3 * (isNaN(R) ? 60 : R); if (d) for (const c of d.split(";")) "metric_bucket" === c && k && !k.split(";").includes("custom") || (E[c] = v + U); else E.all = v + U } else R ? E.all = v + function ratelimit_parseRetryAfterHeader(c, u = Date.now()) { const d = parseInt(`${c}`, 10); if (!isNaN(d)) return 1e3 * d; const v = Date.parse(`${c}`); return isNaN(v) ? br : v - u }(R, v) : 429 === u && (E.all = v + 6e4); return E } function isNodeEnv() { return !function env_isBrowserBundle() { return "undefined" != typeof __SENTRY_BROWSER_BUNDLE__ && !!__SENTRY_BROWSER_BUNDLE__ }() && "[object process]" === Object.prototype.toString.call("undefined" != typeof process ? process : 0) } function isBrowser() { return "undefined" != typeof window && (!isNodeEnv() || function isElectronNodeRenderer() { return void 0 !== Un.process && "renderer" === Un.process.type }()) } const bindReporter = (c, u, d, v) => { let E, k; return R => { u.value >= 0 && (R || v) && (k = u.value - (E || 0), (k || void 0 === E) && (E = u.value, u.delta = k, u.rating = ((c, u) => c > u[1] ? "poor" : c > u[0] ? "needs-improvement" : "good")(u.value, d), c(u))) } }, getNavigationEntry = () => ht.performance && performance.getEntriesByType && performance.getEntriesByType("navigation")[0], getActivationStart = () => { const c = getNavigationEntry(); return c && c.activationStart || 0 }, initMetric = (c, u) => { const d = getNavigationEntry(); let v = "navigate"; d && (ht.document && ht.document.prerendering || getActivationStart() > 0 ? v = "prerender" : ht.document && ht.document.wasDiscarded ? v = "restore" : d.type && (v = d.type.replace(/_/g, "-"))); return { "name": c, "value": void 0 === u ? -1 : u, "rating": "good", "delta": 0, "entries": [], "id": `v3-${Date.now()}-${Math.floor(8999999999999 * Math.random()) + 1e12}`, "navigationType": v } }, observe = (c, u, d) => { try { if (PerformanceObserver.supportedEntryTypes.includes(c)) { const v = new PerformanceObserver((c => { Promise.resolve().then((() => { u(c.getEntries()) })) })); return v.observe(Object.assign({ "type": c, "buffered": !0 }, d || {})), v } } catch (c) { } }, onHidden = c => { const onHiddenOrPageHide = u => { ("pagehide" === u.type || ht.document && "hidden" === ht.document.visibilityState) && c(u) }; ht.document && (addEventListener("visibilitychange", onHiddenOrPageHide, !0), addEventListener("pagehide", onHiddenOrPageHide, !0)) }, runOnce = c => { let u = !1; return d => { u || (c(d), u = !0) } }; let Sr = -1; const onVisibilityUpdate = c => { "hidden" === ht.document.visibilityState && Sr > -1 && (Sr = "visibilitychange" === c.type ? c.timeStamp : 0, removeEventListener("visibilitychange", onVisibilityUpdate, !0), removeEventListener("prerenderingchange", onVisibilityUpdate, !0)) }, getVisibilityWatcher = () => (ht.document && Sr < 0 && (Sr = "hidden" !== ht.document.visibilityState || ht.document.prerendering ? 1 / 0 : 0, addEventListener("visibilitychange", onVisibilityUpdate, !0), addEventListener("prerenderingchange", onVisibilityUpdate, !0)), { get "firstHiddenTime"() { return Sr } }), whenActivated = c => { ht.document && ht.document.prerendering ? addEventListener("prerenderingchange", (() => c()), !0) : c() }, wr = [1800, 3e3], Er = [.1, .25], onCLS = (c, u = {}) => { ((c, u = {}) => { whenActivated((() => { const d = getVisibilityWatcher(), v = initMetric("FCP"); let E; const k = observe("paint", (c => { c.forEach((c => { "first-contentful-paint" === c.name && (k.disconnect(), c.startTime < d.firstHiddenTime && (v.value = Math.max(c.startTime - getActivationStart(), 0), v.entries.push(c), E(!0))) })) })); k && (E = bindReporter(c, v, wr, u.reportAllChanges)) })) })(runOnce((() => { const d = initMetric("CLS", 0); let v, E = 0, k = []; const handleEntries = c => { c.forEach((c => { if (!c.hadRecentInput) { const u = k[0], d = k[k.length - 1]; E && u && d && c.startTime - d.startTime < 1e3 && c.startTime - u.startTime < 5e3 ? (E += c.value, k.push(c)) : (E = c.value, k = [c]) } })), E > d.value && (d.value = E, d.entries = k, v()) }, R = observe("layout-shift", handleEntries); R && (v = bindReporter(c, d, Er, u.reportAllChanges), onHidden((() => { handleEntries(R.takeRecords()), v(!0) })), setTimeout(v, 0)) }))) }, Cr = [100, 300], onFID = (c, u = {}) => { whenActivated((() => { const d = getVisibilityWatcher(), v = initMetric("FID"); let E; const handleEntry = c => { c.startTime < d.firstHiddenTime && (v.value = c.processingStart - c.startTime, v.entries.push(c), E(!0)) }, handleEntries = c => { c.forEach(handleEntry) }, k = observe("first-input", handleEntries); E = bindReporter(c, v, Cr, u.reportAllChanges), k && onHidden(runOnce((() => { handleEntries(k.takeRecords()), k.disconnect() }))) })) }; let Tr = 0, xr = 1 / 0, Ar = 0; const updateEstimate = c => { c.forEach((c => { c.interactionId && (xr = Math.min(xr, c.interactionId), Ar = Math.max(Ar, c.interactionId), Tr = Ar ? (Ar - xr) / 7 + 1 : 0) })) }; let Ir; const initInteractionCountPolyfill = () => { "interactionCount" in performance || Ir || (Ir = observe("event", updateEstimate, { "type": "event", "buffered": !0, "durationThreshold": 0 })) }, kr = [200, 500], getInteractionCountForNavigation = () => (Ir ? Tr : performance.interactionCount || 0) - 0, Or = [], Pr = {}, processEntry = c => { const u = Or[Or.length - 1], d = Pr[c.interactionId]; if (d || Or.length < 10 || u && c.duration > u.latency) { if (d) d.entries.push(c), d.latency = Math.max(d.latency, c.duration); else { const u = { "id": c.interactionId, "latency": c.duration, "entries": [c] }; Pr[u.id] = u, Or.push(u) } Or.sort(((c, u) => u.latency - c.latency)), Or.splice(10).forEach((c => { delete Pr[c.id] })) } }, onINP = (c, u = {}) => { whenActivated((() => { initInteractionCountPolyfill(); const d = initMetric("INP"); let v; const handleEntries = c => { c.forEach((c => { if (c.interactionId && processEntry(c), "first-input" === c.entryType) { !Or.some((u => u.entries.some((u => c.duration === u.duration && c.startTime === u.startTime)))) && processEntry(c) } })); const u = (() => { const c = Math.min(Or.length - 1, Math.floor(getInteractionCountForNavigation() / 50)); return Or[c] })(); u && u.latency !== d.value && (d.value = u.latency, d.entries = u.entries, v()) }, E = observe("event", handleEntries, { "durationThreshold": null != u.durationThreshold ? u.durationThreshold : 40 }); v = bindReporter(c, d, kr, u.reportAllChanges), E && ("PerformanceEventTiming" in ht && "interactionId" in PerformanceEventTiming.prototype && E.observe({ "type": "first-input", "buffered": !0 }), onHidden((() => { handleEntries(E.takeRecords()), d.value < 0 && getInteractionCountForNavigation() > 0 && (d.value = 0, d.entries = []), v(!0) }))) })) }, Rr = [2500, 4e3], Mr = {}, onLCP = (c, u = {}) => { whenActivated((() => { const d = getVisibilityWatcher(), v = initMetric("LCP"); let E; const handleEntries = c => { const u = c[c.length - 1]; u && u.startTime < d.firstHiddenTime && (v.value = Math.max(u.startTime - getActivationStart(), 0), v.entries = [u], E()) }, k = observe("largest-contentful-paint", handleEntries); if (k) { E = bindReporter(c, v, Rr, u.reportAllChanges); const d = runOnce((() => { Mr[v.id] || (handleEntries(k.takeRecords()), k.disconnect(), Mr[v.id] = !0, E(!0)) }));["keydown", "click"].forEach((c => { ht.document && addEventListener(c, (() => setTimeout(d, 0)), !0) })), onHidden(d) } })) }, Nr = [800, 1800], whenReady = c => { ht.document && ht.document.prerendering ? whenActivated((() => whenReady(c))) : ht.document && "complete" !== ht.document.readyState ? addEventListener("load", (() => whenReady(c)), !0) : setTimeout(c, 0) }, onTTFB = (c, u = {}) => { const d = initMetric("TTFB"), v = bindReporter(c, d, Nr, u.reportAllChanges); whenReady((() => { const c = getNavigationEntry(); if (c) { const u = c.responseStart; if (u <= 0 || u > performance.now()) return; d.value = Math.max(u - getActivationStart(), 0), d.entries = [c], v(!0) } })) }, Dr = {}, $r = {}; let Lr, Fr, jr, Br, Ur; function addClsInstrumentationHandler(c, u = !1) { return addMetricObserver("cls", c, instrumentCls, Lr, u) } function addLcpInstrumentationHandler(c, u = !1) { return addMetricObserver("lcp", c, instrumentLcp, jr, u) } function addFidInstrumentationHandler(c) { return addMetricObserver("fid", c, instrumentFid, Fr) } function addInpInstrumentationHandler(c) { return addMetricObserver("inp", c, instrumentInp, Ur) } function addPerformanceInstrumentationHandler(c, u) { return instrument_addHandler(c, u), $r[c] || (!function instrumentPerformanceObserver(c) { const u = {}; "event" === c && (u.durationThreshold = 0); observe(c, (u => { instrument_triggerHandlers(c, { "entries": u }) }), u) }(c), $r[c] = !0), getCleanupCallback(c, u) } function instrument_triggerHandlers(c, u) { const d = Dr[c]; if (d && d.length) for (const v of d) try { v(u) } catch (u) { en && ct.error(`Error while triggering instrumentation handler.\nType: ${c}\nName: ${stacktrace_getFunctionName(v)}\nError:`, u) } } function instrumentCls() { return onCLS((c => { instrument_triggerHandlers("cls", { "metric": c }), Lr = c }), { "reportAllChanges": !0 }) } function instrumentFid() { return onFID((c => { instrument_triggerHandlers("fid", { "metric": c }), Fr = c })) } function instrumentLcp() { return onLCP((c => { instrument_triggerHandlers("lcp", { "metric": c }), jr = c }), { "reportAllChanges": !0 }) } function instrumentTtfb() { return onTTFB((c => { instrument_triggerHandlers("ttfb", { "metric": c }), Br = c })) } function instrumentInp() { return onINP((c => { instrument_triggerHandlers("inp", { "metric": c }), Ur = c })) } function addMetricObserver(c, u, d, v, E = !1) { let k; return instrument_addHandler(c, u), $r[c] || (k = d(), $r[c] = !0), v && u({ "metric": v }), getCleanupCallback(c, u, E ? k : void 0) } function instrument_addHandler(c, u) { Dr[c] = Dr[c] || [], Dr[c].push(u) } function getCleanupCallback(c, u, d) { return () => { d && d(); const v = Dr[c]; if (!v) return; const E = v.indexOf(u); -1 !== E && v.splice(E, 1) } } const Hr = Un, zr = "sentryReplaySession", qr = "replay_event", Gr = "Unable to send Replay", Vr = 15e4, Wr = 5e3, Zr = 2e7, Yr = 36e5; function _nullishCoalesce$1(c, u) { return null != c ? c : u() } function _optionalChain$5(c) { let u, d = c[0], v = 1; for (; v < c.length;) { const E = c[v], k = c[v + 1]; if (v += 2, ("optionalAccess" === E || "optionalCall" === E) && null == d) return; "access" === E || "optionalAccess" === E ? (u = d, d = k(d)) : "call" !== E && "optionalCall" !== E || (d = k(((...c) => d.call(u, ...c))), u = void 0) } return d } var Jr; function isShadowRoot(c) { const u = _optionalChain$5([c, "optionalAccess", c => c.host]); return Boolean(_optionalChain$5([u, "optionalAccess", c => c.shadowRoot]) === c) } function isNativeShadowDom(c) { return "[object ShadowRoot]" === Object.prototype.toString.call(c) } function stringifyStylesheet(c) { try { const u = c.rules || c.cssRules; return u ? function fixBrowserCompatibilityIssuesInCSS(c) { return c.includes(" background-clip: text;") && !c.includes(" -webkit-background-clip: text;") && (c = c.replace(" background-clip: text;", " -webkit-background-clip: text; background-clip: text;")), c }(Array.from(u, stringifyRule).join("")) : null } catch (c) { return null } } function stringifyRule(c) { let u; if (function isCSSImportRule(c) { return "styleSheet" in c }(c)) try { u = stringifyStylesheet(c.styleSheet) || function escapeImportStatement(c) { const { "cssText": u } = c; if (u.split('"').length < 3) return u; const d = ["@import", `url(${JSON.stringify(c.href)})`]; return "" === c.layerName ? d.push("layer") : c.layerName && d.push(`layer(${c.layerName})`), c.supportsText && d.push(`supports(${c.supportsText})`), c.media.length && d.push(c.media.mediaText), d.join(" ") + ";" }(c) } catch (c) { } else if (function isCSSStyleRule(c) { return "selectorText" in c }(c) && c.selectorText.includes(":")) return function fixSafariColons(c) { const u = /(\[(?:[\w-]+)[^\\])(:(?:[\w-]+)\])/gm; return c.replace(u, "$1\\$2") }(c.cssText); return u || c.cssText } !function (c) { c[c.Document = 0] = "Document", c[c.DocumentType = 1] = "DocumentType", c[c.Element = 2] = "Element", c[c.Text = 3] = "Text", c[c.CDATA = 4] = "CDATA", c[c.Comment = 5] = "Comment" }(Jr || (Jr = {})); class Mirror { "constructor"() { this.idNodeMap = new Map, this.nodeMetaMap = new WeakMap } "getId"(c) { if (!c) return -1; return _nullishCoalesce$1(_optionalChain$5([this, "access", c => c.getMeta, "call", u => u(c), "optionalAccess", c => c.id]), (() => -1)) } "getNode"(c) { return this.idNodeMap.get(c) || null } "getIds"() { return Array.from(this.idNodeMap.keys()) } "getMeta"(c) { return this.nodeMetaMap.get(c) || null } "removeNodeFromMap"(c) { const u = this.getId(c); this.idNodeMap.delete(u), c.childNodes && c.childNodes.forEach((c => this.removeNodeFromMap(c))) } "has"(c) { return this.idNodeMap.has(c) } "hasNode"(c) { return this.nodeMetaMap.has(c) } "add"(c, u) { const d = u.id; this.idNodeMap.set(d, c), this.nodeMetaMap.set(c, u) } "replace"(c, u) { const d = this.getNode(c); if (d) { const c = this.nodeMetaMap.get(d); c && this.nodeMetaMap.set(u, c) } this.idNodeMap.set(c, u) } "reset"() { this.idNodeMap = new Map, this.nodeMetaMap = new WeakMap } } function shouldMaskInput({ "maskInputOptions": c, "tagName": u, "type": d }) { return "OPTION" === u && (u = "SELECT"), Boolean(c[u.toLowerCase()] || d && c[d] || "password" === d || "INPUT" === u && !d && c.text) } function maskInputValue({ "isMasked": c, "element": u, "value": d, "maskInputFn": v }) { let E = d || ""; return c ? (v && (E = v(E, u)), "*".repeat(E.length)) : E } function toLowerCase(c) { return c.toLowerCase() } function toUpperCase(c) { return c.toUpperCase() } const Kr = "__rrweb_original__"; function getInputType(c) { const u = c.type; return c.hasAttribute("data-rr-is-password") ? "password" : u ? toLowerCase(u) : null } function getInputValue(c, u, d) { return "INPUT" !== u || "radio" !== d && "checkbox" !== d ? c.value : c.getAttribute("value") || "" } function extractFileExtension(c, u) { let d; try { d = new URL(c, _nullishCoalesce$1(u, (() => window.location.href))) } catch (c) { return null } return _nullishCoalesce$1(_optionalChain$5([d.pathname.match(/\.([0-9a-z]+)(?:$)/i), "optionalAccess", c => c[1]]), (() => null)) } const Xr = {}; function getImplementation$1(c) { const u = Xr[c]; if (u) return u; const d = window.document; let v = window[c]; if (d && "function" == typeof d.createElement) try { const u = d.createElement("iframe"); u.hidden = !0, d.head.appendChild(u); const E = u.contentWindow; E && E[c] && (v = E[c]), d.head.removeChild(u) } catch (c) { } return Xr[c] = v.bind(window) } function setTimeout$2(...c) { return getImplementation$1("setTimeout")(...c) } function clearTimeout$2(...c) { return getImplementation$1("clearTimeout")(...c) } let Qr = 1; const eo = new RegExp("[^a-z0-9-_:]"), to = -2; function genId() { return Qr++ } let no, ro; const oo = /url\((?:(')([^']*)'|(")(.*?)"|([^)]*))\)/gm, io = /^(?:[a-z+]+:)?\/\//i, ao = /^www\..*/i, so = /^(data:)([^,]*),(.*)/i; function absoluteToStylesheet(c, u) { return (c || "").replace(oo, ((c, d, v, E, k, R) => { const U = v || k || R, H = d || E || ""; if (!U) return c; if (io.test(U) || ao.test(U)) return `url(${H}${U}${H})`; if (so.test(U)) return `url(${H}${U}${H})`; if ("/" === U[0]) return `url(${H}${function extractOrigin(c) { let u = ""; return u = c.indexOf("//") > -1 ? c.split("/").slice(0, 3).join("/") : c.split("/")[0], u = u.split("?")[0], u }(u) + U}${H})`; const G = u.split("/"), W = U.split("/"); G.pop(); for (const c of W) "." !== c && (".." === c ? G.pop() : G.push(c)); return `url(${H}${G.join("/")}${H})` })) } const co = /^[^ \t\n\r\u000c]+/, lo = /^[, \t\n\r\u000c]+/; function absoluteToDoc(c, u) { if (!u || "" === u.trim()) return u; const d = c.createElement("a"); return d.href = u, d.href } function isSVGElement(c) { return Boolean("svg" === c.tagName || c.ownerSVGElement) } function getHref() { const c = document.createElement("a"); return c.href = "", c.href } function transformAttribute(c, u, d, v, E, k) { return v ? "src" === d || "href" === d && ("use" !== u || "#" !== v[0]) || "xlink:href" === d && "#" !== v[0] ? absoluteToDoc(c, v) : "background" !== d || "table" !== u && "td" !== u && "th" !== u ? "srcset" === d ? function getAbsoluteSrcsetString(c, u) { if ("" === u.trim()) return u; let d = 0; function collectCharacters(c) { let v; const E = c.exec(u.substring(d)); return E ? (v = E[0], d += v.length, v) : "" } const v = []; for (; collectCharacters(lo), !(d >= u.length);) { let E = collectCharacters(co); if ("," === E.slice(-1)) E = absoluteToDoc(c, E.substring(0, E.length - 1)), v.push(E); else { let k = ""; E = absoluteToDoc(c, E); let R = !1; for (; ;) { const c = u.charAt(d); if ("" === c) { v.push((E + k).trim()); break } if (R) ")" === c && (R = !1); else { if ("," === c) { d += 1, v.push((E + k).trim()); break } "(" === c && (R = !0) } k += c, d += 1 } } } return v.join(", ") }(c, v) : "style" === d ? absoluteToStylesheet(v, getHref()) : "object" === u && "data" === d ? absoluteToDoc(c, v) : "function" == typeof k ? k(d, v, E) : v : absoluteToDoc(c, v) : v } function ignoreAttribute(c, u, d) { return ("video" === c || "audio" === c) && "autoplay" === u } function distanceToMatch(c, u, d = 1 / 0, v = 0) { return c ? c.nodeType !== c.ELEMENT_NODE || v > d ? -1 : u(c) ? v : distanceToMatch(c.parentNode, u, d, v + 1) : -1 } function createMatchPredicate(c, u) { return d => { const v = d; if (null === v) return !1; try { if (c) if ("string" == typeof c) { if (v.matches(`.${c}`)) return !0 } else if (function elementClassMatchesRegex(c, u) { for (let d = c.classList.length; d--;) { const v = c.classList[d]; if (u.test(v)) return !0 } return !1 }(v, c)) return !0; return !(!u || !v.matches(u)) } catch (c) { return !1 } } } function needMaskingText(c, u, d, v, E, k) { try { const R = c.nodeType === c.ELEMENT_NODE ? c : c.parentElement; if (null === R) return !1; if ("INPUT" === R.tagName) { const c = R.getAttribute("autocomplete"); if (["current-password", "new-password", "cc-number", "cc-exp", "cc-exp-month", "cc-exp-year", "cc-csc"].includes(c)) return !0 } let U = -1, H = -1; if (k) { if (H = distanceToMatch(R, createMatchPredicate(v, E)), H < 0) return !0; U = distanceToMatch(R, createMatchPredicate(u, d), H >= 0 ? H : 1 / 0) } else { if (U = distanceToMatch(R, createMatchPredicate(u, d)), U < 0) return !1; H = distanceToMatch(R, createMatchPredicate(v, E), U >= 0 ? U : 1 / 0) } return U >= 0 ? !(H >= 0) || U <= H : !(H >= 0) && !!k } catch (c) { } return !!k } function serializeNode(c, u) { const { "doc": d, "mirror": v, "blockClass": E, "blockSelector": k, "unblockSelector": R, "maskAllText": U, "maskAttributeFn": H, "maskTextClass": G, "unmaskTextClass": W, "maskTextSelector": Z, "unmaskTextSelector": Y, "inlineStylesheet": J, "maskInputOptions": K = {}, "maskTextFn": X, "maskInputFn": Q, "dataURLOptions": ee = {}, "inlineImages": te, "recordCanvas": ne, "keepIframeSrcFn": re, "newlyAddedElement": oe = !1 } = u, ie = function getRootId(c, u) { if (!u.hasNode(c)) return; const d = u.getId(c); return 1 === d ? void 0 : d }(d, v); switch (c.nodeType) { case c.DOCUMENT_NODE: return "CSS1Compat" !== c.compatMode ? { "type": Jr.Document, "childNodes": [], "compatMode": c.compatMode } : { "type": Jr.Document, "childNodes": [] }; case c.DOCUMENT_TYPE_NODE: return { "type": Jr.DocumentType, "name": c.name, "publicId": c.publicId, "systemId": c.systemId, "rootId": ie }; case c.ELEMENT_NODE: return function serializeElementNode(c, u) { const { "doc": d, "blockClass": v, "blockSelector": E, "unblockSelector": k, "inlineStylesheet": R, "maskInputOptions": U = {}, "maskAttributeFn": H, "maskInputFn": G, "dataURLOptions": W = {}, "inlineImages": Z, "recordCanvas": Y, "keepIframeSrcFn": J, "newlyAddedElement": K = !1, "rootId": X, "maskAllText": Q, "maskTextClass": ee, "unmaskTextClass": te, "maskTextSelector": ne, "unmaskTextSelector": re } = u, oe = function _isBlockedElement(c, u, d, v) { try { if (v && c.matches(v)) return !1; if ("string" == typeof u) { if (c.classList.contains(u)) return !0 } else for (let d = c.classList.length; d--;) { const v = c.classList[d]; if (u.test(v)) return !0 } if (d) return c.matches(d) } catch (c) { } return !1 }(c, v, E, k), ie = function getValidTagName(c) { if (c instanceof HTMLFormElement) return "form"; const u = toLowerCase(c.tagName); return eo.test(u) ? "div" : u }(c); let ae = {}; const se = c.attributes.length; for (let u = 0; u < se; u++) { const v = c.attributes[u]; v.name && !ignoreAttribute(ie, v.name, v.value) && (ae[v.name] = transformAttribute(d, ie, toLowerCase(v.name), v.value, c, H)) } if ("link" === ie && R) { const u = Array.from(d.styleSheets).find((u => u.href === c.href)); let v = null; u && (v = stringifyStylesheet(u)), v && (delete ae.rel, delete ae.href, ae._cssText = absoluteToStylesheet(v, u.href)) } if ("style" === ie && c.sheet && !(c.innerText || c.textContent || "").trim().length) { const u = stringifyStylesheet(c.sheet); u && (ae._cssText = absoluteToStylesheet(u, getHref())) } if ("input" === ie || "textarea" === ie || "select" === ie || "option" === ie) { const u = c, d = getInputType(u), v = getInputValue(u, toUpperCase(ie), d), E = u.checked; if ("submit" !== d && "button" !== d && v) { const c = needMaskingText(u, ee, ne, te, re, shouldMaskInput({ "type": d, "tagName": toUpperCase(ie), "maskInputOptions": U })); ae.value = maskInputValue({ "isMasked": c, "element": u, "value": v, "maskInputFn": G }) } E && (ae.checked = E) } "option" === ie && (c.selected && !U.select ? ae.selected = !0 : delete ae.selected); if ("canvas" === ie && Y) if ("2d" === c.__context) (function is2DCanvasBlank(c) { const u = c.getContext("2d"); if (!u) return !0; for (let d = 0; d < c.width; d += 50)for (let v = 0; v < c.height; v += 50) { const E = u.getImageData, k = Kr in E ? E[Kr] : E; if (new Uint32Array(k.call(u, d, v, Math.min(50, c.width - d), Math.min(50, c.height - v)).data.buffer).some((c => 0 !== c))) return !1 } return !0 })(c) || (ae.rr_dataURL = c.toDataURL(W.type, W.quality)); else if (!("__context" in c)) { const u = c.toDataURL(W.type, W.quality), d = document.createElement("canvas"); d.width = c.width, d.height = c.height; u !== d.toDataURL(W.type, W.quality) && (ae.rr_dataURL = u) } if ("img" === ie && Z) { no || (no = d.createElement("canvas"), ro = no.getContext("2d")); const u = c, v = u.crossOrigin; u.crossOrigin = "anonymous"; const recordInlineImage = () => { u.removeEventListener("load", recordInlineImage); try { no.width = u.naturalWidth, no.height = u.naturalHeight, ro.drawImage(u, 0, 0), ae.rr_dataURL = no.toDataURL(W.type, W.quality) } catch (c) { console.warn(`Cannot inline img src=${u.currentSrc}! Error: ${c}`) } v ? ae.crossOrigin = v : u.removeAttribute("crossorigin") }; u.complete && 0 !== u.naturalWidth ? recordInlineImage() : u.addEventListener("load", recordInlineImage) } "audio" !== ie && "video" !== ie || (ae.rr_mediaState = c.paused ? "paused" : "played", ae.rr_mediaCurrentTime = c.currentTime); K || (c.scrollLeft && (ae.rr_scrollLeft = c.scrollLeft), c.scrollTop && (ae.rr_scrollTop = c.scrollTop)); if (oe) { const { "width": u, "height": d } = c.getBoundingClientRect(); ae = { "class": ae.class, "rr_width": `${u}px`, "rr_height": `${d}px` } } "iframe" !== ie || J(ae.src) || (oe || c.contentDocument || (ae.rr_src = ae.src), delete ae.src); let ce; try { customElements.get(ie) && (ce = !0) } catch (c) { } return { "type": Jr.Element, "tagName": ie, "attributes": ae, "childNodes": [], "isSVG": isSVGElement(c) || void 0, "needBlock": oe, "rootId": X, "isCustom": ce } }(c, { "doc": d, "blockClass": E, "blockSelector": k, "unblockSelector": R, "inlineStylesheet": J, "maskAttributeFn": H, "maskInputOptions": K, "maskInputFn": Q, "dataURLOptions": ee, "inlineImages": te, "recordCanvas": ne, "keepIframeSrcFn": re, "newlyAddedElement": oe, "rootId": ie, "maskAllText": U, "maskTextClass": G, "unmaskTextClass": W, "maskTextSelector": Z, "unmaskTextSelector": Y }); case c.TEXT_NODE: return function serializeTextNode(c, u) { const { "maskAllText": d, "maskTextClass": v, "unmaskTextClass": E, "maskTextSelector": k, "unmaskTextSelector": R, "maskTextFn": U, "maskInputOptions": H, "maskInputFn": G, "rootId": W } = u, Z = c.parentNode && c.parentNode.tagName; let Y = c.textContent; const J = "STYLE" === Z || void 0, K = "SCRIPT" === Z || void 0, X = "TEXTAREA" === Z || void 0; if (J && Y) { try { c.nextSibling || c.previousSibling || _optionalChain$5([c, "access", c => c.parentNode, "access", c => c.sheet, "optionalAccess", c => c.cssRules]) && (Y = stringifyStylesheet(c.parentNode.sheet)) } catch (u) { console.warn(`Cannot get CSS styles from text's parentNode. Error: ${u}`, c) } Y = absoluteToStylesheet(Y, getHref()) } K && (Y = "SCRIPT_PLACEHOLDER"); const Q = needMaskingText(c, v, k, E, R, d); J || K || X || !Y || !Q || (Y = U ? U(Y, c.parentElement) : Y.replace(/[\S]/g, "*")); X && Y && (H.textarea || Q) && (Y = G ? G(Y, c.parentNode) : Y.replace(/[\S]/g, "*")); if ("OPTION" === Z && Y) { Y = maskInputValue({ "isMasked": needMaskingText(c, v, k, E, R, shouldMaskInput({ "type": null, "tagName": Z, "maskInputOptions": H })), "element": c, "value": Y, "maskInputFn": G }) } return { "type": Jr.Text, "textContent": Y || "", "isStyle": J, "rootId": W } }(c, { "maskAllText": U, "maskTextClass": G, "unmaskTextClass": W, "maskTextSelector": Z, "unmaskTextSelector": Y, "maskTextFn": X, "maskInputOptions": K, "maskInputFn": Q, "rootId": ie }); case c.CDATA_SECTION_NODE: return { "type": Jr.CDATA, "textContent": "", "rootId": ie }; case c.COMMENT_NODE: return { "type": Jr.Comment, "textContent": c.textContent || "", "rootId": ie }; default: return !1 } } function lowerIfExists(c) { return null == c ? "" : c.toLowerCase() } function serializeNodeWithId(c, u) { const { "doc": d, "mirror": v, "blockClass": E, "blockSelector": k, "unblockSelector": R, "maskAllText": U, "maskTextClass": H, "unmaskTextClass": G, "maskTextSelector": W, "unmaskTextSelector": Z, "skipChild": Y = !1, "inlineStylesheet": J = !0, "maskInputOptions": K = {}, "maskAttributeFn": X, "maskTextFn": Q, "maskInputFn": ee, "slimDOMOptions": te, "dataURLOptions": ne = {}, "inlineImages": re = !1, "recordCanvas": oe = !1, "onSerialize": ie, "onIframeLoad": ae, "iframeLoadTimeout": se = 5e3, "onStylesheetLoad": ce, "stylesheetLoadTimeout": le = 5e3, "keepIframeSrcFn": ue = (() => !1), "newlyAddedElement": de = !1 } = u; let { "preserveWhiteSpace": pe = !0 } = u; const fe = serializeNode(c, { "doc": d, "mirror": v, "blockClass": E, "blockSelector": k, "maskAllText": U, "unblockSelector": R, "maskTextClass": H, "unmaskTextClass": G, "maskTextSelector": W, "unmaskTextSelector": Z, "inlineStylesheet": J, "maskInputOptions": K, "maskAttributeFn": X, "maskTextFn": Q, "maskInputFn": ee, "dataURLOptions": ne, "inlineImages": re, "recordCanvas": oe, "keepIframeSrcFn": ue, "newlyAddedElement": de }); if (!fe) return console.warn(c, "not serialized"), null; let he; he = v.hasNode(c) ? v.getId(c) : !function slimDOMExcluded(c, u) { if (u.comment && c.type === Jr.Comment) return !0; if (c.type === Jr.Element) { if (u.script && ("script" === c.tagName || "link" === c.tagName && ("preload" === c.attributes.rel || "modulepreload" === c.attributes.rel) && "script" === c.attributes.as || "link" === c.tagName && "prefetch" === c.attributes.rel && "string" == typeof c.attributes.href && "js" === extractFileExtension(c.attributes.href))) return !0; if (u.headFavicon && ("link" === c.tagName && "shortcut icon" === c.attributes.rel || "meta" === c.tagName && (lowerIfExists(c.attributes.name).match(/^msapplication-tile(image|color)$/) || "application-name" === lowerIfExists(c.attributes.name) || "icon" === lowerIfExists(c.attributes.rel) || "apple-touch-icon" === lowerIfExists(c.attributes.rel) || "shortcut icon" === lowerIfExists(c.attributes.rel)))) return !0; if ("meta" === c.tagName) { if (u.headMetaDescKeywords && lowerIfExists(c.attributes.name).match(/^description|keywords$/)) return !0; if (u.headMetaSocial && (lowerIfExists(c.attributes.property).match(/^(og|twitter|fb):/) || lowerIfExists(c.attributes.name).match(/^(og|twitter):/) || "pinterest" === lowerIfExists(c.attributes.name))) return !0; if (u.headMetaRobots && ("robots" === lowerIfExists(c.attributes.name) || "googlebot" === lowerIfExists(c.attributes.name) || "bingbot" === lowerIfExists(c.attributes.name))) return !0; if (u.headMetaHttpEquiv && void 0 !== c.attributes["http-equiv"]) return !0; if (u.headMetaAuthorship && ("author" === lowerIfExists(c.attributes.name) || "generator" === lowerIfExists(c.attributes.name) || "framework" === lowerIfExists(c.attributes.name) || "publisher" === lowerIfExists(c.attributes.name) || "progid" === lowerIfExists(c.attributes.name) || lowerIfExists(c.attributes.property).match(/^article:/) || lowerIfExists(c.attributes.property).match(/^product:/))) return !0; if (u.headMetaVerification && ("google-site-verification" === lowerIfExists(c.attributes.name) || "yandex-verification" === lowerIfExists(c.attributes.name) || "csrf-token" === lowerIfExists(c.attributes.name) || "p:domain_verify" === lowerIfExists(c.attributes.name) || "verify-v1" === lowerIfExists(c.attributes.name) || "verification" === lowerIfExists(c.attributes.name) || "shopify-checkout-api-token" === lowerIfExists(c.attributes.name))) return !0 } } return !1 }(fe, te) && (pe || fe.type !== Jr.Text || fe.isStyle || fe.textContent.replace(/^\s+|\s+$/gm, "").length) ? genId() : to; const me = Object.assign(fe, { "id": he }); if (v.add(c, me), he === to) return null; ie && ie(c); let ge = !Y; if (me.type === Jr.Element) { ge = ge && !me.needBlock, delete me.needBlock; const u = c.shadowRoot; u && isNativeShadowDom(u) && (me.isShadowHost = !0) } if ((me.type === Jr.Document || me.type === Jr.Element) && ge) { te.headWhitespace && me.type === Jr.Element && "head" === me.tagName && (pe = !1); const u = { "doc": d, "mirror": v, "blockClass": E, "blockSelector": k, "maskAllText": U, "unblockSelector": R, "maskTextClass": H, "unmaskTextClass": G, "maskTextSelector": W, "unmaskTextSelector": Z, "skipChild": Y, "inlineStylesheet": J, "maskInputOptions": K, "maskAttributeFn": X, "maskTextFn": Q, "maskInputFn": ee, "slimDOMOptions": te, "dataURLOptions": ne, "inlineImages": re, "recordCanvas": oe, "preserveWhiteSpace": pe, "onSerialize": ie, "onIframeLoad": ae, "iframeLoadTimeout": se, "onStylesheetLoad": ce, "stylesheetLoadTimeout": le, "keepIframeSrcFn": ue }; for (const d of Array.from(c.childNodes)) { const c = serializeNodeWithId(d, u); c && me.childNodes.push(c) } if (function isElement$1(c) { return c.nodeType === c.ELEMENT_NODE }(c) && c.shadowRoot) for (const d of Array.from(c.shadowRoot.childNodes)) { const v = serializeNodeWithId(d, u); v && (isNativeShadowDom(c.shadowRoot) && (v.isShadow = !0), me.childNodes.push(v)) } } return c.parentNode && isShadowRoot(c.parentNode) && isNativeShadowDom(c.parentNode) && (me.isShadow = !0), me.type === Jr.Element && "iframe" === me.tagName && function onceIframeLoaded(c, u, d) { const v = c.contentWindow; if (!v) return; let E, k = !1; try { E = v.document.readyState } catch (c) { return } if ("complete" !== E) { const v = setTimeout$2((() => { k || (u(), k = !0) }), d); return void c.addEventListener("load", (() => { clearTimeout$2(v), k = !0, u() })) } const R = "about:blank"; if (v.location.href !== R || c.src === R || "" === c.src) return setTimeout$2(u, 0), c.addEventListener("load", u); c.addEventListener("load", u) }(c, (() => { const u = c.contentDocument; if (u && ae) { const d = serializeNodeWithId(u, { "doc": u, "mirror": v, "blockClass": E, "blockSelector": k, "unblockSelector": R, "maskAllText": U, "maskTextClass": H, "unmaskTextClass": G, "maskTextSelector": W, "unmaskTextSelector": Z, "skipChild": !1, "inlineStylesheet": J, "maskInputOptions": K, "maskAttributeFn": X, "maskTextFn": Q, "maskInputFn": ee, "slimDOMOptions": te, "dataURLOptions": ne, "inlineImages": re, "recordCanvas": oe, "preserveWhiteSpace": pe, "onSerialize": ie, "onIframeLoad": ae, "iframeLoadTimeout": se, "onStylesheetLoad": ce, "stylesheetLoadTimeout": le, "keepIframeSrcFn": ue }); d && ae(c, d) } }), se), me.type === Jr.Element && "link" === me.tagName && "string" == typeof me.attributes.rel && ("stylesheet" === me.attributes.rel || "preload" === me.attributes.rel && "string" == typeof me.attributes.href && "css" === extractFileExtension(me.attributes.href)) && function onceStylesheetLoaded(c, u, d) { let v, E = !1; try { v = c.sheet } catch (c) { return } if (v) return; const k = setTimeout$2((() => { E || (u(), E = !0) }), d); c.addEventListener("load", (() => { clearTimeout$2(k), E = !0, u() })) }(c, (() => { if (ce) { const u = serializeNodeWithId(c, { "doc": d, "mirror": v, "blockClass": E, "blockSelector": k, "unblockSelector": R, "maskAllText": U, "maskTextClass": H, "unmaskTextClass": G, "maskTextSelector": W, "unmaskTextSelector": Z, "skipChild": !1, "inlineStylesheet": J, "maskInputOptions": K, "maskAttributeFn": X, "maskTextFn": Q, "maskInputFn": ee, "slimDOMOptions": te, "dataURLOptions": ne, "inlineImages": re, "recordCanvas": oe, "preserveWhiteSpace": pe, "onSerialize": ie, "onIframeLoad": ae, "iframeLoadTimeout": se, "onStylesheetLoad": ce, "stylesheetLoadTimeout": le, "keepIframeSrcFn": ue }); u && ce(c, u) } }), le), me } function _optionalChain$4(c) { let u, d = c[0], v = 1; for (; v < c.length;) { const E = c[v], k = c[v + 1]; if (v += 2, ("optionalAccess" === E || "optionalCall" === E) && null == d) return; "access" === E || "optionalAccess" === E ? (u = d, d = k(d)) : "call" !== E && "optionalCall" !== E || (d = k(((...c) => d.call(u, ...c))), u = void 0) } return d } function on(c, u, d = document) { const v = { "capture": !0, "passive": !0 }; return d.addEventListener(c, u, v), () => d.removeEventListener(c, u, v) } const uo = "Please stop import mirror directly. Instead of that,\r\nnow you can use replayer.getMirror() to access the mirror instance of a replayer,\r\nor you can use record.mirror to access the mirror instance during recording."; let po = { "map": {}, "getId"() { return console.error(uo), -1 }, "getNode"() { return console.error(uo), null }, "removeNodeFromMap"() { console.error(uo) }, "has"() { return console.error(uo), !1 }, "reset"() { console.error(uo) } }; function throttle$1(c, u, d = {}) { let v = null, E = 0; return function (...k) { const R = Date.now(); E || !1 !== d.leading || (E = R); const U = u - (R - E), H = this; U <= 0 || U > u ? (v && (!function clearTimeout$1(...c) { return getImplementation("clearTimeout")(...c) }(v), v = null), E = R, c.apply(H, k)) : v || !1 === d.trailing || (v = setTimeout$1((() => { E = !1 === d.leading ? 0 : Date.now(), v = null, c.apply(H, k) }), U)) } } function hookSetter(c, u, d, v, E = window) { const k = E.Object.getOwnPropertyDescriptor(c, u); return E.Object.defineProperty(c, u, v ? d : { "set"(c) { setTimeout$1((() => { d.set.call(this, c) }), 0), k && k.set && k.set.call(this, c) } }), () => hookSetter(c, u, k || {}, !0) } function patch(c, u, d) { try { if (!(u in c)) return () => { }; const v = c[u], E = d(v); return "function" == typeof E && (E.prototype = E.prototype || {}, Object.defineProperties(E, { "__rrweb_original__": { "enumerable": !1, "value": v } })), c[u] = E, () => { c[u] = v } } catch (c) { return () => { } } } "undefined" != typeof window && window.Proxy && window.Reflect && (po = new Proxy(po, { "get"(c, u, d) { return "map" === u && console.error(uo), Reflect.get(c, u, d) } })); let fo = Date.now; function getWindowScroll(c) { const u = c.document; return { "left": u.scrollingElement ? u.scrollingElement.scrollLeft : void 0 !== c.pageXOffset ? c.pageXOffset : _optionalChain$4([u, "optionalAccess", c => c.documentElement, "access", c => c.scrollLeft]) || _optionalChain$4([u, "optionalAccess", c => c.body, "optionalAccess", c => c.parentElement, "optionalAccess", c => c.scrollLeft]) || _optionalChain$4([u, "optionalAccess", c => c.body, "optionalAccess", c => c.scrollLeft]) || 0, "top": u.scrollingElement ? u.scrollingElement.scrollTop : void 0 !== c.pageYOffset ? c.pageYOffset : _optionalChain$4([u, "optionalAccess", c => c.documentElement, "access", c => c.scrollTop]) || _optionalChain$4([u, "optionalAccess", c => c.body, "optionalAccess", c => c.parentElement, "optionalAccess", c => c.scrollTop]) || _optionalChain$4([u, "optionalAccess", c => c.body, "optionalAccess", c => c.scrollTop]) || 0 } } function getWindowHeight() { return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight } function getWindowWidth() { return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth } function closestElementOfNode(c) { if (!c) return null; return c.nodeType === c.ELEMENT_NODE ? c : c.parentElement } function isBlocked(c, u, d, v, E) { if (!c) return !1; const k = closestElementOfNode(c); if (!k) return !1; const R = createMatchPredicate(u, d); if (!E) { const c = v && k.matches(v); return R(k) && !c } const U = distanceToMatch(k, R); let H = -1; return !(U < 0) && (v && (H = distanceToMatch(k, createMatchPredicate(null, v))), U > -1 && H < 0 || U < H) } function isIgnored(c, u) { return u.getId(c) === to } function isAncestorRemoved(c, u) { if (isShadowRoot(c)) return !1; const d = u.getId(c); return !u.has(d) || (!c.parentNode || c.parentNode.nodeType !== c.DOCUMENT_NODE) && (!c.parentNode || isAncestorRemoved(c.parentNode, u)) } function legacy_isTouchEvent(c) { return Boolean(c.changedTouches) } function isSerializedIframe(c, u) { return Boolean("IFRAME" === c.nodeName && u.getMeta(c)) } function isSerializedStylesheet(c, u) { return Boolean("LINK" === c.nodeName && c.nodeType === c.ELEMENT_NODE && c.getAttribute && "stylesheet" === c.getAttribute("rel") && u.getMeta(c)) } function hasShadowRoot(c) { return Boolean(_optionalChain$4([c, "optionalAccess", c => c.shadowRoot])) } /[1-9][0-9]{12}/.test(Date.now().toString()) || (fo = () => (new Date).getTime()); class StyleSheetMirror { "constructor"() { this.id = 1, this.styleIDMap = new WeakMap, this.idStyleMap = new Map } "getId"(c) { return function _nullishCoalesce(c, u) { return null != c ? c : u() }(this.styleIDMap.get(c), (() => -1)) } "has"(c) { return this.styleIDMap.has(c) } "add"(c, u) { if (this.has(c)) return this.getId(c); let d; return d = void 0 === u ? this.id++ : u, this.styleIDMap.set(c, d), this.idStyleMap.set(d, c), d } "getStyle"(c) { return this.idStyleMap.get(c) || null } "reset"() { this.styleIDMap = new WeakMap, this.idStyleMap = new Map, this.id = 1 } "generateId"() { return this.id++ } } function getShadowHost(c) { let u = null; return _optionalChain$4([c, "access", c => c.getRootNode, "optionalCall", c => c(), "optionalAccess", c => c.nodeType]) === Node.DOCUMENT_FRAGMENT_NODE && c.getRootNode().host && (u = c.getRootNode().host), u } function shadowHostInDom(c) { const u = c.ownerDocument; if (!u) return !1; const d = function getRootShadowHost(c) { let u, d = c; for (; u = getShadowHost(d);)d = u; return d }(c); return u.contains(d) } function inDom(c) { const u = c.ownerDocument; return !!u && (u.contains(c) || shadowHostInDom(c)) } const ho = {}; function getImplementation(c) { const u = ho[c]; if (u) return u; const d = window.document; let v = window[c]; if (d && "function" == typeof d.createElement) try { const u = d.createElement("iframe"); u.hidden = !0, d.head.appendChild(u); const E = u.contentWindow; E && E[c] && (v = E[c]), d.head.removeChild(u) } catch (c) { } return ho[c] = v.bind(window) } function setTimeout$1(...c) { return getImplementation("setTimeout")(...c) } var mo = (c => (c[c.DomContentLoaded = 0] = "DomContentLoaded", c[c.Load = 1] = "Load", c[c.FullSnapshot = 2] = "FullSnapshot", c[c.IncrementalSnapshot = 3] = "IncrementalSnapshot", c[c.Meta = 4] = "Meta", c[c.Custom = 5] = "Custom", c[c.Plugin = 6] = "Plugin", c))(mo || {}), _o = (c => (c[c.Mutation = 0] = "Mutation", c[c.MouseMove = 1] = "MouseMove", c[c.MouseInteraction = 2] = "MouseInteraction", c[c.Scroll = 3] = "Scroll", c[c.ViewportResize = 4] = "ViewportResize", c[c.Input = 5] = "Input", c[c.TouchMove = 6] = "TouchMove", c[c.MediaInteraction = 7] = "MediaInteraction", c[c.StyleSheetRule = 8] = "StyleSheetRule", c[c.CanvasMutation = 9] = "CanvasMutation", c[c.Font = 10] = "Font", c[c.Log = 11] = "Log", c[c.Drag = 12] = "Drag", c[c.StyleDeclaration = 13] = "StyleDeclaration", c[c.Selection = 14] = "Selection", c[c.AdoptedStyleSheet = 15] = "AdoptedStyleSheet", c[c.CustomElement = 16] = "CustomElement", c))(_o || {}), vo = (c => (c[c.MouseUp = 0] = "MouseUp", c[c.MouseDown = 1] = "MouseDown", c[c.Click = 2] = "Click", c[c.ContextMenu = 3] = "ContextMenu", c[c.DblClick = 4] = "DblClick", c[c.Focus = 5] = "Focus", c[c.Blur = 6] = "Blur", c[c.TouchStart = 7] = "TouchStart", c[c.TouchMove_Departed = 8] = "TouchMove_Departed", c[c.TouchEnd = 9] = "TouchEnd", c[c.TouchCancel = 10] = "TouchCancel", c))(vo || {}), yo = (c => (c[c.Mouse = 0] = "Mouse", c[c.Pen = 1] = "Pen", c[c.Touch = 2] = "Touch", c))(yo || {}); function _optionalChain$3(c) { let u, d = c[0], v = 1; for (; v < c.length;) { const E = c[v], k = c[v + 1]; if (v += 2, ("optionalAccess" === E || "optionalCall" === E) && null == d) return; "access" === E || "optionalAccess" === E ? (u = d, d = k(d)) : "call" !== E && "optionalCall" !== E || (d = k(((...c) => d.call(u, ...c))), u = void 0) } return d } function isNodeInLinkedList(c) { return "__ln" in c } class DoubleLinkedList { "constructor"() { this.length = 0, this.head = null, this.tail = null } "get"(c) { if (c >= this.length) throw new Error("Position outside of list range"); let u = this.head; for (let d = 0; d < c; d++)u = _optionalChain$3([u, "optionalAccess", c => c.next]) || null; return u } "addNode"(c) { const u = { "value": c, "previous": null, "next": null }; if (c.__ln = u, c.previousSibling && isNodeInLinkedList(c.previousSibling)) { const d = c.previousSibling.__ln.next; u.next = d, u.previous = c.previousSibling.__ln, c.previousSibling.__ln.next = u, d && (d.previous = u) } else if (c.nextSibling && isNodeInLinkedList(c.nextSibling) && c.nextSibling.__ln.previous) { const d = c.nextSibling.__ln.previous; u.previous = d, u.next = c.nextSibling.__ln, c.nextSibling.__ln.previous = u, d && (d.next = u) } else this.head && (this.head.previous = u), u.next = this.head, this.head = u; null === u.next && (this.tail = u), this.length++ } "removeNode"(c) { const u = c.__ln; this.head && (u.previous ? (u.previous.next = u.next, u.next ? u.next.previous = u.previous : this.tail = u.previous) : (this.head = u.next, this.head ? this.head.previous = null : this.tail = null), c.__ln && delete c.__ln, this.length--) } } const moveKey = (c, u) => `${c}@${u}`; class MutationBuffer { "constructor"() { this.frozen = !1, this.locked = !1, this.texts = [], this.attributes = [], this.attributeMap = new WeakMap, this.removes = [], this.mapRemoves = [], this.movedMap = {}, this.addedSet = new Set, this.movedSet = new Set, this.droppedSet = new Set, this.processMutations = c => { c.forEach(this.processMutation), this.emit() }, this.emit = () => { if (this.frozen || this.locked) return; const c = [], u = new Set, d = new DoubleLinkedList, getNextId = c => { let u = c, d = to; for (; d === to;)u = u && u.nextSibling, d = u && this.mirror.getId(u); return d }, pushAdd = v => { if (!v.parentNode || !inDom(v)) return; const E = isShadowRoot(v.parentNode) ? this.mirror.getId(getShadowHost(v)) : this.mirror.getId(v.parentNode), k = getNextId(v); if (-1 === E || -1 === k) return d.addNode(v); const R = serializeNodeWithId(v, { "doc": this.doc, "mirror": this.mirror, "blockClass": this.blockClass, "blockSelector": this.blockSelector, "maskAllText": this.maskAllText, "unblockSelector": this.unblockSelector, "maskTextClass": this.maskTextClass, "unmaskTextClass": this.unmaskTextClass, "maskTextSelector": this.maskTextSelector, "unmaskTextSelector": this.unmaskTextSelector, "skipChild": !0, "newlyAddedElement": !0, "inlineStylesheet": this.inlineStylesheet, "maskInputOptions": this.maskInputOptions, "maskAttributeFn": this.maskAttributeFn, "maskTextFn": this.maskTextFn, "maskInputFn": this.maskInputFn, "slimDOMOptions": this.slimDOMOptions, "dataURLOptions": this.dataURLOptions, "recordCanvas": this.recordCanvas, "inlineImages": this.inlineImages, "onSerialize": c => { isSerializedIframe(c, this.mirror) && !isBlocked(c, this.blockClass, this.blockSelector, this.unblockSelector, !1) && this.iframeManager.addIframe(c), isSerializedStylesheet(c, this.mirror) && this.stylesheetManager.trackLinkElement(c), hasShadowRoot(v) && this.shadowDomManager.addShadowRoot(v.shadowRoot, this.doc) }, "onIframeLoad": (c, u) => { isBlocked(c, this.blockClass, this.blockSelector, this.unblockSelector, !1) || (this.iframeManager.attachIframe(c, u), c.contentWindow && this.canvasManager.addWindow(c.contentWindow), this.shadowDomManager.observeAttachShadow(c)) }, "onStylesheetLoad": (c, u) => { this.stylesheetManager.attachLinkElement(c, u) } }); R && (c.push({ "parentId": E, "nextId": k, "node": R }), u.add(R.id)) }; for (; this.mapRemoves.length;)this.mirror.removeNodeFromMap(this.mapRemoves.shift()); for (const c of this.movedSet) isParentRemoved(this.removes, c, this.mirror) && !this.movedSet.has(c.parentNode) || pushAdd(c); for (const c of this.addedSet) isAncestorInSet(this.droppedSet, c) || isParentRemoved(this.removes, c, this.mirror) ? isAncestorInSet(this.movedSet, c) ? pushAdd(c) : this.droppedSet.add(c) : pushAdd(c); let v = null; for (; d.length;) { let c = null; if (v) { const u = this.mirror.getId(v.value.parentNode), d = getNextId(v.value); -1 !== u && -1 !== d && (c = v) } if (!c) { let u = d.tail; for (; u;) { const d = u; if (u = u.previous, d) { const u = this.mirror.getId(d.value.parentNode); if (-1 === getNextId(d.value)) continue; if (-1 !== u) { c = d; break } { const u = d.value; if (u.parentNode && u.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) { const v = u.parentNode.host; if (-1 !== this.mirror.getId(v)) { c = d; break } } } } } } if (!c) { for (; d.head;)d.removeNode(d.head.value); break } v = c.previous, d.removeNode(c.value), pushAdd(c.value) } const E = { "texts": this.texts.map((c => ({ "id": this.mirror.getId(c.node), "value": c.value }))).filter((c => !u.has(c.id))).filter((c => this.mirror.has(c.id))), "attributes": this.attributes.map((c => { const { "attributes": u } = c; if ("string" == typeof u.style) { const d = JSON.stringify(c.styleDiff), v = JSON.stringify(c._unchangedStyles); d.length < u.style.length && (d + v).split("var(").length === u.style.split("var(").length && (u.style = c.styleDiff) } return { "id": this.mirror.getId(c.node), "attributes": u } })).filter((c => !u.has(c.id))).filter((c => this.mirror.has(c.id))), "removes": this.removes, "adds": c }; (E.texts.length || E.attributes.length || E.removes.length || E.adds.length) && (this.texts = [], this.attributes = [], this.attributeMap = new WeakMap, this.removes = [], this.addedSet = new Set, this.movedSet = new Set, this.droppedSet = new Set, this.movedMap = {}, this.mutationCb(E)) }, this.processMutation = c => { if (!isIgnored(c.target, this.mirror)) switch (c.type) { case "characterData": { const u = c.target.textContent; isBlocked(c.target, this.blockClass, this.blockSelector, this.unblockSelector, !1) || u === c.oldValue || this.texts.push({ "value": needMaskingText(c.target, this.maskTextClass, this.maskTextSelector, this.unmaskTextClass, this.unmaskTextSelector, this.maskAllText) && u ? this.maskTextFn ? this.maskTextFn(u, closestElementOfNode(c.target)) : u.replace(/[\S]/g, "*") : u, "node": c.target }); break } case "attributes": { const u = c.target; let d = c.attributeName, v = c.target.getAttribute(d); if ("value" === d) { const d = getInputType(u), E = u.tagName; v = getInputValue(u, E, d); const k = shouldMaskInput({ "maskInputOptions": this.maskInputOptions, "tagName": E, "type": d }); v = maskInputValue({ "isMasked": needMaskingText(c.target, this.maskTextClass, this.maskTextSelector, this.unmaskTextClass, this.unmaskTextSelector, k), "element": u, "value": v, "maskInputFn": this.maskInputFn }) } if (isBlocked(c.target, this.blockClass, this.blockSelector, this.unblockSelector, !1) || v === c.oldValue) return; let E = this.attributeMap.get(c.target); if ("IFRAME" === u.tagName && "src" === d && !this.keepIframeSrcFn(v)) { if (u.contentDocument) return; d = "rr_src" } if (E || (E = { "node": c.target, "attributes": {}, "styleDiff": {}, "_unchangedStyles": {} }, this.attributes.push(E), this.attributeMap.set(c.target, E)), "type" === d && "INPUT" === u.tagName && "password" === (c.oldValue || "").toLowerCase() && u.setAttribute("data-rr-is-password", "true"), !ignoreAttribute(u.tagName, d) && (E.attributes[d] = transformAttribute(this.doc, toLowerCase(u.tagName), toLowerCase(d), v, u, this.maskAttributeFn), "style" === d)) { if (!this.unattachedDoc) try { this.unattachedDoc = document.implementation.createHTMLDocument() } catch (c) { this.unattachedDoc = this.doc } const d = this.unattachedDoc.createElement("span"); c.oldValue && d.setAttribute("style", c.oldValue); for (const c of Array.from(u.style)) { const v = u.style.getPropertyValue(c), k = u.style.getPropertyPriority(c); v !== d.style.getPropertyValue(c) || k !== d.style.getPropertyPriority(c) ? E.styleDiff[c] = "" === k ? v : [v, k] : E._unchangedStyles[c] = [v, k] } for (const c of Array.from(d.style)) "" === u.style.getPropertyValue(c) && (E.styleDiff[c] = !1) } break } case "childList": if (isBlocked(c.target, this.blockClass, this.blockSelector, this.unblockSelector, !0)) return; c.addedNodes.forEach((u => this.genAdds(u, c.target))), c.removedNodes.forEach((u => { const d = this.mirror.getId(u), v = isShadowRoot(c.target) ? this.mirror.getId(c.target.host) : this.mirror.getId(c.target); isBlocked(c.target, this.blockClass, this.blockSelector, this.unblockSelector, !1) || isIgnored(u, this.mirror) || !function isSerialized(c, u) { return -1 !== u.getId(c) }(u, this.mirror) || (this.addedSet.has(u) ? (deepDelete(this.addedSet, u), this.droppedSet.add(u)) : this.addedSet.has(c.target) && -1 === d || isAncestorRemoved(c.target, this.mirror) || (this.movedSet.has(u) && this.movedMap[moveKey(d, v)] ? deepDelete(this.movedSet, u) : this.removes.push({ "parentId": v, "id": d, "isShadow": !(!isShadowRoot(c.target) || !isNativeShadowDom(c.target)) || void 0 })), this.mapRemoves.push(u)) })) } }, this.genAdds = (c, u) => { if (!this.processedNodeManager.inOtherBuffer(c, this) && !this.addedSet.has(c) && !this.movedSet.has(c)) { if (this.mirror.hasNode(c)) { if (isIgnored(c, this.mirror)) return; this.movedSet.add(c); let d = null; u && this.mirror.hasNode(u) && (d = this.mirror.getId(u)), d && -1 !== d && (this.movedMap[moveKey(this.mirror.getId(c), d)] = !0) } else this.addedSet.add(c), this.droppedSet.delete(c); isBlocked(c, this.blockClass, this.blockSelector, this.unblockSelector, !1) || (c.childNodes.forEach((c => this.genAdds(c))), hasShadowRoot(c) && c.shadowRoot.childNodes.forEach((u => { this.processedNodeManager.add(u, this), this.genAdds(u, c) }))) } } } "init"(c) { ["mutationCb", "blockClass", "blockSelector", "unblockSelector", "maskAllText", "maskTextClass", "unmaskTextClass", "maskTextSelector", "unmaskTextSelector", "inlineStylesheet", "maskInputOptions", "maskAttributeFn", "maskTextFn", "maskInputFn", "keepIframeSrcFn", "recordCanvas", "inlineImages", "slimDOMOptions", "dataURLOptions", "doc", "mirror", "iframeManager", "stylesheetManager", "shadowDomManager", "canvasManager", "processedNodeManager"].forEach((u => { this[u] = c[u] })) } "freeze"() { this.frozen = !0, this.canvasManager.freeze() } "unfreeze"() { this.frozen = !1, this.canvasManager.unfreeze(), this.emit() } "isFrozen"() { return this.frozen } "lock"() { this.locked = !0, this.canvasManager.lock() } "unlock"() { this.locked = !1, this.canvasManager.unlock(), this.emit() } "reset"() { this.shadowDomManager.reset(), this.canvasManager.reset() } } function deepDelete(c, u) { c.delete(u), u.childNodes.forEach((u => deepDelete(c, u))) } function isParentRemoved(c, u, d) { return 0 !== c.length && _isParentRemoved(c, u, d) } function _isParentRemoved(c, u, d) { const { "parentNode": v } = u; if (!v) return !1; const E = d.getId(v); return !!c.some((c => c.id === E)) || _isParentRemoved(c, v, d) } function isAncestorInSet(c, u) { return 0 !== c.size && _isAncestorInSet(c, u) } function _isAncestorInSet(c, u) { const { "parentNode": d } = u; return !!d && (!!c.has(d) || _isAncestorInSet(c, d)) } let bo; function registerErrorHandler(c) { bo = c } function unregisterErrorHandler() { bo = void 0 } const callbackWrapper = c => { if (!bo) return c; return (...u) => { try { return c(...u) } catch (c) { if (bo && !0 === bo(c)) return () => { }; throw c } } }; function _optionalChain$2(c) { let u, d = c[0], v = 1; for (; v < c.length;) { const E = c[v], k = c[v + 1]; if (v += 2, ("optionalAccess" === E || "optionalCall" === E) && null == d) return; "access" === E || "optionalAccess" === E ? (u = d, d = k(d)) : "call" !== E && "optionalCall" !== E || (d = k(((...c) => d.call(u, ...c))), u = void 0) } return d } const So = []; function esm_getEventTarget(c) { try { if ("composedPath" in c) { const u = c.composedPath(); if (u.length) return u[0] } else if ("path" in c && c.path.length) return c.path[0] } catch (c) { } return c && c.target } function initMutationObserver(c, u) { const d = new MutationBuffer; So.push(d), d.init(c); let v = window.MutationObserver || window.__rrMutationObserver; const E = _optionalChain$2([window, "optionalAccess", c => c.Zone, "optionalAccess", c => c.__symbol__, "optionalCall", c => c("MutationObserver")]); E && window[E] && (v = window[E]); const k = new v(callbackWrapper((u => { c.onMutation && !1 === c.onMutation(u) || d.processMutations.bind(d)(u) }))); return k.observe(u, { "attributes": !0, "attributeOldValue": !0, "characterData": !0, "characterDataOldValue": !0, "childList": !0, "subtree": !0 }), k } function initMouseInteractionObserver({ "mouseInteractionCb": c, "doc": u, "mirror": d, "blockClass": v, "blockSelector": E, "unblockSelector": k, "sampling": R }) { if (!1 === R.mouseInteraction) return () => { }; const U = !0 === R.mouseInteraction || void 0 === R.mouseInteraction ? {} : R.mouseInteraction, H = []; let G = null; return Object.keys(vo).filter((c => Number.isNaN(Number(c)) && !c.endsWith("_Departed") && !1 !== U[c])).forEach((R => { let U = toLowerCase(R); const W = (u => R => { const U = esm_getEventTarget(R); if (isBlocked(U, v, E, k, !0)) return; let H = null, W = u; if ("pointerType" in R) { switch (R.pointerType) { case "mouse": H = yo.Mouse; break; case "touch": H = yo.Touch; break; case "pen": H = yo.Pen }H === yo.Touch ? vo[u] === vo.MouseDown ? W = "TouchStart" : vo[u] === vo.MouseUp && (W = "TouchEnd") : yo.Pen } else legacy_isTouchEvent(R) && (H = yo.Touch); null !== H ? (G = H, (W.startsWith("Touch") && H === yo.Touch || W.startsWith("Mouse") && H === yo.Mouse) && (H = null)) : vo[u] === vo.Click && (H = G, G = null); const Z = legacy_isTouchEvent(R) ? R.changedTouches[0] : R; if (!Z) return; const Y = d.getId(U), { "clientX": J, "clientY": K } = Z; callbackWrapper(c)({ "type": vo[W], "id": Y, "x": J, "y": K, ...null !== H && { "pointerType": H } }) })(R); if (window.PointerEvent) switch (vo[R]) { case vo.MouseDown: case vo.MouseUp: U = U.replace("mouse", "pointer"); break; case vo.TouchStart: case vo.TouchEnd: return }H.push(on(U, W, u)) })), callbackWrapper((() => { H.forEach((c => c())) })) } function initScrollObserver({ "scrollCb": c, "doc": u, "mirror": d, "blockClass": v, "blockSelector": E, "unblockSelector": k, "sampling": R }) { return on("scroll", callbackWrapper(throttle$1(callbackWrapper((R => { const U = esm_getEventTarget(R); if (!U || isBlocked(U, v, E, k, !0)) return; const H = d.getId(U); if (U === u && u.defaultView) { const d = getWindowScroll(u.defaultView); c({ "id": H, "x": d.left, "y": d.top }) } else c({ "id": H, "x": U.scrollLeft, "y": U.scrollTop }) })), R.scroll || 100)), u) } const wo = ["INPUT", "TEXTAREA", "SELECT"], Eo = new WeakMap; function initInputObserver({ "inputCb": c, "doc": u, "mirror": d, "blockClass": v, "blockSelector": E, "unblockSelector": k, "ignoreClass": R, "ignoreSelector": U, "maskInputOptions": H, "maskInputFn": G, "sampling": W, "userTriggeredOnInput": Z, "maskTextClass": Y, "unmaskTextClass": J, "maskTextSelector": K, "unmaskTextSelector": X }) { function eventHandler(c) { let d = esm_getEventTarget(c); const W = c.isTrusted, Q = d && toUpperCase(d.tagName); if ("OPTION" === Q && (d = d.parentElement), !d || !Q || wo.indexOf(Q) < 0 || isBlocked(d, v, E, k, !0)) return; const ee = d; if (ee.classList.contains(R) || U && ee.matches(U)) return; const te = getInputType(d); let ne = getInputValue(ee, Q, te), re = !1; const oe = shouldMaskInput({ "maskInputOptions": H, "tagName": Q, "type": te }), ie = needMaskingText(d, Y, K, J, X, oe); "radio" !== te && "checkbox" !== te || (re = d.checked), ne = maskInputValue({ "isMasked": ie, "element": d, "value": ne, "maskInputFn": G }), cbWithDedup(d, Z ? { "text": ne, "isChecked": re, "userTriggered": W } : { "text": ne, "isChecked": re }); const ae = d.name; "radio" === te && ae && re && u.querySelectorAll(`input[type="radio"][name="${ae}"]`).forEach((c => { if (c !== d) { const u = maskInputValue({ "isMasked": ie, "element": c, "value": getInputValue(c, Q, te), "maskInputFn": G }); cbWithDedup(c, Z ? { "text": u, "isChecked": !re, "userTriggered": !1 } : { "text": u, "isChecked": !re }) } })) } function cbWithDedup(u, v) { const E = Eo.get(u); if (!E || E.text !== v.text || E.isChecked !== v.isChecked) { Eo.set(u, v); const E = d.getId(u); callbackWrapper(c)({ ...v, "id": E }) } } const Q = ("last" === W.input ? ["change"] : ["input", "change"]).map((c => on(c, callbackWrapper(eventHandler), u))), ee = u.defaultView; if (!ee) return () => { Q.forEach((c => c())) }; const te = ee.Object.getOwnPropertyDescriptor(ee.HTMLInputElement.prototype, "value"), ne = [[ee.HTMLInputElement.prototype, "value"], [ee.HTMLInputElement.prototype, "checked"], [ee.HTMLSelectElement.prototype, "value"], [ee.HTMLTextAreaElement.prototype, "value"], [ee.HTMLSelectElement.prototype, "selectedIndex"], [ee.HTMLOptionElement.prototype, "selected"]]; return te && te.set && Q.push(...ne.map((c => hookSetter(c[0], c[1], { "set"() { callbackWrapper(eventHandler)({ "target": this, "isTrusted": !1 }) } }, !1, ee)))), callbackWrapper((() => { Q.forEach((c => c())) })) } function getNestedCSSRulePositions(c) { return function recurse(c, u) { if (hasNestedCSSRule("CSSGroupingRule") && c.parentRule instanceof CSSGroupingRule || hasNestedCSSRule("CSSMediaRule") && c.parentRule instanceof CSSMediaRule || hasNestedCSSRule("CSSSupportsRule") && c.parentRule instanceof CSSSupportsRule || hasNestedCSSRule("CSSConditionRule") && c.parentRule instanceof CSSConditionRule) { const d = Array.from(c.parentRule.cssRules).indexOf(c); u.unshift(d) } else if (c.parentStyleSheet) { const d = Array.from(c.parentStyleSheet.cssRules).indexOf(c); u.unshift(d) } return u }(c, []) } function getIdAndStyleId(c, u, d) { let v, E; return c ? (c.ownerNode ? v = u.getId(c.ownerNode) : E = d.getId(c), { "styleId": E, "id": v }) : {} } function initAdoptedStyleSheetObserver({ "mirror": c, "stylesheetManager": u }, d) { let v = null; v = "#document" === d.nodeName ? c.getId(d) : c.getId(d.host); const E = "#document" === d.nodeName ? _optionalChain$2([d, "access", c => c.defaultView, "optionalAccess", c => c.Document]) : _optionalChain$2([d, "access", c => c.ownerDocument, "optionalAccess", c => c.defaultView, "optionalAccess", c => c.ShadowRoot]), k = _optionalChain$2([E, "optionalAccess", c => c.prototype]) ? Object.getOwnPropertyDescriptor(_optionalChain$2([E, "optionalAccess", c => c.prototype]), "adoptedStyleSheets") : void 0; return null !== v && -1 !== v && E && k ? (Object.defineProperty(d, "adoptedStyleSheets", { "configurable": k.configurable, "enumerable": k.enumerable, "get"() { return _optionalChain$2([k, "access", c => c.get, "optionalAccess", c => c.call, "call", c => c(this)]) }, "set"(c) { const d = _optionalChain$2([k, "access", c => c.set, "optionalAccess", c => c.call, "call", u => u(this, c)]); if (null !== v && -1 !== v) try { u.adoptStyleSheets(c, v) } catch (c) { } return d } }), callbackWrapper((() => { Object.defineProperty(d, "adoptedStyleSheets", { "configurable": k.configurable, "enumerable": k.enumerable, "get": k.get, "set": k.set }) }))) : () => { } } function initObservers(c, u = {}) { const d = c.doc.defaultView; if (!d) return () => { }; let v; c.recordDOM && (v = initMutationObserver(c, c.doc)); const E = function initMoveObserver({ "mousemoveCb": c, "sampling": u, "doc": d, "mirror": v }) { if (!1 === u.mousemove) return () => { }; const E = "number" == typeof u.mousemove ? u.mousemove : 50, k = "number" == typeof u.mousemoveCallback ? u.mousemoveCallback : 500; let R, U = []; const H = throttle$1(callbackWrapper((u => { const d = Date.now() - R; c(U.map((c => (c.timeOffset -= d, c))), u), U = [], R = null })), k), G = callbackWrapper(throttle$1(callbackWrapper((c => { const u = esm_getEventTarget(c), { "clientX": d, "clientY": E } = legacy_isTouchEvent(c) ? c.changedTouches[0] : c; R || (R = fo()), U.push({ "x": d, "y": E, "id": v.getId(u), "timeOffset": fo() - R }), H("undefined" != typeof DragEvent && c instanceof DragEvent ? _o.Drag : c instanceof MouseEvent ? _o.MouseMove : _o.TouchMove) })), E, { "trailing": !1 })), W = [on("mousemove", G, d), on("touchmove", G, d), on("drag", G, d)]; return callbackWrapper((() => { W.forEach((c => c())) })) }(c), k = initMouseInteractionObserver(c), R = initScrollObserver(c), U = function initViewportResizeObserver({ "viewportResizeCb": c }, { "win": u }) { let d = -1, v = -1; return on("resize", callbackWrapper(throttle$1(callbackWrapper((() => { const u = getWindowHeight(), E = getWindowWidth(); d === u && v === E || (c({ "width": Number(E), "height": Number(u) }), d = u, v = E) })), 200)), u) }(c, { "win": d }), H = initInputObserver(c), G = function initMediaInteractionObserver({ "mediaInteractionCb": c, "blockClass": u, "blockSelector": d, "unblockSelector": v, "mirror": E, "sampling": k, "doc": R }) { const U = callbackWrapper((R => throttle$1(callbackWrapper((k => { const U = esm_getEventTarget(k); if (!U || isBlocked(U, u, d, v, !0)) return; const { "currentTime": H, "volume": G, "muted": W, "playbackRate": Z } = U; c({ "type": R, "id": E.getId(U), "currentTime": H, "volume": G, "muted": W, "playbackRate": Z }) })), k.media || 500))), H = [on("play", U(0), R), on("pause", U(1), R), on("seeked", U(2), R), on("volumechange", U(3), R), on("ratechange", U(4), R)]; return callbackWrapper((() => { H.forEach((c => c())) })) }(c); let styleSheetObserver = () => { }, adoptedStyleSheetObserver = () => { }, styleDeclarationObserver = () => { }, fontObserver = () => { }; c.recordDOM && (styleSheetObserver = function initStyleSheetObserver({ "styleSheetRuleCb": c, "mirror": u, "stylesheetManager": d }, { "win": v }) { if (!v.CSSStyleSheet || !v.CSSStyleSheet.prototype) return () => { }; const E = v.CSSStyleSheet.prototype.insertRule; v.CSSStyleSheet.prototype.insertRule = new Proxy(E, { "apply": callbackWrapper(((v, E, k) => { const [R, U] = k, { "id": H, "styleId": G } = getIdAndStyleId(E, u, d.styleMirror); return (H && -1 !== H || G && -1 !== G) && c({ "id": H, "styleId": G, "adds": [{ "rule": R, "index": U }] }), v.apply(E, k) })) }); const k = v.CSSStyleSheet.prototype.deleteRule; let R, U; v.CSSStyleSheet.prototype.deleteRule = new Proxy(k, { "apply": callbackWrapper(((v, E, k) => { const [R] = k, { "id": U, "styleId": H } = getIdAndStyleId(E, u, d.styleMirror); return (U && -1 !== U || H && -1 !== H) && c({ "id": U, "styleId": H, "removes": [{ "index": R }] }), v.apply(E, k) })) }), v.CSSStyleSheet.prototype.replace && (R = v.CSSStyleSheet.prototype.replace, v.CSSStyleSheet.prototype.replace = new Proxy(R, { "apply": callbackWrapper(((v, E, k) => { const [R] = k, { "id": U, "styleId": H } = getIdAndStyleId(E, u, d.styleMirror); return (U && -1 !== U || H && -1 !== H) && c({ "id": U, "styleId": H, "replace": R }), v.apply(E, k) })) })), v.CSSStyleSheet.prototype.replaceSync && (U = v.CSSStyleSheet.prototype.replaceSync, v.CSSStyleSheet.prototype.replaceSync = new Proxy(U, { "apply": callbackWrapper(((v, E, k) => { const [R] = k, { "id": U, "styleId": H } = getIdAndStyleId(E, u, d.styleMirror); return (U && -1 !== U || H && -1 !== H) && c({ "id": U, "styleId": H, "replaceSync": R }), v.apply(E, k) })) })); const H = {}; canMonkeyPatchNestedCSSRule("CSSGroupingRule") ? H.CSSGroupingRule = v.CSSGroupingRule : (canMonkeyPatchNestedCSSRule("CSSMediaRule") && (H.CSSMediaRule = v.CSSMediaRule), canMonkeyPatchNestedCSSRule("CSSConditionRule") && (H.CSSConditionRule = v.CSSConditionRule), canMonkeyPatchNestedCSSRule("CSSSupportsRule") && (H.CSSSupportsRule = v.CSSSupportsRule)); const G = {}; return Object.entries(H).forEach((([v, E]) => { G[v] = { "insertRule": E.prototype.insertRule, "deleteRule": E.prototype.deleteRule }, E.prototype.insertRule = new Proxy(G[v].insertRule, { "apply": callbackWrapper(((v, E, k) => { const [R, U] = k, { "id": H, "styleId": G } = getIdAndStyleId(E.parentStyleSheet, u, d.styleMirror); return (H && -1 !== H || G && -1 !== G) && c({ "id": H, "styleId": G, "adds": [{ "rule": R, "index": [...getNestedCSSRulePositions(E), U || 0] }] }), v.apply(E, k) })) }), E.prototype.deleteRule = new Proxy(G[v].deleteRule, { "apply": callbackWrapper(((v, E, k) => { const [R] = k, { "id": U, "styleId": H } = getIdAndStyleId(E.parentStyleSheet, u, d.styleMirror); return (U && -1 !== U || H && -1 !== H) && c({ "id": U, "styleId": H, "removes": [{ "index": [...getNestedCSSRulePositions(E), R] }] }), v.apply(E, k) })) }) })), callbackWrapper((() => { v.CSSStyleSheet.prototype.insertRule = E, v.CSSStyleSheet.prototype.deleteRule = k, R && (v.CSSStyleSheet.prototype.replace = R), U && (v.CSSStyleSheet.prototype.replaceSync = U), Object.entries(H).forEach((([c, u]) => { u.prototype.insertRule = G[c].insertRule, u.prototype.deleteRule = G[c].deleteRule })) })) }(c, { "win": d }), adoptedStyleSheetObserver = initAdoptedStyleSheetObserver(c, c.doc), styleDeclarationObserver = function initStyleDeclarationObserver({ "styleDeclarationCb": c, "mirror": u, "ignoreCSSAttributes": d, "stylesheetManager": v }, { "win": E }) { const k = E.CSSStyleDeclaration.prototype.setProperty; E.CSSStyleDeclaration.prototype.setProperty = new Proxy(k, { "apply": callbackWrapper(((E, R, U) => { const [H, G, W] = U; if (d.has(H)) return k.apply(R, [H, G, W]); const { "id": Z, "styleId": Y } = getIdAndStyleId(_optionalChain$2([R, "access", c => c.parentRule, "optionalAccess", c => c.parentStyleSheet]), u, v.styleMirror); return (Z && -1 !== Z || Y && -1 !== Y) && c({ "id": Z, "styleId": Y, "set": { "property": H, "value": G, "priority": W }, "index": getNestedCSSRulePositions(R.parentRule) }), E.apply(R, U) })) }); const R = E.CSSStyleDeclaration.prototype.removeProperty; return E.CSSStyleDeclaration.prototype.removeProperty = new Proxy(R, { "apply": callbackWrapper(((E, k, U) => { const [H] = U; if (d.has(H)) return R.apply(k, [H]); const { "id": G, "styleId": W } = getIdAndStyleId(_optionalChain$2([k, "access", c => c.parentRule, "optionalAccess", c => c.parentStyleSheet]), u, v.styleMirror); return (G && -1 !== G || W && -1 !== W) && c({ "id": G, "styleId": W, "remove": { "property": H }, "index": getNestedCSSRulePositions(k.parentRule) }), E.apply(k, U) })) }), callbackWrapper((() => { E.CSSStyleDeclaration.prototype.setProperty = k, E.CSSStyleDeclaration.prototype.removeProperty = R })) }(c, { "win": d }), c.collectFonts && (fontObserver = function initFontObserver({ "fontCb": c, "doc": u }) { const d = u.defaultView; if (!d) return () => { }; const v = [], E = new WeakMap, k = d.FontFace; d.FontFace = function FontFace(c, u, d) { const v = new k(c, u, d); return E.set(v, { "family": c, "buffer": "string" != typeof u, "descriptors": d, "fontSource": "string" == typeof u ? u : JSON.stringify(Array.from(new Uint8Array(u))) }), v }; const R = patch(u.fonts, "add", (function (u) { return function (d) { return setTimeout$1(callbackWrapper((() => { const u = E.get(d); u && (c(u), E.delete(d)) })), 0), u.apply(this, [d]) } })); return v.push((() => { d.FontFace = k })), v.push(R), callbackWrapper((() => { v.forEach((c => c())) })) }(c))); const W = function initSelectionObserver(c) { const { "doc": u, "mirror": d, "blockClass": v, "blockSelector": E, "unblockSelector": k, "selectionCb": R } = c; let U = !0; const H = callbackWrapper((() => { const c = u.getSelection(); if (!c || U && _optionalChain$2([c, "optionalAccess", c => c.isCollapsed])) return; U = c.isCollapsed || !1; const H = [], G = c.rangeCount || 0; for (let u = 0; u < G; u++) { const R = c.getRangeAt(u), { "startContainer": U, "startOffset": G, "endContainer": W, "endOffset": Z } = R; isBlocked(U, v, E, k, !0) || isBlocked(W, v, E, k, !0) || H.push({ "start": d.getId(U), "startOffset": G, "end": d.getId(W), "endOffset": Z }) } R({ "ranges": H }) })); return H(), on("selectionchange", H) }(c), Z = function initCustomElementObserver({ "doc": c, "customElementCb": u }) { const d = c.defaultView; return d && d.customElements ? patch(d.customElements, "define", (function (c) { return function (d, v, E) { try { u({ "define": { "name": d } }) } catch (c) { } return c.apply(this, [d, v, E]) } })) : () => { } }(c), Y = []; for (const u of c.plugins) Y.push(u.observer(u.callback, d, u.options)); return callbackWrapper((() => { So.forEach((c => c.reset())), _optionalChain$2([v, "optionalAccess", c => c.disconnect, "call", c => c()]), E(), k(), R(), U(), H(), G(), styleSheetObserver(), adoptedStyleSheetObserver(), styleDeclarationObserver(), fontObserver(), W(), Z(), Y.forEach((c => c())) })) } function hasNestedCSSRule(c) { return void 0 !== window[c] } function canMonkeyPatchNestedCSSRule(c) { return Boolean(void 0 !== window[c] && window[c].prototype && "insertRule" in window[c].prototype && "deleteRule" in window[c].prototype) } class CrossOriginIframeMirror { "constructor"(c) { this.generateIdFn = c, this.iframeIdToRemoteIdMap = new WeakMap, this.iframeRemoteIdToIdMap = new WeakMap } "getId"(c, u, d, v) { const E = d || this.getIdToRemoteIdMap(c), k = v || this.getRemoteIdToIdMap(c); let R = E.get(u); return R || (R = this.generateIdFn(), E.set(u, R), k.set(R, u)), R } "getIds"(c, u) { const d = this.getIdToRemoteIdMap(c), v = this.getRemoteIdToIdMap(c); return u.map((u => this.getId(c, u, d, v))) } "getRemoteId"(c, u, d) { const v = d || this.getRemoteIdToIdMap(c); if ("number" != typeof u) return u; const E = v.get(u); return E || -1 } "getRemoteIds"(c, u) { const d = this.getRemoteIdToIdMap(c); return u.map((u => this.getRemoteId(c, u, d))) } "reset"(c) { if (!c) return this.iframeIdToRemoteIdMap = new WeakMap, void (this.iframeRemoteIdToIdMap = new WeakMap); this.iframeIdToRemoteIdMap.delete(c), this.iframeRemoteIdToIdMap.delete(c) } "getIdToRemoteIdMap"(c) { let u = this.iframeIdToRemoteIdMap.get(c); return u || (u = new Map, this.iframeIdToRemoteIdMap.set(c, u)), u } "getRemoteIdToIdMap"(c) { let u = this.iframeRemoteIdToIdMap.get(c); return u || (u = new Map, this.iframeRemoteIdToIdMap.set(c, u)), u } } function _optionalChain$1(c) { let u, d = c[0], v = 1; for (; v < c.length;) { const E = c[v], k = c[v + 1]; if (v += 2, ("optionalAccess" === E || "optionalCall" === E) && null == d) return; "access" === E || "optionalAccess" === E ? (u = d, d = k(d)) : "call" !== E && "optionalCall" !== E || (d = k(((...c) => d.call(u, ...c))), u = void 0) } return d } class IframeManagerNoop { "constructor"() { this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId), this.crossOriginIframeRootIdMap = new WeakMap } "addIframe"() { } "addLoadListener"() { } "attachIframe"() { } } class IframeManager { "constructor"(c) { this.iframes = new WeakMap, this.crossOriginIframeMap = new WeakMap, this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId), this.crossOriginIframeRootIdMap = new WeakMap, this.mutationCb = c.mutationCb, this.wrappedEmit = c.wrappedEmit, this.stylesheetManager = c.stylesheetManager, this.recordCrossOriginIframes = c.recordCrossOriginIframes, this.crossOriginIframeStyleMirror = new CrossOriginIframeMirror(this.stylesheetManager.styleMirror.generateId.bind(this.stylesheetManager.styleMirror)), this.mirror = c.mirror, this.recordCrossOriginIframes && window.addEventListener("message", this.handleMessage.bind(this)) } "addIframe"(c) { this.iframes.set(c, !0), c.contentWindow && this.crossOriginIframeMap.set(c.contentWindow, c) } "addLoadListener"(c) { this.loadListener = c } "attachIframe"(c, u) { this.mutationCb({ "adds": [{ "parentId": this.mirror.getId(c), "nextId": null, "node": u }], "removes": [], "texts": [], "attributes": [], "isAttachIframe": !0 }), _optionalChain$1([this, "access", c => c.loadListener, "optionalCall", u => u(c)]), c.contentDocument && c.contentDocument.adoptedStyleSheets && c.contentDocument.adoptedStyleSheets.length > 0 && this.stylesheetManager.adoptStyleSheets(c.contentDocument.adoptedStyleSheets, this.mirror.getId(c.contentDocument)) } "handleMessage"(c) { const u = c; if ("rrweb" !== u.data.type || u.origin !== u.data.origin) return; if (!c.source) return; const d = this.crossOriginIframeMap.get(c.source); if (!d) return; const v = this.transformCrossOriginEvent(d, u.data.event); v && this.wrappedEmit(v, u.data.isCheckout) } "transformCrossOriginEvent"(c, u) { switch (u.type) { case mo.FullSnapshot: { this.crossOriginIframeMirror.reset(c), this.crossOriginIframeStyleMirror.reset(c), this.replaceIdOnNode(u.data.node, c); const d = u.data.node.id; return this.crossOriginIframeRootIdMap.set(c, d), this.patchRootIdOnNode(u.data.node, d), { "timestamp": u.timestamp, "type": mo.IncrementalSnapshot, "data": { "source": _o.Mutation, "adds": [{ "parentId": this.mirror.getId(c), "nextId": null, "node": u.data.node }], "removes": [], "texts": [], "attributes": [], "isAttachIframe": !0 } } } case mo.Meta: case mo.Load: case mo.DomContentLoaded: return !1; case mo.Plugin: return u; case mo.Custom: return this.replaceIds(u.data.payload, c, ["id", "parentId", "previousId", "nextId"]), u; case mo.IncrementalSnapshot: switch (u.data.source) { case _o.Mutation: return u.data.adds.forEach((u => { this.replaceIds(u, c, ["parentId", "nextId", "previousId"]), this.replaceIdOnNode(u.node, c); const d = this.crossOriginIframeRootIdMap.get(c); d && this.patchRootIdOnNode(u.node, d) })), u.data.removes.forEach((u => { this.replaceIds(u, c, ["parentId", "id"]) })), u.data.attributes.forEach((u => { this.replaceIds(u, c, ["id"]) })), u.data.texts.forEach((u => { this.replaceIds(u, c, ["id"]) })), u; case _o.Drag: case _o.TouchMove: case _o.MouseMove: return u.data.positions.forEach((u => { this.replaceIds(u, c, ["id"]) })), u; case _o.ViewportResize: return !1; case _o.MediaInteraction: case _o.MouseInteraction: case _o.Scroll: case _o.CanvasMutation: case _o.Input: return this.replaceIds(u.data, c, ["id"]), u; case _o.StyleSheetRule: case _o.StyleDeclaration: return this.replaceIds(u.data, c, ["id"]), this.replaceStyleIds(u.data, c, ["styleId"]), u; case _o.Font: return u; case _o.Selection: return u.data.ranges.forEach((u => { this.replaceIds(u, c, ["start", "end"]) })), u; case _o.AdoptedStyleSheet: return this.replaceIds(u.data, c, ["id"]), this.replaceStyleIds(u.data, c, ["styleIds"]), _optionalChain$1([u, "access", c => c.data, "access", c => c.styles, "optionalAccess", c => c.forEach, "call", u => u((u => { this.replaceStyleIds(u, c, ["styleId"]) }))]), u } }return !1 } "replace"(c, u, d, v) { for (const E of v) (Array.isArray(u[E]) || "number" == typeof u[E]) && (Array.isArray(u[E]) ? u[E] = c.getIds(d, u[E]) : u[E] = c.getId(d, u[E])); return u } "replaceIds"(c, u, d) { return this.replace(this.crossOriginIframeMirror, c, u, d) } "replaceStyleIds"(c, u, d) { return this.replace(this.crossOriginIframeStyleMirror, c, u, d) } "replaceIdOnNode"(c, u) { this.replaceIds(c, u, ["id", "rootId"]), "childNodes" in c && c.childNodes.forEach((c => { this.replaceIdOnNode(c, u) })) } "patchRootIdOnNode"(c, u) { c.type === Jr.Document || c.rootId || (c.rootId = u), "childNodes" in c && c.childNodes.forEach((c => { this.patchRootIdOnNode(c, u) })) } } class ShadowDomManagerNoop { "init"() { } "addShadowRoot"() { } "observeAttachShadow"() { } "reset"() { } } class ShadowDomManager { "constructor"(c) { this.shadowDoms = new WeakSet, this.restoreHandlers = [], this.mutationCb = c.mutationCb, this.scrollCb = c.scrollCb, this.bypassOptions = c.bypassOptions, this.mirror = c.mirror, this.init() } "init"() { this.reset(), this.patchAttachShadow(Element, document) } "addShadowRoot"(c, u) { if (!isNativeShadowDom(c)) return; if (this.shadowDoms.has(c)) return; this.shadowDoms.add(c), this.bypassOptions.canvasManager.addShadowRoot(c); const d = initMutationObserver({ ...this.bypassOptions, "doc": u, "mutationCb": this.mutationCb, "mirror": this.mirror, "shadowDomManager": this }, c); this.restoreHandlers.push((() => d.disconnect())), this.restoreHandlers.push(initScrollObserver({ ...this.bypassOptions, "scrollCb": this.scrollCb, "doc": c, "mirror": this.mirror })), setTimeout$1((() => { c.adoptedStyleSheets && c.adoptedStyleSheets.length > 0 && this.bypassOptions.stylesheetManager.adoptStyleSheets(c.adoptedStyleSheets, this.mirror.getId(c.host)), this.restoreHandlers.push(initAdoptedStyleSheetObserver({ "mirror": this.mirror, "stylesheetManager": this.bypassOptions.stylesheetManager }, c)) }), 0) } "observeAttachShadow"(c) { c.contentWindow && c.contentDocument && this.patchAttachShadow(c.contentWindow.Element, c.contentDocument) } "patchAttachShadow"(c, u) { const d = this; this.restoreHandlers.push(patch(c.prototype, "attachShadow", (function (c) { return function (v) { const E = c.call(this, v); return this.shadowRoot && inDom(this) && d.addShadowRoot(this.shadowRoot, u), E } }))) } "reset"() { this.restoreHandlers.forEach((c => { try { c() } catch (c) { } })), this.restoreHandlers = [], this.shadowDoms = new WeakSet, this.bypassOptions.canvasManager.resetShadowRoots() } } class CanvasManagerNoop { "reset"() { } "freeze"() { } "unfreeze"() { } "lock"() { } "unlock"() { } "snapshot"() { } "addWindow"() { } "addShadowRoot"() { } "resetShadowRoots"() { } } class StylesheetManager { "constructor"(c) { this.trackedLinkElements = new WeakSet, this.styleMirror = new StyleSheetMirror, this.mutationCb = c.mutationCb, this.adoptedStyleSheetCb = c.adoptedStyleSheetCb } "attachLinkElement"(c, u) { "_cssText" in u.attributes && this.mutationCb({ "adds": [], "removes": [], "texts": [], "attributes": [{ "id": u.id, "attributes": u.attributes }] }), this.trackLinkElement(c) } "trackLinkElement"(c) { this.trackedLinkElements.has(c) || (this.trackedLinkElements.add(c), this.trackStylesheetInLinkElement(c)) } "adoptStyleSheets"(c, u) { if (0 === c.length) return; const d = { "id": u, "styleIds": [] }, v = []; for (const u of c) { let c; this.styleMirror.has(u) ? c = this.styleMirror.getId(u) : (c = this.styleMirror.add(u), v.push({ "styleId": c, "rules": Array.from(u.rules || CSSRule, ((c, u) => ({ "rule": stringifyRule(c), "index": u }))) })), d.styleIds.push(c) } v.length > 0 && (d.styles = v), this.adoptedStyleSheetCb(d) } "reset"() { this.styleMirror.reset(), this.trackedLinkElements = new WeakSet } "trackStylesheetInLinkElement"(c) { } } class ProcessedNodeManager { "constructor"() { this.nodeMap = new WeakMap, this.loop = !0, this.periodicallyClear() } "periodicallyClear"() { !function onRequestAnimationFrame(...c) { return getImplementation("requestAnimationFrame")(...c) }((() => { this.clear(), this.loop && this.periodicallyClear() })) } "inOtherBuffer"(c, u) { const d = this.nodeMap.get(c); return d && Array.from(d).some((c => c !== u)) } "add"(c, u) { this.nodeMap.set(c, (this.nodeMap.get(c) || new Set).add(u)) } "clear"() { this.nodeMap = new WeakMap } "destroy"() { this.loop = !1 } } let Co, To; try { if (2 !== Array.from([1], (c => 2 * c))[0]) { const c = document.createElement("iframe"); document.body.appendChild(c), Array.from = _optionalChain([c, "access", c => c.contentWindow, "optionalAccess", c => c.Array, "access", c => c.from]) || Array.from, document.body.removeChild(c) } } catch (c) { console.debug("Unable to override Array.from", c) } const xo = function createMirror() { return new Mirror }(); function record(c = {}) { const { "emit": u, "checkoutEveryNms": d, "checkoutEveryNth": v, "blockClass": E = "rr-block", "blockSelector": k = null, "unblockSelector": R = null, "ignoreClass": U = "rr-ignore", "ignoreSelector": H = null, "maskAllText": G = !1, "maskTextClass": W = "rr-mask", "unmaskTextClass": Z = null, "maskTextSelector": Y = null, "unmaskTextSelector": J = null, "inlineStylesheet": K = !0, "maskAllInputs": X, "maskInputOptions": Q, "slimDOMOptions": ee, "maskAttributeFn": te, "maskInputFn": ne, "maskTextFn": re, "maxCanvasSize": oe = null, "packFn": ie, "sampling": ae = {}, "dataURLOptions": se = {}, "mousemoveWait": ce, "recordDOM": le = !0, "recordCanvas": ue = !1, "recordCrossOriginIframes": de = !1, "recordAfter": pe = ("DOMContentLoaded" === c.recordAfter ? c.recordAfter : "load"), "userTriggeredOnInput": fe = !1, "collectFonts": he = !1, "inlineImages": me = !1, "plugins": ge, "keepIframeSrcFn": _e = (() => !1), "ignoreCSSAttributes": ve = new Set([]), "errorHandler": ye, "onMutation": be, "getCanvasManager": Se } = c; registerErrorHandler(ye); const we = !de || window.parent === window; let Ee = !1; if (!we) try { window.parent.document && (Ee = !1) } catch (c) { Ee = !0 } if (we && !u) throw new Error("emit function is required"); void 0 !== ce && void 0 === ae.mousemove && (ae.mousemove = ce), xo.reset(); const Ce = !0 === X ? { "color": !0, "date": !0, "datetime-local": !0, "email": !0, "month": !0, "number": !0, "range": !0, "search": !0, "tel": !0, "text": !0, "time": !0, "url": !0, "week": !0, "textarea": !0, "select": !0, "radio": !0, "checkbox": !0 } : void 0 !== Q ? Q : {}, Te = !0 === ee || "all" === ee ? { "script": !0, "comment": !0, "headFavicon": !0, "headWhitespace": !0, "headMetaSocial": !0, "headMetaRobots": !0, "headMetaHttpEquiv": !0, "headMetaVerification": !0, "headMetaAuthorship": "all" === ee, "headMetaDescKeywords": "all" === ee } : ee || {}; let xe; !function polyfill(c = window) { "NodeList" in c && !c.NodeList.prototype.forEach && (c.NodeList.prototype.forEach = Array.prototype.forEach), "DOMTokenList" in c && !c.DOMTokenList.prototype.forEach && (c.DOMTokenList.prototype.forEach = Array.prototype.forEach), Node.prototype.contains || (Node.prototype.contains = (...c) => { let u = c[0]; if (!(0 in c)) throw new TypeError("1 argument is required"); do { if (this === u) return !0 } while (u = u && u.parentNode); return !1 }) }(); let Ae = 0; const eventProcessor = c => { for (const u of ge || []) u.eventProcessor && (c = u.eventProcessor(c)); return ie && !Ee && (c = ie(c)), c }; Co = (c, E) => { const k = c; if (k.timestamp = fo(), !_optionalChain([So, "access", c => c[0], "optionalAccess", c => c.isFrozen, "call", c => c()]) || k.type === mo.FullSnapshot || k.type === mo.IncrementalSnapshot && k.data.source === _o.Mutation || So.forEach((c => c.unfreeze())), we) _optionalChain([u, "optionalCall", c => c(eventProcessor(k), E)]); else if (Ee) { const c = { "type": "rrweb", "event": eventProcessor(k), "origin": window.location.origin, "isCheckout": E }; window.parent.postMessage(c, "*") } if (k.type === mo.FullSnapshot) xe = k, Ae = 0; else if (k.type === mo.IncrementalSnapshot) { if (k.data.source === _o.Mutation && k.data.isAttachIframe) return; Ae++; const c = v && Ae >= v, u = d && xe && k.timestamp - xe.timestamp > d; (c || u) && takeFullSnapshot(!0) } }; const wrappedMutationEmit = c => { Co({ "type": mo.IncrementalSnapshot, "data": { "source": _o.Mutation, ...c } }) }, wrappedScrollEmit = c => Co({ "type": mo.IncrementalSnapshot, "data": { "source": _o.Scroll, ...c } }), wrappedCanvasMutationEmit = c => Co({ "type": mo.IncrementalSnapshot, "data": { "source": _o.CanvasMutation, ...c } }), Ie = new StylesheetManager({ "mutationCb": wrappedMutationEmit, "adoptedStyleSheetCb": c => Co({ "type": mo.IncrementalSnapshot, "data": { "source": _o.AdoptedStyleSheet, ...c } }) }), ke = "boolean" == typeof __RRWEB_EXCLUDE_IFRAME__ && __RRWEB_EXCLUDE_IFRAME__ ? new IframeManagerNoop : new IframeManager({ "mirror": xo, "mutationCb": wrappedMutationEmit, "stylesheetManager": Ie, "recordCrossOriginIframes": de, "wrappedEmit": Co }); for (const c of ge || []) c.getMirror && c.getMirror({ "nodeMirror": xo, "crossOriginIframeMirror": ke.crossOriginIframeMirror, "crossOriginIframeStyleMirror": ke.crossOriginIframeStyleMirror }); const Oe = new ProcessedNodeManager, Pe = function _getCanvasManager(c, u) { try { return c ? c(u) : new CanvasManagerNoop } catch (c) { return console.warn("Unable to initialize CanvasManager"), new CanvasManagerNoop } }(Se, { "mirror": xo, "win": window, "mutationCb": c => Co({ "type": mo.IncrementalSnapshot, "data": { "source": _o.CanvasMutation, ...c } }), "recordCanvas": ue, "blockClass": E, "blockSelector": k, "unblockSelector": R, "maxCanvasSize": oe, "sampling": ae.canvas, "dataURLOptions": se, "errorHandler": ye }), Re = "boolean" == typeof __RRWEB_EXCLUDE_SHADOW_DOM__ && __RRWEB_EXCLUDE_SHADOW_DOM__ ? new ShadowDomManagerNoop : new ShadowDomManager({ "mutationCb": wrappedMutationEmit, "scrollCb": wrappedScrollEmit, "bypassOptions": { "onMutation": be, "blockClass": E, "blockSelector": k, "unblockSelector": R, "maskAllText": G, "maskTextClass": W, "unmaskTextClass": Z, "maskTextSelector": Y, "unmaskTextSelector": J, "inlineStylesheet": K, "maskInputOptions": Ce, "dataURLOptions": se, "maskAttributeFn": te, "maskTextFn": re, "maskInputFn": ne, "recordCanvas": ue, "inlineImages": me, "sampling": ae, "slimDOMOptions": Te, "iframeManager": ke, "stylesheetManager": Ie, "canvasManager": Pe, "keepIframeSrcFn": _e, "processedNodeManager": Oe }, "mirror": xo }), takeFullSnapshot = (c = !1) => { if (!le) return; Co({ "type": mo.Meta, "data": { "href": window.location.href, "width": getWindowWidth(), "height": getWindowHeight() } }, c), Ie.reset(), Re.init(), So.forEach((c => c.lock())); const u = function snapshot(c, u) { const { "mirror": d = new Mirror, "blockClass": v = "rr-block", "blockSelector": E = null, "unblockSelector": k = null, "maskAllText": R = !1, "maskTextClass": U = "rr-mask", "unmaskTextClass": H = null, "maskTextSelector": G = null, "unmaskTextSelector": W = null, "inlineStylesheet": Z = !0, "inlineImages": Y = !1, "recordCanvas": J = !1, "maskAllInputs": K = !1, "maskAttributeFn": X, "maskTextFn": Q, "maskInputFn": ee, "slimDOM": te = !1, "dataURLOptions": ne, "preserveWhiteSpace": re, "onSerialize": oe, "onIframeLoad": ie, "iframeLoadTimeout": ae, "onStylesheetLoad": se, "stylesheetLoadTimeout": ce, "keepIframeSrcFn": le = (() => !1) } = u || {}; return serializeNodeWithId(c, { "doc": c, "mirror": d, "blockClass": v, "blockSelector": E, "unblockSelector": k, "maskAllText": R, "maskTextClass": U, "unmaskTextClass": H, "maskTextSelector": G, "unmaskTextSelector": W, "skipChild": !1, "inlineStylesheet": Z, "maskInputOptions": !0 === K ? { "color": !0, "date": !0, "datetime-local": !0, "email": !0, "month": !0, "number": !0, "range": !0, "search": !0, "tel": !0, "text": !0, "time": !0, "url": !0, "week": !0, "textarea": !0, "select": !0 } : !1 === K ? {} : K, "maskAttributeFn": X, "maskTextFn": Q, "maskInputFn": ee, "slimDOMOptions": !0 === te || "all" === te ? { "script": !0, "comment": !0, "headFavicon": !0, "headWhitespace": !0, "headMetaDescKeywords": "all" === te, "headMetaSocial": !0, "headMetaRobots": !0, "headMetaHttpEquiv": !0, "headMetaAuthorship": !0, "headMetaVerification": !0 } : !1 === te ? {} : te, "dataURLOptions": ne, "inlineImages": Y, "recordCanvas": J, "preserveWhiteSpace": re, "onSerialize": oe, "onIframeLoad": ie, "iframeLoadTimeout": ae, "onStylesheetLoad": se, "stylesheetLoadTimeout": ce, "keepIframeSrcFn": le, "newlyAddedElement": !1 }) }(document, { "mirror": xo, "blockClass": E, "blockSelector": k, "unblockSelector": R, "maskAllText": G, "maskTextClass": W, "unmaskTextClass": Z, "maskTextSelector": Y, "unmaskTextSelector": J, "inlineStylesheet": K, "maskAllInputs": Ce, "maskAttributeFn": te, "maskInputFn": ne, "maskTextFn": re, "slimDOM": Te, "dataURLOptions": se, "recordCanvas": ue, "inlineImages": me, "onSerialize": c => { isSerializedIframe(c, xo) && ke.addIframe(c), isSerializedStylesheet(c, xo) && Ie.trackLinkElement(c), hasShadowRoot(c) && Re.addShadowRoot(c.shadowRoot, document) }, "onIframeLoad": (c, u) => { ke.attachIframe(c, u), c.contentWindow && Pe.addWindow(c.contentWindow), Re.observeAttachShadow(c) }, "onStylesheetLoad": (c, u) => { Ie.attachLinkElement(c, u) }, "keepIframeSrcFn": _e }); if (!u) return console.warn("Failed to snapshot the document"); Co({ "type": mo.FullSnapshot, "data": { "node": u, "initialOffset": getWindowScroll(window) } }), So.forEach((c => c.unlock())), document.adoptedStyleSheets && document.adoptedStyleSheets.length > 0 && Ie.adoptStyleSheets(document.adoptedStyleSheets, xo.getId(document)) }; To = takeFullSnapshot; try { const c = [], observe = c => callbackWrapper(initObservers)({ "onMutation": be, "mutationCb": wrappedMutationEmit, "mousemoveCb": (c, u) => Co({ "type": mo.IncrementalSnapshot, "data": { "source": u, "positions": c } }), "mouseInteractionCb": c => Co({ "type": mo.IncrementalSnapshot, "data": { "source": _o.MouseInteraction, ...c } }), "scrollCb": wrappedScrollEmit, "viewportResizeCb": c => Co({ "type": mo.IncrementalSnapshot, "data": { "source": _o.ViewportResize, ...c } }), "inputCb": c => Co({ "type": mo.IncrementalSnapshot, "data": { "source": _o.Input, ...c } }), "mediaInteractionCb": c => Co({ "type": mo.IncrementalSnapshot, "data": { "source": _o.MediaInteraction, ...c } }), "styleSheetRuleCb": c => Co({ "type": mo.IncrementalSnapshot, "data": { "source": _o.StyleSheetRule, ...c } }), "styleDeclarationCb": c => Co({ "type": mo.IncrementalSnapshot, "data": { "source": _o.StyleDeclaration, ...c } }), "canvasMutationCb": wrappedCanvasMutationEmit, "fontCb": c => Co({ "type": mo.IncrementalSnapshot, "data": { "source": _o.Font, ...c } }), "selectionCb": c => { Co({ "type": mo.IncrementalSnapshot, "data": { "source": _o.Selection, ...c } }) }, "customElementCb": c => { Co({ "type": mo.IncrementalSnapshot, "data": { "source": _o.CustomElement, ...c } }) }, "blockClass": E, "ignoreClass": U, "ignoreSelector": H, "maskAllText": G, "maskTextClass": W, "unmaskTextClass": Z, "maskTextSelector": Y, "unmaskTextSelector": J, "maskInputOptions": Ce, "inlineStylesheet": K, "sampling": ae, "recordDOM": le, "recordCanvas": ue, "inlineImages": me, "userTriggeredOnInput": fe, "collectFonts": he, "doc": c, "maskAttributeFn": te, "maskInputFn": ne, "maskTextFn": re, "keepIframeSrcFn": _e, "blockSelector": k, "unblockSelector": R, "slimDOMOptions": Te, "dataURLOptions": se, "mirror": xo, "iframeManager": ke, "stylesheetManager": Ie, "shadowDomManager": Re, "processedNodeManager": Oe, "canvasManager": Pe, "ignoreCSSAttributes": ve, "plugins": _optionalChain([ge, "optionalAccess", c => c.filter, "call", c => c((c => c.observer)), "optionalAccess", c => c.map, "call", c => c((c => ({ "observer": c.observer, "options": c.options, "callback": u => Co({ "type": mo.Plugin, "data": { "plugin": c.name, "payload": u } }) })))]) || [] }, {}); ke.addLoadListener((u => { try { c.push(observe(u.contentDocument)) } catch (c) { console.warn(c) } })); const init = () => { takeFullSnapshot(), c.push(observe(document)) }; return "interactive" === document.readyState || "complete" === document.readyState ? init() : (c.push(on("DOMContentLoaded", (() => { Co({ "type": mo.DomContentLoaded, "data": {} }), "DOMContentLoaded" === pe && init() }))), c.push(on("load", (() => { Co({ "type": mo.Load, "data": {} }), "load" === pe && init() }), window))), () => { c.forEach((c => c())), Oe.destroy(), To = void 0, unregisterErrorHandler() } } catch (c) { console.warn(c) } } record.mirror = xo, record.takeFullSnapshot = function takeFullSnapshot(c) { if (!To) throw new Error("please take full snapshot after start recording"); To(c) }; const Ao = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__, Io = ["info", "warn", "error", "log"], ko = "[Replay] "; function _addBreadcrumb(c, u = "info") { !function breadcrumbs_addBreadcrumb(c, u) { const d = build_esm_currentScopes_getClient(), v = build_esm_currentScopes_getIsolationScope(); if (!d) return; const { "beforeBreadcrumb": E = null, "maxBreadcrumbs": k = tr } = d.getOptions(); if (k <= 0) return; const R = { "timestamp": utils_build_esm_time_dateTimestampInSeconds(), ...c }, U = E ? utils_build_esm_logger_consoleSandbox((() => E(R, u))) : R; null !== U && (d.emit && d.emit("beforeAddBreadcrumb", U, u), v.addBreadcrumb(U, k)) }({ "category": "console", "data": { "logger": "replay" }, "level": u, "message": `${ko}${c}` }, { "level": u }) } const Oo = function makeReplayLogger() { let c = !1, u = !1; const d = { "exception": () => { }, "infoTick": () => { }, "setConfig": d => { c = d.captureExceptions, u = d.traceInternals } }; return Ao ? (Io.forEach((c => { d[c] = (...d) => { Yn[c](ko, ...d), u && _addBreadcrumb(d[0]) } })), d.exception = (v, ...E) => { d.error && d.error(...E), Yn.error(ko, v), c ? esm_exports_captureException(v) : u && _addBreadcrumb(v) }, d.infoTick = (...c) => { Yn.info(ko, ...c), u && setTimeout((() => _addBreadcrumb(c[0])), 0) }) : Io.forEach((c => { d[c] = () => { } })), d }(), Po = 3; function timestampToMs(c) { return c > 9999999999 ? c : 1e3 * c } function timestampToS(c) { return c > 9999999999 ? c / 1e3 : c } function addBreadcrumbEvent(c, u) { "sentry.transaction" !== u.category && (["ui.click", "ui.input"].includes(u.category) ? c.triggerUserActivity() : c.checkAndHandleExpiredSession(), c.addUpdate((() => (c.throttledAddEvent({ "type": mo.Custom, "timestamp": 1e3 * (u.timestamp || 0), "data": { "tag": "breadcrumb", "payload": esm_normalize_normalize(u, 10, 1e3) } }), "console" === u.category)))) } const Ro = "button,a"; function getClosestInteractive(c) { return c.closest(Ro) || c } function getClickTargetNode(c) { const u = getTargetNode(c); return u && u instanceof Element ? getClosestInteractive(u) : u } function getTargetNode(c) { return function isEventWithTarget(c) { return "object" == typeof c && !!c && "target" in c }(c) ? c.target : c } let Mo; function onWindowOpen(c) { return Mo || (Mo = [], function monkeyPatchWindowOpen() { build_esm_object_fill(Hr, "open", (function (c) { return function (...u) { if (Mo) try { Mo.forEach((c => c())) } catch (c) { } return c.apply(Hr, u) } })) }()), Mo.push(c), () => { const u = Mo ? Mo.indexOf(c) : -1; u > -1 && Mo.splice(u, 1) } } const No = new Set([_o.Mutation, _o.StyleSheetRule, _o.StyleDeclaration, _o.AdoptedStyleSheet, _o.CanvasMutation, _o.Selection, _o.MediaInteraction]); class ClickDetector { "constructor"(c, u, d = addBreadcrumbEvent) { this._lastMutation = 0, this._lastScroll = 0, this._clicks = [], this._timeout = u.timeout / 1e3, this._threshold = u.threshold / 1e3, this._scollTimeout = u.scrollTimeout / 1e3, this._replay = c, this._ignoreSelector = u.ignoreSelector, this._addBreadcrumbEvent = d } "addListeners"() { const c = onWindowOpen((() => { this._lastMutation = nowInSeconds() })); this._teardown = () => { c(), this._clicks = [], this._lastMutation = 0, this._lastScroll = 0 } } "removeListeners"() { this._teardown && this._teardown(), this._checkClickTimeout && clearTimeout(this._checkClickTimeout) } "handleClick"(c, u) { if (function ignoreElement(c, u) { if (!Do.includes(c.tagName)) return !0; if ("INPUT" === c.tagName && !["submit", "button"].includes(c.getAttribute("type") || "")) return !0; if ("A" === c.tagName && (c.hasAttribute("download") || c.hasAttribute("target") && "_self" !== c.getAttribute("target"))) return !0; if (u && c.matches(u)) return !0; return !1 }(u, this._ignoreSelector) || !function isClickBreadcrumb(c) { return !(!c.data || "number" != typeof c.data.nodeId || !c.timestamp) }(c)) return; const d = { "timestamp": timestampToS(c.timestamp), "clickBreadcrumb": c, "clickCount": 0, "node": u }; this._clicks.some((c => c.node === d.node && Math.abs(c.timestamp - d.timestamp) < 1)) || (this._clicks.push(d), 1 === this._clicks.length && this._scheduleCheckClicks()) } "registerMutation"(c = Date.now()) { this._lastMutation = timestampToS(c) } "registerScroll"(c = Date.now()) { this._lastScroll = timestampToS(c) } "registerClick"(c) { const u = getClosestInteractive(c); this._handleMultiClick(u) } "_handleMultiClick"(c) { this._getClicks(c).forEach((c => { c.clickCount++ })) } "_getClicks"(c) { return this._clicks.filter((u => u.node === c)) } "_checkClicks"() { const c = [], u = nowInSeconds(); this._clicks.forEach((d => { !d.mutationAfter && this._lastMutation && (d.mutationAfter = d.timestamp <= this._lastMutation ? this._lastMutation - d.timestamp : void 0), !d.scrollAfter && this._lastScroll && (d.scrollAfter = d.timestamp <= this._lastScroll ? this._lastScroll - d.timestamp : void 0), d.timestamp + this._timeout <= u && c.push(d) })); for (const u of c) { const c = this._clicks.indexOf(u); c > -1 && (this._generateBreadcrumbs(u), this._clicks.splice(c, 1)) } this._clicks.length && this._scheduleCheckClicks() } "_generateBreadcrumbs"(c) { const u = this._replay, d = c.scrollAfter && c.scrollAfter <= this._scollTimeout, v = c.mutationAfter && c.mutationAfter <= this._threshold, E = !d && !v, { "clickCount": k, "clickBreadcrumb": R } = c; if (E) { const d = 1e3 * Math.min(c.mutationAfter || this._timeout, this._timeout), v = d < 1e3 * this._timeout ? "mutation" : "timeout", E = { "type": "default", "message": R.message, "timestamp": R.timestamp, "category": "ui.slowClickDetected", "data": { ...R.data, "url": Hr.location.href, "route": u.getCurrentRoute(), "timeAfterClickMs": d, "endReason": v, "clickCount": k || 1 } }; this._addBreadcrumbEvent(u, E) } else if (k > 1) { const c = { "type": "default", "message": R.message, "timestamp": R.timestamp, "category": "ui.multiClick", "data": { ...R.data, "url": Hr.location.href, "route": u.getCurrentRoute(), "clickCount": k, "metric": !0 } }; this._addBreadcrumbEvent(u, c) } } "_scheduleCheckClicks"() { this._checkClickTimeout && clearTimeout(this._checkClickTimeout), this._checkClickTimeout = getNativeImplementation_setTimeout((() => this._checkClicks()), 1e3) } } const Do = ["A", "BUTTON", "INPUT"]; function nowInSeconds() { return Date.now() / 1e3 } function updateClickDetectorForRecordingEvent(c, u) { try { if (!function isIncrementalEvent(c) { return c.type === Po }(u)) return; const { "source": d } = u.data; if (No.has(d) && c.registerMutation(u.timestamp), d === _o.Scroll && c.registerScroll(u.timestamp), function isIncrementalMouseInteraction(c) { return c.data.source === _o.MouseInteraction }(u)) { const { "type": d, "id": v } = u.data, E = record.mirror.getNode(v); E instanceof HTMLElement && d === vo.Click && c.registerClick(E) } } catch (c) { } } function createBreadcrumb(c) { return { "timestamp": Date.now() / 1e3, "type": "default", ...c } } var $o; !function (c) { c[c.Document = 0] = "Document", c[c.DocumentType = 1] = "DocumentType", c[c.Element = 2] = "Element", c[c.Text = 3] = "Text", c[c.CDATA = 4] = "CDATA", c[c.Comment = 5] = "Comment" }($o || ($o = {})); const Lo = new Set(["id", "class", "aria-label", "role", "name", "alt", "title", "data-test-id", "data-testid", "disabled", "aria-disabled", "data-sentry-component"]); function getAttributesToRecord(c) { const u = {}; !c["data-sentry-component"] && c["data-sentry-element"] && (c["data-sentry-component"] = c["data-sentry-element"]); for (const d in c) if (Lo.has(d)) { let v = d; "data-testid" !== d && "data-test-id" !== d || (v = "testId"), u[v] = c[d] } return u } const handleDomListener = c => u => { if (!c.isEnabled()) return; const d = function handleDom(c) { const { "target": u, "message": d } = function getDomTarget(c) { const u = "click" === c.name; let d, v = null; try { v = u ? getClickTargetNode(c.event) : getTargetNode(c.event), d = esm_browser_htmlTreeAsString(v, { "maxStringLength": 200 }) || "<unknown>" } catch (c) { d = "<unknown>" } return { "target": v, "message": d } }(c); return createBreadcrumb({ "category": `ui.${c.name}`, ...getBaseDomBreadcrumb(u, d) }) }(u); if (!d) return; const v = "click" === u.name, E = v ? u.event : void 0; !(v && c.clickDetector && E && E.target) || E.altKey || E.metaKey || E.ctrlKey || E.shiftKey || function handleClick(c, u, d) { c.handleClick(u, d) }(c.clickDetector, d, getClickTargetNode(u.event)), addBreadcrumbEvent(c, d) }; function getBaseDomBreadcrumb(c, u) { const d = record.mirror.getId(c), v = d && record.mirror.getNode(d), E = v && record.mirror.getMeta(v), k = E && function esm_isElement(c) { return c.type === $o.Element }(E) ? E : null; return { "message": u, "data": k ? { "nodeId": d, "node": { "id": d, "tagName": k.tagName, "textContent": Array.from(k.childNodes).map((c => c.type === $o.Text && c.textContent)).filter(Boolean).map((c => c.trim())).join(""), "attributes": getAttributesToRecord(k.attributes) } } : {} } } function handleKeyboardEvent(c, u) { if (!c.isEnabled()) return; c.updateUserActivity(); const d = function getKeyboardBreadcrumb(c) { const { "metaKey": u, "shiftKey": d, "ctrlKey": v, "altKey": E, "key": k, "target": R } = c; if (!R || function isInputElement(c) { return "INPUT" === c.tagName || "TEXTAREA" === c.tagName || c.isContentEditable }(R) || !k) return null; const U = u || v || E, H = 1 === k.length; if (!U && H) return null; const G = esm_browser_htmlTreeAsString(R, { "maxStringLength": 200 }) || "<unknown>", W = getBaseDomBreadcrumb(R, G); return createBreadcrumb({ "category": "ui.keyDown", "message": G, "data": { ...W.data, "metaKey": u, "shiftKey": d, "ctrlKey": v, "altKey": E, "key": k } }) }(u); d && addBreadcrumbEvent(c, d) } const Fo = { "resource": function createResourceEntry(c) { const { "entryType": u, "initiatorType": d, "name": v, "responseEnd": E, "startTime": k, "decodedBodySize": R, "encodedBodySize": U, "responseStatus": H, "transferSize": G } = c; if (["fetch", "xmlhttprequest"].includes(d)) return null; return { "type": `${u}.${d}`, "start": getAbsoluteTime(k), "end": getAbsoluteTime(E), "name": v, "data": { "size": G, "statusCode": H, "decodedBodySize": R, "encodedBodySize": U } } }, "paint": function createPaintEntry(c) { const { "duration": u, "entryType": d, "name": v, "startTime": E } = c, k = getAbsoluteTime(E); return { "type": d, "name": v, "start": k, "end": k + u, "data": void 0 } }, "navigation": function createNavigationEntry(c) { const { "entryType": u, "name": d, "decodedBodySize": v, "duration": E, "domComplete": k, "encodedBodySize": R, "domContentLoadedEventStart": U, "domContentLoadedEventEnd": H, "domInteractive": G, "loadEventStart": W, "loadEventEnd": Z, "redirectCount": Y, "startTime": J, "transferSize": K, "type": X } = c; if (0 === E) return null; return { "type": `${u}.${X}`, "start": getAbsoluteTime(J), "end": getAbsoluteTime(k), "name": d, "data": { "size": K, "decodedBodySize": v, "encodedBodySize": R, "duration": E, "domInteractive": G, "domContentLoadedEventStart": U, "domContentLoadedEventEnd": H, "loadEventStart": W, "loadEventEnd": Z, "domComplete": k, "redirectCount": Y } } } }; function webVitalHandler(c, u) { return ({ "metric": d }) => { u.replayPerformanceEntries.push(c(d)) } } function createPerformanceEntry(c) { const u = Fo[c.entryType]; return u ? u(c) : null } function getAbsoluteTime(c) { return ((Gn || Hr.performance.timeOrigin) + c) / 1e3 } function getLargestContentfulPaint(c) { const u = c.entries[c.entries.length - 1]; return getWebVital(c, "largest-contentful-paint", u && u.element ? [u.element] : void 0) } function isLayoutShift(c) { return void 0 !== c.sources } function getCumulativeLayoutShift(c) { const u = [], d = []; for (const v of c.entries) if (isLayoutShift(v)) { const c = []; for (const u of v.sources) if (u.node) { d.push(u.node); const v = record.mirror.getId(u.node); v && c.push(v) } u.push({ "value": v.value, "nodeIds": c.length ? c : void 0 }) } return getWebVital(c, "cumulative-layout-shift", d, u) } function getFirstInputDelay(c) { const u = c.entries[c.entries.length - 1]; return getWebVital(c, "first-input-delay", u && u.target ? [u.target] : void 0) } function getInteractionToNextPaint(c) { const u = c.entries[c.entries.length - 1]; return getWebVital(c, "interaction-to-next-paint", u && u.target ? [u.target] : void 0) } function getWebVital(c, u, d, v) { const E = c.value, k = c.rating, R = getAbsoluteTime(E); return { "type": "web-vital", "name": u, "start": R, "end": R, "data": { "value": E, "size": E, "rating": k, "nodeIds": d ? d.map((c => record.mirror.getId(c))) : void 0, "attributions": v } } } const jo = 'var t=Uint8Array,n=Uint16Array,r=Int32Array,e=new t([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),i=new t([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),a=new t([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),s=function(t,e){for(var i=new n(31),a=0;a<31;++a)i[a]=e+=1<<t[a-1];var s=new r(i[30]);for(a=1;a<30;++a)for(var o=i[a];o<i[a+1];++o)s[o]=o-i[a]<<5|a;return{b:i,r:s}},o=s(e,2),f=o.b,h=o.r;f[28]=258,h[258]=28;for(var l=s(i,0).r,u=new n(32768),c=0;c<32768;++c){var v=(43690&c)>>1|(21845&c)<<1;v=(61680&(v=(52428&v)>>2|(13107&v)<<2))>>4|(3855&v)<<4,u[c]=((65280&v)>>8|(255&v)<<8)>>1}var d=function(t,r,e){for(var i=t.length,a=0,s=new n(r);a<i;++a)t[a]&&++s[t[a]-1];var o,f=new n(r);for(a=1;a<r;++a)f[a]=f[a-1]+s[a-1]<<1;if(e){o=new n(1<<r);var h=15-r;for(a=0;a<i;++a)if(t[a])for(var l=a<<4|t[a],c=r-t[a],v=f[t[a]-1]++<<c,d=v|(1<<c)-1;v<=d;++v)o[u[v]>>h]=l}else for(o=new n(i),a=0;a<i;++a)t[a]&&(o[a]=u[f[t[a]-1]++]>>15-t[a]);return o},g=new t(288);for(c=0;c<144;++c)g[c]=8;for(c=144;c<256;++c)g[c]=9;for(c=256;c<280;++c)g[c]=7;for(c=280;c<288;++c)g[c]=8;var w=new t(32);for(c=0;c<32;++c)w[c]=5;var p=d(g,9,0),y=d(w,5,0),m=function(t){return(t+7)/8|0},b=function(n,r,e){return(null==r||r<0)&&(r=0),(null==e||e>n.length)&&(e=n.length),new t(n.subarray(r,e))},M=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],E=function(t,n,r){var e=new Error(n||M[t]);if(e.code=t,Error.captureStackTrace&&Error.captureStackTrace(e,E),!r)throw e;return e},z=function(t,n,r){r<<=7&n;var e=n/8|0;t[e]|=r,t[e+1]|=r>>8},A=function(t,n,r){r<<=7&n;var e=n/8|0;t[e]|=r,t[e+1]|=r>>8,t[e+2]|=r>>16},_=function(r,e){for(var i=[],a=0;a<r.length;++a)r[a]&&i.push({s:a,f:r[a]});var s=i.length,o=i.slice();if(!s)return{t:F,l:0};if(1==s){var f=new t(i[0].s+1);return f[i[0].s]=1,{t:f,l:1}}i.sort((function(t,n){return t.f-n.f})),i.push({s:-1,f:25001});var h=i[0],l=i[1],u=0,c=1,v=2;for(i[0]={s:-1,f:h.f+l.f,l:h,r:l};c!=s-1;)h=i[i[u].f<i[v].f?u++:v++],l=i[u!=c&&i[u].f<i[v].f?u++:v++],i[c++]={s:-1,f:h.f+l.f,l:h,r:l};var d=o[0].s;for(a=1;a<s;++a)o[a].s>d&&(d=o[a].s);var g=new n(d+1),w=x(i[c-1],g,0);if(w>e){a=0;var p=0,y=w-e,m=1<<y;for(o.sort((function(t,n){return g[n.s]-g[t.s]||t.f-n.f}));a<s;++a){var b=o[a].s;if(!(g[b]>e))break;p+=m-(1<<w-g[b]),g[b]=e}for(p>>=y;p>0;){var M=o[a].s;g[M]<e?p-=1<<e-g[M]++-1:++a}for(;a>=0&&p;--a){var E=o[a].s;g[E]==e&&(--g[E],++p)}w=e}return{t:new t(g),l:w}},x=function(t,n,r){return-1==t.s?Math.max(x(t.l,n,r+1),x(t.r,n,r+1)):n[t.s]=r},D=function(t){for(var r=t.length;r&&!t[--r];);for(var e=new n(++r),i=0,a=t[0],s=1,o=function(t){e[i++]=t},f=1;f<=r;++f)if(t[f]==a&&f!=r)++s;else{if(!a&&s>2){for(;s>138;s-=138)o(32754);s>2&&(o(s>10?s-11<<5|28690:s-3<<5|12305),s=0)}else if(s>3){for(o(a),--s;s>6;s-=6)o(8304);s>2&&(o(s-3<<5|8208),s=0)}for(;s--;)o(a);s=1,a=t[f]}return{c:e.subarray(0,i),n:r}},T=function(t,n){for(var r=0,e=0;e<n.length;++e)r+=t[e]*n[e];return r},k=function(t,n,r){var e=r.length,i=m(n+2);t[i]=255&e,t[i+1]=e>>8,t[i+2]=255^t[i],t[i+3]=255^t[i+1];for(var a=0;a<e;++a)t[i+a+4]=r[a];return 8*(i+4+e)},C=function(t,r,s,o,f,h,l,u,c,v,m){z(r,m++,s),++f[256];for(var b=_(f,15),M=b.t,E=b.l,x=_(h,15),C=x.t,U=x.l,F=D(M),I=F.c,S=F.n,L=D(C),O=L.c,j=L.n,q=new n(19),B=0;B<I.length;++B)++q[31&I[B]];for(B=0;B<O.length;++B)++q[31&O[B]];for(var G=_(q,7),H=G.t,J=G.l,K=19;K>4&&!H[a[K-1]];--K);var N,P,Q,R,V=v+5<<3,W=T(f,g)+T(h,w)+l,X=T(f,M)+T(h,C)+l+14+3*K+T(q,H)+2*q[16]+3*q[17]+7*q[18];if(c>=0&&V<=W&&V<=X)return k(r,m,t.subarray(c,c+v));if(z(r,m,1+(X<W)),m+=2,X<W){N=d(M,E,0),P=M,Q=d(C,U,0),R=C;var Y=d(H,J,0);z(r,m,S-257),z(r,m+5,j-1),z(r,m+10,K-4),m+=14;for(B=0;B<K;++B)z(r,m+3*B,H[a[B]]);m+=3*K;for(var Z=[I,O],$=0;$<2;++$){var tt=Z[$];for(B=0;B<tt.length;++B){var nt=31&tt[B];z(r,m,Y[nt]),m+=H[nt],nt>15&&(z(r,m,tt[B]>>5&127),m+=tt[B]>>12)}}}else N=p,P=g,Q=y,R=w;for(B=0;B<u;++B){var rt=o[B];if(rt>255){A(r,m,N[(nt=rt>>18&31)+257]),m+=P[nt+257],nt>7&&(z(r,m,rt>>23&31),m+=e[nt]);var et=31&rt;A(r,m,Q[et]),m+=R[et],et>3&&(A(r,m,rt>>5&8191),m+=i[et])}else A(r,m,N[rt]),m+=P[rt]}return A(r,m,N[256]),m+P[256]},U=new r([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),F=new t(0),I=function(){for(var t=new Int32Array(256),n=0;n<256;++n){for(var r=n,e=9;--e;)r=(1&r&&-306674912)^r>>>1;t[n]=r}return t}(),S=function(){var t=-1;return{p:function(n){for(var r=t,e=0;e<n.length;++e)r=I[255&r^n[e]]^r>>>8;t=r},d:function(){return~t}}},L=function(){var t=1,n=0;return{p:function(r){for(var e=t,i=n,a=0|r.length,s=0;s!=a;){for(var o=Math.min(s+2655,a);s<o;++s)i+=e+=r[s];e=(65535&e)+15*(e>>16),i=(65535&i)+15*(i>>16)}t=e,n=i},d:function(){return(255&(t%=65521))<<24|(65280&t)<<8|(255&(n%=65521))<<8|n>>8}}},O=function(a,s,o,f,u){if(!u&&(u={l:1},s.dictionary)){var c=s.dictionary.subarray(-32768),v=new t(c.length+a.length);v.set(c),v.set(a,c.length),a=v,u.w=c.length}return function(a,s,o,f,u,c){var v=c.z||a.length,d=new t(f+v+5*(1+Math.ceil(v/7e3))+u),g=d.subarray(f,d.length-u),w=c.l,p=7&(c.r||0);if(s){p&&(g[0]=c.r>>3);for(var y=U[s-1],M=y>>13,E=8191&y,z=(1<<o)-1,A=c.p||new n(32768),_=c.h||new n(z+1),x=Math.ceil(o/3),D=2*x,T=function(t){return(a[t]^a[t+1]<<x^a[t+2]<<D)&z},F=new r(25e3),I=new n(288),S=new n(32),L=0,O=0,j=c.i||0,q=0,B=c.w||0,G=0;j+2<v;++j){var H=T(j),J=32767&j,K=_[H];if(A[J]=K,_[H]=J,B<=j){var N=v-j;if((L>7e3||q>24576)&&(N>423||!w)){p=C(a,g,0,F,I,S,O,q,G,j-G,p),q=L=O=0,G=j;for(var P=0;P<286;++P)I[P]=0;for(P=0;P<30;++P)S[P]=0}var Q=2,R=0,V=E,W=J-K&32767;if(N>2&&H==T(j-W))for(var X=Math.min(M,N)-1,Y=Math.min(32767,j),Z=Math.min(258,N);W<=Y&&--V&&J!=K;){if(a[j+Q]==a[j+Q-W]){for(var $=0;$<Z&&a[j+$]==a[j+$-W];++$);if($>Q){if(Q=$,R=W,$>X)break;var tt=Math.min(W,$-2),nt=0;for(P=0;P<tt;++P){var rt=j-W+P&32767,et=rt-A[rt]&32767;et>nt&&(nt=et,K=rt)}}}W+=(J=K)-(K=A[J])&32767}if(R){F[q++]=268435456|h[Q]<<18|l[R];var it=31&h[Q],at=31&l[R];O+=e[it]+i[at],++I[257+it],++S[at],B=j+Q,++L}else F[q++]=a[j],++I[a[j]]}}for(j=Math.max(j,B);j<v;++j)F[q++]=a[j],++I[a[j]];p=C(a,g,w,F,I,S,O,q,G,j-G,p),w||(c.r=7&p|g[p/8|0]<<3,p-=7,c.h=_,c.p=A,c.i=j,c.w=B)}else{for(j=c.w||0;j<v+w;j+=65535){var st=j+65535;st>=v&&(g[p/8|0]=w,st=v),p=k(g,p+1,a.subarray(j,st))}c.i=v}return b(d,0,f+m(p)+u)}(a,null==s.level?6:s.level,null==s.mem?Math.ceil(1.5*Math.max(8,Math.min(13,Math.log(a.length)))):12+s.mem,o,f,u)},j=function(t,n,r){for(;r;++n)t[n]=r,r>>>=8},q=function(t,n){var r=n.filename;if(t[0]=31,t[1]=139,t[2]=8,t[8]=n.level<2?4:9==n.level?2:0,t[9]=3,0!=n.mtime&&j(t,4,Math.floor(new Date(n.mtime||Date.now())/1e3)),r){t[3]=8;for(var e=0;e<=r.length;++e)t[e+10]=r.charCodeAt(e)}},B=function(t){return 10+(t.filename?t.filename.length+1:0)},G=function(){function n(n,r){if("function"==typeof n&&(r=n,n={}),this.ondata=r,this.o=n||{},this.s={l:0,i:32768,w:32768,z:32768},this.b=new t(98304),this.o.dictionary){var e=this.o.dictionary.subarray(-32768);this.b.set(e,32768-e.length),this.s.i=32768-e.length}}return n.prototype.p=function(t,n){this.ondata(O(t,this.o,0,0,this.s),n)},n.prototype.push=function(n,r){this.ondata||E(5),this.s.l&&E(4);var e=n.length+this.s.z;if(e>this.b.length){if(e>2*this.b.length-32768){var i=new t(-32768&e);i.set(this.b.subarray(0,this.s.z)),this.b=i}var a=this.b.length-this.s.z;a&&(this.b.set(n.subarray(0,a),this.s.z),this.s.z=this.b.length,this.p(this.b,!1)),this.b.set(this.b.subarray(-32768)),this.b.set(n.subarray(a),32768),this.s.z=n.length-a+32768,this.s.i=32766,this.s.w=32768}else this.b.set(n,this.s.z),this.s.z+=n.length;this.s.l=1&r,(this.s.z>this.s.w+8191||r)&&(this.p(this.b,r||!1),this.s.w=this.s.i,this.s.i-=2)},n}();var H=function(){function t(t,n){this.c=L(),this.v=1,G.call(this,t,n)}return t.prototype.push=function(t,n){this.c.p(t),G.prototype.push.call(this,t,n)},t.prototype.p=function(t,n){var r=O(t,this.o,this.v&&(this.o.dictionary?6:2),n&&4,this.s);this.v&&(function(t,n){var r=n.level,e=0==r?0:r<6?1:9==r?3:2;if(t[0]=120,t[1]=e<<6|(n.dictionary&&32),t[1]|=31-(t[0]<<8|t[1])%31,n.dictionary){var i=L();i.p(n.dictionary),j(t,2,i.d())}}(r,this.o),this.v=0),n&&j(r,r.length-4,this.c.d()),this.ondata(r,n)},t}(),J="undefined"!=typeof TextEncoder&&new TextEncoder,K="undefined"!=typeof TextDecoder&&new TextDecoder;try{K.decode(F,{stream:!0})}catch(t){}var N=function(){function t(t){this.ondata=t}return t.prototype.push=function(t,n){this.ondata||E(5),this.d&&E(4),this.ondata(P(t),this.d=n||!1)},t}();function P(n,r){if(r){for(var e=new t(n.length),i=0;i<n.length;++i)e[i]=n.charCodeAt(i);return e}if(J)return J.encode(n);var a=n.length,s=new t(n.length+(n.length>>1)),o=0,f=function(t){s[o++]=t};for(i=0;i<a;++i){if(o+5>s.length){var h=new t(o+8+(a-i<<1));h.set(s),s=h}var l=n.charCodeAt(i);l<128||r?f(l):l<2048?(f(192|l>>6),f(128|63&l)):l>55295&&l<57344?(f(240|(l=65536+(1047552&l)|1023&n.charCodeAt(++i))>>18),f(128|l>>12&63),f(128|l>>6&63),f(128|63&l)):(f(224|l>>12),f(128|l>>6&63),f(128|63&l))}return b(s,0,o)}function Q(t){return function(t,n){n||(n={});var r=S(),e=t.length;r.p(t);var i=O(t,n,B(n),8),a=i.length;return q(i,n),j(i,a-8,r.d()),j(i,a-4,e),i}(P(t))}const R=new class{constructor(){this._init()}clear(){this._init()}addEvent(t){if(!t)throw new Error("Adding invalid event");const n=this._hasEvents?",":"";this.stream.push(n+t),this._hasEvents=!0}finish(){this.stream.push("]",!0);const t=function(t){let n=0;for(const r of t)n+=r.length;const r=new Uint8Array(n);for(let n=0,e=0,i=t.length;n<i;n++){const i=t[n];r.set(i,e),e+=i.length}return r}(this._deflatedData);return this._init(),t}_init(){this._hasEvents=!1,this._deflatedData=[],this.deflate=new H,this.deflate.ondata=(t,n)=>{this._deflatedData.push(t)},this.stream=new N(((t,n)=>{this.deflate.push(t,n)})),this.stream.push("[")}},V={clear:()=>{R.clear()},addEvent:t=>R.addEvent(t),finish:()=>R.finish(),compress:t=>Q(t)};addEventListener("message",(function(t){const n=t.data.method,r=t.data.id,e=t.data.arg;if(n in V&&"function"==typeof V[n])try{const t=V[n](e);postMessage({id:r,method:n,success:!0,response:t})}catch(t){postMessage({id:r,method:n,success:!1,response:t.message}),console.error(t)}})),postMessage({id:void 0,method:"init",success:!0,response:void 0});'; class EventBufferSizeExceededError extends Error { "constructor"() { super("Event buffer exceeded maximum size of 20000000.") } } class EventBufferArray { "constructor"() { this.events = [], this._totalSize = 0, this.hasCheckout = !1 } get "hasEvents"() { return this.events.length > 0 } get "type"() { return "sync" } "destroy"() { this.events = [] } async"addEvent"(c) { const u = JSON.stringify(c).length; if (this._totalSize += u, this._totalSize > Zr) throw new EventBufferSizeExceededError; this.events.push(c) } "finish"() { return new Promise((c => { const u = this.events; this.clear(), c(JSON.stringify(u)) })) } "clear"() { this.events = [], this._totalSize = 0, this.hasCheckout = !1 } "getEarliestTimestamp"() { const c = this.events.map((c => c.timestamp)).sort()[0]; return c ? timestampToMs(c) : null } } class WorkerHandler { "constructor"(c) { this._worker = c, this._id = 0 } "ensureReady"() { return this._ensureReadyPromise || (this._ensureReadyPromise = new Promise(((c, u) => { this._worker.addEventListener("message", (({ "data": d }) => { d.success ? c() : u() }), { "once": !0 }), this._worker.addEventListener("error", (c => { u(c) }), { "once": !0 }) }))), this._ensureReadyPromise } "destroy"() { Ao && Oo.info("Destroying compression worker"), this._worker.terminate() } "postMessage"(c, u) { const d = this._getAndIncrementId(); return new Promise(((v, E) => { const listener = ({ "data": u }) => { const k = u; if (k.method === c && k.id === d) { if (this._worker.removeEventListener("message", listener), !k.success) return Ao && Oo.error("Error in compression worker: ", k.response), void E(new Error("Error in compression worker")); v(k.response) } }; this._worker.addEventListener("message", listener), this._worker.postMessage({ "id": d, "method": c, "arg": u }) })) } "_getAndIncrementId"() { return this._id++ } } class EventBufferCompressionWorker { "constructor"(c) { this._worker = new WorkerHandler(c), this._earliestTimestamp = null, this._totalSize = 0, this.hasCheckout = !1 } get "hasEvents"() { return !!this._earliestTimestamp } get "type"() { return "worker" } "ensureReady"() { return this._worker.ensureReady() } "destroy"() { this._worker.destroy() } "addEvent"(c) { const u = timestampToMs(c.timestamp); (!this._earliestTimestamp || u < this._earliestTimestamp) && (this._earliestTimestamp = u); const d = JSON.stringify(c); return this._totalSize += d.length, this._totalSize > Zr ? Promise.reject(new EventBufferSizeExceededError) : this._sendEventToWorker(d) } "finish"() { return this._finishRequest() } "clear"() { this._earliestTimestamp = null, this._totalSize = 0, this.hasCheckout = !1, this._worker.postMessage("clear").then(null, (c => { Ao && Oo.exception(c, 'Sending "clear" message to worker failed', c) })) } "getEarliestTimestamp"() { return this._earliestTimestamp } "_sendEventToWorker"(c) { return this._worker.postMessage("addEvent", c) } async"_finishRequest"() { const c = await this._worker.postMessage("finish"); return this._earliestTimestamp = null, this._totalSize = 0, c } } class EventBufferProxy { "constructor"(c) { this._fallback = new EventBufferArray, this._compression = new EventBufferCompressionWorker(c), this._used = this._fallback, this._ensureWorkerIsLoadedPromise = this._ensureWorkerIsLoaded() } get "type"() { return this._used.type } get "hasEvents"() { return this._used.hasEvents } get "hasCheckout"() { return this._used.hasCheckout } set "hasCheckout"(c) { this._used.hasCheckout = c } "destroy"() { this._fallback.destroy(), this._compression.destroy() } "clear"() { return this._used.clear() } "getEarliestTimestamp"() { return this._used.getEarliestTimestamp() } "addEvent"(c) { return this._used.addEvent(c) } async"finish"() { return await this.ensureWorkerIsLoaded(), this._used.finish() } "ensureWorkerIsLoaded"() { return this._ensureWorkerIsLoadedPromise } async"_ensureWorkerIsLoaded"() { try { await this._compression.ensureReady() } catch (c) { return void (Ao && Oo.exception(c, "Failed to load the compression worker, falling back to simple buffer")) } await this._switchToCompressionWorker() } async"_switchToCompressionWorker"() { const { "events": c, "hasCheckout": u } = this._fallback, d = []; for (const u of c) d.push(this._compression.addEvent(u)); this._compression.hasCheckout = u, this._used = this._compression; try { await Promise.all(d) } catch (c) { Ao && Oo.exception(c, "Failed to add events when switching buffers.") } } } function createEventBuffer({ "useCompression": c, "workerUrl": u }) { if (c && window.Worker) { const c = function _loadWorker(c) { try { const u = c || function _getWorkerUrl() { if ("undefined" == typeof __SENTRY_EXCLUDE_REPLAY_WORKER__ || !__SENTRY_EXCLUDE_REPLAY_WORKER__) return function e() { const c = new Blob([jo]); return URL.createObjectURL(c) }(); return "" }(); if (!u) return; Ao && Oo.info("Using compression worker" + (c ? ` from ${c}` : "")); const d = new Worker(u); return new EventBufferProxy(d) } catch (c) { Ao && Oo.exception(c, "Failed to create compression worker") } }(u); if (c) return c } return Ao && Oo.info("Using simple buffer"), new EventBufferArray } function hasSessionStorage() { try { return "sessionStorage" in Hr && !!Hr.sessionStorage } catch (c) { return !1 } } function clearSession(c) { !function deleteSession() { if (!hasSessionStorage()) return; try { Hr.sessionStorage.removeItem(zr) } catch (c) { } }(), c.session = void 0 } function isSampled(c) { return void 0 !== c && Math.random() < c } function esm_makeSession(c) { const u = Date.now(); return { "id": c.id || utils_build_esm_misc_uuid4(), "started": c.started || u, "lastActivity": c.lastActivity || u, "segmentId": c.segmentId || 0, "sampled": c.sampled, "previousSessionId": c.previousSessionId } } function saveSession(c) { if (hasSessionStorage()) try { Hr.sessionStorage.setItem(zr, JSON.stringify(c)) } catch (c) { } } function createSession({ "sessionSampleRate": c, "allowBuffering": u, "stickySession": d = !1 }, { "previousSessionId": v } = {}) { const E = function getSessionSampleType(c, u) { return isSampled(c) ? "session" : !!u && "buffer" }(c, u), k = esm_makeSession({ "sampled": E, "previousSessionId": v }); return d && saveSession(k), k } function isExpired(c, u, d = +new Date) { return null === c || void 0 === u || u < 0 || 0 !== u && c + u <= d } function isSessionExpired(c, { "maxReplayDuration": u, "sessionIdleExpire": d, "targetTime": v = Date.now() }) { return isExpired(c.started, u, v) || isExpired(c.lastActivity, d, v) } function shouldRefreshSession(c, { "sessionIdleExpire": u, "maxReplayDuration": d }) { return !!isSessionExpired(c, { "sessionIdleExpire": u, "maxReplayDuration": d }) && ("buffer" !== c.sampled || 0 !== c.segmentId) } function loadOrCreateSession({ "sessionIdleExpire": c, "maxReplayDuration": u, "previousSessionId": d }, v) { const E = v.stickySession && function fetchSession() { if (!hasSessionStorage()) return null; try { const c = Hr.sessionStorage.getItem(zr); if (!c) return null; const u = JSON.parse(c); return Ao && Oo.infoTick("Loading existing session"), esm_makeSession(u) } catch (c) { return null } }(); return E ? shouldRefreshSession(E, { "sessionIdleExpire": c, "maxReplayDuration": u }) ? (Ao && Oo.infoTick("Session in sessionStorage is expired, creating new one..."), createSession(v, { "previousSessionId": E.id })) : E : (Ao && Oo.infoTick("Creating new session"), createSession(v, { "previousSessionId": d })) } function addEventSync(c, u, d) { return !!shouldAddEvent(c, u) && (_addEvent(c, u, d), !0) } async function _addEvent(c, u, d) { if (!c.eventBuffer) return null; try { d && "buffer" === c.recordingMode && c.eventBuffer.clear(), d && (c.eventBuffer.hasCheckout = !0); const v = function maybeApplyCallback(c, u) { try { if ("function" == typeof u && function isCustomEvent(c) { return c.type === mo.Custom }(c)) return u(c) } catch (c) { return Ao && Oo.exception(c, "An error occured in the `beforeAddRecordingEvent` callback, skipping the event..."), null } return c }(u, c.getOptions().beforeAddRecordingEvent); if (!v) return; return await c.eventBuffer.addEvent(v) } catch (u) { const d = u && u instanceof EventBufferSizeExceededError ? "addEventSizeExceeded" : "addEvent"; c.handleException(u), await c.stop({ "reason": d }); const v = build_esm_currentScopes_getClient(); v && v.recordDroppedEvent("internal_sdk_error", "replay") } } function shouldAddEvent(c, u) { if (!c.eventBuffer || c.isPaused() || !c.isEnabled()) return !1; const d = timestampToMs(u.timestamp); return !(d + c.timeouts.sessionIdlePause < Date.now()) && (!(d > c.getContext().initialTimestamp + c.getOptions().maxReplayDuration) || (Ao && Oo.infoTick(`Skipping event with timestamp ${d} because it is after maxReplayDuration`), !1)) } function esm_isErrorEvent(c) { return !c.type } function esm_isTransactionEvent(c) { return "transaction" === c.type } function isFeedbackEvent(c) { return "feedback" === c.type } function handleAfterSendEvent(c) { return (u, d) => { if (!c.isEnabled() || !esm_isErrorEvent(u) && !esm_isTransactionEvent(u)) return; const v = d && d.statusCode; !v || v < 200 || v >= 300 || (esm_isTransactionEvent(u) ? function handleTransactionEvent(c, u) { const d = c.getContext(); u.contexts && u.contexts.trace && u.contexts.trace.trace_id && d.traceIds.size < 100 && d.traceIds.add(u.contexts.trace.trace_id) }(c, u) : function handleErrorEvent(c, u) { const d = c.getContext(); u.event_id && d.errorIds.size < 100 && d.errorIds.add(u.event_id); if ("buffer" !== c.recordingMode || !u.tags || !u.tags.replayId) return; const { "beforeErrorSampling": v } = c.getOptions(); if ("function" == typeof v && !v(u)) return; getNativeImplementation_setTimeout((() => { c.sendBufferedReplayOrFlush() })) }(c, u)) } } function handleBeforeSendEvent(c) { return u => { c.isEnabled() && esm_isErrorEvent(u) && function handleHydrationError(c, u) { const d = u.exception && u.exception.values && u.exception.values[0] && u.exception.values[0].value; if ("string" != typeof d) return; if (d.match(/(reactjs\.org\/docs\/error-decoder\.html\?invariant=|react\.dev\/errors\/)(418|419|422|423|425)/) || d.match(/(does not match server-rendered HTML|Hydration failed because)/i)) { addBreadcrumbEvent(c, createBreadcrumb({ "category": "replay.hydrate-error", "data": { "url": browser_getLocationHref() } })) } }(c, u) } } function handleBreadcrumbs(c) { const u = build_esm_currentScopes_getClient(); u && u.on("beforeAddBreadcrumb", (u => function beforeAddBreadcrumb(c, u) { if (!c.isEnabled() || !isBreadcrumbWithCategory(u)) return; const d = function normalizeBreadcrumb(c) { if (!isBreadcrumbWithCategory(c) || ["fetch", "xhr", "sentry.event", "sentry.transaction"].includes(c.category) || c.category.startsWith("ui.")) return null; if ("console" === c.category) return function normalizeConsoleBreadcrumb(c) { const u = c.data && c.data.arguments; if (!Array.isArray(u) || 0 === u.length) return createBreadcrumb(c); let d = !1; const v = u.map((c => { if (!c) return c; if ("string" == typeof c) return c.length > Wr ? (d = !0, `${c.slice(0, Wr)}…`) : c; if ("object" == typeof c) try { const u = esm_normalize_normalize(c, 7); return JSON.stringify(u).length > Wr ? (d = !0, `${JSON.stringify(u, null, 2).slice(0, Wr)}…`) : u } catch (c) { } return c })); return createBreadcrumb({ ...c, "data": { ...c.data, "arguments": v, ...d ? { "_meta": { "warnings": ["CONSOLE_ARG_TRUNCATED"] } } : {} } }) }(c); return createBreadcrumb(c) }(u); d && addBreadcrumbEvent(c, d) }(c, u))) } function isBreadcrumbWithCategory(c) { return !!c.category } function handleGlobalEventListener(c) { return Object.assign(((u, d) => { if (!c.isEnabled()) return u; if (function isReplayEvent(c) { return "replay_event" === c.type }(u)) return delete u.breadcrumbs, u; if (!esm_isErrorEvent(u) && !esm_isTransactionEvent(u) && !isFeedbackEvent(u)) return u; if (!c.checkAndHandleExpiredSession()) return u; if (isFeedbackEvent(u)) return c.flush(), u.contexts.feedback.replay_id = c.getSessionId(), function addFeedbackBreadcrumb(c, u) { c.triggerUserActivity(), c.addUpdate((() => !u.timestamp || (c.throttledAddEvent({ "type": mo.Custom, "timestamp": 1e3 * u.timestamp, "data": { "tag": "breadcrumb", "payload": { "timestamp": u.timestamp, "type": "default", "category": "sentry.feedback", "data": { "feedbackId": u.event_id } } } }), !1))) }(c, u), u; if (function isRrwebError(c, u) { return !(c.type || !c.exception || !c.exception.values || !c.exception.values.length || !u.originalException || !u.originalException.__rrweb__) }(u, d) && !c.getOptions()._experiments.captureExceptions) return Ao && Oo.log("Ignoring error from rrweb internals", u), null; const v = function shouldSampleForBufferEvent(c, u) { return "buffer" === c.recordingMode && u.message !== Gr && !(!u.exception || u.type) && isSampled(c.getOptions().errorSampleRate) }(c, u); return (v || "session" === c.recordingMode) && (u.tags = { ...u.tags, "replayId": c.getSessionId() }), u }), { "id": "Replay" }) } function createPerformanceSpans(c, u) { return u.map((({ "type": u, "start": d, "end": v, "name": E, "data": k }) => { const R = c.throttledAddEvent({ "type": mo.Custom, "timestamp": d, "data": { "tag": "performanceSpan", "payload": { "op": u, "description": E, "startTimestamp": d, "endTimestamp": v, "data": k } } }); return "string" == typeof R ? Promise.resolve(null) : R })) } function handleHistorySpanListener(c) { return u => { if (!c.isEnabled()) return; const d = function handleHistory(c) { const { "from": u, "to": d } = c, v = Date.now() / 1e3; return { "type": "navigation.push", "start": v, "end": v, "name": d, "data": { "previous": u } } }(u); null !== d && (c.getContext().urls.push(d.name), c.triggerUserActivity(), c.addUpdate((() => (createPerformanceSpans(c, [d]), !1)))) } } function addNetworkBreadcrumb(c, u) { c.isEnabled() && null !== u && (function shouldFilterRequest(c, u) { return (!Ao || !c.getOptions()._experiments.traceInternals) && isSentryRequestUrl_isSentryRequestUrl(u, build_esm_currentScopes_getClient()) }(c, u.name) || c.addUpdate((() => (createPerformanceSpans(c, [u]), !0)))) } function getBodySize(c) { if (!c) return; const u = new TextEncoder; try { if ("string" == typeof c) return u.encode(c).length; if (c instanceof URLSearchParams) return u.encode(c.toString()).length; if (c instanceof FormData) { const d = _serializeFormData(c); return u.encode(d).length } if (c instanceof Blob) return c.size; if (c instanceof ArrayBuffer) return c.byteLength } catch (c) { } } function parseContentLengthHeader(c) { if (!c) return; const u = parseInt(c, 10); return isNaN(u) ? void 0 : u } function getBodyString(c) { try { if ("string" == typeof c) return [c]; if (c instanceof URLSearchParams) return [c.toString()]; if (c instanceof FormData) return [_serializeFormData(c)]; if (!c) return [void 0] } catch (u) { return Ao && Oo.exception(u, "Failed to serialize body", c), [void 0, "BODY_PARSE_ERROR"] } return Ao && Oo.info("Skipping network body because of body type", c), [void 0, "UNPARSEABLE_BODY_TYPE"] } function mergeWarning(c, u) { if (!c) return { "headers": {}, "size": void 0, "_meta": { "warnings": [u] } }; const d = { ...c._meta }, v = d.warnings || []; return d.warnings = [...v, u], c._meta = d, c } function makeNetworkReplayBreadcrumb(c, u) { if (!u) return null; const { "startTimestamp": d, "endTimestamp": v, "url": E, "method": k, "statusCode": R, "request": U, "response": H } = u; return { "type": c, "start": d / 1e3, "end": v / 1e3, "name": E, "data": node_modules_sentry_utils_build_esm_object_dropUndefinedKeys({ "method": k, "statusCode": R, "request": U, "response": H }) } } function buildSkippedNetworkRequestOrResponse(c) { return { "headers": {}, "size": c, "_meta": { "warnings": ["URL_SKIPPED"] } } } function buildNetworkRequestOrResponse(c, u, d) { if (!u && 0 === Object.keys(c).length) return; if (!u) return { "headers": c }; if (!d) return { "headers": c, "size": u }; const v = { "headers": c, "size": u }, { "body": E, "warnings": k } = function normalizeNetworkBody(c) { if (!c || "string" != typeof c) return { "body": c }; const u = c.length > Vr, d = function _strIsProbablyJson(c) { const u = c[0], d = c[c.length - 1]; return "[" === u && "]" === d || "{" === u && "}" === d }(c); if (u) { const u = c.slice(0, Vr); return d ? { "body": u, "warnings": ["MAYBE_JSON_TRUNCATED"] } : { "body": `${u}…`, "warnings": ["TEXT_TRUNCATED"] } } if (d) try { return { "body": JSON.parse(c) } } catch (c) { } return { "body": c } }(d); return v.body = E, k && k.length > 0 && (v._meta = { "warnings": k }), v } function getAllowedHeaders(c, u) { return Object.entries(c).reduce(((d, [v, E]) => { const k = v.toLowerCase(); return u.includes(k) && c[v] && (d[k] = E), d }), {}) } function _serializeFormData(c) { return new URLSearchParams(c).toString() } function urlMatches(c, u) { const d = function getFullUrl(c, u = Hr.document.baseURI) { if (c.startsWith("http://") || c.startsWith("https://") || c.startsWith(Hr.location.origin)) return c; const d = new URL(c, u); if (d.origin !== new URL(u).origin) return c; const v = d.href; if (!c.endsWith("/") && v.endsWith("/")) return v.slice(0, -1); return v }(c); return function string_stringMatchesSomePattern(c, u = [], d = !1) { return u.some((u => string_isMatchingPattern(c, u, d))) }(d, u) } async function captureFetchBreadcrumbToReplay(c, u, d) { try { const v = await async function _prepareFetchData(c, u, d) { const v = Date.now(), { "startTimestamp": E = v, "endTimestamp": k = v } = u, { "url": R, "method": U, "status_code": H = 0, "request_body_size": G, "response_body_size": W } = c.data, Z = urlMatches(R, d.networkDetailAllowUrls) && !urlMatches(R, d.networkDetailDenyUrls), Y = Z ? function _getRequestInfo({ "networkCaptureBodies": c, "networkRequestHeaders": u }, d, v) { const E = d ? function getRequestHeaders(c, u) { if (1 === c.length && "string" != typeof c[0]) return getHeadersFromOptions(c[0], u); if (2 === c.length) return getHeadersFromOptions(c[1], u); return {} }(d, u) : {}; if (!c) return buildNetworkRequestOrResponse(E, v, void 0); const k = _getFetchRequestArgBody(d), [R, U] = getBodyString(k), H = buildNetworkRequestOrResponse(E, v, R); if (U) return mergeWarning(H, U); return H }(d, u.input, G) : buildSkippedNetworkRequestOrResponse(G), J = await async function _getResponseInfo(c, { "networkCaptureBodies": u, "networkResponseHeaders": d }, v, E) { if (!c && void 0 !== E) return buildSkippedNetworkRequestOrResponse(E); const k = v ? getAllHeaders(v.headers, d) : {}; if (!v || !u && void 0 !== E) return buildNetworkRequestOrResponse(k, E, void 0); const [R, U] = await async function _parseFetchResponseBody(c) { const u = function _tryCloneResponse(c) { try { return c.clone() } catch (c) { Ao && Oo.exception(c, "Failed to clone response body") } }(c); if (!u) return [void 0, "BODY_PARSE_ERROR"]; try { const c = await function _tryGetResponseText(c) { return new Promise(((u, d) => { const v = getNativeImplementation_setTimeout((() => d(new Error("Timeout while trying to read response body"))), 500); (async function _getResponseText(c) { return await c.text() })(c).then((c => u(c)), (c => d(c))).finally((() => clearTimeout(v))) })) }(u); return [c] } catch (c) { return Ao && Oo.exception(c, "Failed to get text body from response"), [void 0, "BODY_PARSE_ERROR"] } }(v), H = function getResponseData(c, { "networkCaptureBodies": u, "responseBodySize": d, "captureDetails": v, "headers": E }) { try { const k = c && c.length && void 0 === d ? getBodySize(c) : d; return v ? buildNetworkRequestOrResponse(E, k, u ? c : void 0) : buildSkippedNetworkRequestOrResponse(k) } catch (c) { return Ao && Oo.exception(c, "Failed to serialize response body"), buildNetworkRequestOrResponse(E, d, void 0) } }(R, { "networkCaptureBodies": u, "responseBodySize": E, "captureDetails": c, "headers": k }); if (U) return mergeWarning(H, U); return H }(Z, d, u.response, W); return { "startTimestamp": E, "endTimestamp": k, "url": R, "method": U, "statusCode": H, "request": Y, "response": J } }(c, u, d), E = makeNetworkReplayBreadcrumb("resource.fetch", v); addNetworkBreadcrumb(d.replay, E) } catch (c) { Ao && Oo.exception(c, "Failed to capture fetch breadcrumb") } } function _getFetchRequestArgBody(c = []) { if (2 === c.length && "object" == typeof c[1]) return c[1].body } function getAllHeaders(c, u) { const d = {}; return u.forEach((u => { c.get(u) && (d[u] = c.get(u)) })), d } function getHeadersFromOptions(c, u) { if (!c) return {}; const d = c.headers; return d ? d instanceof Headers ? getAllHeaders(d, u) : Array.isArray(d) ? {} : getAllowedHeaders(d, u) : {} } async function captureXhrBreadcrumbToReplay(c, u, d) { try { const v = function _prepareXhrData(c, u, d) { const v = Date.now(), { "startTimestamp": E = v, "endTimestamp": k = v, "input": R, "xhr": U } = u, { "url": H, "method": G, "status_code": W = 0, "request_body_size": Z, "response_body_size": Y } = c.data; if (!H) return null; if (!U || !urlMatches(H, d.networkDetailAllowUrls) || urlMatches(H, d.networkDetailDenyUrls)) { return { "startTimestamp": E, "endTimestamp": k, "url": H, "method": G, "statusCode": W, "request": buildSkippedNetworkRequestOrResponse(Z), "response": buildSkippedNetworkRequestOrResponse(Y) } } const J = U[Ot], K = J ? getAllowedHeaders(J.request_headers, d.networkRequestHeaders) : {}, X = getAllowedHeaders(function getResponseHeaders(c) { const u = c.getAllResponseHeaders(); if (!u) return {}; return u.split("\r\n").reduce(((c, u) => { const [d, v] = u.split(": "); return v && (c[d.toLowerCase()] = v), c }), {}) }(U), d.networkResponseHeaders), [Q, ee] = d.networkCaptureBodies ? getBodyString(R) : [void 0], [te, ne] = d.networkCaptureBodies ? function _getXhrResponseBody(c) { const u = []; try { return [c.responseText] } catch (c) { u.push(c) } try { return function _parseXhrResponse(c, u) { try { if ("string" == typeof c) return [c]; if (c instanceof Document) return [c.body.outerHTML]; if ("json" === u && c && "object" == typeof c) return [JSON.stringify(c)]; if (!c) return [void 0] } catch (u) { return Ao && Oo.exception(u, "Failed to serialize body", c), [void 0, "BODY_PARSE_ERROR"] } return Ao && Oo.info("Skipping network body because of body type", c), [void 0, "UNPARSEABLE_BODY_TYPE"] }(c.response, c.responseType) } catch (c) { u.push(c) } return Ao && Oo.warn("Failed to get xhr response body", ...u), [void 0] }(U) : [void 0], re = buildNetworkRequestOrResponse(K, Z, Q), oe = buildNetworkRequestOrResponse(X, Y, te); return { "startTimestamp": E, "endTimestamp": k, "url": H, "method": G, "statusCode": W, "request": ee ? mergeWarning(re, ee) : re, "response": ne ? mergeWarning(oe, ne) : oe } }(c, u, d), E = makeNetworkReplayBreadcrumb("resource.xhr", v); addNetworkBreadcrumb(d.replay, E) } catch (c) { Ao && Oo.exception(c, "Failed to capture xhr breadcrumb") } } function enrichXhrBreadcrumb(c, u) { const { "xhr": d, "input": v } = u; if (!d) return; const E = getBodySize(v), k = d.getResponseHeader("content-length") ? parseContentLengthHeader(d.getResponseHeader("content-length")) : function _getBodySize(c, u) { try { return getBodySize("json" === u && c && "object" == typeof c ? JSON.stringify(c) : c) } catch (c) { return } }(d.response, d.responseType); void 0 !== E && (c.data.request_body_size = E), void 0 !== k && (c.data.response_body_size = k) } function handleNetworkBreadcrumbs(c) { const u = build_esm_currentScopes_getClient(); try { const { "networkDetailAllowUrls": d, "networkDetailDenyUrls": v, "networkCaptureBodies": E, "networkRequestHeaders": k, "networkResponseHeaders": R } = c.getOptions(), U = { "replay": c, "networkDetailAllowUrls": d, "networkDetailDenyUrls": v, "networkCaptureBodies": E, "networkRequestHeaders": k, "networkResponseHeaders": R }; u && u.on("beforeAddBreadcrumb", ((c, u) => function beforeAddNetworkBreadcrumb(c, u, d) { if (!u.data) return; try { (function _isXhrBreadcrumb(c) { return "xhr" === c.category })(u) && function _isXhrHint(c) { return c && c.xhr }(d) && (enrichXhrBreadcrumb(u, d), captureXhrBreadcrumbToReplay(u, d, c)), function _isFetchBreadcrumb(c) { return "fetch" === c.category }(u) && function _isFetchHint(c) { return c && c.response }(d) && (!function enrichFetchBreadcrumb(c, u) { const { "input": d, "response": v } = u, E = getBodySize(d ? _getFetchRequestArgBody(d) : void 0), k = v ? parseContentLengthHeader(v.headers.get("content-length")) : void 0; void 0 !== E && (c.data.request_body_size = E), void 0 !== k && (c.data.response_body_size = k) }(u, d), captureFetchBreadcrumbToReplay(u, d, c)) } catch (c) { Ao && Oo.exception(c, "Error when enriching network breadcrumb") } }(U, c, u))) } catch (c) { } } function addGlobalListeners(c) { const u = build_esm_currentScopes_getClient(); addClickKeypressInstrumentationHandler(handleDomListener(c)), addHistoryInstrumentationHandler(handleHistorySpanListener(c)), handleBreadcrumbs(c), handleNetworkBreadcrumbs(c); !function esm_exports_addEventProcessor(c) { build_esm_currentScopes_getIsolationScope().addEventProcessor(c) }(handleGlobalEventListener(c)), u && (u.on("beforeSendEvent", handleBeforeSendEvent(c)), u.on("afterSendEvent", handleAfterSendEvent(c)), u.on("createDsc", (u => { const d = c.getSessionId(); if (d && c.isEnabled() && "session" === c.recordingMode) { c.checkAndHandleExpiredSession() && (u.replay_id = d) } })), u.on("spanStart", (u => { c.lastActiveSpan = u })), u.on("spanEnd", (u => { c.lastActiveSpan = u })), u.on("beforeSendFeedback", ((u, d) => { const v = c.getSessionId(); d && d.includeReplay && c.isEnabled() && v && u.contexts && u.contexts.feedback && (u.contexts.feedback.replay_id = v) }))) } function createMemoryEntry(c) { const { "jsHeapSizeLimit": u, "totalJSHeapSize": d, "usedJSHeapSize": v } = c, E = Date.now() / 1e3; return { "type": "memory", "name": "memory", "start": E, "end": E, "data": { "memory": { "jsHeapSizeLimit": u, "totalJSHeapSize": d, "usedJSHeapSize": v } } } } function getHandleRecordingEmit(c) { let u = !1; return (d, v) => { if (!c.checkAndHandleExpiredSession()) return void (Ao && Oo.warn("Received replay event after session expired.")); const E = v || !u; u = !0, c.clickDetector && updateClickDetectorForRecordingEvent(c.clickDetector, d), c.addUpdate((() => { if ("buffer" === c.recordingMode && E && c.setInitialState(), !addEventSync(c, d, E)) return !0; if (!E) return !1; if (function addSettingsEvent(c, u) { if (!u || !c.session || 0 !== c.session.segmentId) return; addEventSync(c, function createOptionsEvent(c) { const u = c.getOptions(); return { "type": mo.Custom, "timestamp": Date.now(), "data": { "tag": "options", "payload": { "shouldRecordCanvas": c.isRecordingCanvas(), "sessionSampleRate": u.sessionSampleRate, "errorSampleRate": u.errorSampleRate, "useCompressionOption": u.useCompression, "blockAllMedia": u.blockAllMedia, "maskAllText": u.maskAllText, "maskAllInputs": u.maskAllInputs, "useCompression": !!c.eventBuffer && "worker" === c.eventBuffer.type, "networkDetailHasUrls": u.networkDetailAllowUrls.length > 0, "networkCaptureBodies": u.networkCaptureBodies, "networkRequestHasHeaders": u.networkRequestHeaders.length > 0, "networkResponseHasHeaders": u.networkResponseHeaders.length > 0 } } } }(c), !1) }(c, E), c.session && c.session.previousSessionId) return !0; if ("buffer" === c.recordingMode && c.session && c.eventBuffer) { const u = c.eventBuffer.getEarliestTimestamp(); u && (Ao && Oo.info(`Updating session start time to earliest event in buffer to ${new Date(u)}`), c.session.started = u, c.getOptions().stickySession && saveSession(c.session)) } return "session" === c.recordingMode && c.flush(), !0 })) } } function createReplayEnvelope(c, u, d, v) { return function esm_envelope_createEnvelope(c, u = []) { return [c, u] }(function esm_envelope_createEventEnvelopeHeaders(c, u, d, v) { const E = c.sdkProcessingMetadata && c.sdkProcessingMetadata.dynamicSamplingContext; return { "event_id": c.event_id, "sent_at": (new Date).toISOString(), ...u && { "sdk": u }, ...!!d && v && { "dsn": esm_dsn_dsnToString(v) }, ...E && { "trace": node_modules_sentry_utils_build_esm_object_dropUndefinedKeys({ ...E }) } } }(c, function esm_envelope_getSdkMetadataForEnvelopeHeader(c) { if (!c || !c.sdk) return; const { "name": u, "version": d } = c.sdk; return { "name": u, "version": d } }(c), v, d), [[{ "type": "replay_event" }, c], [{ "type": "replay_recording", "length": "string" == typeof u ? (new TextEncoder).encode(u).length : u.length }, u]]) } async function sendReplayRequest({ "recordingData": c, "replayId": u, "segmentId": d, "eventContext": v, "timestamp": E, "session": k }) { const R = function prepareRecordingData({ "recordingData": c, "headers": u }) { let d; const v = `${JSON.stringify(u)}\n`; if ("string" == typeof c) d = `${v}${c}`; else { const u = (new TextEncoder).encode(v); d = new Uint8Array(u.length + c.length), d.set(u), d.set(c, u.length) } return d }({ "recordingData": c, "headers": { "segment_id": d } }), { "urls": U, "errorIds": H, "traceIds": G, "initialTimestamp": W } = v, Z = build_esm_currentScopes_getClient(), Y = build_esm_currentScopes_getCurrentScope(), J = Z && Z.getTransport(), K = Z && Z.getDsn(); if (!(Z && J && K && k.sampled)) return syncpromise_resolvedSyncPromise({}); const X = { "type": qr, "replay_start_timestamp": W / 1e3, "timestamp": E / 1e3, "error_ids": H, "trace_ids": G, "urls": U, "replay_id": u, "segment_id": d, "replay_type": k.sampled }, Q = await async function prepareReplayEvent({ "client": c, "scope": u, "replayId": d, "event": v }) { const E = { "event_id": d, "integrations": "object" != typeof c._integrations || null === c._integrations || Array.isArray(c._integrations) ? void 0 : Object.keys(c._integrations) }; c.emit("preprocessEvent", v, E); const k = await utils_prepareEvent_prepareEvent(c.getOptions(), v, E, u, c, build_esm_currentScopes_getIsolationScope()); if (!k) return null; k.platform = k.platform || "javascript"; const R = c.getSdkMetadata(), { "name": U, "version": H } = R && R.sdk || {}; return k.sdk = { ...k.sdk, "name": U || "sentry.javascript.unknown", "version": H || "0.0.0" }, k }({ "scope": Y, "client": Z, "replayId": u, "event": X }); if (!Q) return Z.recordDroppedEvent("event_processor", "replay", X), Ao && Oo.info("An event processor returned `null`, will not send event."), syncpromise_resolvedSyncPromise({}); delete Q.sdkProcessingMetadata; const ee = createReplayEnvelope(Q, R, K, Z.getOptions().tunnel); let te; try { te = await J.send(ee) } catch (c) { const u = new Error(Gr); try { u.cause = c } catch (c) { } throw u } if ("number" == typeof te.statusCode && (te.statusCode < 200 || te.statusCode >= 300)) throw new TransportStatusCodeError(te.statusCode); const ne = ratelimit_updateRateLimits({}, te); if (function ratelimit_isRateLimited(c, u, d = Date.now()) { return function ratelimit_disabledUntil(c, u) { return c[u] || c.all || 0 }(c, u) > d }(ne, "replay")) throw new RateLimitError(ne); return te } class TransportStatusCodeError extends Error { "constructor"(c) { super(`Transport returned status code ${c}`) } } class RateLimitError extends Error { "constructor"(c) { super("Rate limit hit"), this.rateLimits = c } } async function sendReplay(c, u = { "count": 0, "interval": 5e3 }) { const { "recordingData": d, "options": v } = c; if (d.length) try { return await sendReplayRequest(c), !0 } catch (d) { if (d instanceof TransportStatusCodeError || d instanceof RateLimitError) throw d; if (function esm_exports_setContext(c, u) { build_esm_currentScopes_getIsolationScope().setContext(c, u) }("Replays", { "_retryCount": u.count }), Ao && v._experiments && v._experiments.captureExceptions && esm_exports_captureException(d), u.count >= 3) { const c = new Error(`${Gr} - max retries exceeded`); try { c.cause = d } catch (c) { } throw c } return u.interval *= ++u.count, new Promise(((d, v) => { getNativeImplementation_setTimeout((async () => { try { await sendReplay(c, u), d(!0) } catch (c) { v(c) } }), u.interval) })) } } const Bo = "__THROTTLED"; function throttle(c, u, d) { const v = new Map; let E = !1; return (...k) => { const R = Math.floor(Date.now() / 1e3); if ((c => { const u = c - d; v.forEach(((c, d) => { d < u && v.delete(d) })) })(R), [...v.values()].reduce(((c, u) => c + u), 0) >= u) { const c = E; return E = !0, c ? "__SKIPPED" : Bo } E = !1; const U = v.get(R) || 0; return v.set(R, U + 1), c(...k) } } class ReplayContainer { "constructor"({ "options": c, "recordingOptions": u }) { ReplayContainer.prototype.__init.call(this), ReplayContainer.prototype.__init2.call(this), ReplayContainer.prototype.__init3.call(this), ReplayContainer.prototype.__init4.call(this), ReplayContainer.prototype.__init5.call(this), ReplayContainer.prototype.__init6.call(this), this.eventBuffer = null, this.performanceEntries = [], this.replayPerformanceEntries = [], this.recordingMode = "session", this.timeouts = { "sessionIdlePause": 3e5, "sessionIdleExpire": 9e5 }, this._lastActivity = Date.now(), this._isEnabled = !1, this._isPaused = !1, this._requiresManualStart = !1, this._hasInitializedCoreListeners = !1, this._context = { "errorIds": new Set, "traceIds": new Set, "urls": [], "initialTimestamp": Date.now(), "initialUrl": "" }, this._recordingOptions = u, this._options = c, this._debouncedFlush = function debounce(c, u, d) { let v, E, k; const R = d && d.maxWait ? Math.max(d.maxWait, u) : 0; function invokeFunc() { return cancelTimers(), v = c(), v } function cancelTimers() { void 0 !== E && clearTimeout(E), void 0 !== k && clearTimeout(k), E = k = void 0 } function debounced() { return E && clearTimeout(E), E = getNativeImplementation_setTimeout(invokeFunc, u), R && void 0 === k && (k = getNativeImplementation_setTimeout(invokeFunc, R)), v } return debounced.cancel = cancelTimers, debounced.flush = function flush() { return void 0 !== E || void 0 !== k ? invokeFunc() : v }, debounced }((() => this._flush()), this._options.flushMinDelay, { "maxWait": this._options.flushMaxDelay }), this._throttledAddEvent = throttle(((c, u) => function addEvent(c, u, d) { return shouldAddEvent(c, u) ? _addEvent(c, u, d) : Promise.resolve(null) }(this, c, u)), 300, 5); const { "slowClickTimeout": d, "slowClickIgnoreSelectors": v } = this.getOptions(), E = d ? { "threshold": Math.min(3e3, d), "timeout": d, "scrollTimeout": 300, "ignoreSelector": v ? v.join(",") : "" } : void 0; if (E && (this.clickDetector = new ClickDetector(this, E)), Ao) { const u = c._experiments; Oo.setConfig({ "captureExceptions": !!u.captureExceptions, "traceInternals": !!u.traceInternals }) } } "getContext"() { return this._context } "isEnabled"() { return this._isEnabled } "isPaused"() { return this._isPaused } "isRecordingCanvas"() { return Boolean(this._canvas) } "getOptions"() { return this._options } "handleException"(c) { Ao && Oo.exception(c) } "initializeSampling"(c) { const { "errorSampleRate": u, "sessionSampleRate": d } = this._options, v = u <= 0 && d <= 0; this._requiresManualStart = v, v || (this._initializeSessionForSampling(c), this.session ? !1 !== this.session.sampled && (this.recordingMode = "buffer" === this.session.sampled && 0 === this.session.segmentId ? "buffer" : "session", Ao && Oo.infoTick(`Starting replay in ${this.recordingMode} mode`), this._initializeRecording()) : Ao && Oo.exception(new Error("Unable to initialize and create session"))) } "start"() { if (this._isEnabled && "session" === this.recordingMode) return void (Ao && Oo.info("Recording is already in progress")); if (this._isEnabled && "buffer" === this.recordingMode) return void (Ao && Oo.info("Buffering is in progress, call `flush()` to save the replay")); Ao && Oo.infoTick("Starting replay in session mode"), this._updateUserActivity(); const c = loadOrCreateSession({ "maxReplayDuration": this._options.maxReplayDuration, "sessionIdleExpire": this.timeouts.sessionIdleExpire }, { "stickySession": this._options.stickySession, "sessionSampleRate": 1, "allowBuffering": !1 }); this.session = c, this._initializeRecording() } "startBuffering"() { if (this._isEnabled) return void (Ao && Oo.info("Buffering is in progress, call `flush()` to save the replay")); Ao && Oo.infoTick("Starting replay in buffer mode"); const c = loadOrCreateSession({ "sessionIdleExpire": this.timeouts.sessionIdleExpire, "maxReplayDuration": this._options.maxReplayDuration }, { "stickySession": this._options.stickySession, "sessionSampleRate": 0, "allowBuffering": !0 }); this.session = c, this.recordingMode = "buffer", this._initializeRecording() } "startRecording"() { try { const c = this._canvas; this._stopRecording = record({ ...this._recordingOptions, ..."buffer" === this.recordingMode && { "checkoutEveryNms": 6e4 }, "emit": getHandleRecordingEmit(this), "onMutation": this._onMutationHandler, ...c ? { "recordCanvas": c.recordCanvas, "getCanvasManager": c.getCanvasManager, "sampling": c.sampling, "dataURLOptions": c.dataURLOptions } : {} }) } catch (c) { this.handleException(c) } } "stopRecording"() { try { return this._stopRecording && (this._stopRecording(), this._stopRecording = void 0), !0 } catch (c) { return this.handleException(c), !1 } } async"stop"({ "forceFlush": c = !1, "reason": u } = {}) { if (this._isEnabled) { this._isEnabled = !1; try { Ao && Oo.info("Stopping Replay" + (u ? ` triggered by ${u}` : "")), this._removeListeners(), this.stopRecording(), this._debouncedFlush.cancel(), c && await this._flush({ "force": !0 }), this.eventBuffer && this.eventBuffer.destroy(), this.eventBuffer = null, clearSession(this) } catch (c) { this.handleException(c) } } } "pause"() { this._isPaused || (this._isPaused = !0, this.stopRecording(), Ao && Oo.info("Pausing replay")) } "resume"() { this._isPaused && this._checkSession() && (this._isPaused = !1, this.startRecording(), Ao && Oo.info("Resuming replay")) } async"sendBufferedReplayOrFlush"({ "continueRecording": c = !0 } = {}) { if ("session" === this.recordingMode) return this.flushImmediate(); const u = Date.now(); Ao && Oo.info("Converting buffer to session"), await this.flushImmediate(); const d = this.stopRecording(); c && d && "session" !== this.recordingMode && (this.recordingMode = "session", this.session && (this._updateUserActivity(u), this._updateSessionActivity(u), this._maybeSaveSession()), this.startRecording()) } "addUpdate"(c) { const u = c(); "buffer" !== this.recordingMode && !0 !== u && this._debouncedFlush() } "triggerUserActivity"() { if (this._updateUserActivity(), this._stopRecording) this.checkAndHandleExpiredSession(), this._updateSessionActivity(); else { if (!this._checkSession()) return; this.resume() } } "updateUserActivity"() { this._updateUserActivity(), this._updateSessionActivity() } "conditionalFlush"() { return "buffer" === this.recordingMode ? Promise.resolve() : this.flushImmediate() } "flush"() { return this._debouncedFlush() } "flushImmediate"() { return this._debouncedFlush(), this._debouncedFlush.flush() } "cancelFlush"() { this._debouncedFlush.cancel() } "getSessionId"() { return this.session && this.session.id } "checkAndHandleExpiredSession"() { if (!(this._lastActivity && isExpired(this._lastActivity, this.timeouts.sessionIdlePause) && this.session && "session" === this.session.sampled)) return !!this._checkSession(); this.pause() } "setInitialState"() { const c = `${Hr.location.pathname}${Hr.location.hash}${Hr.location.search}`, u = `${Hr.location.origin}${c}`; this.performanceEntries = [], this.replayPerformanceEntries = [], this._clearContext(), this._context.initialUrl = u, this._context.initialTimestamp = Date.now(), this._context.urls.push(u) } "throttledAddEvent"(c, u) { const d = this._throttledAddEvent(c, u); if (d === Bo) { const c = createBreadcrumb({ "category": "replay.throttled" }); this.addUpdate((() => !addEventSync(this, { "type": 5, "timestamp": c.timestamp || 0, "data": { "tag": "breadcrumb", "payload": c, "metric": !0 } }))) } return d } "getCurrentRoute"() { const c = this.lastActiveSpan || spanUtils_getActiveSpan(), u = c && spanUtils_getRootSpan(c), d = (u && utils_spanUtils_spanToJSON(u).data || {})[cr]; if (u && d && ["route", "custom"].includes(d)) return utils_spanUtils_spanToJSON(u).description } "_initializeRecording"() { this.setInitialState(), this._updateSessionActivity(), this.eventBuffer = createEventBuffer({ "useCompression": this._options.useCompression, "workerUrl": this._options.workerUrl }), this._removeListeners(), this._addListeners(), this._isEnabled = !0, this._isPaused = !1, this.startRecording() } "_initializeSessionForSampling"(c) { const u = this._options.errorSampleRate > 0, d = loadOrCreateSession({ "sessionIdleExpire": this.timeouts.sessionIdleExpire, "maxReplayDuration": this._options.maxReplayDuration, "previousSessionId": c }, { "stickySession": this._options.stickySession, "sessionSampleRate": this._options.sessionSampleRate, "allowBuffering": u }); this.session = d } "_checkSession"() { if (!this.session) return !1; const c = this.session; return !shouldRefreshSession(c, { "sessionIdleExpire": this.timeouts.sessionIdleExpire, "maxReplayDuration": this._options.maxReplayDuration }) || (this._refreshSession(c), !1) } async"_refreshSession"(c) { this._isEnabled && (await this.stop({ "reason": "refresh session" }), this.initializeSampling(c.id)) } "_addListeners"() { try { Hr.document.addEventListener("visibilitychange", this._handleVisibilityChange), Hr.addEventListener("blur", this._handleWindowBlur), Hr.addEventListener("focus", this._handleWindowFocus), Hr.addEventListener("keydown", this._handleKeyboardEvent), this.clickDetector && this.clickDetector.addListeners(), this._hasInitializedCoreListeners || (addGlobalListeners(this), this._hasInitializedCoreListeners = !0) } catch (c) { this.handleException(c) } this._performanceCleanupCallback = function setupPerformanceObserver(c) { function addPerformanceEntry(u) { c.performanceEntries.includes(u) || c.performanceEntries.push(u) } function onEntries({ "entries": c }) { c.forEach(addPerformanceEntry) } const u = []; return ["navigation", "paint", "resource"].forEach((c => { u.push(addPerformanceInstrumentationHandler(c, onEntries)) })), u.push(addLcpInstrumentationHandler(webVitalHandler(getLargestContentfulPaint, c)), addClsInstrumentationHandler(webVitalHandler(getCumulativeLayoutShift, c)), addFidInstrumentationHandler(webVitalHandler(getFirstInputDelay, c)), addInpInstrumentationHandler(webVitalHandler(getInteractionToNextPaint, c))), () => { u.forEach((c => c())) } }(this) } "_removeListeners"() { try { Hr.document.removeEventListener("visibilitychange", this._handleVisibilityChange), Hr.removeEventListener("blur", this._handleWindowBlur), Hr.removeEventListener("focus", this._handleWindowFocus), Hr.removeEventListener("keydown", this._handleKeyboardEvent), this.clickDetector && this.clickDetector.removeListeners(), this._performanceCleanupCallback && this._performanceCleanupCallback() } catch (c) { this.handleException(c) } } "__init"() { this._handleVisibilityChange = () => { "visible" === Hr.document.visibilityState ? this._doChangeToForegroundTasks() : this._doChangeToBackgroundTasks() } } "__init2"() { this._handleWindowBlur = () => { const c = createBreadcrumb({ "category": "ui.blur" }); this._doChangeToBackgroundTasks(c) } } "__init3"() { this._handleWindowFocus = () => { const c = createBreadcrumb({ "category": "ui.focus" }); this._doChangeToForegroundTasks(c) } } "__init4"() { this._handleKeyboardEvent = c => { handleKeyboardEvent(this, c) } } "_doChangeToBackgroundTasks"(c) { if (!this.session) return; isSessionExpired(this.session, { "maxReplayDuration": this._options.maxReplayDuration, "sessionIdleExpire": this.timeouts.sessionIdleExpire }) || (c && this._createCustomBreadcrumb(c), this.conditionalFlush()) } "_doChangeToForegroundTasks"(c) { if (!this.session) return; this.checkAndHandleExpiredSession() ? c && this._createCustomBreadcrumb(c) : Ao && Oo.info("Document has become active, but session has expired") } "_updateUserActivity"(c = Date.now()) { this._lastActivity = c } "_updateSessionActivity"(c = Date.now()) { this.session && (this.session.lastActivity = c, this._maybeSaveSession()) } "_createCustomBreadcrumb"(c) { this.addUpdate((() => { this.throttledAddEvent({ "type": mo.Custom, "timestamp": c.timestamp || 0, "data": { "tag": "breadcrumb", "payload": c } }) })) } "_addPerformanceEntries"() { const c = function createPerformanceEntries(c) { return c.map(createPerformanceEntry).filter(Boolean) }(this.performanceEntries).concat(this.replayPerformanceEntries); return this.performanceEntries = [], this.replayPerformanceEntries = [], Promise.all(createPerformanceSpans(this, c)) } "_clearContext"() { this._context.errorIds.clear(), this._context.traceIds.clear(), this._context.urls = [] } "_updateInitialTimestampFromEventBuffer"() { const { "session": c, "eventBuffer": u } = this; if (!c || !u || this._requiresManualStart) return; if (c.segmentId) return; const d = u.getEarliestTimestamp(); d && d < this._context.initialTimestamp && (this._context.initialTimestamp = d) } "_popEventContext"() { const c = { "initialTimestamp": this._context.initialTimestamp, "initialUrl": this._context.initialUrl, "errorIds": Array.from(this._context.errorIds), "traceIds": Array.from(this._context.traceIds), "urls": this._context.urls }; return this._clearContext(), c } async"_runFlush"() { const c = this.getSessionId(); if (this.session && this.eventBuffer && c) { if (await this._addPerformanceEntries(), this.eventBuffer && this.eventBuffer.hasEvents && (await async function addMemoryEntry(c) { try { return Promise.all(createPerformanceSpans(c, [createMemoryEntry(Hr.performance.memory)])) } catch (c) { return [] } }(this), this.eventBuffer && c === this.getSessionId())) try { this._updateInitialTimestampFromEventBuffer(); const u = Date.now(); if (u - this._context.initialTimestamp > this._options.maxReplayDuration + 3e4) throw new Error("Session is too long, not sending replay"); const d = this._popEventContext(), v = this.session.segmentId++; this._maybeSaveSession(); const E = await this.eventBuffer.finish(); await sendReplay({ "replayId": c, "recordingData": E, "segmentId": v, "eventContext": d, "session": this.session, "options": this.getOptions(), "timestamp": u }) } catch (c) { this.handleException(c), this.stop({ "reason": "sendReplay" }); const u = build_esm_currentScopes_getClient(); u && u.recordDroppedEvent("send_error", "replay") } } else Ao && Oo.error("No session or eventBuffer found to flush.") } "__init5"() { this._flush = async ({ "force": c = !1 } = {}) => { if (!this._isEnabled && !c) return; if (!this.checkAndHandleExpiredSession()) return void (Ao && Oo.error("Attempting to finish replay event after session expired.")); if (!this.session) return; const u = this.session.started, d = Date.now() - u; this._debouncedFlush.cancel(); const v = d < this._options.minReplayDuration, E = d > this._options.maxReplayDuration + 5e3; if (v || E) return Ao && Oo.info(`Session duration (${Math.floor(d / 1e3)}s) is too ${v ? "short" : "long"}, not sending replay.`), void (v && this._debouncedFlush()); const k = this.eventBuffer; if (k && 0 === this.session.segmentId && !k.hasCheckout && Ao && Oo.info("Flushing initial segment without checkout."), !this._flushLock) return this._flushLock = this._runFlush(), await this._flushLock, void (this._flushLock = void 0); try { await this._flushLock } catch (c) { Ao && Oo.error(c) } finally { this._debouncedFlush() } } } "_maybeSaveSession"() { this.session && this._options.stickySession && saveSession(this.session) } "__init6"() { this._onMutationHandler = c => { const u = c.length, d = this._options.mutationLimit, v = d && u > d; if (u > this._options.mutationBreadcrumbLimit || v) { const c = createBreadcrumb({ "category": "replay.mutations", "data": { "count": u, "limit": v } }); this._createCustomBreadcrumb(c) } return !v || (this.stop({ "reason": "mutationLimit", "forceFlush": "session" === this.recordingMode }), !1) } } } function getOption(c, u) { return [...c, ...u].join(",") } const Uo = 'img,image,svg,video,object,picture,embed,map,audio,link[rel="icon"],link[rel="apple-touch-icon"]', Ho = ["content-length", "content-type", "accept"]; let zo = !1; const replayIntegration = c => new Replay(c); class Replay { static "__initStatic"() { this.id = "Replay" } "constructor"({ "flushMinDelay": c = 5e3, "flushMaxDelay": u = 5500, "minReplayDuration": d = 4999, "maxReplayDuration": v = 36e5, "stickySession": E = !0, "useCompression": k = !0, "workerUrl": R, "_experiments": U = {}, "maskAllText": H = !0, "maskAllInputs": G = !0, "blockAllMedia": W = !0, "mutationBreadcrumbLimit": Z = 750, "mutationLimit": Y = 1e4, "slowClickTimeout": J = 7e3, "slowClickIgnoreSelectors": K = [], "networkDetailAllowUrls": X = [], "networkDetailDenyUrls": Q = [], "networkCaptureBodies": ee = !0, "networkRequestHeaders": te = [], "networkResponseHeaders": ne = [], "mask": re = [], "maskAttributes": oe = ["title", "placeholder"], "unmask": ie = [], "block": ae = [], "unblock": se = [], "ignore": ce = [], "maskFn": le, "beforeAddRecordingEvent": ue, "beforeErrorSampling": de } = {}) { this.name = Replay.id; const pe = function getPrivacyOptions({ "mask": c, "unmask": u, "block": d, "unblock": v, "ignore": E }) { return { "maskTextSelector": getOption(c, [".sentry-mask", "[data-sentry-mask]"]), "unmaskTextSelector": getOption(u, []), "blockSelector": getOption(d, [".sentry-block", "[data-sentry-block]", 'base[href="/"]']), "unblockSelector": getOption(v, []), "ignoreSelector": getOption(E, [".sentry-ignore", "[data-sentry-ignore]", 'input[type="file"]']) } }({ "mask": re, "unmask": ie, "block": ae, "unblock": se, "ignore": ce }); if (this._recordingOptions = { "maskAllInputs": G, "maskAllText": H, "maskInputOptions": { "password": !0 }, "maskTextFn": le, "maskInputFn": le, "maskAttributeFn": (c, u, d) => function maskAttribute({ "el": c, "key": u, "maskAttributes": d, "maskAllText": v, "privacyOptions": E, "value": k }) { return v ? E.unmaskTextSelector && c.matches(E.unmaskTextSelector) ? k : d.includes(u) || "value" === u && "INPUT" === c.tagName && ["submit", "button"].includes(c.getAttribute("type") || "") ? k.replace(/[\S]/g, "*") : k : k }({ "maskAttributes": oe, "maskAllText": H, "privacyOptions": pe, "key": c, "value": u, "el": d }), ...pe, "slimDOMOptions": "all", "inlineStylesheet": !0, "inlineImages": !1, "collectFonts": !0, "errorHandler": c => { try { c.__rrweb__ = !0 } catch (c) { } } }, this._initialOptions = { "flushMinDelay": c, "flushMaxDelay": u, "minReplayDuration": Math.min(d, 15e3), "maxReplayDuration": Math.min(v, Yr), "stickySession": E, "useCompression": k, "workerUrl": R, "blockAllMedia": W, "maskAllInputs": G, "maskAllText": H, "mutationBreadcrumbLimit": Z, "mutationLimit": Y, "slowClickTimeout": J, "slowClickIgnoreSelectors": K, "networkDetailAllowUrls": X, "networkDetailDenyUrls": Q, "networkCaptureBodies": ee, "networkRequestHeaders": _getMergedNetworkHeaders(te), "networkResponseHeaders": _getMergedNetworkHeaders(ne), "beforeAddRecordingEvent": ue, "beforeErrorSampling": de, "_experiments": U }, this._initialOptions.blockAllMedia && (this._recordingOptions.blockSelector = this._recordingOptions.blockSelector ? `${this._recordingOptions.blockSelector},${Uo}` : Uo), this._isInitialized && isBrowser()) throw new Error("Multiple Sentry Session Replay instances are not supported"); this._isInitialized = !0 } get "_isInitialized"() { return zo } set "_isInitialized"(c) { zo = c } "afterAllSetup"(c) { isBrowser() && !this._replay && (this._setup(c), this._initialize(c)) } "start"() { this._replay && this._replay.start() } "startBuffering"() { this._replay && this._replay.startBuffering() } "stop"() { return this._replay ? this._replay.stop({ "forceFlush": "session" === this._replay.recordingMode }) : Promise.resolve() } "flush"(c) { return this._replay ? this._replay.isEnabled() ? this._replay.sendBufferedReplayOrFlush(c) : (this._replay.start(), Promise.resolve()) : Promise.resolve() } "getReplayId"() { if (this._replay && this._replay.isEnabled()) return this._replay.getSessionId() } "_initialize"(c) { this._replay && (this._maybeLoadFromReplayCanvasIntegration(c), this._replay.initializeSampling()) } "_setup"(c) { const u = function loadReplayOptionsFromClient(c, u) { const d = u.getOptions(), v = { "sessionSampleRate": 0, "errorSampleRate": 0, ...node_modules_sentry_utils_build_esm_object_dropUndefinedKeys(c) }, E = parseSampleRate_parseSampleRate(d.replaysSessionSampleRate), k = parseSampleRate_parseSampleRate(d.replaysOnErrorSampleRate); null == E && null == k && utils_build_esm_logger_consoleSandbox((() => { console.warn("Replay is disabled because neither `replaysSessionSampleRate` nor `replaysOnErrorSampleRate` are set.") })); null != E && (v.sessionSampleRate = E); null != k && (v.errorSampleRate = k); return v }(this._initialOptions, c); this._replay = new ReplayContainer({ "options": u, "recordingOptions": this._recordingOptions }) } "_maybeLoadFromReplayCanvasIntegration"(c) { try { const u = c.getIntegrationByName("ReplayCanvas"); if (!u) return; this._replay._canvas = u.getOptions() } catch (c) { } } } function _getMergedNetworkHeaders(c) { return [...Ho, ...c.map((c => c.toLowerCase()))] } function getReplay() { const c = build_esm_currentScopes_getClient(); return c && c.getIntegrationByName("Replay") } function _optionalChain_optionalChain(c) { let u, d = c[0], v = 1; for (; v < c.length;) { const E = c[v], k = c[v + 1]; if (v += 2, ("optionalAccess" === E || "optionalCall" === E) && null == d) return; "access" === E || "optionalAccess" === E ? (u = d, d = k(d)) : "call" !== E && "optionalCall" !== E || (d = k(((...c) => d.call(u, ...c))), u = void 0) } return d } Replay.__initStatic(); var qo; function esm_distanceToMatch(c, u, d = 1 / 0, v = 0) { return c ? c.nodeType !== c.ELEMENT_NODE || v > d ? -1 : u(c) ? v : esm_distanceToMatch(c.parentNode, u, d, v + 1) : -1 } function esm_createMatchPredicate(c, u) { return d => { const v = d; if (null === v) return !1; try { if (c) if ("string" == typeof c) { if (v.matches(`.${c}`)) return !0 } else if (function esm_elementClassMatchesRegex(c, u) { for (let d = c.classList.length; d--;) { const v = c.classList[d]; if (u.test(v)) return !0 } return !1 }(v, c)) return !0; return !(!u || !v.matches(u)) } catch (c) { return !1 } } } !function (c) { c[c.Document = 0] = "Document", c[c.DocumentType = 1] = "DocumentType", c[c.Element = 2] = "Element", c[c.Text = 3] = "Text", c[c.CDATA = 4] = "CDATA", c[c.Comment = 5] = "Comment" }(qo || (qo = {})); const Go = "Please stop import mirror directly. Instead of that,\r\nnow you can use replayer.getMirror() to access the mirror instance of a replayer,\r\nor you can use record.mirror to access the mirror instance during recording."; let Vo = { "map": {}, "getId"() { return console.error(Go), -1 }, "getNode"() { return console.error(Go), null }, "removeNodeFromMap"() { console.error(Go) }, "has"() { return console.error(Go), !1 }, "reset"() { console.error(Go) } }; function esm_hookSetter(c, u, d, v, E = window) { const k = E.Object.getOwnPropertyDescriptor(c, u); return E.Object.defineProperty(c, u, v ? d : { "set"(c) { esm_setTimeout((() => { d.set.call(this, c) }), 0), k && k.set && k.set.call(this, c) } }), () => esm_hookSetter(c, u, k || {}, !0) } function esm_patch(c, u, d) { try { if (!(u in c)) return () => { }; const v = c[u], E = d(v); return "function" == typeof E && (E.prototype = E.prototype || {}, Object.defineProperties(E, { "__rrweb_original__": { "enumerable": !1, "value": v } })), c[u] = E, () => { c[u] = v } } catch (c) { return () => { } } } function esm_isBlocked(c, u, d, v, E) { if (!c) return !1; const k = function esm_closestElementOfNode(c) { return c ? c.nodeType === c.ELEMENT_NODE ? c : c.parentElement : null }(c); if (!k) return !1; const R = esm_createMatchPredicate(u, d); if (!E) { const c = v && k.matches(v); return R(k) && !c } const U = esm_distanceToMatch(k, R); let H = -1; return !(U < 0) && (v && (H = esm_distanceToMatch(k, esm_createMatchPredicate(null, v))), U > -1 && H < 0 || U < H) } "undefined" != typeof window && window.Proxy && window.Reflect && (Vo = new Proxy(Vo, { "get"(c, u, d) { return "map" === u && console.error(Go), Reflect.get(c, u, d) } })), /[1-9][0-9]{12}/.test(Date.now().toString()); const Wo = {}; function esm_getImplementation(c) { const u = Wo[c]; if (u) return u; const d = window.document; let v = window[c]; if (d && "function" == typeof d.createElement) try { const u = d.createElement("iframe"); u.hidden = !0, d.head.appendChild(u); const E = u.contentWindow; E && E[c] && (v = E[c]), d.head.removeChild(u) } catch (c) { } return Wo[c] = v.bind(window) } function esm_onRequestAnimationFrame(...c) { return esm_getImplementation("requestAnimationFrame")(...c) } function esm_setTimeout(...c) { return esm_getImplementation("setTimeout")(...c) } var Zo = (c => (c[c["2D"] = 0] = "2D", c[c.WebGL = 1] = "WebGL", c[c.WebGL2 = 2] = "WebGL2", c))(Zo || {}); let Yo; const esm_callbackWrapper = c => { if (!Yo) return c; return (...u) => { try { return c(...u) } catch (c) { if (Yo && !0 === Yo(c)) return () => { }; throw c } } }; for (var Jo = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Ko = "undefined" == typeof Uint8Array ? [] : new Uint8Array(256), Xo = 0; Xo < 64; Xo++)Ko[Jo.charCodeAt(Xo)] = Xo; const Qo = new Map; const saveWebGLVar = (c, u, d) => { if (!c || !isInstanceOfWebGLObject(c, u) && "object" != typeof c) return; const v = function variableListFor(c, u) { let d = Qo.get(c); return d || (d = new Map, Qo.set(c, d)), d.has(u) || d.set(u, []), d.get(u) }(d, c.constructor.name); let E = v.indexOf(c); return -1 === E && (E = v.length, v.push(c)), E }; function serializeArg(c, u, d) { if (c instanceof Array) return c.map((c => serializeArg(c, u, d))); if (null === c) return c; if (c instanceof Float32Array || c instanceof Float64Array || c instanceof Int32Array || c instanceof Uint32Array || c instanceof Uint8Array || c instanceof Uint16Array || c instanceof Int16Array || c instanceof Int8Array || c instanceof Uint8ClampedArray) { return { "rr_type": c.constructor.name, "args": [Object.values(c)] } } if (c instanceof ArrayBuffer) { const u = c.constructor.name, d = function (c) { var u, d = new Uint8Array(c), v = d.length, E = ""; for (u = 0; u < v; u += 3)E += Jo[d[u] >> 2], E += Jo[(3 & d[u]) << 4 | d[u + 1] >> 4], E += Jo[(15 & d[u + 1]) << 2 | d[u + 2] >> 6], E += Jo[63 & d[u + 2]]; return v % 3 == 2 ? E = E.substring(0, E.length - 1) + "=" : v % 3 == 1 && (E = E.substring(0, E.length - 2) + "=="), E }(c); return { "rr_type": u, "base64": d } } if (c instanceof DataView) { return { "rr_type": c.constructor.name, "args": [serializeArg(c.buffer, u, d), c.byteOffset, c.byteLength] } } if (c instanceof HTMLImageElement) { const u = c.constructor.name, { "src": d } = c; return { "rr_type": u, "src": d } } if (c instanceof HTMLCanvasElement) { return { "rr_type": "HTMLImageElement", "src": c.toDataURL() } } if (c instanceof ImageData) { return { "rr_type": c.constructor.name, "args": [serializeArg(c.data, u, d), c.width, c.height] } } if (isInstanceOfWebGLObject(c, u) || "object" == typeof c) { return { "rr_type": c.constructor.name, "index": saveWebGLVar(c, u, d) } } return c } const serializeArgs = (c, u, d) => c.map((c => serializeArg(c, u, d))), isInstanceOfWebGLObject = (c, u) => { const d = ["WebGLActiveInfo", "WebGLBuffer", "WebGLFramebuffer", "WebGLProgram", "WebGLRenderbuffer", "WebGLShader", "WebGLShaderPrecisionFormat", "WebGLTexture", "WebGLUniformLocation", "WebGLVertexArrayObject", "WebGLVertexArrayObjectOES"].filter((c => "function" == typeof u[c])); return Boolean(d.find((d => c instanceof u[d]))) }; function initCanvasContextObserver(c, u, d, v, E) { const k = []; try { const R = esm_patch(c.HTMLCanvasElement.prototype, "getContext", (function (c) { return function (k, ...R) { if (!esm_isBlocked(this, u, d, v, !0)) { const c = function getNormalizedContextName(c) { return "experimental-webgl" === c ? "webgl" : c }(k); if ("__context" in this || (this.__context = c), E && ["webgl", "webgl2"].includes(c)) if (R[0] && "object" == typeof R[0]) { const c = R[0]; c.preserveDrawingBuffer || (c.preserveDrawingBuffer = !0) } else R.splice(0, 1, { "preserveDrawingBuffer": !0 }) } return c.apply(this, [k, ...R]) } })); k.push(R) } catch (c) { console.error("failed to patch HTMLCanvasElement.prototype.getContext") } return () => { k.forEach((c => c())) } } function patchGLPrototype(c, u, d, v, E, k, R, U) { const H = [], G = Object.getOwnPropertyNames(c); for (const R of G) if (!["isContextLost", "canvas", "drawingBufferWidth", "drawingBufferHeight"].includes(R)) try { if ("function" != typeof c[R]) continue; const G = esm_patch(c, R, (function (c) { return function (...H) { const G = c.apply(this, H); if (saveWebGLVar(G, U, this), "tagName" in this.canvas && !esm_isBlocked(this.canvas, v, E, k, !0)) { const c = serializeArgs(H, U, this), v = { "type": u, "property": R, "args": c }; d(this.canvas, v) } return G } })); H.push(G) } catch (v) { const E = esm_hookSetter(c, R, { "set"(c) { d(this.canvas, { "type": u, "property": R, "args": [c], "setter": !0 }) } }); H.push(E) } return H } class CanvasManager { "reset"() { this.pendingCanvasMutations.clear(), this.restoreHandlers.forEach((c => { try { c() } catch (c) { } })), this.restoreHandlers = [], this.windowsSet = new WeakSet, this.windows = [], this.shadowDoms = new Set, _optionalChain_optionalChain([this, "access", c => c.worker, "optionalAccess", c => c.terminate, "call", c => c()]), this.worker = null, this.snapshotInProgressMap = new Map, (this.options.recordCanvas && "number" == typeof this.options.sampling || this.options.enableManualSnapshot) && (this.worker = this.initFPSWorker()) } "freeze"() { this.frozen = !0 } "unfreeze"() { this.frozen = !1 } "lock"() { this.locked = !0 } "unlock"() { this.locked = !1 } "constructor"(c) { this.pendingCanvasMutations = new Map, this.rafStamps = { "latestId": 0, "invokeId": null }, this.shadowDoms = new Set, this.windowsSet = new WeakSet, this.windows = [], this.restoreHandlers = [], this.frozen = !1, this.locked = !1, this.snapshotInProgressMap = new Map, this.worker = null, this.processMutation = (c, u) => { !(this.rafStamps.invokeId && this.rafStamps.latestId !== this.rafStamps.invokeId) && this.rafStamps.invokeId || (this.rafStamps.invokeId = this.rafStamps.latestId), this.pendingCanvasMutations.has(c) || this.pendingCanvasMutations.set(c, []), this.pendingCanvasMutations.get(c).push(u) }; const { "sampling": u = "all", "win": d, "blockClass": v, "blockSelector": E, "unblockSelector": k, "maxCanvasSize": R, "recordCanvas": U, "dataURLOptions": H, "errorHandler": G } = c; this.mutationCb = c.mutationCb, this.mirror = c.mirror, this.options = c, G && function esm_registerErrorHandler(c) { Yo = c }(G), (U && "number" == typeof u || c.enableManualSnapshot) && (this.worker = this.initFPSWorker()), this.addWindow(d), c.enableManualSnapshot || esm_callbackWrapper((() => { U && "all" === u && (this.startRAFTimestamping(), this.startPendingCanvasMutationFlusher()), U && "number" == typeof u && this.initCanvasFPSObserver(u, v, E, k, R, { "dataURLOptions": H }) }))() } "addWindow"(c) { const { "sampling": u = "all", "blockClass": d, "blockSelector": v, "unblockSelector": E, "recordCanvas": k, "enableManualSnapshot": R } = this.options; if (!this.windowsSet.has(c)) { if (R) return this.windowsSet.add(c), void this.windows.push(new WeakRef(c)); esm_callbackWrapper((() => { if (k && "all" === u && this.initCanvasMutationObserver(c, d, v, E), k && "number" == typeof u) { const u = initCanvasContextObserver(c, d, v, E, !0); this.restoreHandlers.push((() => { u() })) } }))(), this.windowsSet.add(c), this.windows.push(new WeakRef(c)) } } "addShadowRoot"(c) { this.shadowDoms.add(new WeakRef(c)) } "resetShadowRoots"() { this.shadowDoms = new Set } "initFPSWorker"() { const c = new Worker(function t() { const c = new Blob(['for(var e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",t="undefined"==typeof Uint8Array?[]:new Uint8Array(256),a=0;a<64;a++)t[e.charCodeAt(a)]=a;var n=function(t){var a,n=new Uint8Array(t),r=n.length,s="";for(a=0;a<r;a+=3)s+=e[n[a]>>2],s+=e[(3&n[a])<<4|n[a+1]>>4],s+=e[(15&n[a+1])<<2|n[a+2]>>6],s+=e[63&n[a+2]];return r%3==2?s=s.substring(0,s.length-1)+"=":r%3==1&&(s=s.substring(0,s.length-2)+"=="),s};const r=new Map,s=new Map;const i=self;i.onmessage=async function(e){if(!("OffscreenCanvas"in globalThis))return i.postMessage({id:e.data.id});{const{id:t,bitmap:a,width:o,height:f,maxCanvasSize:c,dataURLOptions:g}=e.data,u=async function(e,t,a){const r=e+"-"+t;if("OffscreenCanvas"in globalThis){if(s.has(r))return s.get(r);const i=new OffscreenCanvas(e,t);i.getContext("2d");const o=await i.convertToBlob(a),f=await o.arrayBuffer(),c=n(f);return s.set(r,c),c}return""}(o,f,g),[h,d]=function(e,t,a){if(!a)return[e,t];const[n,r]=a;if(e<=n&&t<=r)return[e,t];let s=e,i=t;return s>n&&(i=Math.floor(n*t/e),s=n),i>r&&(s=Math.floor(r*e/t),i=r),[s,i]}(o,f,c),l=new OffscreenCanvas(h,d),w=l.getContext("bitmaprenderer"),p=h===o&&d===f?a:await createImageBitmap(a,{resizeWidth:h,resizeHeight:d,resizeQuality:"low"});w.transferFromImageBitmap(p),a.close();const y=await l.convertToBlob(g),v=y.type,b=await y.arrayBuffer(),m=n(b);if(p.close(),!r.has(t)&&await u===m)return r.set(t,m),i.postMessage({id:t});if(r.get(t)===m)return i.postMessage({id:t});i.postMessage({id:t,type:v,base64:m,width:o,height:f}),r.set(t,m)}};']); return URL.createObjectURL(c) }()); return c.onmessage = c => { const u = c.data, { "id": d } = u; if (this.snapshotInProgressMap.set(d, !1), !("base64" in u)) return; const { "base64": v, "type": E, "width": k, "height": R } = u; this.mutationCb({ "id": d, "type": Zo["2D"], "commands": [{ "property": "clearRect", "args": [0, 0, k, R] }, { "property": "drawImage", "args": [{ "rr_type": "ImageBitmap", "args": [{ "rr_type": "Blob", "data": [{ "rr_type": "ArrayBuffer", "base64": v }], "type": E }] }, 0, 0, k, R] }] }) }, c } "initCanvasFPSObserver"(c, u, d, v, E, k) { const R = this.takeSnapshot(!1, c, u, d, v, E, k.dataURLOptions); this.restoreHandlers.push((() => { cancelAnimationFrame(R) })) } "initCanvasMutationObserver"(c, u, d, v) { const E = initCanvasContextObserver(c, u, d, v, !1), k = function initCanvas2DMutationObserver(c, u, d, v, E) { const k = [], R = Object.getOwnPropertyNames(u.CanvasRenderingContext2D.prototype); for (const U of R) try { if ("function" != typeof u.CanvasRenderingContext2D.prototype[U]) continue; const R = esm_patch(u.CanvasRenderingContext2D.prototype, U, (function (k) { return function (...R) { return esm_isBlocked(this.canvas, d, v, E, !0) || esm_setTimeout((() => { const d = serializeArgs(R, u, this); c(this.canvas, { "type": Zo["2D"], "property": U, "args": d }) }), 0), k.apply(this, R) } })); k.push(R) } catch (d) { const v = esm_hookSetter(u.CanvasRenderingContext2D.prototype, U, { "set"(u) { c(this.canvas, { "type": Zo["2D"], "property": U, "args": [u], "setter": !0 }) } }); k.push(v) } return () => { k.forEach((c => c())) } }(this.processMutation.bind(this), c, u, d, v), R = function initCanvasWebGLMutationObserver(c, u, d, v, E, k) { const R = []; return R.push(...patchGLPrototype(u.WebGLRenderingContext.prototype, Zo.WebGL, c, d, v, E, 0, u)), void 0 !== u.WebGL2RenderingContext && R.push(...patchGLPrototype(u.WebGL2RenderingContext.prototype, Zo.WebGL2, c, d, v, E, 0, u)), () => { R.forEach((c => c())) } }(this.processMutation.bind(this), c, u, d, v, this.mirror); this.restoreHandlers.push((() => { E(), k(), R() })) } "snapshot"(c) { const { "options": u } = this, d = this.takeSnapshot(!0, "all" === u.sampling ? 2 : u.sampling || 2, u.blockClass, u.blockSelector, u.unblockSelector, u.maxCanvasSize, u.dataURLOptions, c); this.restoreHandlers.push((() => { cancelAnimationFrame(d) })) } "takeSnapshot"(c, u, d, v, E, k, R, U) { const H = 1e3 / u; let G, W = 0; const getCanvas = c => { if (c) return [c]; const u = [], searchCanvas = c => { c.querySelectorAll("canvas").forEach((c => { esm_isBlocked(c, d, v, E, !0) || u.push(c) })) }; for (const c of this.windows) { const u = c.deref(); u && searchCanvas(u.document) } for (const c of this.shadowDoms) { const u = c.deref(); u && searchCanvas(u) } return u }, takeCanvasSnapshots = u => { this.windows.length && (W && u - W < H ? G = esm_onRequestAnimationFrame(takeCanvasSnapshots) : (W = u, getCanvas(U).forEach((u => { if (!this.mirror.hasNode(u)) return; const d = this.mirror.getId(u); if (!this.snapshotInProgressMap.get(d) && u.width && u.height) { if (this.snapshotInProgressMap.set(d, !0), !c && ["webgl", "webgl2"].includes(u.__context)) { const c = u.getContext(u.__context); !1 === _optionalChain_optionalChain([c, "optionalAccess", c => c.getContextAttributes, "call", c => c(), "optionalAccess", c => c.preserveDrawingBuffer]) && c.clear(c.COLOR_BUFFER_BIT) } createImageBitmap(u).then((c => { _optionalChain_optionalChain([this, "access", c => c.worker, "optionalAccess", c => c.postMessage, "call", v => v({ "id": d, "bitmap": c, "width": u.width, "height": u.height, "dataURLOptions": R, "maxCanvasSize": k }, [c])]) })).catch((c => { esm_callbackWrapper((() => { throw c }))() })) } })), c || (G = esm_onRequestAnimationFrame(takeCanvasSnapshots)))) }; return G = esm_onRequestAnimationFrame(takeCanvasSnapshots), G } "startPendingCanvasMutationFlusher"() { esm_onRequestAnimationFrame((() => this.flushPendingCanvasMutations())) } "startRAFTimestamping"() { const setLatestRAFTimestamp = c => { this.rafStamps.latestId = c, esm_onRequestAnimationFrame(setLatestRAFTimestamp) }; esm_onRequestAnimationFrame(setLatestRAFTimestamp) } "flushPendingCanvasMutations"() { this.pendingCanvasMutations.forEach(((c, u) => { const d = this.mirror.getId(u); this.flushPendingCanvasMutationFor(u, d) })), esm_onRequestAnimationFrame((() => this.flushPendingCanvasMutations())) } "flushPendingCanvasMutationFor"(c, u) { if (this.frozen || this.locked) return; const d = this.pendingCanvasMutations.get(c); if (!d || -1 === u) return; const v = d.map((c => { const { "type": u, ...d } = c; return d })), { "type": E } = d[0]; this.mutationCb({ "id": u, "type": E, "commands": v }), this.pendingCanvasMutations.delete(c) } } const ei = { "low": { "sampling": { "canvas": 1 }, "dataURLOptions": { "type": "image/webp", "quality": .25 } }, "medium": { "sampling": { "canvas": 2 }, "dataURLOptions": { "type": "image/webp", "quality": .4 } }, "high": { "sampling": { "canvas": 4 }, "dataURLOptions": { "type": "image/webp", "quality": .5 } } }, ti = 1280, replayCanvasIntegration = (c = {}) => { const [u, d] = c.maxCanvasSize || [], v = { "quality": c.quality || "medium", "enableManualSnapshot": c.enableManualSnapshot, "maxCanvasSize": [u ? Math.min(u, ti) : ti, d ? Math.min(d, ti) : ti] }; let E; const k = new Promise((c => E = c)); return { "name": "ReplayCanvas", "getOptions"() { const { "quality": c, "enableManualSnapshot": u, "maxCanvasSize": d } = v; return { "enableManualSnapshot": u, "recordCanvas": !0, "getCanvasManager": c => { const v = new CanvasManager({ ...c, "enableManualSnapshot": u, "maxCanvasSize": d, "errorHandler": c => { try { "object" == typeof c && (c.__rrweb__ = !0) } catch (c) { } } }); return E(v), v }, ...ei[c || "medium"] || ei.medium } }, async"snapshot"(c) { (await k).snapshot(c) } } }, ni = "8.30.0", ri = globalThis; function _sentry_utils_build_esm_worldwide_getGlobalSingleton(c, u, d) { const v = d || ri, E = v.__SENTRY__ = v.__SENTRY__ || {}, k = E[ni] = E[ni] || {}; return k[c] || (k[c] = u()) } function core_build_esm_carrier_getMainCarrier() { return core_build_esm_carrier_getSentryCarrier(ri), ri } function core_build_esm_carrier_getSentryCarrier(c) { const u = c.__SENTRY__ = c.__SENTRY__ || {}; return u.version = u.version || ni, u[ni] = u[ni] || {} } const oi = Object.prototype.toString; function utils_build_esm_is_isBuiltin(c, u) { return oi.call(c) === `[object ${u}]` } function utils_build_esm_is_isPlainObject(c) { return utils_build_esm_is_isBuiltin(c, "Object") } function _sentry_utils_build_esm_misc_uuid4() { const c = ri, u = c.crypto || c.msCrypto; let getRandomByte = () => 16 * Math.random(); try { if (u && u.randomUUID) return u.randomUUID().replace(/-/g, ""); u && u.getRandomValues && (getRandomByte = () => { const c = new Uint8Array(1); return u.getRandomValues(c), c[0] }) } catch (c) { } return ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, (c => (c ^ (15 & getRandomByte()) >> c / 4).toString(16))) } function utils_build_esm_propagationContext_generatePropagationContext() { return { "traceId": _sentry_utils_build_esm_misc_uuid4(), "spanId": _sentry_utils_build_esm_misc_uuid4().substring(16) } } const ii = 1e3; function _sentry_utils_build_esm_time_dateTimestampInSeconds() { return Date.now() / ii } const ai = function utils_build_esm_time_createUnixTimestampInSecondsFunc() { const { "performance": c } = ri; if (!c || !c.now) return _sentry_utils_build_esm_time_dateTimestampInSeconds; const u = Date.now() - c.now(), d = null == c.timeOrigin ? u : c.timeOrigin; return () => (d + c.now()) / ii }(); let si; (() => { const { "performance": c } = ri; if (!c || !c.now) return void (si = "none"); const u = 36e5, d = c.now(), v = Date.now(), E = c.timeOrigin ? Math.abs(c.timeOrigin + d - v) : u, k = E < u, R = c.timing && c.timing.navigationStart, U = "number" == typeof R ? Math.abs(R + d - v) : u; k || U < u ? E <= U ? (si = "timeOrigin", c.timeOrigin) : si = "navigationStart" : si = "dateNow" })(); const ci = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__, li = ["debug", "info", "warn", "error", "log", "assert", "trace"], ui = {}; const di = _sentry_utils_build_esm_worldwide_getGlobalSingleton("logger", (function utils_build_esm_logger_makeLogger() { let c = !1; const u = { "enable": () => { c = !0 }, "disable": () => { c = !1 }, "isEnabled": () => c }; return ci ? li.forEach((d => { u[d] = (...u) => { c && function _sentry_utils_build_esm_logger_consoleSandbox(c) { if (!("console" in ri)) return c(); const u = ri.console, d = {}, v = Object.keys(ui); v.forEach((c => { const v = ui[c]; d[c] = u[c], u[c] = v })); try { return c() } finally { v.forEach((c => { u[c] = d[c] })) } }((() => { ri.console[d](`Sentry Logger [${d}]:`, ...u) })) } })) : li.forEach((c => { u[c] = () => { } })), u })); function core_build_esm_session_updateSession(c, u = {}) { if (u.user && (!c.ipAddress && u.user.ip_address && (c.ipAddress = u.user.ip_address), c.did || u.did || (c.did = u.user.id || u.user.email || u.user.username)), c.timestamp = u.timestamp || ai(), u.abnormal_mechanism && (c.abnormal_mechanism = u.abnormal_mechanism), u.ignoreDuration && (c.ignoreDuration = u.ignoreDuration), u.sid && (c.sid = 32 === u.sid.length ? u.sid : _sentry_utils_build_esm_misc_uuid4()), void 0 !== u.init && (c.init = u.init), !c.did && u.did && (c.did = `${u.did}`), "number" == typeof u.started && (c.started = u.started), c.ignoreDuration) c.duration = void 0; else if ("number" == typeof u.duration) c.duration = u.duration; else { const u = c.timestamp - c.started; c.duration = u >= 0 ? u : 0 } u.release && (c.release = u.release), u.environment && (c.environment = u.environment), !c.ipAddress && u.ipAddress && (c.ipAddress = u.ipAddress), !c.userAgent && u.userAgent && (c.userAgent = u.userAgent), "number" == typeof u.errors && (c.errors = u.errors), u.status && (c.status = u.status) } function _sentry_utils_build_esm_object_addNonEnumerableProperty(c, u, d) { try { Object.defineProperty(c, u, { "value": d, "writable": !0, "configurable": !0 }) } catch (d) { ci && di.log(`Failed to add non-enumerable property "${u}" to object`, c) } } function feedback_node_modules_sentry_utils_build_esm_object_dropUndefinedKeys(c) { return _sentry_internal_feedback_node_modules_sentry_utils_build_esm_object_dropUndefinedKeys(c, new Map) } function _sentry_internal_feedback_node_modules_sentry_utils_build_esm_object_dropUndefinedKeys(c, u) { if (function utils_build_esm_object_isPojo(c) { if (!utils_build_esm_is_isPlainObject(c)) return !1; try { const u = Object.getPrototypeOf(c).constructor.name; return !u || "Object" === u } catch (c) { return !0 } }(c)) { const d = u.get(c); if (void 0 !== d) return d; const v = {}; u.set(c, v); for (const d of Object.keys(c)) void 0 !== c[d] && (v[d] = _sentry_internal_feedback_node_modules_sentry_utils_build_esm_object_dropUndefinedKeys(c[d], u)); return v } if (Array.isArray(c)) { const d = u.get(c); if (void 0 !== d) return d; const v = []; return u.set(c, v), c.forEach((c => { v.push(_sentry_internal_feedback_node_modules_sentry_utils_build_esm_object_dropUndefinedKeys(c, u)) })), v } return c } const pi = "_sentrySpan"; function build_esm_utils_spanOnScope_setSpanForScope(c, u) { u ? _sentry_utils_build_esm_object_addNonEnumerableProperty(c, pi, u) : delete c[pi] } function esm_utils_spanOnScope_getSpanForScope(c) { return c[pi] } class build_esm_scope_ScopeClass { "constructor"() { this._notifyingListeners = !1, this._scopeListeners = [], this._eventProcessors = [], this._breadcrumbs = [], this._attachments = [], this._user = {}, this._tags = {}, this._extra = {}, this._contexts = {}, this._sdkProcessingMetadata = {}, this._propagationContext = utils_build_esm_propagationContext_generatePropagationContext() } "clone"() { const c = new build_esm_scope_ScopeClass; return c._breadcrumbs = [...this._breadcrumbs], c._tags = { ...this._tags }, c._extra = { ...this._extra }, c._contexts = { ...this._contexts }, c._user = this._user, c._level = this._level, c._session = this._session, c._transactionName = this._transactionName, c._fingerprint = this._fingerprint, c._eventProcessors = [...this._eventProcessors], c._requestSession = this._requestSession, c._attachments = [...this._attachments], c._sdkProcessingMetadata = { ...this._sdkProcessingMetadata }, c._propagationContext = { ...this._propagationContext }, c._client = this._client, c._lastEventId = this._lastEventId, build_esm_utils_spanOnScope_setSpanForScope(c, esm_utils_spanOnScope_getSpanForScope(this)), c } "setClient"(c) { this._client = c } "setLastEventId"(c) { this._lastEventId = c } "getClient"() { return this._client } "lastEventId"() { return this._lastEventId } "addScopeListener"(c) { this._scopeListeners.push(c) } "addEventProcessor"(c) { return this._eventProcessors.push(c), this } "setUser"(c) { return this._user = c || { "email": void 0, "id": void 0, "ip_address": void 0, "username": void 0 }, this._session && core_build_esm_session_updateSession(this._session, { "user": c }), this._notifyScopeListeners(), this } "getUser"() { return this._user } "getRequestSession"() { return this._requestSession } "setRequestSession"(c) { return this._requestSession = c, this } "setTags"(c) { return this._tags = { ...this._tags, ...c }, this._notifyScopeListeners(), this } "setTag"(c, u) { return this._tags = { ...this._tags, [c]: u }, this._notifyScopeListeners(), this } "setExtras"(c) { return this._extra = { ...this._extra, ...c }, this._notifyScopeListeners(), this } "setExtra"(c, u) { return this._extra = { ...this._extra, [c]: u }, this._notifyScopeListeners(), this } "setFingerprint"(c) { return this._fingerprint = c, this._notifyScopeListeners(), this } "setLevel"(c) { return this._level = c, this._notifyScopeListeners(), this } "setTransactionName"(c) { return this._transactionName = c, this._notifyScopeListeners(), this } "setContext"(c, u) { return null === u ? delete this._contexts[c] : this._contexts[c] = u, this._notifyScopeListeners(), this } "setSession"(c) { return c ? this._session = c : delete this._session, this._notifyScopeListeners(), this } "getSession"() { return this._session } "update"(c) { if (!c) return this; const u = "function" == typeof c ? c(this) : c, [d, v] = u instanceof fi ? [u.getScopeData(), u.getRequestSession()] : utils_build_esm_is_isPlainObject(u) ? [c, c.requestSession] : [], { "tags": E, "extra": k, "user": R, "contexts": U, "level": H, "fingerprint": G = [], "propagationContext": W } = d || {}; return this._tags = { ...this._tags, ...E }, this._extra = { ...this._extra, ...k }, this._contexts = { ...this._contexts, ...U }, R && Object.keys(R).length && (this._user = R), H && (this._level = H), G.length && (this._fingerprint = G), W && (this._propagationContext = W), v && (this._requestSession = v), this } "clear"() { return this._breadcrumbs = [], this._tags = {}, this._extra = {}, this._user = {}, this._contexts = {}, this._level = void 0, this._transactionName = void 0, this._fingerprint = void 0, this._requestSession = void 0, this._session = void 0, build_esm_utils_spanOnScope_setSpanForScope(this, void 0), this._attachments = [], this._propagationContext = utils_build_esm_propagationContext_generatePropagationContext(), this._notifyScopeListeners(), this } "addBreadcrumb"(c, u) { const d = "number" == typeof u ? u : 100; if (d <= 0) return this; const v = { "timestamp": _sentry_utils_build_esm_time_dateTimestampInSeconds(), ...c }, E = this._breadcrumbs; return E.push(v), this._breadcrumbs = E.length > d ? E.slice(-d) : E, this._notifyScopeListeners(), this } "getLastBreadcrumb"() { return this._breadcrumbs[this._breadcrumbs.length - 1] } "clearBreadcrumbs"() { return this._breadcrumbs = [], this._notifyScopeListeners(), this } "addAttachment"(c) { return this._attachments.push(c), this } "clearAttachments"() { return this._attachments = [], this } "getScopeData"() { return { "breadcrumbs": this._breadcrumbs, "attachments": this._attachments, "contexts": this._contexts, "tags": this._tags, "extra": this._extra, "user": this._user, "level": this._level, "fingerprint": this._fingerprint || [], "eventProcessors": this._eventProcessors, "propagationContext": this._propagationContext, "sdkProcessingMetadata": this._sdkProcessingMetadata, "transactionName": this._transactionName, "span": esm_utils_spanOnScope_getSpanForScope(this) } } "setSDKProcessingMetadata"(c) { return this._sdkProcessingMetadata = { ...this._sdkProcessingMetadata, ...c }, this } "setPropagationContext"(c) { return this._propagationContext = c, this } "getPropagationContext"() { return this._propagationContext } "captureException"(c, u) { const d = u && u.event_id ? u.event_id : _sentry_utils_build_esm_misc_uuid4(); if (!this._client) return di.warn("No client configured on scope - will not capture exception!"), d; const v = new Error("Sentry syntheticException"); return this._client.captureException(c, { "originalException": c, "syntheticException": v, ...u, "event_id": d }, this), d } "captureMessage"(c, u, d) { const v = d && d.event_id ? d.event_id : _sentry_utils_build_esm_misc_uuid4(); if (!this._client) return di.warn("No client configured on scope - will not capture message!"), v; const E = new Error(c); return this._client.captureMessage(c, u, { "originalException": c, "syntheticException": E, ...d, "event_id": v }, this), v } "captureEvent"(c, u) { const d = u && u.event_id ? u.event_id : _sentry_utils_build_esm_misc_uuid4(); return this._client ? (this._client.captureEvent(c, { ...u, "event_id": d }, this), d) : (di.warn("No client configured on scope - will not capture event!"), d) } "_notifyScopeListeners"() { this._notifyingListeners || (this._notifyingListeners = !0, this._scopeListeners.forEach((c => { c(this) })), this._notifyingListeners = !1) } } const fi = build_esm_scope_ScopeClass; class esm_asyncContext_stackStrategy_AsyncContextStack { "constructor"(c, u) { let d, v; d = c || new fi, v = u || new fi, this._stack = [{ "scope": d }], this._isolationScope = v } "withScope"(c) { const u = this._pushScope(); let d; try { d = c(u) } catch (c) { throw this._popScope(), c } return function _sentry_utils_build_esm_is_isThenable(c) { return Boolean(c && c.then && "function" == typeof c.then) }(d) ? d.then((c => (this._popScope(), c)), (c => { throw this._popScope(), c })) : (this._popScope(), d) } "getClient"() { return this.getStackTop().client } "getScope"() { return this.getStackTop().scope } "getIsolationScope"() { return this._isolationScope } "getStackTop"() { return this._stack[this._stack.length - 1] } "_pushScope"() { const c = this.getScope().clone(); return this._stack.push({ "client": this.getClient(), "scope": c }), c } "_popScope"() { return !(this._stack.length <= 1) && !!this._stack.pop() } } function esm_asyncContext_stackStrategy_getAsyncContextStack() { const c = core_build_esm_carrier_getSentryCarrier(core_build_esm_carrier_getMainCarrier()); return c.stack = c.stack || new esm_asyncContext_stackStrategy_AsyncContextStack(function build_esm_defaultScopes_getDefaultCurrentScope() { return _sentry_utils_build_esm_worldwide_getGlobalSingleton("defaultCurrentScope", (() => new fi)) }(), function build_esm_defaultScopes_getDefaultIsolationScope() { return _sentry_utils_build_esm_worldwide_getGlobalSingleton("defaultIsolationScope", (() => new fi)) }()) } function build_esm_asyncContext_stackStrategy_withScope(c) { return esm_asyncContext_stackStrategy_getAsyncContextStack().withScope(c) } function esm_asyncContext_stackStrategy_withSetScope(c, u) { const d = esm_asyncContext_stackStrategy_getAsyncContextStack(); return d.withScope((() => (d.getStackTop().scope = c, u(c)))) } function build_esm_asyncContext_stackStrategy_withIsolationScope(c) { return esm_asyncContext_stackStrategy_getAsyncContextStack().withScope((() => c(esm_asyncContext_stackStrategy_getAsyncContextStack().getIsolationScope()))) } function core_build_esm_asyncContext_getAsyncContextStrategy(c) { const u = core_build_esm_carrier_getSentryCarrier(c); return u.acs ? u.acs : function esm_asyncContext_stackStrategy_getStackAsyncContextStrategy() { return { "withIsolationScope": build_esm_asyncContext_stackStrategy_withIsolationScope, "withScope": build_esm_asyncContext_stackStrategy_withScope, "withSetScope": esm_asyncContext_stackStrategy_withSetScope, "withSetIsolationScope": (c, u) => build_esm_asyncContext_stackStrategy_withIsolationScope(u), "getCurrentScope": () => esm_asyncContext_stackStrategy_getAsyncContextStack().getScope(), "getIsolationScope": () => esm_asyncContext_stackStrategy_getAsyncContextStack().getIsolationScope() } }() } function core_build_esm_currentScopes_getCurrentScope() { return core_build_esm_asyncContext_getAsyncContextStrategy(core_build_esm_carrier_getMainCarrier()).getCurrentScope() } function core_build_esm_currentScopes_getClient() { return core_build_esm_currentScopes_getCurrentScope().getClient() } const hi = ri; function esm_browser_getLocationHref() { try { return hi.document.location.href } catch (c) { return "" } } function node_isNodeEnv() { return !function esm_env_isBrowserBundle() { return "undefined" != typeof __SENTRY_BROWSER_BUNDLE__ && !!__SENTRY_BROWSER_BUNDLE__ }() && "[object process]" === Object.prototype.toString.call("undefined" != typeof process ? process : 0) } function isBrowser_isBrowser() { return "undefined" != typeof window && (!node_isNodeEnv() || function isBrowser_isElectronNodeRenderer() { return void 0 !== ri.process && "renderer" === ri.process.type }()) } const mi = ri, gi = mi.document, _i = mi.navigator, vi = "Report a Bug", yi = "widget", sendFeedback = (c, u = { "includeReplay": !0 }) => { if (!c.message) throw new Error("Unable to submit feedback with empty message"); const d = core_build_esm_currentScopes_getClient(); if (!d) throw new Error("No client setup, cannot send feedback."); c.tags && Object.keys(c.tags).length && core_build_esm_currentScopes_getCurrentScope().setTags(c.tags); const v = function feedback_captureFeedback(c, u = {}, d = core_build_esm_currentScopes_getCurrentScope()) { const { "message": v, "name": E, "email": k, "url": R, "source": U, "associatedEventId": H, "tags": G } = c, W = { "contexts": { "feedback": feedback_node_modules_sentry_utils_build_esm_object_dropUndefinedKeys({ "contact_email": k, "name": E, "message": v, "url": R, "source": U, "associated_event_id": H }) }, "type": "feedback", "level": "info", "tags": G }, Z = d && d.getClient() || core_build_esm_currentScopes_getClient(); return Z && Z.emit("beforeSendFeedback", W, u), d.captureEvent(W, u) }({ "source": "api", "url": esm_browser_getLocationHref(), ...c }, u); return new Promise(((c, u) => { const E = setTimeout((() => u("Unable to determine if Feedback was correctly sent.")), 5e3), k = d.on("afterSendEvent", ((d, R) => { if (d.event_id === v) return clearTimeout(E), k(), R && "number" == typeof R.statusCode && R.statusCode >= 200 && R.statusCode < 300 && c(v), R && "number" == typeof R.statusCode && 0 === R.statusCode ? u("Unable to send Feedback. This is because of network issues, or because you are using an ad-blocker.") : R && "number" == typeof R.statusCode && 403 === R.statusCode ? u("Unable to send Feedback. This could be because this domain is not in your list of allowed domains.") : u("Unable to send Feedback. This could be because of network issues, or because you are using an ad-blocker") })) })) }, bi = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__; function mergeOptions(c, u) { return { ...c, ...u, "tags": { ...c.tags, ...u.tags }, "onFormOpen": () => { u.onFormOpen && u.onFormOpen(), c.onFormOpen && c.onFormOpen() }, "onFormClose": () => { u.onFormClose && u.onFormClose(), c.onFormClose && c.onFormClose() }, "onSubmitSuccess": d => { u.onSubmitSuccess && u.onSubmitSuccess(d), c.onSubmitSuccess && c.onSubmitSuccess(d) }, "onSubmitError": d => { u.onSubmitError && u.onSubmitError(d), c.onSubmitError && c.onSubmitError(d) }, "onFormSubmitted": () => { u.onFormSubmitted && u.onFormSubmitted(), c.onFormSubmitted && c.onFormSubmitted() }, "themeDark": { ...c.themeDark, ...u.themeDark }, "themeLight": { ...c.themeLight, ...u.themeLight } } } function setAttributesNS(c, u) { return Object.entries(u).forEach((([u, d]) => { c.setAttributeNS(null, u, d) })), c } const Si = 20, wi = "http://www.w3.org/2000/svg"; function Actor({ "triggerLabel": c, "triggerAriaLabel": u, "shadow": d, "styleNonce": v }) { const E = gi.createElement("button"); if (E.type = "button", E.className = "widget__actor", E.ariaHidden = "false", E.ariaLabel = u || c || vi, E.appendChild(function FeedbackIcon() { const createElementNS = c => mi.document.createElementNS(wi, c), c = setAttributesNS(createElementNS("svg"), { "width": `${Si}`, "height": `${Si}`, "viewBox": `0 0 ${Si} ${Si}`, "fill": "var(--foreground)" }), u = setAttributesNS(createElementNS("g"), { "clipPath": "url(#clip0_57_80)" }), d = setAttributesNS(createElementNS("path"), { "fill-rule": "evenodd", "clip-rule": "evenodd", "d": "M15.6622 15H12.3997C12.2129 14.9959 12.031 14.9396 11.8747 14.8375L8.04965 12.2H7.49956V19.1C7.4875 19.3348 7.3888 19.5568 7.22256 19.723C7.05632 19.8892 6.83435 19.9879 6.59956 20H2.04956C1.80193 19.9968 1.56535 19.8969 1.39023 19.7218C1.21511 19.5467 1.1153 19.3101 1.11206 19.0625V12.2H0.949652C0.824431 12.2017 0.700142 12.1783 0.584123 12.1311C0.468104 12.084 0.362708 12.014 0.274155 11.9255C0.185602 11.8369 0.115689 11.7315 0.0685419 11.6155C0.0213952 11.4995 -0.00202913 11.3752 -0.00034808 11.25V3.75C-0.00900498 3.62067 0.0092504 3.49095 0.0532651 3.36904C0.0972798 3.24712 0.166097 3.13566 0.255372 3.04168C0.344646 2.94771 0.452437 2.87327 0.571937 2.82307C0.691437 2.77286 0.82005 2.74798 0.949652 2.75H8.04965L11.8747 0.1625C12.031 0.0603649 12.2129 0.00407221 12.3997 0H15.6622C15.9098 0.00323746 16.1464 0.103049 16.3215 0.278167C16.4966 0.453286 16.5964 0.689866 16.5997 0.9375V3.25269C17.3969 3.42959 18.1345 3.83026 18.7211 4.41679C19.5322 5.22788 19.9878 6.32796 19.9878 7.47502C19.9878 8.62209 19.5322 9.72217 18.7211 10.5333C18.1345 11.1198 17.3969 11.5205 16.5997 11.6974V14.0125C16.6047 14.1393 16.5842 14.2659 16.5395 14.3847C16.4948 14.5035 16.4268 14.6121 16.3394 14.7042C16.252 14.7962 16.147 14.8698 16.0307 14.9206C15.9144 14.9714 15.7891 14.9984 15.6622 15ZM1.89695 10.325H1.88715V4.625H8.33715C8.52423 4.62301 8.70666 4.56654 8.86215 4.4625L12.6872 1.875H14.7247V13.125H12.6872L8.86215 10.4875C8.70666 10.3835 8.52423 10.327 8.33715 10.325H2.20217C2.15205 10.3167 2.10102 10.3125 2.04956 10.3125C1.9981 10.3125 1.94708 10.3167 1.89695 10.325ZM2.98706 12.2V18.1625H5.66206V12.2H2.98706ZM16.5997 9.93612V5.01393C16.6536 5.02355 16.7072 5.03495 16.7605 5.04814C17.1202 5.13709 17.4556 5.30487 17.7425 5.53934C18.0293 5.77381 18.2605 6.06912 18.4192 6.40389C18.578 6.73866 18.6603 7.10452 18.6603 7.47502C18.6603 7.84552 18.578 8.21139 18.4192 8.54616C18.2605 8.88093 18.0293 9.17624 17.7425 9.41071C17.4556 9.64518 17.1202 9.81296 16.7605 9.90191C16.7072 9.91509 16.6536 9.9265 16.5997 9.93612Z" }); c.appendChild(u).appendChild(d); const v = createElementNS("defs"), E = setAttributesNS(createElementNS("clipPath"), { "id": "clip0_57_80" }), k = setAttributesNS(createElementNS("rect"), { "width": `${Si}`, "height": `${Si}`, "fill": "white" }); return E.appendChild(k), v.appendChild(E), c.appendChild(v).appendChild(E).appendChild(k), c }()), c) { const u = gi.createElement("span"); u.appendChild(gi.createTextNode(c)), E.appendChild(u) } const k = function createActorStyles(c) { const u = gi.createElement("style"); return u.textContent = '\n.widget__actor {\n  position: fixed;\n  z-index: var(--z-index);\n  margin: var(--page-margin);\n  inset: var(--actor-inset);\n\n  display: flex;\n  align-items: center;\n  gap: 8px;\n  padding: 16px;\n\n  font-family: inherit;\n  font-size: var(--font-size);\n  font-weight: 600;\n  line-height: 1.14em;\n  text-decoration: none;\n\n  background: var(--actor-background, var(--background));\n  border-radius: var(--actor-border-radius, 1.7em/50%);\n  border: var(--actor-border, var(--border));\n  box-shadow: var(--actor-box-shadow, var(--box-shadow));\n  color: var(--actor-color, var(--foreground));\n  fill: var(--actor-color, var(--foreground));\n  cursor: pointer;\n  opacity: 1;\n  transition: transform 0.2s ease-in-out;\n  transform: translate(0, 0) scale(1);\n}\n.widget__actor[aria-hidden="true"] {\n  opacity: 0;\n  pointer-events: none;\n  visibility: hidden;\n  transform: translate(0, 16px) scale(0.98);\n}\n\n.widget__actor:hover {\n  background: var(--actor-hover-background, var(--background));\n  filter: var(--interactive-filter);\n}\n\n.widget__actor svg {\n  width: 1.14em;\n  height: 1.14em;\n}\n\n@media (max-width: 600px) {\n  .widget__actor span {\n    display: none;\n  }\n}\n', c && u.setAttribute("nonce", c), u }(v); return { "el": E, "appendToDom"() { d.appendChild(k), d.appendChild(E) }, "removeFromDom"() { d.removeChild(E), d.removeChild(k) }, "show"() { E.ariaHidden = "false" }, "hide"() { E.ariaHidden = "true" } } } const Ei = "rgba(88, 74, 192, 1)", Ci = { "foreground": "#2b2233", "background": "#ffffff", "accentForeground": "white", "accentBackground": Ei, "successColor": "#268d75", "errorColor": "#df3338", "border": "1.5px solid rgba(41, 35, 47, 0.13)", "boxShadow": "0px 4px 24px 0px rgba(43, 34, 51, 0.12)", "outline": "1px auto var(--accent-background)", "interactiveFilter": "brightness(95%)" }, Ti = { "foreground": "#ebe6ef", "background": "#29232f", "accentForeground": "white", "accentBackground": Ei, "successColor": "#2da98c", "errorColor": "#f55459", "border": "1.5px solid rgba(235, 230, 239, 0.15)", "boxShadow": "0px 4px 24px 0px rgba(43, 34, 51, 0.12)", "outline": "1px auto var(--accent-background)", "interactiveFilter": "brightness(150%)" }; function getThemedCssVariables(c) { return `\n  --foreground: ${c.foreground};\n  --background: ${c.background};\n  --accent-foreground: ${c.accentForeground};\n  --accent-background: ${c.accentBackground};\n  --success-color: ${c.successColor};\n  --error-color: ${c.errorColor};\n  --border: ${c.border};\n  --box-shadow: ${c.boxShadow};\n  --outline: ${c.outline};\n  --interactive-filter: ${c.interactiveFilter};\n  ` } const buildFeedbackIntegration = ({ "lazyLoadIntegration": c, "getModalIntegration": u, "getScreenshotIntegration": d }) => ({ "id": v = "sentry-feedback", "autoInject": E = !0, "showBranding": k = !0, "isEmailRequired": R = !1, "isNameRequired": U = !1, "showEmail": H = !0, "showName": G = !0, "enableScreenshot": W = !0, "useSentryUser": Z = { "email": "email", "name": "username" }, "tags": Y, "styleNonce": J, "scriptNonce": K, "colorScheme": X = "system", "themeLight": Q = {}, "themeDark": ee = {}, "addScreenshotButtonLabel": te = "Add a screenshot", "cancelButtonLabel": ne = "Cancel", "confirmButtonLabel": re = "Confirm", "emailLabel": oe = "Email", "emailPlaceholder": ie = "your.email@example.org", "formTitle": ae = "Report a Bug", "isRequiredLabel": se = "(required)", "messageLabel": ce = "Description", "messagePlaceholder": le = "What's the bug? What did you expect?", "nameLabel": ue = "Name", "namePlaceholder": de = "Your Name", "removeScreenshotButtonLabel": pe = "Remove screenshot", "submitButtonLabel": fe = "Send Bug Report", "successMessageText": he = "Thank you for your report!", "triggerLabel": me = vi, "triggerAriaLabel": ge = "", "onFormOpen": _e, "onFormClose": ve, "onSubmitSuccess": ye, "onSubmitError": be, "onFormSubmitted": Se } = {}) => { const we = { "id": v, "autoInject": E, "showBranding": k, "isEmailRequired": R, "isNameRequired": U, "showEmail": H, "showName": G, "enableScreenshot": W, "useSentryUser": Z, "tags": Y, "styleNonce": J, "scriptNonce": K, "colorScheme": X, "themeDark": ee, "themeLight": Q, "triggerLabel": me, "triggerAriaLabel": ge, "cancelButtonLabel": ne, "submitButtonLabel": fe, "confirmButtonLabel": re, "formTitle": ae, "emailLabel": oe, "emailPlaceholder": ie, "messageLabel": ce, "messagePlaceholder": le, "nameLabel": ue, "namePlaceholder": de, "successMessageText": he, "isRequiredLabel": se, "addScreenshotButtonLabel": te, "removeScreenshotButtonLabel": pe, "onFormClose": ve, "onFormOpen": _e, "onSubmitError": be, "onSubmitSuccess": ye, "onFormSubmitted": Se }; let Ee = null, Ce = []; const _createShadow = c => { if (!Ee) { const u = gi.createElement("div"); u.id = String(c.id), gi.body.appendChild(u), Ee = u.attachShadow({ "mode": "open" }), Ee.appendChild(function createMainStyles({ "colorScheme": c, "themeDark": u, "themeLight": d, "styleNonce": v }) { const E = gi.createElement("style"); return E.textContent = `\n:host {\n  --font-family: system-ui, 'Helvetica Neue', Arial, sans-serif;\n  --font-size: 14px;\n  --z-index: 100000;\n\n  --page-margin: 16px;\n  --inset: auto 0 0 auto;\n  --actor-inset: var(--inset);\n\n  font-family: var(--font-family);\n  font-size: var(--font-size);\n\n  ${"system" !== c ? "color-scheme: only light;" : ""}\n\n  ${getThemedCssVariables("dark" === c ? { ...Ti, ...u } : { ...Ci, ...d })}\n}\n\n${"system" === c ? `\n@media (prefers-color-scheme: dark) {\n  :host {\n    ${getThemedCssVariables({ ...Ti, ...u })}\n  }\n}` : ""}\n}\n`, v && E.setAttribute("nonce", v), E }(c)) } return Ee }, _findIntegration = async (u, d, v) => { const E = core_build_esm_currentScopes_getClient(), k = E && E.getIntegrationByName(u); if (k) return k; const R = (d && d() || await c(v, K))(); return E && E.addIntegration(R), R }, _loadAndRenderDialog = async c => { const v = c.enableScreenshot && function isScreenshotSupported() { return !(/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(_i.userAgent) || /Macintosh/i.test(_i.userAgent) && _i.maxTouchPoints && _i.maxTouchPoints > 1 || !isSecureContext) }(), [E, k] = await Promise.all([_findIntegration("FeedbackModal", u, "feedbackModalIntegration"), v ? _findIntegration("FeedbackScreenshot", d, "feedbackScreenshotIntegration") : void 0]); if (!E) throw bi && di.error("[Feedback] Missing feedback modal integration. Try using `feedbackSyncIntegration` in your `Sentry.init`."), new Error("[Feedback] Missing feedback modal integration!"); v && !k && bi && di.error("[Feedback] Missing feedback screenshot integration. Proceeding without screenshots."); const R = E.createDialog({ "options": { ...c, "onFormClose": () => { R && R.close(), c.onFormClose && c.onFormClose() }, "onFormSubmitted": () => { R && R.close(), c.onFormSubmitted && c.onFormSubmitted() } }, "screenshotIntegration": v ? k : void 0, "sendFeedback": sendFeedback, "shadow": _createShadow(c) }); return R }, _attachTo = (c, u = {}) => { const d = mergeOptions(we, u), v = "string" == typeof c ? gi.querySelector(c) : "function" == typeof c.addEventListener ? c : null; if (!v) throw bi && di.error("[Feedback] Unable to attach to target element"), new Error("Unable to attach to target element"); let E = null; const handleClick = async () => { E || (E = await _loadAndRenderDialog({ ...d, "onFormSubmitted": () => { E && E.removeFromDom(), d.onFormSubmitted && d.onFormSubmitted() } })), E.appendToDom(), E.open() }; v.addEventListener("click", handleClick); const unsubscribe = () => { Ce = Ce.filter((c => c !== unsubscribe)), E && E.removeFromDom(), E = null, v.removeEventListener("click", handleClick) }; return Ce.push(unsubscribe), unsubscribe }, _createActor = (c = {}) => { const u = mergeOptions(we, c), d = _createShadow(u), v = Actor({ "triggerLabel": u.triggerLabel, "triggerAriaLabel": u.triggerAriaLabel, "shadow": d, "styleNonce": J }); return _attachTo(v.el, { ...u, "onFormOpen"() { v.hide() }, "onFormClose"() { v.show() }, "onFormSubmitted"() { v.show() } }), v }; return { "name": "Feedback", "setupOnce"() { isBrowser_isBrowser() && we.autoInject && ("loading" === gi.readyState ? gi.addEventListener("DOMContentLoaded", (() => _createActor().appendToDom())) : _createActor().appendToDom()) }, "attachTo": _attachTo, "createWidget"(c = {}) { const u = _createActor(mergeOptions(we, c)); return u.appendToDom(), u }, async"createForm"(c = {}) { return _loadAndRenderDialog(mergeOptions(we, c)) }, "remove"() { Ee && (Ee.parentElement && Ee.parentElement.remove(), Ee = null), Ce.forEach((c => c())), Ce = [] } } }; function getFeedback() { const c = core_build_esm_currentScopes_getClient(); return c && c.getIntegrationByName("Feedback") } var xi, Ai, Ii, ki, Oi, Pi, Ri, Mi = {}, Ni = [], Di = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, $i = Array.isArray; function v$1(c, u) { for (var d in u) c[d] = u[d]; return c } function p$1(c) { var u = c.parentNode; u && u.removeChild(c) } function y$1(c, u, d) { var v, E, k, R = {}; for (k in u) "key" == k ? v = u[k] : "ref" == k ? E = u[k] : R[k] = u[k]; if (arguments.length > 2 && (R.children = arguments.length > 3 ? xi.call(arguments, 2) : d), "function" == typeof c && null != c.defaultProps) for (k in c.defaultProps) void 0 === R[k] && (R[k] = c.defaultProps[k]); return d$1(c, R, v, E, null) } function d$1(c, u, d, v, E) { var k = { "type": c, "props": u, "key": d, "ref": v, "__k": null, "__": null, "__b": 0, "__e": null, "__d": void 0, "__c": null, "constructor": void 0, "__v": null == E ? ++Ii : E, "__i": -1, "__u": 0 }; return null == E && null != Ai.vnode && Ai.vnode(k), k } function g$1(c) { return c.children } function b$1(c, u) { this.props = c, this.context = u } function m$1(c, u) { if (null == u) return c.__ ? m$1(c.__, c.__i + 1) : null; for (var d; u < c.__k.length; u++)if (null != (d = c.__k[u]) && null != d.__e) return d.__e; return "function" == typeof c.type ? m$1(c) : null } function w$1(c, u, d) { var v, E = c.__v, k = E.__e, R = c.__P; if (R) return (v = v$1({}, E)).__v = E.__v + 1, Ai.vnode && Ai.vnode(v), M(R, v, E, c.__n, void 0 !== R.ownerSVGElement, 32 & E.__u ? [k] : null, u, null == k ? m$1(E) : k, !!(32 & E.__u), d), v.__.__k[v.__i] = v, v.__d = void 0, v.__e != k && k$1(v), v } function k$1(c) { var u, d; if (null != (c = c.__) && null != c.__c) { for (c.__e = c.__c.base = null, u = 0; u < c.__k.length; u++)if (null != (d = c.__k[u]) && null != d.__e) { c.__e = c.__c.base = d.__e; break } return k$1(c) } } function x$1(c) { (!c.__d && (c.__d = !0) && ki.push(c) && !C$1.__r++ || Oi !== Ai.debounceRendering) && ((Oi = Ai.debounceRendering) || Pi)(C$1) } function C$1() { var c, u, d, v = [], E = []; for (ki.sort(Ri); c = ki.shift();)c.__d && (d = ki.length, u = w$1(c, v, E) || u, 0 === d || ki.length > d ? (j$1(v, u, E), E.length = v.length = 0, u = void 0, ki.sort(Ri)) : u && Ai.__c && Ai.__c(u, Ni)); u && j$1(v, u, E), C$1.__r = 0 } function P$1(c, u, d, v, E, k, R, U, H, G, W) { var Z, Y, J, K, X, Q = v && v.__k || Ni, ee = u.length; for (d.__d = H, function S(c, u, d) { var v, E, k, R, U, H = u.length, G = d.length, W = G, Z = 0; for (c.__k = [], v = 0; v < H; v++)null != (E = c.__k[v] = null == (E = u[v]) || "boolean" == typeof E || "function" == typeof E ? null : "string" == typeof E || "number" == typeof E || "bigint" == typeof E || E.constructor == String ? d$1(null, E, null, null, E) : $i(E) ? d$1(g$1, { "children": E }, null, null, null) : void 0 === E.constructor && E.__b > 0 ? d$1(E.type, E.props, E.key, E.ref ? E.ref : null, E.__v) : E) ? (E.__ = c, E.__b = c.__b + 1, U = I(E, d, R = v + Z, W), E.__i = U, k = null, -1 !== U && (W--, (k = d[U]) && (k.__u |= 131072)), null == k || null === k.__v ? (-1 == U && Z--, "function" != typeof E.type && (E.__u |= 65536)) : U !== R && (U === R + 1 ? Z++ : U > R ? W > H - R ? Z += U - R : Z-- : Z = U < R && U == R - 1 ? U - R : 0, U !== v + Z && (E.__u |= 65536))) : (k = d[v]) && null == k.key && k.__e && (k.__e == c.__d && (c.__d = m$1(k)), O(k, k, !1), d[v] = null, W--); if (W) for (v = 0; v < G; v++)null != (k = d[v]) && !(131072 & k.__u) && (k.__e == c.__d && (c.__d = m$1(k)), O(k, k)) }(d, u, Q), H = d.__d, Z = 0; Z < ee; Z++)null != (J = d.__k[Z]) && "boolean" != typeof J && "function" != typeof J && (Y = -1 === J.__i ? Mi : Q[J.__i] || Mi, J.__i = Z, M(c, J, Y, E, k, R, U, H, G, W), K = J.__e, J.ref && Y.ref != J.ref && (Y.ref && N(Y.ref, null, J), W.push(J.ref, J.__c || K, J)), null == X && null != K && (X = K), 65536 & J.__u || Y.__k === J.__k ? H = $(J, H, c) : "function" == typeof J.type && void 0 !== J.__d ? H = J.__d : K && (H = K.nextSibling), J.__d = void 0, J.__u &= -196609); d.__d = H, d.__e = X } function $(c, u, d) { var v, E; if ("function" == typeof c.type) { for (v = c.__k, E = 0; v && E < v.length; E++)v[E] && (v[E].__ = c, u = $(v[E], u, d)); return u } c.__e != u && (d.insertBefore(c.__e, u || null), u = c.__e); do { u = u && u.nextSibling } while (null != u && 8 === u.nodeType); return u } function I(c, u, d, v) { var E = c.key, k = c.type, R = d - 1, U = d + 1, H = u[d]; if (null === H || H && E == H.key && k === H.type) return d; if (v > (null == H || 131072 & H.__u ? 0 : 1)) for (; R >= 0 || U < u.length;) { if (R >= 0) { if ((H = u[R]) && !(131072 & H.__u) && E == H.key && k === H.type) return R; R-- } if (U < u.length) { if ((H = u[U]) && !(131072 & H.__u) && E == H.key && k === H.type) return U; U++ } } return -1 } function T$1(c, u, d) { "-" === u[0] ? c.setProperty(u, null == d ? "" : d) : c[u] = null == d ? "" : "number" != typeof d || Di.test(u) ? d : d + "px" } function A$1(c, u, d, v, E) { var k; e: if ("style" === u) if ("string" == typeof d) c.style.cssText = d; else { if ("string" == typeof v && (c.style.cssText = v = ""), v) for (u in v) d && u in d || T$1(c.style, u, ""); if (d) for (u in d) v && d[u] === v[u] || T$1(c.style, u, d[u]) } else if ("o" === u[0] && "n" === u[1]) k = u !== (u = u.replace(/(PointerCapture)$|Capture$/i, "$1")), u = u.toLowerCase() in c ? u.toLowerCase().slice(2) : u.slice(2), c.l || (c.l = {}), c.l[u + k] = d, d ? v ? d.u = v.u : (d.u = Date.now(), c.addEventListener(u, k ? L : D$1, k)) : c.removeEventListener(u, k ? L : D$1, k); else { if (E) u = u.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s"); else if ("width" !== u && "height" !== u && "href" !== u && "list" !== u && "form" !== u && "tabIndex" !== u && "download" !== u && "rowSpan" !== u && "colSpan" !== u && "role" !== u && u in c) try { c[u] = null == d ? "" : d; break e } catch (c) { } "function" == typeof d || (null == d || !1 === d && "-" !== u[4] ? c.removeAttribute(u) : c.setAttribute(u, d)) } } function D$1(c) { if (this.l) { var u = this.l[c.type + !1]; if (c.t) { if (c.t <= u.u) return } else c.t = Date.now(); return u(Ai.event ? Ai.event(c) : c) } } function L(c) { if (this.l) return this.l[c.type + !0](Ai.event ? Ai.event(c) : c) } function M(c, u, d, v, E, k, R, U, H, G) { var W, Z, Y, J, K, X, Q, ee, te, ne, re, oe, ie, ae, se, ce = u.type; if (void 0 !== u.constructor) return null; 128 & d.__u && (H = !!(32 & d.__u), k = [U = u.__e = d.__e]), (W = Ai.__b) && W(u); e: if ("function" == typeof ce) try { if (ee = u.props, te = (W = ce.contextType) && v[W.__c], ne = W ? te ? te.props.value : W.__ : v, d.__c ? Q = (Z = u.__c = d.__c).__ = Z.__E : ("prototype" in ce && ce.prototype.render ? u.__c = Z = new ce(ee, ne) : (u.__c = Z = new b$1(ee, ne), Z.constructor = ce, Z.render = q$1), te && te.sub(Z), Z.props = ee, Z.state || (Z.state = {}), Z.context = ne, Z.__n = v, Y = Z.__d = !0, Z.__h = [], Z._sb = []), null == Z.__s && (Z.__s = Z.state), null != ce.getDerivedStateFromProps && (Z.__s == Z.state && (Z.__s = v$1({}, Z.__s)), v$1(Z.__s, ce.getDerivedStateFromProps(ee, Z.__s))), J = Z.props, K = Z.state, Z.__v = u, Y) null == ce.getDerivedStateFromProps && null != Z.componentWillMount && Z.componentWillMount(), null != Z.componentDidMount && Z.__h.push(Z.componentDidMount); else { if (null == ce.getDerivedStateFromProps && ee !== J && null != Z.componentWillReceiveProps && Z.componentWillReceiveProps(ee, ne), !Z.__e && (null != Z.shouldComponentUpdate && !1 === Z.shouldComponentUpdate(ee, Z.__s, ne) || u.__v === d.__v)) { for (u.__v !== d.__v && (Z.props = ee, Z.state = Z.__s, Z.__d = !1), u.__e = d.__e, u.__k = d.__k, u.__k.forEach((function (c) { c && (c.__ = u) })), re = 0; re < Z._sb.length; re++)Z.__h.push(Z._sb[re]); Z._sb = [], Z.__h.length && R.push(Z); break e } null != Z.componentWillUpdate && Z.componentWillUpdate(ee, Z.__s, ne), null != Z.componentDidUpdate && Z.__h.push((function () { Z.componentDidUpdate(J, K, X) })) } if (Z.context = ne, Z.props = ee, Z.__P = c, Z.__e = !1, oe = Ai.__r, ie = 0, "prototype" in ce && ce.prototype.render) { for (Z.state = Z.__s, Z.__d = !1, oe && oe(u), W = Z.render(Z.props, Z.state, Z.context), ae = 0; ae < Z._sb.length; ae++)Z.__h.push(Z._sb[ae]); Z._sb = [] } else do { Z.__d = !1, oe && oe(u), W = Z.render(Z.props, Z.state, Z.context), Z.state = Z.__s } while (Z.__d && ++ie < 25); Z.state = Z.__s, null != Z.getChildContext && (v = v$1(v$1({}, v), Z.getChildContext())), Y || null == Z.getSnapshotBeforeUpdate || (X = Z.getSnapshotBeforeUpdate(J, K)), P$1(c, $i(se = null != W && W.type === g$1 && null == W.key ? W.props.children : W) ? se : [se], u, d, v, E, k, R, U, H, G), Z.base = u.__e, u.__u &= -161, Z.__h.length && R.push(Z), Q && (Z.__E = Z.__ = null) } catch (c) { u.__v = null, H || null != k ? (u.__e = U, u.__u |= H ? 160 : 32, k[k.indexOf(U)] = null) : (u.__e = d.__e, u.__k = d.__k), Ai.__e(c, u, d) } else null == k && u.__v === d.__v ? (u.__k = d.__k, u.__e = d.__e) : u.__e = z$1(d.__e, u, d, v, E, k, R, H, G); (W = Ai.diffed) && W(u) } function j$1(c, u, d) { for (var v = 0; v < d.length; v++)N(d[v], d[++v], d[++v]); Ai.__c && Ai.__c(u, c), c.some((function (u) { try { c = u.__h, u.__h = [], c.some((function (c) { c.call(u) })) } catch (c) { Ai.__e(c, u.__v) } })) } function z$1(c, u, d, v, E, k, R, U, H) { var G, W, Z, Y, J, K, X, Q = d.props, ee = u.props, te = u.type; if ("svg" === te && (E = !0), null != k) for (G = 0; G < k.length; G++)if ((J = k[G]) && "setAttribute" in J == !!te && (te ? J.localName === te : 3 === J.nodeType)) { c = J, k[G] = null; break } if (null == c) { if (null === te) return document.createTextNode(ee); c = E ? document.createElementNS("http://www.w3.org/2000/svg", te) : document.createElement(te, ee.is && ee), k = null, U = !1 } if (null === te) Q === ee || U && c.data === ee || (c.data = ee); else { if (k = k && xi.call(c.childNodes), Q = d.props || Mi, !U && null != k) for (Q = {}, G = 0; G < c.attributes.length; G++)Q[(J = c.attributes[G]).name] = J.value; for (G in Q) J = Q[G], "children" == G || ("dangerouslySetInnerHTML" == G ? Z = J : "key" === G || G in ee || A$1(c, G, null, J, E)); for (G in ee) J = ee[G], "children" == G ? Y = J : "dangerouslySetInnerHTML" == G ? W = J : "value" == G ? K = J : "checked" == G ? X = J : "key" === G || U && "function" != typeof J || Q[G] === J || A$1(c, G, J, Q[G], E); if (W) U || Z && (W.__html === Z.__html || W.__html === c.innerHTML) || (c.innerHTML = W.__html), u.__k = []; else if (Z && (c.innerHTML = ""), P$1(c, $i(Y) ? Y : [Y], u, d, v, E && "foreignObject" !== te, k, R, k ? k[0] : d.__k && m$1(d, 0), U, H), null != k) for (G = k.length; G--;)null != k[G] && p$1(k[G]); U || (G = "value", void 0 !== K && (K !== c[G] || "progress" === te && !K || "option" === te && K !== Q[G]) && A$1(c, G, K, Q[G], !1), G = "checked", void 0 !== X && X !== c[G] && A$1(c, G, X, Q[G], !1)) } return c } function N(c, u, d) { try { "function" == typeof c ? c(u) : c.current = u } catch (c) { Ai.__e(c, d) } } function O(c, u, d) { var v, E; if (Ai.unmount && Ai.unmount(c), (v = c.ref) && (v.current && v.current !== c.__e || N(v, null, u)), null != (v = c.__c)) { if (v.componentWillUnmount) try { v.componentWillUnmount() } catch (c) { Ai.__e(c, u) } v.base = v.__P = null, c.__c = void 0 } if (v = c.__k) for (E = 0; E < v.length; E++)v[E] && O(v[E], u, d || "function" != typeof c.type); d || null == c.__e || p$1(c.__e), c.__ = c.__e = c.__d = void 0 } function q$1(c, u, d) { return this.constructor(c, d) } xi = Ni.slice, Ai = { "__e": function (c, u, d, v) { for (var E, k, R; u = u.__;)if ((E = u.__c) && !E.__) try { if ((k = E.constructor) && null != k.getDerivedStateFromError && (E.setState(k.getDerivedStateFromError(c)), R = E.__d), null != E.componentDidCatch && (E.componentDidCatch(c, v || {}), R = E.__d), R) return E.__E = E } catch (u) { c = u } throw c } }, Ii = 0, b$1.prototype.setState = function (c, u) { var d; d = null != this.__s && this.__s !== this.state ? this.__s : this.__s = v$1({}, this.state), "function" == typeof c && (c = c(v$1({}, d), this.props)), c && v$1(d, c), null != c && this.__v && (u && this._sb.push(u), x$1(this)) }, b$1.prototype.forceUpdate = function (c) { this.__v && (this.__e = !0, c && this.__h.push(c), x$1(this)) }, b$1.prototype.render = g$1, ki = [], Pi = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, Ri = function (c, u) { return c.__v.__b - u.__v.__b }, C$1.__r = 0; var Li, Fi, ji, Bi, Ui = 0, Hi = [], zi = [], qi = Ai, Gi = qi.__b, Vi = qi.__r, Wi = qi.diffed, Zi = qi.__c, Yi = qi.unmount, Ji = qi.__; function h(c, u) { qi.__h && qi.__h(Fi, c, Ui || u), Ui = 0; var d = Fi.__H || (Fi.__H = { "__": [], "__h": [] }); return c >= d.__.length && d.__.push({ "__V": zi }), d.__[c] } function p(c) { return Ui = 1, y(D, c) } function y(c, u, d) { var v = h(Li++, 2); if (v.t = c, !v.__c && (v.__ = [d ? d(u) : D(void 0, u), function (c) { var u = v.__N ? v.__N[0] : v.__[0], d = v.t(u, c); u !== d && (v.__N = [d, v.__[1]], v.__c.setState({})) }], v.__c = Fi, !Fi.u)) { var f = function (c, u, d) { if (!v.__c.__H) return !0; var k = v.__c.__H.__.filter((function (c) { return !!c.__c })); if (k.every((function (c) { return !c.__N }))) return !E || E.call(this, c, u, d); var R = !1; return k.forEach((function (c) { if (c.__N) { var u = c.__[0]; c.__ = c.__N, c.__N = void 0, u !== c.__[0] && (R = !0) } })), !(!R && v.__c.props === c) && (!E || E.call(this, c, u, d)) }; Fi.u = !0; var E = Fi.shouldComponentUpdate, k = Fi.componentWillUpdate; Fi.componentWillUpdate = function (c, u, d) { if (this.__e) { var v = E; E = void 0, f(c, u, d), E = v } k && k.call(this, c, u, d) }, Fi.shouldComponentUpdate = f } return v.__N || v.__ } function A(c, u) { var d = h(Li++, 4); !qi.__s && C(d.__H, u) && (d.__ = c, d.i = u, Fi.__h.push(d)) } function q(c, u) { var d = h(Li++, 7); return C(d.__H, u) ? (d.__V = c(), d.i = u, d.__h = c, d.__V) : d.__ } function x(c, u) { return Ui = 8, q((function () { return c }), u) } function j() { for (var c; c = Hi.shift();)if (c.__P && c.__H) try { c.__H.__h.forEach(z), c.__H.__h.forEach(B), c.__H.__h = [] } catch (u) { c.__H.__h = [], qi.__e(u, c.__v) } } qi.__b = function (c) { Fi = null, Gi && Gi(c) }, qi.__ = function (c, u) { u.__k && u.__k.__m && (c.__m = u.__k.__m), Ji && Ji(c, u) }, qi.__r = function (c) { Vi && Vi(c), Li = 0; var u = (Fi = c.__c).__H; u && (ji === Fi ? (u.__h = [], Fi.__h = [], u.__.forEach((function (c) { c.__N && (c.__ = c.__N), c.__V = zi, c.__N = c.i = void 0 }))) : (u.__h.forEach(z), u.__h.forEach(B), u.__h = [], Li = 0)), ji = Fi }, qi.diffed = function (c) { Wi && Wi(c); var u = c.__c; u && u.__H && (u.__H.__h.length && (1 !== Hi.push(u) && Bi === qi.requestAnimationFrame || ((Bi = qi.requestAnimationFrame) || w)(j)), u.__H.__.forEach((function (c) { c.i && (c.__H = c.i), c.__V !== zi && (c.__ = c.__V), c.i = void 0, c.__V = zi }))), ji = Fi = null }, qi.__c = function (c, u) { u.some((function (c) { try { c.__h.forEach(z), c.__h = c.__h.filter((function (c) { return !c.__ || B(c) })) } catch (d) { u.some((function (c) { c.__h && (c.__h = []) })), u = [], qi.__e(d, c.__v) } })), Zi && Zi(c, u) }, qi.unmount = function (c) { Yi && Yi(c); var u, d = c.__c; d && d.__H && (d.__H.__.forEach((function (c) { try { z(c) } catch (c) { u = c } })), d.__H = void 0, u && qi.__e(u, d.__v)) }; var Ki = "function" == typeof requestAnimationFrame; function w(c) { var u, r = function () { clearTimeout(d), Ki && cancelAnimationFrame(u), setTimeout(c) }, d = setTimeout(r, 100); Ki && (u = requestAnimationFrame(r)) } function z(c) { var u = Fi, d = c.__c; "function" == typeof d && (c.__c = void 0, d()), Fi = u } function B(c) { var u = Fi; c.__c = c.__(), Fi = u } function C(c, u) { return !c || c.length !== u.length || u.some((function (u, d) { return u !== c[d] })) } function D(c, u) { return "function" == typeof u ? u(c) : u } const Xi = { "__proto__": null, "useCallback": x, "useContext": function P(c) { var u = Fi.context[c.__c], d = h(Li++, 9); return d.c = c, u ? (null == d.__ && (d.__ = !0, u.sub(Fi)), u.props.value) : c.__ }, "useDebugValue": function V(c, u) { qi.useDebugValue && qi.useDebugValue(u ? u(c) : c) }, "useEffect": function _(c, u) { var d = h(Li++, 3); !qi.__s && C(d.__H, u) && (d.__ = c, d.i = u, Fi.__H.__h.push(d)) }, "useErrorBoundary": function b(c) { var u = h(Li++, 10), d = p(); return u.__ = c, Fi.componentDidCatch || (Fi.componentDidCatch = function (c, v) { u.__ && u.__(c, v), d[1](c) }), [d[0], function () { d[1](void 0) }] }, "useId": function g() { var c = h(Li++, 11); if (!c.__) { for (var u = Fi.__v; null !== u && !u.__m && null !== u.__;)u = u.__; var d = u.__m || (u.__m = [0, 0]); c.__ = "P" + d[0] + "-" + d[1]++ } return c.__ }, "useImperativeHandle": function T(c, u, d) { Ui = 6, A((function () { return "function" == typeof c ? (c(u()), function () { return c(null) }) : c ? (c.current = u(), function () { return c.current = null }) : void 0 }), null == d ? d : d.concat(c)) }, "useLayoutEffect": A, "useMemo": q, "useReducer": y, "useRef": function F(c) { return Ui = 5, q((function () { return { "current": c } }), []) }, "useState": p }, Qi = "http://www.w3.org/2000/svg"; function SentryLogo() { const createElementNS = c => gi.createElementNS(Qi, c), c = setAttributesNS(createElementNS("svg"), { "width": "32", "height": "30", "viewBox": "0 0 72 66", "fill": "inherit" }), u = setAttributesNS(createElementNS("path"), { "transform": "translate(11, 11)", "d": "M29,2.26a4.67,4.67,0,0,0-8,0L14.42,13.53A32.21,32.21,0,0,1,32.17,40.19H27.55A27.68,27.68,0,0,0,12.09,17.47L6,28a15.92,15.92,0,0,1,9.23,12.17H4.62A.76.76,0,0,1,4,39.06l2.94-5a10.74,10.74,0,0,0-3.36-1.9l-2.91,5a4.54,4.54,0,0,0,1.69,6.24A4.66,4.66,0,0,0,4.62,44H19.15a19.4,19.4,0,0,0-8-17.31l2.31-4A23.87,23.87,0,0,1,23.76,44H36.07a35.88,35.88,0,0,0-16.41-31.8l4.67-8a.77.77,0,0,1,1.05-.27c.53.29,20.29,34.77,20.66,35.17a.76.76,0,0,1-.68,1.13H40.6q.09,1.91,0,3.81h4.78A4.59,4.59,0,0,0,50,39.43a4.49,4.49,0,0,0-.62-2.28Z" }); return c.appendChild(u), c } const ea = "/home/runner/work/sentry-javascript/sentry-javascript/packages/feedback/src/modal/components/DialogHeader.tsx"; function DialogHeader({ "options": c }) { const u = q((() => ({ "__html": SentryLogo().outerHTML })), []); return y$1("h2", { "class": "dialog__header", "__self": this, "__source": { "fileName": ea, "lineNumber": 16 } }, c.formTitle, c.showBranding ? y$1("a", { "class": "brand-link", "target": "_blank", "href": "https://sentry.io/welcome/", "title": "Powered by Sentry", "rel": "noopener noreferrer", "dangerouslySetInnerHTML": u, "__self": this, "__source": { "fileName": ea, "lineNumber": 19 } }) : null) } const ta = "/home/runner/work/sentry-javascript/sentry-javascript/packages/feedback/src/modal/components/Form.tsx"; function retrieveStringValue(c, u) { const d = c.get(u); return "string" == typeof d ? d.trim() : "" } function Form({ "options": c, "defaultEmail": u, "defaultName": d, "onFormClose": v, "onSubmit": E, "onSubmitSuccess": k, "onSubmitError": R, "showEmail": U, "showName": H, "screenshotInput": G }) { const { "tags": W, "addScreenshotButtonLabel": Z, "removeScreenshotButtonLabel": Y, "cancelButtonLabel": J, "emailLabel": K, "emailPlaceholder": X, "isEmailRequired": Q, "isNameRequired": ee, "messageLabel": te, "messagePlaceholder": ne, "nameLabel": re, "namePlaceholder": oe, "submitButtonLabel": ie, "isRequiredLabel": ae } = c, [se, ce] = p(null), [le, ue] = p(!1), de = G && G.input, [pe, fe] = p(null), he = x((c => { fe(c), ue(!1) }), []), me = x((c => { const u = function getMissingFields(c, u) { const d = []; return u.isNameRequired && !c.name && d.push(u.nameLabel), u.isEmailRequired && !c.email && d.push(u.emailLabel), c.message || d.push(u.messageLabel), d }(c, { "emailLabel": K, "isEmailRequired": Q, "isNameRequired": ee, "messageLabel": te, "nameLabel": re }); return u.length > 0 ? ce(`Please enter in the following required fields: ${u.join(", ")}`) : ce(null), 0 === u.length }), [K, Q, ee, te, re]), ge = x((async c => { try { if (c.preventDefault(), !(c.target instanceof HTMLFormElement)) return; const u = new FormData(c.target), d = await (G && le ? G.value() : void 0), v = { "name": retrieveStringValue(u, "name"), "email": retrieveStringValue(u, "email"), "message": retrieveStringValue(u, "message"), "attachments": d ? [d] : void 0 }; if (!me(v)) return; try { await E({ "name": v.name, "email": v.email, "message": v.message, "source": yi, "tags": W }, { "attachments": v.attachments }), k(v) } catch (c) { bi && di.error(c), ce(c), R(c) } } catch (c) { } }), [G && le, k, R]); return y$1("form", { "class": "form", "onSubmit": ge, "__self": this, "__source": { "fileName": ta, "lineNumber": 144 } }, de && le ? y$1(de, { "onError": he, "__self": this, "__source": { "fileName": ta, "lineNumber": 146 } }) : null, y$1("div", { "class": "form__right", "data-sentry-feedback": !0, "__self": this, "__source": { "fileName": ta, "lineNumber": 149 } }, y$1("div", { "class": "form__top", "__self": this, "__source": { "fileName": ta, "lineNumber": 150 } }, se ? y$1("div", { "class": "form__error-container", "__self": this, "__source": { "fileName": ta, "lineNumber": 151 } }, se) : null, H ? y$1("label", { "for": "name", "class": "form__label", "__self": this, "__source": { "fileName": ta, "lineNumber": 154 } }, y$1(LabelText, { "label": re, "isRequiredLabel": ae, "isRequired": ee, "__self": this, "__source": { "fileName": ta, "lineNumber": 155 } }), y$1("input", { "class": "form__input", "defaultValue": d, "id": "name", "name": "name", "placeholder": oe, "required": ee, "type": "text", "__self": this, "__source": { "fileName": ta, "lineNumber": 156 } })) : y$1("input", { "aria-hidden": !0, "value": d, "name": "name", "type": "hidden", "__self": this, "__source": { "fileName": ta, "lineNumber": 167 } }), U ? y$1("label", { "for": "email", "class": "form__label", "__self": this, "__source": { "fileName": ta, "lineNumber": 171 } }, y$1(LabelText, { "label": K, "isRequiredLabel": ae, "isRequired": Q, "__self": this, "__source": { "fileName": ta, "lineNumber": 172 } }), y$1("input", { "class": "form__input", "defaultValue": u, "id": "email", "name": "email", "placeholder": X, "required": Q, "type": "email", "__self": this, "__source": { "fileName": ta, "lineNumber": 173 } })) : y$1("input", { "aria-hidden": !0, "value": u, "name": "email", "type": "hidden", "__self": this, "__source": { "fileName": ta, "lineNumber": 184 } }), y$1("label", { "for": "message", "class": "form__label", "__self": this, "__source": { "fileName": ta, "lineNumber": 187 } }, y$1(LabelText, { "label": te, "isRequiredLabel": ae, "isRequired": !0, "__self": this, "__source": { "fileName": ta, "lineNumber": 188 } }), y$1("textarea", { "autoFocus": !0, "class": "form__input form__input--textarea", "id": "message", "name": "message", "placeholder": ne, "required": !0, "rows": 5, "__self": this, "__source": { "fileName": ta, "lineNumber": 189 } })), de ? y$1("label", { "for": "screenshot", "class": "form__label", "__self": this, "__source": { "fileName": ta, "lineNumber": 201 } }, y$1("button", { "class": "btn btn--default", "type": "button", "onClick": () => { fe(null), ue((c => !c)) }, "__self": this, "__source": { "fileName": ta, "lineNumber": 202 } }, le ? Y : Z), pe ? y$1("div", { "class": "form__error-container", "__self": this, "__source": { "fileName": ta, "lineNumber": 212 } }, pe.message) : null) : null), y$1("div", { "class": "btn-group", "__self": this, "__source": { "fileName": ta, "lineNumber": 216 } }, y$1("button", { "class": "btn btn--primary", "type": "submit", "__self": this, "__source": { "fileName": ta, "lineNumber": 217 } }, ie), y$1("button", { "class": "btn btn--default", "type": "button", "onClick": v, "__self": this, "__source": { "fileName": ta, "lineNumber": 220 } }, J)))) } function LabelText({ "label": c, "isRequired": u, "isRequiredLabel": d }) { return y$1("span", { "class": "form__label__text", "__self": this, "__source": { "fileName": ta, "lineNumber": 239 } }, c, u && y$1("span", { "class": "form__label__text--required", "__self": this, "__source": { "fileName": ta, "lineNumber": 241 } }, d)) } const na = 16, ra = 17, oa = "http://www.w3.org/2000/svg"; function SuccessIcon() { const createElementNS = c => mi.document.createElementNS(oa, c), c = setAttributesNS(createElementNS("svg"), { "width": `${na}`, "height": `${ra}`, "viewBox": `0 0 ${na} ${ra}`, "fill": "inherit" }), u = setAttributesNS(createElementNS("g"), { "clipPath": "url(#clip0_57_156)" }), d = setAttributesNS(createElementNS("path"), { "fill-rule": "evenodd", "clip-rule": "evenodd", "d": "M3.55544 15.1518C4.87103 16.0308 6.41775 16.5 8 16.5C10.1217 16.5 12.1566 15.6571 13.6569 14.1569C15.1571 12.6566 16 10.6217 16 8.5C16 6.91775 15.5308 5.37103 14.6518 4.05544C13.7727 2.73985 12.5233 1.71447 11.0615 1.10897C9.59966 0.503466 7.99113 0.34504 6.43928 0.653721C4.88743 0.962403 3.46197 1.72433 2.34315 2.84315C1.22433 3.96197 0.462403 5.38743 0.153721 6.93928C-0.15496 8.49113 0.00346625 10.0997 0.608967 11.5615C1.21447 13.0233 2.23985 14.2727 3.55544 15.1518ZM4.40546 3.1204C5.46945 2.40946 6.72036 2.03 8 2.03C9.71595 2.03 11.3616 2.71166 12.575 3.92502C13.7883 5.13838 14.47 6.78405 14.47 8.5C14.47 9.77965 14.0905 11.0306 13.3796 12.0945C12.6687 13.1585 11.6582 13.9878 10.476 14.4775C9.29373 14.9672 7.99283 15.0953 6.73777 14.8457C5.48271 14.596 4.32987 13.9798 3.42502 13.075C2.52018 12.1701 1.90397 11.0173 1.65432 9.76224C1.40468 8.50718 1.5328 7.20628 2.0225 6.02404C2.5122 4.8418 3.34148 3.83133 4.40546 3.1204Z" }), v = setAttributesNS(createElementNS("path"), { "d": "M6.68775 12.4297C6.78586 12.4745 6.89218 12.4984 7 12.5C7.11275 12.4955 7.22315 12.4664 7.32337 12.4145C7.4236 12.3627 7.51121 12.2894 7.58 12.2L12 5.63999C12.0848 5.47724 12.1071 5.28902 12.0625 5.11098C12.0178 4.93294 11.9095 4.77744 11.7579 4.67392C11.6064 4.57041 11.4221 4.52608 11.24 4.54931C11.0579 4.57254 10.8907 4.66173 10.77 4.79999L6.88 10.57L5.13 8.56999C5.06508 8.49566 4.98613 8.43488 4.89768 8.39111C4.80922 8.34735 4.713 8.32148 4.61453 8.31498C4.51605 8.30847 4.41727 8.32147 4.32382 8.35322C4.23038 8.38497 4.14413 8.43484 4.07 8.49999C3.92511 8.63217 3.83692 8.81523 3.82387 9.01092C3.81083 9.2066 3.87393 9.39976 4 9.54999L6.43 12.24C6.50187 12.3204 6.58964 12.385 6.68775 12.4297Z" }); c.appendChild(u).append(v, d); const E = createElementNS("defs"), k = setAttributesNS(createElementNS("clipPath"), { "id": "clip0_57_156" }), R = setAttributesNS(createElementNS("rect"), { "width": `${na}`, "height": `${na}`, "fill": "white", "transform": "translate(0 0.5)" }); return k.appendChild(R), E.appendChild(k), c.appendChild(E).appendChild(k).appendChild(R), c } const ia = "/home/runner/work/sentry-javascript/sentry-javascript/packages/feedback/src/modal/components/Dialog.tsx"; function Dialog({ "open": c, "onFormSubmitted": u, ...d }) { const v = d.options, E = q((() => ({ "__html": SuccessIcon().outerHTML })), []), [k, R] = p(null), U = x((() => { k && (clearTimeout(k), R(null)), u() }), [k]), H = x((c => { d.onSubmitSuccess(c), R(setTimeout((() => { u(), R(null) }), 5e3)) }), [u]); return y$1(g$1, { "__self": this, "__source": { "fileName": ia, "lineNumber": 48 } }, k ? y$1("div", { "class": "success__position", "onClick": U, "__self": this, "__source": { "fileName": ia, "lineNumber": 50 } }, y$1("div", { "class": "success__content", "__self": this, "__source": { "fileName": ia, "lineNumber": 51 } }, v.successMessageText, y$1("span", { "class": "success__icon", "dangerouslySetInnerHTML": E, "__self": this, "__source": { "fileName": ia, "lineNumber": 53 } }))) : y$1("dialog", { "class": "dialog", "onClick": v.onFormClose, "open": c, "__self": this, "__source": { "fileName": ia, "lineNumber": 57 } }, y$1("div", { "class": "dialog__position", "__self": this, "__source": { "fileName": ia, "lineNumber": 58 } }, y$1("div", { "class": "dialog__content", "onClick": c => { c.stopPropagation() }, "__self": this, "__source": { "fileName": ia, "lineNumber": 59 } }, y$1(DialogHeader, { "options": v, "__self": this, "__source": { "fileName": ia, "lineNumber": 66 } }), y$1(Form, { ...d, "onSubmitSuccess": H, "__self": this, "__source": { "fileName": ia, "lineNumber": 67 } }))))) } function getUser() { const c = core_build_esm_currentScopes_getCurrentScope().getUser(), u = function core_build_esm_currentScopes_getIsolationScope() { return core_build_esm_asyncContext_getAsyncContextStrategy(core_build_esm_carrier_getMainCarrier()).getIsolationScope() }().getUser(), d = function core_build_esm_currentScopes_getGlobalScope() { return _sentry_utils_build_esm_worldwide_getGlobalSingleton("globalScope", (() => new fi)) }().getUser(); return c && Object.keys(c).length ? c : u && Object.keys(u).length ? u : d } const feedbackModalIntegration = () => ({ "name": "FeedbackModal", "setupOnce"() { }, "createDialog": ({ "options": c, "screenshotIntegration": u, "sendFeedback": d, "shadow": v }) => { const E = v, k = c.useSentryUser, R = getUser(), U = gi.createElement("div"), H = function createDialogStyles(c) { const u = gi.createElement("style"); return u.textContent = "\n:host {\n  --dialog-inset: var(--inset);\n}\n\n\n.dialog {\n  position: fixed;\n  z-index: var(--z-index);\n  margin: 0;\n  inset: 0;\n\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  padding: 0;\n  height: 100vh;\n  width: 100vw;\n\n  color: var(--dialog-color, var(--foreground));\n  fill: var(--dialog-color, var(--foreground));\n  line-height: 1.75em;\n\n  background-color: rgba(0, 0, 0, 0.05);\n  border: none;\n  inset: 0;\n  opacity: 1;\n  transition: opacity 0.2s ease-in-out;\n}\n\n.dialog__position {\n  position: fixed;\n  z-index: var(--z-index);\n  inset: var(--dialog-inset);\n  padding: var(--page-margin);\n  display: flex;\n  max-height: calc(100vh - (2 * var(--page-margin)));\n}\n@media (max-width: 600px) {\n  .dialog__position {\n    inset: var(--page-margin);\n    padding: 0;\n  }\n}\n\n.dialog__position:has(.editor) {\n  inset: var(--page-margin);\n  padding: 0;\n}\n\n.dialog:not([open]) {\n  opacity: 0;\n  pointer-events: none;\n  visibility: hidden;\n}\n.dialog:not([open]) .dialog__content {\n  transform: translate(0, -16px) scale(0.98);\n}\n\n.dialog__content {\n  display: flex;\n  flex-direction: column;\n  gap: 16px;\n  padding: var(--dialog-padding, 24px);\n  max-width: 100%;\n  width: 100%;\n  max-height: 100%;\n  overflow: auto;\n\n  background: var(--dialog-background, var(--background));\n  border-radius: var(--dialog-border-radius, 20px);\n  border: var(--dialog-border, var(--border));\n  box-shadow: var(--dialog-box-shadow, var(--box-shadow));\n  transform: translate(0, 0) scale(1);\n  transition: transform 0.2s ease-in-out;\n}\n\n\n.dialog__header {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  font-weight: var(--dialog-header-weight, 600);\n  margin: 0;\n}\n\n.brand-link {\n  display: inline-flex;\n}\n.brand-link:focus-visible {\n  outline: var(--outline);\n}\n\n\n.form {\n  display: flex;\n  overflow: auto;\n  flex-direction: row;\n  gap: 16px;\n  flex: 1 0;\n}\n\n.form__right {\n  flex: 0 0 var(--form-width, 272px);\n  width: var(--form-width, 272px);\n  display: flex;\n  overflow: auto;\n  flex-direction: column;\n  justify-content: space-between;\n  gap: 20px;\n}\n\n@media (max-width: 600px) {\n  .form__right {\n    width: auto;\n  }\n}\n\n.form__top {\n  display: flex;\n  flex-direction: column;\n  gap: 8px;\n}\n\n.form__error-container {\n  color: var(--error-color);\n  fill: var(--error-color);\n}\n\n.form__label {\n  display: flex;\n  flex-direction: column;\n  gap: 4px;\n  margin: 0px;\n}\n\n.form__label__text {\n  display: flex;\n  gap: 4px;\n  align-items: center;\n}\n\n.form__label__text--required {\n  font-size: 0.85em;\n}\n\n.form__input {\n  font-family: inherit;\n  line-height: inherit;\n  background: transparent;\n  box-sizing: border-box;\n  border: var(--input-border, var(--border));\n  border-radius: var(--input-border-radius, 6px);\n  color: var(--input-color, inherit);\n  fill: var(--input-color, inherit);\n  font-size: var(--input-font-size, inherit);\n  font-weight: var(--input-font-weight, 500);\n  padding: 6px 12px;\n}\n\n.form__input::placeholder {\n  opacity: 0.65;\n  color: var(--input-placeholder-color, inherit);\n  filter: var(--interactive-filter);\n}\n\n.form__input:focus-visible {\n  outline: var(--input-focus-outline, var(--outline));\n}\n\n.form__input--textarea {\n  font-family: inherit;\n  resize: vertical;\n}\n\n.error {\n  color: var(--error-color);\n  fill: var(--error-color);\n}\n\n\n.btn-group {\n  display: grid;\n  gap: 8px;\n}\n\n.btn {\n  line-height: inherit;\n  border: var(--button-border, var(--border));\n  border-radius: var(--button-border-radius, 6px);\n  cursor: pointer;\n  font-family: inherit;\n  font-size: var(--button-font-size, inherit);\n  font-weight: var(--button-font-weight, 600);\n  padding: var(--button-padding, 6px 16px);\n}\n.btn[disabled] {\n  opacity: 0.6;\n  pointer-events: none;\n}\n\n.btn--primary {\n  color: var(--button-primary-color, var(--accent-foreground));\n  fill: var(--button-primary-color, var(--accent-foreground));\n  background: var(--button-primary-background, var(--accent-background));\n  border: var(--button-primary-border, var(--border));\n  border-radius: var(--button-primary-border-radius, 6px);\n  font-weight: var(--button-primary-font-weight, 500);\n}\n.btn--primary:hover {\n  color: var(--button-primary-hover-color, var(--accent-foreground));\n  fill: var(--button-primary-hover-color, var(--accent-foreground));\n  background: var(--button-primary-hover-background, var(--accent-background));\n  filter: var(--interactive-filter);\n}\n.btn--primary:focus-visible {\n  background: var(--button-primary-hover-background, var(--accent-background));\n  filter: var(--interactive-filter);\n  outline: var(--button-primary-focus-outline, var(--outline));\n}\n\n.btn--default {\n  color: var(--button-color, var(--foreground));\n  fill: var(--button-color, var(--foreground));\n  background: var(--button-background, var(--background));\n  border: var(--button-border, var(--border));\n  border-radius: var(--button-border-radius, 6px);\n  font-weight: var(--button-font-weight, 500);\n}\n.btn--default:hover {\n  color: var(--button-color, var(--foreground));\n  fill: var(--button-color, var(--foreground));\n  background: var(--button-hover-background, var(--background));\n  filter: var(--interactive-filter);\n}\n.btn--default:focus-visible {\n  background: var(--button-hover-background, var(--background));\n  filter: var(--interactive-filter);\n  outline: var(--button-focus-outline, var(--outline));\n}\n\n\n.success__position {\n  position: fixed;\n  inset: var(--dialog-inset);\n  padding: var(--page-margin);\n  z-index: var(--z-index);\n}\n.success__content {\n  background: var(--success-background, var(--background));\n  border: var(--success-border, var(--border));\n  border-radius: var(--success-border-radius, 1.7em/50%);\n  box-shadow: var(--success-box-shadow, var(--box-shadow));\n  font-weight: var(--success-font-weight, 600);\n  color: var(--success-color);\n  fill: var(--success-color);\n  padding: 12px 24px;\n  line-height: 1.75em;\n\n  display: grid;\n  align-items: center;\n  grid-auto-flow: column;\n  gap: 6px;\n  cursor: default;\n}\n\n.success__icon {\n  display: flex;\n}\n\n", c && u.setAttribute("nonce", c), u }(c.styleNonce); let G = ""; const W = { get "el"() { return U }, "appendToDom"() { E.contains(H) || E.contains(U) || (E.appendChild(H), E.appendChild(U)) }, "removeFromDom"() { E.removeChild(U), E.removeChild(H), gi.body.style.overflow = G }, "open"() { renderContent(!0), c.onFormOpen && c.onFormOpen(), G = gi.body.style.overflow, gi.body.style.overflow = "hidden" }, "close"() { renderContent(!1), gi.body.style.overflow = G } }, Z = u && u.createInput({ "h": y$1, "hooks": Xi, "dialog": W, "options": c }), renderContent = u => { !function B$1(c, u, d) { var v, E, k, R; Ai.__ && Ai.__(c, u), E = (v = "function" == typeof d) ? null : d && d.__k || u.__k, k = [], R = [], M(u, c = (!v && d || u).__k = y$1(g$1, null, [c]), E || Mi, Mi, void 0 !== u.ownerSVGElement, !v && d ? [d] : E ? null : u.firstChild ? xi.call(u.childNodes) : null, k, !v && d ? d : E ? E.__e : u.firstChild, v, R), c.__d = void 0, j$1(k, c, R) }(y$1(Dialog, { "options": c, "screenshotInput": Z, "showName": c.showName || c.isNameRequired, "showEmail": c.showEmail || c.isEmailRequired, "defaultName": k && R && R[k.name] || "", "defaultEmail": k && R && R[k.email] || "", "onFormClose": () => { renderContent(!1), c.onFormClose && c.onFormClose() }, "onSubmit": d, "onSubmitSuccess": u => { renderContent(!1), c.onSubmitSuccess && c.onSubmitSuccess(u) }, "onSubmitError": u => { c.onSubmitError && c.onSubmitError(u) }, "onFormSubmitted": () => { c.onFormSubmitted && c.onFormSubmitted() }, "open": u, "__self": void 0, "__source": { "fileName": "/home/runner/work/sentry-javascript/sentry-javascript/packages/feedback/src/modal/integration.tsx", "lineNumber": 67 } }), U) }; return W } }), aa = "/home/runner/work/sentry-javascript/sentry-javascript/packages/feedback/src/screenshot/components/CropCorner.tsx"; function createScreenshotInputStyles(c) { const u = gi.createElement("style"), d = "#1A141F", v = "#302735"; return u.textContent = `\n.editor {\n  padding: 10px;\n  padding-top: 65px;\n  padding-bottom: 65px;\n  flex-grow: 1;\n\n  background-color: ${d};\n  background-image: repeating-linear-gradient(\n      -145deg,\n      transparent,\n      transparent 8px,\n      ${d} 8px,\n      ${d} 11px\n    ),\n    repeating-linear-gradient(\n      -45deg,\n      transparent,\n      transparent 15px,\n      ${v} 15px,\n      ${v} 16px\n    );\n}\n\n.editor__canvas-container {\n  width: 100%;\n  height: 100%;\n  position: relative;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.editor__canvas-container canvas {\n  object-fit: contain;\n  position: relative;\n}\n\n.editor__crop-btn-group {\n  padding: 8px;\n  gap: 8px;\n  border-radius: var(--menu-border-radius, 6px);\n  background: var(--button-primary-background, var(--background));\n  width: 175px;\n  position: absolute;\n}\n\n.editor__crop-corner {\n  width: 30px;\n  height: 30px;\n  position: absolute;\n  background: none;\n  border: 3px solid #ffffff;\n}\n\n.editor__crop-corner--top-left {\n  cursor: nwse-resize;\n  border-right: none;\n  border-bottom: none;\n}\n.editor__crop-corner--top-right {\n  cursor: nesw-resize;\n  border-left: none;\n  border-bottom: none;\n}\n.editor__crop-corner--bottom-left {\n  cursor: nesw-resize;\n  border-right: none;\n  border-top: none;\n}\n.editor__crop-corner--bottom-right {\n  cursor: nwse-resize;\n  border-left: none;\n  border-top: none;\n}\n`, c && u.setAttribute("nonce", c), u } const sa = "/home/runner/work/sentry-javascript/sentry-javascript/packages/feedback/src/screenshot/components/ScreenshotEditor.tsx", ca = 33, la = mi.devicePixelRatio, constructRect = c => ({ "x": Math.min(c.startX, c.endX), "y": Math.min(c.startY, c.endY), "width": Math.abs(c.startX - c.endX), "height": Math.abs(c.startY - c.endY) }), getContainedSize = c => { const u = c.clientHeight, d = c.clientWidth, v = c.width / c.height; let E = u * v, k = u; E > d && (E = d, k = d / v); const R = (d - E) / 2, U = (u - k) / 2; return { "startX": R, "startY": U, "endX": E + R, "endY": k + U } }; function ScreenshotEditorFactory({ "h": c, "hooks": u, "imageBuffer": d, "dialog": v, "options": E }) { const k = function useTakeScreenshotFactory({ "hooks": c }) { return function useTakeScreenshot({ "onBeforeScreenshot": u, "onScreenshot": d, "onAfterScreenshot": v, "onError": E }) { c.useEffect((() => { (async () => { u(); const c = await _i.mediaDevices.getDisplayMedia({ "video": { "width": mi.innerWidth * mi.devicePixelRatio, "height": mi.innerHeight * mi.devicePixelRatio }, "audio": !1, "monitorTypeSurfaces": "exclude", "preferCurrentTab": !0, "selfBrowserSurface": "include", "surfaceSwitching": "exclude" }), E = gi.createElement("video"); await new Promise(((u, v) => { E.srcObject = c, E.onloadedmetadata = () => { d(E), c.getTracks().forEach((c => c.stop())), u() }, E.play().catch(v) })), v() })().catch(E) }), []) } }({ "hooks": u }); return function ScreenshotEditor({ "onError": R }) { const U = u.useMemo((() => ({ "__html": createScreenshotInputStyles(E.styleNonce).innerText })), []), H = function CropCornerFactory({ "h": c }) { return function CropCorner({ "top": u, "left": d, "corner": v, "onGrabButton": E }) { return c("button", { "class": `editor__crop-corner editor__crop-corner--${v} `, "style": { "top": u, "left": d }, "onMouseDown": c => { c.preventDefault(), E(c, v) }, "onClick": c => { c.preventDefault() }, "__self": this, "__source": { "fileName": aa, "lineNumber": 22 } }) } }({ "h": c }), G = u.useRef(null), W = u.useRef(null), Z = u.useRef(null), [Y, J] = u.useState({ "startX": 0, "startY": 0, "endX": 0, "endY": 0 }), [K, X] = u.useState(!1), [Q, ee] = u.useState(!1); function resizeCropper() { const c = Z.current, u = constructRect(getContainedSize(d)); if (c) { c.width = u.width * la, c.height = u.height * la, c.style.width = `${u.width}px`, c.style.height = `${u.height}px`; const d = c.getContext("2d"); d && d.scale(la, la) } const v = W.current; v && (v.style.width = `${u.width}px`, v.style.height = `${u.height}px`), J({ "startX": 0, "startY": 0, "endX": u.width, "endY": u.height }) } function onGrabButton(c, u) { X(!1), ee(!0); const d = te(u), handleMouseUp = () => { gi.removeEventListener("mousemove", d), gi.removeEventListener("mouseup", handleMouseUp), X(!0), ee(!1) }; gi.addEventListener("mouseup", handleMouseUp), gi.addEventListener("mousemove", d) } u.useEffect((() => { mi.addEventListener("resize", resizeCropper, !1) }), []), u.useEffect((() => { const c = Z.current; if (!c) return; const u = c.getContext("2d"); if (!u) return; const v = constructRect(getContainedSize(d)), E = constructRect(Y); u.clearRect(0, 0, v.width, v.height), u.fillStyle = "rgba(0, 0, 0, 0.5)", u.fillRect(0, 0, v.width, v.height), u.clearRect(E.x, E.y, E.width, E.height), u.strokeStyle = "#ffffff", u.lineWidth = 3, u.strokeRect(E.x + 1, E.y + 1, E.width - 2, E.height - 2), u.strokeStyle = "#000000", u.lineWidth = 1, u.strokeRect(E.x + 3, E.y + 3, E.width - 6, E.height - 6) }), [Y]); const te = u.useCallback((c => function (u) { if (!Z.current) return; const d = Z.current, v = d.getBoundingClientRect(), E = u.clientX - v.x, k = u.clientY - v.y; switch (c) { case "top-left": J((c => ({ ...c, "startX": Math.min(Math.max(0, E), c.endX - ca), "startY": Math.min(Math.max(0, k), c.endY - ca) }))); break; case "top-right": J((c => ({ ...c, "endX": Math.max(Math.min(E, d.width / la), c.startX + ca), "startY": Math.min(Math.max(0, k), c.endY - ca) }))); break; case "bottom-left": J((c => ({ ...c, "startX": Math.min(Math.max(0, E), c.endX - ca), "endY": Math.max(Math.min(k, d.height / la), c.startY + ca) }))); break; case "bottom-right": J((c => ({ ...c, "endX": Math.max(Math.min(E, d.width / la), c.startX + ca), "endY": Math.max(Math.min(k, d.height / la), c.startY + ca) }))) } }), []), ne = u.useRef({ "initialX": 0, "initialY": 0 }); return k({ "onBeforeScreenshot": u.useCallback((() => { v.el.style.display = "none" }), []), "onScreenshot": u.useCallback((c => { const u = d.getContext("2d"); if (!u) throw new Error("Could not get canvas context"); d.width = c.videoWidth, d.height = c.videoHeight, d.style.width = "100%", d.style.height = "100%", u.drawImage(c, 0, 0) }), [d]), "onAfterScreenshot": u.useCallback((() => { v.el.style.display = "block"; const c = G.current; c && c.appendChild(d), resizeCropper() }), []), "onError": u.useCallback((c => { v.el.style.display = "block", R(c) }), []) }), c("div", { "class": "editor", "__self": this, "__source": { "fileName": sa, "lineNumber": 315 } }, c("style", { "nonce": E.styleNonce, "dangerouslySetInnerHTML": U, "__self": this, "__source": { "fileName": sa, "lineNumber": 316 } }), c("div", { "class": "editor__canvas-container", "ref": G, "__self": this, "__source": { "fileName": sa, "lineNumber": 317 } }, c("div", { "class": "editor__crop-container", "style": { "position": "absolute", "zIndex": 1 }, "ref": W, "__self": this, "__source": { "fileName": sa, "lineNumber": 318 } }, c("canvas", { "onMouseDown": function onDragStart(c) { if (Q) return; ne.current = { "initialX": c.clientX, "initialY": c.clientY }; const handleMouseMove = c => { const u = Z.current; if (!u) return; const d = c.clientX - ne.current.initialX, v = c.clientY - ne.current.initialY; J((E => { const k = Math.max(0, Math.min(E.startX + d, u.width / la - (E.endX - E.startX))), R = Math.max(0, Math.min(E.startY + v, u.height / la - (E.endY - E.startY))), U = k + (E.endX - E.startX), H = R + (E.endY - E.startY); return ne.current.initialX = c.clientX, ne.current.initialY = c.clientY, { "startX": k, "startY": R, "endX": U, "endY": H } })) }, handleMouseUp = () => { gi.removeEventListener("mousemove", handleMouseMove), gi.removeEventListener("mouseup", handleMouseUp) }; gi.addEventListener("mousemove", handleMouseMove), gi.addEventListener("mouseup", handleMouseUp) }, "style": { "position": "absolute", "cursor": K ? "move" : "auto" }, "ref": Z, "__self": this, "__source": { "fileName": sa, "lineNumber": 319 } }), c(H, { "left": Y.startX - 3, "top": Y.startY - 3, "onGrabButton": onGrabButton, "corner": "top-left", "__self": this, "__source": { "fileName": sa, "lineNumber": 324 } }), c(H, { "left": Y.endX - 30 + 3, "top": Y.startY - 3, "onGrabButton": onGrabButton, "corner": "top-right", "__self": this, "__source": { "fileName": sa, "lineNumber": 330 } }), c(H, { "left": Y.startX - 3, "top": Y.endY - 30 + 3, "onGrabButton": onGrabButton, "corner": "bottom-left", "__self": this, "__source": { "fileName": sa, "lineNumber": 336 } }), c(H, { "left": Y.endX - 30 + 3, "top": Y.endY - 30 + 3, "onGrabButton": onGrabButton, "corner": "bottom-right", "__self": this, "__source": { "fileName": sa, "lineNumber": 342 } }), c("div", { "style": { "left": Math.max(0, Y.endX - 191), "top": Math.max(0, Y.endY + 8), "display": K ? "flex" : "none" }, "class": "editor__crop-btn-group", "__self": this, "__source": { "fileName": sa, "lineNumber": 348 } }, c("button", { "onClick": c => { c.preventDefault(), Z.current && J({ "startX": 0, "startY": 0, "endX": Z.current.width / la, "endY": Z.current.height / la }), X(!1) }, "class": "btn btn--default", "__self": this, "__source": { "fileName": sa, "lineNumber": 356 } }, E.cancelButtonLabel), c("button", { "onClick": c => { c.preventDefault(), function submit() { const c = gi.createElement("canvas"), u = constructRect(getContainedSize(d)), v = constructRect(Y); c.width = v.width * la, c.height = v.height * la; const E = c.getContext("2d"); E && d && E.drawImage(d, v.x / u.width * d.width, v.y / u.height * d.height, v.width / u.width * d.width, v.height / u.height * d.height, 0, 0, c.width, c.height); const k = d.getContext("2d"); k && (k.clearRect(0, 0, d.width, d.height), d.width = c.width, d.height = c.height, d.style.width = `${v.width}px`, d.style.height = `${v.height}px`, k.drawImage(c, 0, 0), resizeCropper()) }(), X(!1) }, "class": "btn btn--primary", "__self": this, "__source": { "fileName": sa, "lineNumber": 373 } }, E.confirmButtonLabel))))) } } const feedbackScreenshotIntegration = () => ({ "name": "FeedbackScreenshot", "setupOnce"() { }, "createInput": ({ "h": c, "hooks": u, "dialog": d, "options": v }) => { const E = gi.createElement("canvas"); return { "input": ScreenshotEditorFactory({ "h": c, "hooks": u, "imageBuffer": E, "dialog": d, "options": v }), "value": async () => { const c = await new Promise((c => { E.toBlob(c, "image/png") })); if (c) { return { "data": new Uint8Array(await c.arrayBuffer()), "filename": "screenshot.png", "contentType": "application/png" } } } } } }), ua = buildFeedbackIntegration({ "lazyLoadIntegration": lazyLoadIntegration }), da = buildFeedbackIntegration({ "lazyLoadIntegration": lazyLoadIntegration, "getModalIntegration": () => feedbackModalIntegration, "getScreenshotIntegration": () => feedbackScreenshotIntegration }), pa = "c", fa = "g", ha = "s", ma = "d"; function getMetricsAggregatorForClient(c, u) { const d = worldwide_getGlobalSingleton("globalMetricsAggregators", (() => new WeakMap)), v = d.get(c); if (v) return v; const E = new u(c); return c.on("flush", (() => E.flush())), c.on("close", (() => E.close())), d.set(c, E), E } function addToMetricsAggregator(c, u, d, v, E = {}) { const k = E.client || currentScopes_getClient(); if (!k) return; const R = getActiveSpan(), U = R ? getRootSpan(R) : void 0, H = U && spanUtils_spanToJSON(U).description, { "unit": G, "tags": W, "timestamp": Z } = E, { "release": Y, "environment": J } = k.getOptions(), K = {}; Y && (K.release = Y), J && (K.environment = J), H && (K.transaction = H), he && ue.log(`Adding value of ${v} to ${u} metric ${d}`); getMetricsAggregatorForClient(k, c).add(u, d, v, G, { ...K, ...W }, Z) } function distribution(c, u, d, v) { addToMetricsAggregator(c, ma, u, ensureNumber(d), v) } const ga = { "increment": function increment(c, u, d = 1, v) { addToMetricsAggregator(c, "c", u, ensureNumber(d), v) }, "distribution": distribution, "set": function set(c, u, d, v) { addToMetricsAggregator(c, "s", u, d, v) }, "gauge": function gauge(c, u, d, v) { addToMetricsAggregator(c, "g", u, ensureNumber(d), v) }, "timing": function timing(c, u, d, v = "second", E) { if ("function" == typeof d) { const v = ge(); return startSpanManual({ "op": "metrics.timing", "name": u, "startTime": v, "onlyIfParent": !0 }, (k => handleCallbackErrors_handleCallbackErrors((() => d()), (() => { }), (() => { const d = ge(); distribution(c, u, d - v, { ...E, "unit": "second" }), k.end(d) })))) } distribution(c, u, d, { ...E, "unit": v }) }, "getMetricsAggregatorForClient": getMetricsAggregatorForClient }; function ensureNumber(c) { return "string" == typeof c ? parseInt(c) : c } function sanitizeTagKey(c) { return c.replace(/[^\w\-./]+/gi, "") } const _a = [["\n", "\\n"], ["\r", "\\r"], ["\t", "\\t"], ["\\", "\\\\"], ["|", "\\u{7c}"], [",", "\\u{2c}"]]; function sanitizeTagValue(c) { return [...c].reduce(((c, u) => c + function getCharOrReplacement(c) { for (const [u, d] of _a) if (c === u) return d; return c }(u)), "") } function captureAggregateMetrics(c, u) { ue.log(`Flushing aggregated metrics, number of metrics: ${u.length}`); const d = function createMetricEnvelope(c, u, d, v) { const E = { "sent_at": (new Date).toISOString() }; d && d.sdk && (E.sdk = { "name": d.sdk.name, "version": d.sdk.version }); v && u && (E.dsn = dsn_dsnToString(u)); const k = function createMetricEnvelopeItem(c) { const u = function serializeMetricBuckets(c) { let u = ""; for (const d of c) { const c = Object.entries(d.tags), v = c.length > 0 ? `|#${c.map((([c, u]) => `${c}:${u}`)).join(",")}` : ""; u += `${d.name}@${d.unit}:${d.metric}|${d.metricType}${v}|T${d.timestamp}\n` } return u }(c); return [{ "type": "statsd", "length": u.length }, u] }(c); return envelope_createEnvelope(E, [k]) }(u, c.getDsn(), c.getSdkMetadata(), c.getOptions().tunnel); c.sendEnvelope(d) } const va = { [pa]: class CounterMetric { "constructor"(c) { this._value = c } get "weight"() { return 1 } "add"(c) { this._value += c } "toString"() { return `${this._value}` } }, [fa]: class GaugeMetric { "constructor"(c) { this._last = c, this._min = c, this._max = c, this._sum = c, this._count = 1 } get "weight"() { return 5 } "add"(c) { this._last = c, c < this._min && (this._min = c), c > this._max && (this._max = c), this._sum += c, this._count++ } "toString"() { return `${this._last}:${this._min}:${this._max}:${this._sum}:${this._count}` } }, [ma]: class DistributionMetric { "constructor"(c) { this._value = [c] } get "weight"() { return this._value.length } "add"(c) { this._value.push(c) } "toString"() { return this._value.join(":") } }, [ha]: class SetMetric { "constructor"(c) { this.first = c, this._value = new Set([c]) } get "weight"() { return this._value.size } "add"(c) { this._value.add(c) } "toString"() { return Array.from(this._value).map((c => "string" == typeof c ? function simpleHash(c) { let u = 0; for (let d = 0; d < c.length; d++)u = (u << 5) - u + c.charCodeAt(d), u &= u; return u >>> 0 }(c) : c)).join(":") } } }; class BrowserMetricsAggregator { "constructor"(c) { this._client = c, this._buckets = new Map, this._interval = setInterval((() => this.flush()), 5e3) } "add"(c, u, d, v = "none", E = {}, k = ge()) { const R = Math.floor(k), U = function sanitizeMetricKey(c) { return c.replace(/[^\w\-.]+/gi, "_") }(u), H = function sanitizeTags(c) { const u = {}; for (const d in c) Object.prototype.hasOwnProperty.call(c, d) && (u[sanitizeTagKey(d)] = sanitizeTagValue(String(c[d]))); return u }(E), G = function sanitizeUnit(c) { return c.replace(/[^\w]+/gi, "_") }(v), W = function getBucketKey(c, u, d, v) { const E = Object.entries(object_dropUndefinedKeys(v)).sort(((c, u) => c[0].localeCompare(u[0]))); return `${c}${u}${d}${E}` }(c, U, G, H); let Z = this._buckets.get(W); const Y = Z && "s" === c ? Z.metric.weight : 0; Z ? (Z.metric.add(d), Z.timestamp < R && (Z.timestamp = R)) : (Z = { "metric": new va[c](d), "timestamp": R, "metricType": c, "name": U, "unit": G, "tags": H }, this._buckets.set(W, Z)); updateMetricSummaryOnActiveSpan(c, U, "string" == typeof d ? Z.metric.weight - Y : d, G, E, W) } "flush"() { if (0 === this._buckets.size) return; const c = Array.from(this._buckets.values()); captureAggregateMetrics(this._client, c), this._buckets.clear() } "close"() { clearInterval(this._interval), this.flush() } } const ya = { "increment": function metrics_increment(c, u = 1, d) { ga.increment(BrowserMetricsAggregator, c, u, d) }, "distribution": function metrics_distribution(c, u, d) { ga.distribution(BrowserMetricsAggregator, c, u, d) }, "set": function metrics_set(c, u, d) { ga.set(BrowserMetricsAggregator, c, u, d) }, "gauge": function metrics_gauge(c, u, d) { ga.gauge(BrowserMetricsAggregator, c, u, d) }, "timing": function metrics_timing(c, u, d = "second", v) { return ga.timing(BrowserMetricsAggregator, c, u, d, v) } }; function instrumentFetchRequest(c, u, d, v, E = "auto.http.browser") { if (!c.fetchData) return; const k = hasTracingEnabled_hasTracingEnabled() && u(c.fetchData.url); if (c.endTimestamp && k) { const u = c.fetchData.__span; if (!u) return; const d = v[u]; return void (d && (!function endSpan(c, u) { if (u.response) { setHttpStatus(c, u.response.status); const d = u.response && u.response.headers && u.response.headers.get("content-length"); if (d) { const u = parseInt(d); u > 0 && c.setAttribute("http.response_content_length", u) } } else u.error && c.setStatus({ "code": We, "message": "internal_error" }); c.end() }(d, c), delete v[u])) } const R = currentScopes_getCurrentScope(), U = currentScopes_getClient(), { "method": H, "url": G } = c.fetchData, W = function getFullURL(c) { try { return new URL(c).href } catch (c) { return } }(G), Z = W ? url_parseUrl(W).host : void 0, Y = !!getActiveSpan(), J = k && Y ? startInactiveSpan({ "name": `${H} ${G}`, "attributes": { "url": G, "type": "fetch", "http.method": H, "http.url": W, "server.address": Z, [je]: E, [Fe]: "http.client" } }) : new sentryNonRecordingSpan_SentryNonRecordingSpan; if (c.fetchData.__span = J.spanContext().spanId, v[J.spanContext().spanId] = J, d(c.fetchData.url) && U) { const u = c.args[0]; c.args[1] = c.args[1] || {}; const d = c.args[1]; d.headers = function addTracingHeadersToFetchRequest(c, u, d, v, E) { const k = currentScopes_getIsolationScope(), { "traceId": R, "spanId": U, "sampled": H, "dsc": G } = { ...k.getPropagationContext(), ...d.getPropagationContext() }, W = E ? spanToTraceHeader(E) : tracing_generateSentryTraceHeader(R, U, H), Z = baggage_dynamicSamplingContextToSentryBaggageHeader(G || (E ? getDynamicSamplingContextFromSpan(E) : getDynamicSamplingContextFromClient(R, u))), Y = v.headers || ("undefined" != typeof Request && is_isInstanceOf(c, Request) ? c.headers : void 0); if (Y) { if ("undefined" != typeof Headers && is_isInstanceOf(Y, Headers)) { const c = new Headers(Y); return c.append("sentry-trace", W), Z && c.append(Re, Z), c } if (Array.isArray(Y)) { const c = [...Y, ["sentry-trace", W]]; return Z && c.push([Re, Z]), c } { const c = "baggage" in Y ? Y.baggage : void 0, u = []; return Array.isArray(c) ? u.push(...c) : c && u.push(c), Z && u.push(Z), { ...Y, "sentry-trace": W, "baggage": u.length > 0 ? u.join(",") : void 0 } } } return { "sentry-trace": W, "baggage": Z } }(u, U, R, d, hasTracingEnabled_hasTracingEnabled() && Y ? J : void 0) } return J } const ba = new WeakMap, Sa = new Map, wa = { "traceFetch": !0, "traceXHR": !0, "enableHTTPTimings": !0 }; function instrumentOutgoingRequests(c, u) { const { "traceFetch": d, "traceXHR": v, "shouldCreateSpanForRequest": E, "enableHTTPTimings": k, "tracePropagationTargets": R } = { "traceFetch": wa.traceFetch, "traceXHR": wa.traceXHR, ...u }, U = "function" == typeof E ? E : c => !0, shouldAttachHeadersWithTargets = c => function shouldAttachHeaders(c, u) { const d = bt.location && bt.location.href; if (d) { let v, E; try { v = new URL(c, d), E = new URL(d).origin } catch (c) { return !1 } const k = v.origin === E; return u ? stringMatchesSomePattern(v.toString(), u) || k && stringMatchesSomePattern(v.pathname, u) : k } { const d = !!c.match(/^\/(?!\/)/); return u ? stringMatchesSomePattern(c, u) : d } }(c, R), H = {}; d && (c.addEventProcessor((c => ("transaction" === c.type && c.spans && c.spans.forEach((c => { if ("http.client" === c.op) { const u = Sa.get(c.span_id); u && (c.timestamp = u / 1e3, Sa.delete(c.span_id)) } })), c))), function addFetchEndInstrumentationHandler(c) { const u = "fetch-body-resolved"; handlers_addHandler(u, c), handlers_maybeInstrument(u, (() => instrumentFetch(streamHandler))) }((c => { if (c.response) { const u = ba.get(c.response); u && c.endTimestamp && Sa.set(u, c.endTimestamp) } })), addFetchInstrumentationHandler((c => { const u = instrumentFetchRequest(c, U, shouldAttachHeadersWithTargets, H); if (c.response && c.fetchData.__span && ba.set(c.response, c.fetchData.__span), u) { const d = request_getFullURL(c.fetchData.url), v = d ? url_parseUrl(d).host : void 0; u.setAttributes({ "http.url": d, "server.address": v }) } k && u && addHTTPTimings(u) }))), v && addXhrInstrumentationHandler((c => { const u = function xhrCallback(c, u, d, v) { const E = c.xhr, k = E && E[Ot]; if (!E || E.__sentry_own_request__ || !k) return; const R = hasTracingEnabled_hasTracingEnabled() && u(k.url); if (c.endTimestamp && R) { const c = E.__sentry_xhr_span_id__; if (!c) return; const u = v[c]; return void (u && void 0 !== k.status_code && (setHttpStatus(u, k.status_code), u.end(), delete v[c])) } const U = request_getFullURL(k.url), H = U ? url_parseUrl(U).host : void 0, G = !!getActiveSpan(), W = R && G ? startInactiveSpan({ "name": `${k.method} ${k.url}`, "attributes": { "type": "xhr", "http.method": k.method, "http.url": U, "url": k.url, "server.address": H, [je]: "auto.http.browser", [Fe]: "http.client" } }) : new sentryNonRecordingSpan_SentryNonRecordingSpan; E.__sentry_xhr_span_id__ = W.spanContext().spanId, v[E.__sentry_xhr_span_id__] = W; const Z = currentScopes_getClient(); E.setRequestHeader && d(k.url) && Z && function addTracingHeadersToXhrRequest(c, u, d) { const v = currentScopes_getCurrentScope(), E = currentScopes_getIsolationScope(), { "traceId": k, "spanId": R, "sampled": U, "dsc": H } = { ...E.getPropagationContext(), ...v.getPropagationContext() }, G = d && hasTracingEnabled_hasTracingEnabled() ? spanToTraceHeader(d) : tracing_generateSentryTraceHeader(k, R, U), W = baggage_dynamicSamplingContextToSentryBaggageHeader(H || (d ? getDynamicSamplingContextFromSpan(d) : getDynamicSamplingContextFromClient(k, u))); !function setHeaderOnXhr(c, u, d) { try { c.setRequestHeader("sentry-trace", u), d && c.setRequestHeader(Re, d) } catch (c) { } }(c, G, W) }(E, Z, hasTracingEnabled_hasTracingEnabled() && G ? W : void 0); return W }(c, U, shouldAttachHeadersWithTargets, H); k && u && addHTTPTimings(u) })) } function addHTTPTimings(c) { const { "url": u } = spanUtils_spanToJSON(c).data || {}; if (!u || "string" != typeof u) return; const d = addPerformanceInstrumentationHandler("resource", (({ "entries": v }) => { v.forEach((v => { if (function isPerformanceResourceTiming(c) { return "resource" === c.entryType && "initiatorType" in c && "string" == typeof c.nextHopProtocol && ("fetch" === c.initiatorType || "xmlhttprequest" === c.initiatorType) }(v) && v.name.endsWith(u)) { (function resourceTimingEntryToSpanData(c) { const { "name": u, "version": d } = function extractNetworkProtocol(c) { let u = "unknown", d = "unknown", v = ""; for (const E of c) { if ("/" === E) { [u, d] = c.split("/"); break } if (!isNaN(Number(E))) { u = "h" === v ? "http" : v, d = c.split(v)[1]; break } v += E } v === c && (u = v); return { "name": u, "version": d } }(c.nextHopProtocol), v = []; if (v.push(["network.protocol.version", d], ["network.protocol.name", u]), !ve) return v; return [...v, ["http.request.redirect_start", request_getAbsoluteTime(c.redirectStart)], ["http.request.fetch_start", request_getAbsoluteTime(c.fetchStart)], ["http.request.domain_lookup_start", request_getAbsoluteTime(c.domainLookupStart)], ["http.request.domain_lookup_end", request_getAbsoluteTime(c.domainLookupEnd)], ["http.request.connect_start", request_getAbsoluteTime(c.connectStart)], ["http.request.secure_connection_start", request_getAbsoluteTime(c.secureConnectionStart)], ["http.request.connection_end", request_getAbsoluteTime(c.connectEnd)], ["http.request.request_start", request_getAbsoluteTime(c.requestStart)], ["http.request.response_start", request_getAbsoluteTime(c.responseStart)], ["http.request.response_end", request_getAbsoluteTime(c.responseEnd)]] })(v).forEach((u => c.setAttribute(...u))), setTimeout(d) } })) })) } function request_getAbsoluteTime(c = 0) { return ((ve || performance.timeOrigin) + c) / 1e3 } function request_getFullURL(c) { try { return new URL(c, bt.location.origin).href } catch (c) { return } } function _sentry_core_build_esm_carrier_getMainCarrier() { return _sentry_core_build_esm_carrier_getSentryCarrier(it), it } function _sentry_core_build_esm_carrier_getSentryCarrier(c) { const u = c.__SENTRY__ = c.__SENTRY__ || {}; return u.version = u.version || ot, u[ot] = u[ot] || {} } function _sentry_utils_build_esm_propagationContext_generatePropagationContext() { return { "traceId": esm_misc_uuid4(), "spanId": esm_misc_uuid4().substring(16) } } function _sentry_core_build_esm_session_updateSession(c, u = {}) { if (u.user && (!c.ipAddress && u.user.ip_address && (c.ipAddress = u.user.ip_address), c.did || u.did || (c.did = u.user.id || u.user.email || u.user.username)), c.timestamp = u.timestamp || At(), u.abnormal_mechanism && (c.abnormal_mechanism = u.abnormal_mechanism), u.ignoreDuration && (c.ignoreDuration = u.ignoreDuration), u.sid && (c.sid = 32 === u.sid.length ? u.sid : esm_misc_uuid4()), void 0 !== u.init && (c.init = u.init), !c.did && u.did && (c.did = `${u.did}`), "number" == typeof u.started && (c.started = u.started), c.ignoreDuration) c.duration = void 0; else if ("number" == typeof u.duration) c.duration = u.duration; else { const u = c.timestamp - c.started; c.duration = u >= 0 ? u : 0 } u.release && (c.release = u.release), u.environment && (c.environment = u.environment), !c.ipAddress && u.ipAddress && (c.ipAddress = u.ipAddress), !c.userAgent && u.userAgent && (c.userAgent = u.userAgent), "number" == typeof u.errors && (c.errors = u.errors), u.status && (c.status = u.status) } const Ea = "_sentrySpan"; function core_build_esm_utils_spanOnScope_setSpanForScope(c, u) { u ? esm_object_addNonEnumerableProperty(c, Ea, u) : delete c[Ea] } function build_esm_utils_spanOnScope_getSpanForScope(c) { return c[Ea] } class core_build_esm_scope_ScopeClass { "constructor"() { this._notifyingListeners = !1, this._scopeListeners = [], this._eventProcessors = [], this._breadcrumbs = [], this._attachments = [], this._user = {}, this._tags = {}, this._extra = {}, this._contexts = {}, this._sdkProcessingMetadata = {}, this._propagationContext = _sentry_utils_build_esm_propagationContext_generatePropagationContext() } "clone"() { const c = new core_build_esm_scope_ScopeClass; return c._breadcrumbs = [...this._breadcrumbs], c._tags = { ...this._tags }, c._extra = { ...this._extra }, c._contexts = { ...this._contexts }, c._user = this._user, c._level = this._level, c._session = this._session, c._transactionName = this._transactionName, c._fingerprint = this._fingerprint, c._eventProcessors = [...this._eventProcessors], c._requestSession = this._requestSession, c._attachments = [...this._attachments], c._sdkProcessingMetadata = { ...this._sdkProcessingMetadata }, c._propagationContext = { ...this._propagationContext }, c._client = this._client, c._lastEventId = this._lastEventId, core_build_esm_utils_spanOnScope_setSpanForScope(c, build_esm_utils_spanOnScope_getSpanForScope(this)), c } "setClient"(c) { this._client = c } "setLastEventId"(c) { this._lastEventId = c } "getClient"() { return this._client } "lastEventId"() { return this._lastEventId } "addScopeListener"(c) { this._scopeListeners.push(c) } "addEventProcessor"(c) { return this._eventProcessors.push(c), this } "setUser"(c) { return this._user = c || { "email": void 0, "id": void 0, "ip_address": void 0, "username": void 0 }, this._session && _sentry_core_build_esm_session_updateSession(this._session, { "user": c }), this._notifyScopeListeners(), this } "getUser"() { return this._user } "getRequestSession"() { return this._requestSession } "setRequestSession"(c) { return this._requestSession = c, this } "setTags"(c) { return this._tags = { ...this._tags, ...c }, this._notifyScopeListeners(), this } "setTag"(c, u) { return this._tags = { ...this._tags, [c]: u }, this._notifyScopeListeners(), this } "setExtras"(c) { return this._extra = { ...this._extra, ...c }, this._notifyScopeListeners(), this } "setExtra"(c, u) { return this._extra = { ...this._extra, [c]: u }, this._notifyScopeListeners(), this } "setFingerprint"(c) { return this._fingerprint = c, this._notifyScopeListeners(), this } "setLevel"(c) { return this._level = c, this._notifyScopeListeners(), this } "setTransactionName"(c) { return this._transactionName = c, this._notifyScopeListeners(), this } "setContext"(c, u) { return null === u ? delete this._contexts[c] : this._contexts[c] = u, this._notifyScopeListeners(), this } "setSession"(c) { return c ? this._session = c : delete this._session, this._notifyScopeListeners(), this } "getSession"() { return this._session } "update"(c) { if (!c) return this; const u = "function" == typeof c ? c(this) : c, [d, v] = u instanceof Ca ? [u.getScopeData(), u.getRequestSession()] : is_isPlainObject(u) ? [c, c.requestSession] : [], { "tags": E, "extra": k, "user": R, "contexts": U, "level": H, "fingerprint": G = [], "propagationContext": W } = d || {}; return this._tags = { ...this._tags, ...E }, this._extra = { ...this._extra, ...k }, this._contexts = { ...this._contexts, ...U }, R && Object.keys(R).length && (this._user = R), H && (this._level = H), G.length && (this._fingerprint = G), W && (this._propagationContext = W), v && (this._requestSession = v), this } "clear"() { return this._breadcrumbs = [], this._tags = {}, this._extra = {}, this._user = {}, this._contexts = {}, this._level = void 0, this._transactionName = void 0, this._fingerprint = void 0, this._requestSession = void 0, this._session = void 0, core_build_esm_utils_spanOnScope_setSpanForScope(this, void 0), this._attachments = [], this._propagationContext = _sentry_utils_build_esm_propagationContext_generatePropagationContext(), this._notifyScopeListeners(), this } "addBreadcrumb"(c, u) { const d = "number" == typeof u ? u : 100; if (d <= 0) return this; const v = { "timestamp": esm_time_dateTimestampInSeconds(), ...c }, E = this._breadcrumbs; return E.push(v), this._breadcrumbs = E.length > d ? E.slice(-d) : E, this._notifyScopeListeners(), this } "getLastBreadcrumb"() { return this._breadcrumbs[this._breadcrumbs.length - 1] } "clearBreadcrumbs"() { return this._breadcrumbs = [], this._notifyScopeListeners(), this } "addAttachment"(c) { return this._attachments.push(c), this } "clearAttachments"() { return this._attachments = [], this } "getScopeData"() { return { "breadcrumbs": this._breadcrumbs, "attachments": this._attachments, "contexts": this._contexts, "tags": this._tags, "extra": this._extra, "user": this._user, "level": this._level, "fingerprint": this._fingerprint || [], "eventProcessors": this._eventProcessors, "propagationContext": this._propagationContext, "sdkProcessingMetadata": this._sdkProcessingMetadata, "transactionName": this._transactionName, "span": build_esm_utils_spanOnScope_getSpanForScope(this) } } "setSDKProcessingMetadata"(c) { return this._sdkProcessingMetadata = { ...this._sdkProcessingMetadata, ...c }, this } "setPropagationContext"(c) { return this._propagationContext = c, this } "getPropagationContext"() { return this._propagationContext } "captureException"(c, u) { const d = u && u.event_id ? u.event_id : esm_misc_uuid4(); if (!this._client) return ct.warn("No client configured on scope - will not capture exception!"), d; const v = new Error("Sentry syntheticException"); return this._client.captureException(c, { "originalException": c, "syntheticException": v, ...u, "event_id": d }, this), d } "captureMessage"(c, u, d) { const v = d && d.event_id ? d.event_id : esm_misc_uuid4(); if (!this._client) return ct.warn("No client configured on scope - will not capture message!"), v; const E = new Error(c); return this._client.captureMessage(c, u, { "originalException": c, "syntheticException": E, ...d, "event_id": v }, this), v } "captureEvent"(c, u) { const d = u && u.event_id ? u.event_id : esm_misc_uuid4(); return this._client ? (this._client.captureEvent(c, { ...u, "event_id": d }, this), d) : (ct.warn("No client configured on scope - will not capture event!"), d) } "_notifyScopeListeners"() { this._notifyingListeners || (this._notifyingListeners = !0, this._scopeListeners.forEach((c => { c(this) })), this._notifyingListeners = !1) } } const Ca = core_build_esm_scope_ScopeClass; class build_esm_asyncContext_stackStrategy_AsyncContextStack { "constructor"(c, u) { let d, v; d = c || new Ca, v = u || new Ca, this._stack = [{ "scope": d }], this._isolationScope = v } "withScope"(c) { const u = this._pushScope(); let d; try { d = c(u) } catch (c) { throw this._popScope(), c } return function esm_is_isThenable(c) { return Boolean(c && c.then && "function" == typeof c.then) }(d) ? d.then((c => (this._popScope(), c)), (c => { throw this._popScope(), c })) : (this._popScope(), d) } "getClient"() { return this.getStackTop().client } "getScope"() { return this.getStackTop().scope } "getIsolationScope"() { return this._isolationScope } "getStackTop"() { return this._stack[this._stack.length - 1] } "_pushScope"() { const c = this.getScope().clone(); return this._stack.push({ "client": this.getClient(), "scope": c }), c } "_popScope"() { return !(this._stack.length <= 1) && !!this._stack.pop() } } function build_esm_asyncContext_stackStrategy_getAsyncContextStack() { const c = _sentry_core_build_esm_carrier_getSentryCarrier(_sentry_core_build_esm_carrier_getMainCarrier()); return c.stack = c.stack || new build_esm_asyncContext_stackStrategy_AsyncContextStack(function core_build_esm_defaultScopes_getDefaultCurrentScope() { return esm_worldwide_getGlobalSingleton("defaultCurrentScope", (() => new Ca)) }(), function core_build_esm_defaultScopes_getDefaultIsolationScope() { return esm_worldwide_getGlobalSingleton("defaultIsolationScope", (() => new Ca)) }()) } function core_build_esm_asyncContext_stackStrategy_withScope(c) { return build_esm_asyncContext_stackStrategy_getAsyncContextStack().withScope(c) } function build_esm_asyncContext_stackStrategy_withSetScope(c, u) { const d = build_esm_asyncContext_stackStrategy_getAsyncContextStack(); return d.withScope((() => (d.getStackTop().scope = c, u(c)))) } function core_build_esm_asyncContext_stackStrategy_withIsolationScope(c) { return build_esm_asyncContext_stackStrategy_getAsyncContextStack().withScope((() => c(build_esm_asyncContext_stackStrategy_getAsyncContextStack().getIsolationScope()))) } function _sentry_core_build_esm_asyncContext_getAsyncContextStrategy(c) { const u = _sentry_core_build_esm_carrier_getSentryCarrier(c); return u.acs ? u.acs : function build_esm_asyncContext_stackStrategy_getStackAsyncContextStrategy() { return { "withIsolationScope": core_build_esm_asyncContext_stackStrategy_withIsolationScope, "withScope": core_build_esm_asyncContext_stackStrategy_withScope, "withSetScope": build_esm_asyncContext_stackStrategy_withSetScope, "withSetIsolationScope": (c, u) => core_build_esm_asyncContext_stackStrategy_withIsolationScope(u), "getCurrentScope": () => build_esm_asyncContext_stackStrategy_getAsyncContextStack().getScope(), "getIsolationScope": () => build_esm_asyncContext_stackStrategy_getAsyncContextStack().getIsolationScope() } }() } function _sentry_core_build_esm_currentScopes_getCurrentScope() { return _sentry_core_build_esm_asyncContext_getAsyncContextStrategy(_sentry_core_build_esm_carrier_getMainCarrier()).getCurrentScope() } function _sentry_core_build_esm_currentScopes_withScope(...c) { const u = _sentry_core_build_esm_asyncContext_getAsyncContextStrategy(_sentry_core_build_esm_carrier_getMainCarrier()); if (2 === c.length) { const [d, v] = c; return d ? u.withSetScope(d, v) : u.withScope(v) } return u.withScope(c[0]) } function _sentry_core_build_esm_currentScopes_getClient() { return _sentry_core_build_esm_currentScopes_getCurrentScope().getClient() } const Ta = "_sentryMetrics"; function metrics_metric_summary_getMetricSummaryJsonForSpan(c) { const u = c[Ta]; if (!u) return; const d = {}; for (const [, [c, v]] of u) { (d[c] || (d[c] = [])).push(esm_object_dropUndefinedKeys(v)) } return d } const xa = "sentry.source", Aa = "sentry.sample_rate", Ia = "sentry.op", ka = "sentry.origin", Oa = "sentry.measurement_unit", Pa = "sentry.measurement_value", Ra = "sentry.exclusive_time", Ma = 0, Na = 1; const Da = 1; function utils_spanUtils_spanToTransactionTraceContext(c) { const { "spanId": u, "traceId": d } = c.spanContext(), { "data": v, "op": E, "parent_span_id": k, "status": R, "origin": U } = esm_utils_spanUtils_spanToJSON(c); return esm_object_dropUndefinedKeys({ "parent_span_id": k, "span_id": u, "trace_id": d, "data": v, "op": E, "status": R, "origin": U }) } function utils_spanUtils_spanTimeInputToSeconds(c) { return "number" == typeof c ? utils_spanUtils_ensureTimestampInSeconds(c) : Array.isArray(c) ? c[0] + c[1] / 1e9 : c instanceof Date ? utils_spanUtils_ensureTimestampInSeconds(c.getTime()) : At() } function utils_spanUtils_ensureTimestampInSeconds(c) { return c > 9999999999 ? c / 1e3 : c } function esm_utils_spanUtils_spanToJSON(c) { if (function utils_spanUtils_spanIsSentrySpan(c) { return "function" == typeof c.getSpanJSON }(c)) return c.getSpanJSON(); try { const { "spanId": u, "traceId": d } = c.spanContext(); if (function utils_spanUtils_spanIsOpenTelemetrySdkTraceBaseSpan(c) { const u = c; return !!(u.attributes && u.startTime && u.name && u.endTime && u.status) }(c)) { const { "attributes": v, "startTime": E, "name": k, "endTime": R, "parentSpanId": U, "status": H } = c; return esm_object_dropUndefinedKeys({ "span_id": u, "trace_id": d, "data": v, "description": k, "parent_span_id": U, "start_timestamp": utils_spanUtils_spanTimeInputToSeconds(E), "timestamp": utils_spanUtils_spanTimeInputToSeconds(R) || void 0, "status": utils_spanUtils_getStatusMessage(H), "op": v[Ia], "origin": v[ka], "_metrics_summary": metrics_metric_summary_getMetricSummaryJsonForSpan(c) }) } return { "span_id": u, "trace_id": d } } catch (c) { return {} } } function utils_spanUtils_spanIsSampled(c) { const { "traceFlags": u } = c.spanContext(); return u === Da } function utils_spanUtils_getStatusMessage(c) { if (c && c.code !== Ma) return c.code === Na ? "ok" : c.message || "unknown_error" } const $a = "_sentryChildSpans", La = "_sentryRootSpan"; function utils_spanUtils_addChildSpanToSpan(c, u) { const d = c[La] || c; esm_object_addNonEnumerableProperty(u, La, d), c[$a] ? c[$a].add(u) : esm_object_addNonEnumerableProperty(c, $a, new Set([u])) } function utils_spanUtils_getRootSpan(c) { return c[La] || c } function utils_spanUtils_getActiveSpan() { const c = _sentry_core_build_esm_asyncContext_getAsyncContextStrategy(_sentry_core_build_esm_carrier_getMainCarrier()); return c.getActiveSpan ? c.getActiveSpan() : build_esm_utils_spanOnScope_getSpanForScope(_sentry_core_build_esm_currentScopes_getCurrentScope()) } function utils_hasTracingEnabled_hasTracingEnabled(c) { if ("boolean" == typeof __SENTRY_TRACING__ && !__SENTRY_TRACING__) return !1; const u = _sentry_core_build_esm_currentScopes_getClient(), d = c || u && u.getOptions(); return !!d && (d.enableTracing || "tracesSampleRate" in d || "tracesSampler" in d) } const Fa = "sentry-", ja = /^sentry-/; function esm_baggage_baggageHeaderToDynamicSamplingContext(c) { const u = function esm_baggage_parseBaggageHeader(c) { if (!c || !esm_is_isString(c) && !Array.isArray(c)) return; if (Array.isArray(c)) return c.reduce(((c, u) => { const d = esm_baggage_baggageHeaderToObject(u); return Object.entries(d).forEach((([u, d]) => { c[u] = d })), c }), {}); return esm_baggage_baggageHeaderToObject(c) }(c); if (!u) return; const d = Object.entries(u).reduce(((c, [u, d]) => { if (u.match(ja)) { c[u.slice(Fa.length)] = d } return c }), {}); return Object.keys(d).length > 0 ? d : void 0 } function esm_baggage_baggageHeaderToObject(c) { return c.split(",").map((c => c.split("=").map((c => decodeURIComponent(c.trim()))))).reduce(((c, [u, d]) => (u && d && (c[u] = d), c)), {}) } const Ba = "production", Ua = "_frozenDsc"; function tracing_dynamicSamplingContext_freezeDscOnSpan(c, u) { esm_object_addNonEnumerableProperty(c, Ua, u) } function tracing_dynamicSamplingContext_getDynamicSamplingContextFromSpan(c) { const u = _sentry_core_build_esm_currentScopes_getClient(); if (!u) return {}; const d = function tracing_dynamicSamplingContext_getDynamicSamplingContextFromClient(c, u) { const d = u.getOptions(), { "publicKey": v } = u.getDsn() || {}, E = esm_object_dropUndefinedKeys({ "environment": d.environment || Ba, "release": d.release, "public_key": v, "trace_id": c }); return u.emit("createDsc", E), E }(esm_utils_spanUtils_spanToJSON(c).trace_id || "", u), v = utils_spanUtils_getRootSpan(c), E = v[Ua]; if (E) return E; const k = v.spanContext().traceState, R = k && k.get("sentry.dsc"), U = R && esm_baggage_baggageHeaderToDynamicSamplingContext(R); if (U) return U; const H = esm_utils_spanUtils_spanToJSON(v), G = H.data || {}, W = G[Aa]; null != W && (d.sample_rate = `${W}`); const Z = G[xa], Y = H.description; return "url" !== Z && Y && (d.transaction = Y), d.sampled = String(utils_spanUtils_spanIsSampled(v)), u.emit("createDsc", d, v), d } const Ha = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__; function sampling_sampleSpan(c, u) { if (!utils_hasTracingEnabled_hasTracingEnabled(c)) return [!1]; let d; d = "function" == typeof c.tracesSampler ? c.tracesSampler(u) : void 0 !== u.parentSampled ? u.parentSampled : void 0 !== c.tracesSampleRate ? c.tracesSampleRate : 1; const v = function utils_parseSampleRate_parseSampleRate(c) { if ("boolean" == typeof c) return Number(c); const u = "string" == typeof c ? parseFloat(c) : c; if (!("number" != typeof u || isNaN(u) || u < 0 || u > 1)) return u; Ha && ct.warn(`[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(c)} of type ${JSON.stringify(typeof c)}.`) }(d); if (void 0 === v) return Ha && ct.warn("[Tracing] Discarding transaction because of invalid sample rate."), [!1]; if (!v) return Ha && ct.log("[Tracing] Discarding transaction because " + ("function" == typeof c.tracesSampler ? "tracesSampler returned 0 or false" : "a negative sampling decision was inherited or tracesSampleRate is set to 0")), [!1, v]; return Math.random() < v ? [!0, v] : (Ha && ct.log(`[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(d)})`), [!1, v]) } class tracing_sentryNonRecordingSpan_SentryNonRecordingSpan { "constructor"(c = {}) { this._traceId = c.traceId || esm_misc_uuid4(), this._spanId = c.spanId || esm_misc_uuid4().substring(16) } "spanContext"() { return { "spanId": this._spanId, "traceId": this._traceId, "traceFlags": 0 } } "end"(c) { } "setAttribute"(c, u) { return this } "setAttributes"(c) { return this } "setStatus"(c) { return this } "updateName"(c) { return this } "isRecording"() { return !1 } "addEvent"(c, u, d) { return this } "addLink"(c) { return this } "addLinks"(c) { return this } "recordException"(c, u) { } } function build_esm_dsn_dsnToString(c, u = !1) { const { "host": d, "path": v, "pass": E, "port": k, "projectId": R, "protocol": U, "publicKey": H } = c; return `${U}://${H}${u && E ? `:${E}` : ""}@${d}${k ? `:${k}` : ""}/${v ? `${v}/` : v}${R}` } function esm_envelope_createSpanEnvelopeItem(c) { return [{ "type": "span" }, c] } function measurement_timedEventsToMeasurements(c) { if (!c || 0 === c.length) return; const u = {}; return c.forEach((c => { const d = c.attributes || {}, v = d[Oa], E = d[Pa]; "string" == typeof v && "number" == typeof E && (u[c.name] = { "value": E, "unit": v }) })), u } const za = "_sentryScope", qa = "_sentryIsolationScope"; function utils_getCapturedScopesOnSpan(c) { return { "scope": c[za], "isolationScope": c[qa] } } class sentrySpan_SentrySpan { "constructor"(c = {}) { this._traceId = c.traceId || esm_misc_uuid4(), this._spanId = c.spanId || esm_misc_uuid4().substring(16), this._startTime = c.startTimestamp || At(), this._attributes = {}, this.setAttributes({ [ka]: "manual", [Ia]: c.op, ...c.attributes }), this._name = c.name, c.parentSpanId && (this._parentSpanId = c.parentSpanId), "sampled" in c && (this._sampled = c.sampled), c.endTimestamp && (this._endTime = c.endTimestamp), this._events = [], this._isStandaloneSpan = c.isStandalone, this._endTime && this._onSpanEnded() } "addLink"(c) { return this } "addLinks"(c) { return this } "recordException"(c, u) { } "spanContext"() { const { "_spanId": c, "_traceId": u, "_sampled": d } = this; return { "spanId": c, "traceId": u, "traceFlags": d ? Da : 0 } } "setAttribute"(c, u) { return void 0 === u ? delete this._attributes[c] : this._attributes[c] = u, this } "setAttributes"(c) { return Object.keys(c).forEach((u => this.setAttribute(u, c[u]))), this } "updateStartTime"(c) { this._startTime = utils_spanUtils_spanTimeInputToSeconds(c) } "setStatus"(c) { return this._status = c, this } "updateName"(c) { return this._name = c, this } "end"(c) { this._endTime || (this._endTime = utils_spanUtils_spanTimeInputToSeconds(c), function logSpans_logSpanEnd(c) { if (!Ha) return; const { "description": u = "< unknown name >", "op": d = "< unknown op >" } = esm_utils_spanUtils_spanToJSON(c), { "spanId": v } = c.spanContext(), E = `[Tracing] Finishing "${d}" ${utils_spanUtils_getRootSpan(c) === c ? "root " : ""}span "${u}" with ID ${v}`; ct.log(E) }(this), this._onSpanEnded()) } "getSpanJSON"() { return esm_object_dropUndefinedKeys({ "data": this._attributes, "description": this._name, "op": this._attributes[Ia], "parent_span_id": this._parentSpanId, "span_id": this._spanId, "start_timestamp": this._startTime, "status": utils_spanUtils_getStatusMessage(this._status), "timestamp": this._endTime, "trace_id": this._traceId, "origin": this._attributes[ka], "_metrics_summary": metrics_metric_summary_getMetricSummaryJsonForSpan(this), "profile_id": this._attributes["sentry.profile_id"], "exclusive_time": this._attributes[Ra], "measurements": measurement_timedEventsToMeasurements(this._events), "is_segment": this._isStandaloneSpan && utils_spanUtils_getRootSpan(this) === this || void 0, "segment_id": this._isStandaloneSpan ? utils_spanUtils_getRootSpan(this).spanContext().spanId : void 0 }) } "isRecording"() { return !this._endTime && !!this._sampled } "addEvent"(c, u, d) { Ha && ct.log("[Tracing] Adding an event to span:", c); const v = sentrySpan_isSpanTimeInput(u) ? u : d || At(), E = sentrySpan_isSpanTimeInput(u) ? {} : u || {}, k = { "name": c, "time": utils_spanUtils_spanTimeInputToSeconds(v), "attributes": E }; return this._events.push(k), this } "isStandaloneSpan"() { return !!this._isStandaloneSpan } "_onSpanEnded"() { const c = _sentry_core_build_esm_currentScopes_getClient(); c && c.emit("spanEnd", this); if (!(this._isStandaloneSpan || this === utils_spanUtils_getRootSpan(this))) return; if (this._isStandaloneSpan) return void (this._sampled ? function sentrySpan_sendSpanEnvelope(c) { const u = _sentry_core_build_esm_currentScopes_getClient(); if (!u) return; const d = c[1]; if (!d || 0 === d.length) return void u.recordDroppedEvent("before_send", "span"); const v = u.getTransport(); v && v.send(c).then(null, (c => { Ha && ct.error("Error while sending span:", c) })) }(function envelope_createSpanEnvelope(c, u) { const d = tracing_dynamicSamplingContext_getDynamicSamplingContextFromSpan(c[0]), v = u && u.getDsn(), E = u && u.getOptions().tunnel, k = { "sent_at": (new Date).toISOString(), ...function dscHasRequiredProps(c) { return !!c.trace_id && !!c.public_key }(d) && { "trace": d }, ...!!E && v && { "dsn": build_esm_dsn_dsnToString(v) } }, R = u && u.getOptions().beforeSendSpan, U = R ? c => R(esm_utils_spanUtils_spanToJSON(c)) : c => esm_utils_spanUtils_spanToJSON(c), H = []; for (const u of c) { const c = U(u); c && H.push(esm_envelope_createSpanEnvelopeItem(c)) } return function build_esm_envelope_createEnvelope(c, u = []) { return [c, u] }(k, H) }([this], c)) : (Ha && ct.log("[Tracing] Discarding standalone span because its trace was not chosen to be sampled."), c && c.recordDroppedEvent("sample_rate", "span"))); const u = this._convertSpanToTransaction(); if (u) { (utils_getCapturedScopesOnSpan(this).scope || _sentry_core_build_esm_currentScopes_getCurrentScope()).captureEvent(u) } } "_convertSpanToTransaction"() { if (!sentrySpan_isFullFinishedSpan(esm_utils_spanUtils_spanToJSON(this))) return; this._name || (Ha && ct.warn("Transaction has no name, falling back to `<unlabeled transaction>`."), this._name = "<unlabeled transaction>"); const { "scope": c, "isolationScope": u } = utils_getCapturedScopesOnSpan(this), d = (c || _sentry_core_build_esm_currentScopes_getCurrentScope()).getClient() || _sentry_core_build_esm_currentScopes_getClient(); if (!0 !== this._sampled) return Ha && ct.log("[Tracing] Discarding transaction because its trace was not chosen to be sampled."), void (d && d.recordDroppedEvent("sample_rate", "transaction")); const v = function utils_spanUtils_getSpanDescendants(c) { const u = new Set; return function addSpanChildren(c) { if (!u.has(c) && utils_spanUtils_spanIsSampled(c)) { u.add(c); const d = c[$a] ? Array.from(c[$a]) : []; for (const c of d) addSpanChildren(c) } }(c), Array.from(u) }(this).filter((c => c !== this && !function sentrySpan_isStandaloneSpan(c) { return c instanceof sentrySpan_SentrySpan && c.isStandaloneSpan() }(c))).map((c => esm_utils_spanUtils_spanToJSON(c))).filter(sentrySpan_isFullFinishedSpan), E = this._attributes[xa], k = { "contexts": { "trace": utils_spanUtils_spanToTransactionTraceContext(this) }, "spans": v.length > 1e3 ? v.sort(((c, u) => c.start_timestamp - u.start_timestamp)).slice(0, 1e3) : v, "start_timestamp": this._startTime, "timestamp": this._endTime, "transaction": this._name, "type": "transaction", "sdkProcessingMetadata": { "capturedSpanScope": c, "capturedSpanIsolationScope": u, ...esm_object_dropUndefinedKeys({ "dynamicSamplingContext": tracing_dynamicSamplingContext_getDynamicSamplingContextFromSpan(this) }) }, "_metrics_summary": metrics_metric_summary_getMetricSummaryJsonForSpan(this), ...E && { "transaction_info": { "source": E } } }, R = measurement_timedEventsToMeasurements(this._events); return R && Object.keys(R).length && (Ha && ct.log("[Measurements] Adding measurements to transaction event", JSON.stringify(R, void 0, 2)), k.measurements = R), k } } function sentrySpan_isSpanTimeInput(c) { return c && "number" == typeof c || c instanceof Date || Array.isArray(c) } function sentrySpan_isFullFinishedSpan(c) { return !!(c.start_timestamp && c.timestamp && c.span_id && c.trace_id) } const Ga = "__SENTRY_SUPPRESS_TRACING__"; function trace_startInactiveSpan(c) { const u = trace_getAcs(); if (u.startInactiveSpan) return u.startInactiveSpan(c); const d = trace_parseSentrySpanArguments(c), { "forceTransaction": v, "parentSpan": E } = c; return (c.scope ? u => _sentry_core_build_esm_currentScopes_withScope(c.scope, u) : void 0 !== E ? c => trace_withActiveSpan(E, c) : c => c())((() => { const u = _sentry_core_build_esm_currentScopes_getCurrentScope(), E = trace_getParentSpan(u); return c.onlyIfParent && !E ? new tracing_sentryNonRecordingSpan_SentryNonRecordingSpan : trace_createChildOrRootSpan({ "parentSpan": E, "spanArguments": d, "forceTransaction": v, "scope": u }) })) } function trace_withActiveSpan(c, u) { const d = trace_getAcs(); return d.withActiveSpan ? d.withActiveSpan(c, u) : _sentry_core_build_esm_currentScopes_withScope((d => (core_build_esm_utils_spanOnScope_setSpanForScope(d, c || void 0), u(d)))) } function trace_createChildOrRootSpan({ "parentSpan": c, "spanArguments": u, "forceTransaction": d, "scope": v }) { if (!utils_hasTracingEnabled_hasTracingEnabled()) return new tracing_sentryNonRecordingSpan_SentryNonRecordingSpan; const E = function _sentry_core_build_esm_currentScopes_getIsolationScope() { return _sentry_core_build_esm_asyncContext_getAsyncContextStrategy(_sentry_core_build_esm_carrier_getMainCarrier()).getIsolationScope() }(); let k; if (c && !d) k = function trace_startChildSpan(c, u, d) { const { "spanId": v, "traceId": E } = c.spanContext(), k = !u.getScopeData().sdkProcessingMetadata[Ga] && utils_spanUtils_spanIsSampled(c), R = k ? new sentrySpan_SentrySpan({ ...d, "parentSpanId": v, "traceId": E, "sampled": k }) : new tracing_sentryNonRecordingSpan_SentryNonRecordingSpan({ "traceId": E }); utils_spanUtils_addChildSpanToSpan(c, R); const U = _sentry_core_build_esm_currentScopes_getClient(); U && (U.emit("spanStart", R), d.endTimestamp && U.emit("spanEnd", R)); return R }(c, v, u), utils_spanUtils_addChildSpanToSpan(c, k); else if (c) { const d = tracing_dynamicSamplingContext_getDynamicSamplingContextFromSpan(c), { "traceId": E, "spanId": R } = c.spanContext(), U = utils_spanUtils_spanIsSampled(c); k = trace_startRootSpan({ "traceId": E, "parentSpanId": R, ...u }, v, U), tracing_dynamicSamplingContext_freezeDscOnSpan(k, d) } else { const { "traceId": c, "dsc": d, "parentSpanId": R, "sampled": U } = { ...E.getPropagationContext(), ...v.getPropagationContext() }; k = trace_startRootSpan({ "traceId": c, "parentSpanId": R, ...u }, v, U), d && tracing_dynamicSamplingContext_freezeDscOnSpan(k, d) } return function logSpans_logSpanStart(c) { if (!Ha) return; const { "description": u = "< unknown name >", "op": d = "< unknown op >", "parent_span_id": v } = esm_utils_spanUtils_spanToJSON(c), { "spanId": E } = c.spanContext(), k = utils_spanUtils_spanIsSampled(c), R = utils_spanUtils_getRootSpan(c), U = R === c, H = `[Tracing] Starting ${k ? "sampled" : "unsampled"} ${U ? "root " : ""}span`, G = [`op: ${d}`, `name: ${u}`, `ID: ${E}`]; if (v && G.push(`parent ID: ${v}`), !U) { const { "op": c, "description": u } = esm_utils_spanUtils_spanToJSON(R); G.push(`root ID: ${R.spanContext().spanId}`), c && G.push(`root op: ${c}`), u && G.push(`root description: ${u}`) } ct.log(`${H}\n  ${G.join("\n  ")}`) }(k), function utils_setCapturedScopesOnSpan(c, u, d) { c && (esm_object_addNonEnumerableProperty(c, qa, d), esm_object_addNonEnumerableProperty(c, za, u)) }(k, v, E), k } function trace_parseSentrySpanArguments(c) { const u = { "isStandalone": (c.experimental || {}).standalone, ...c }; if (c.startTime) { const d = { ...u }; return d.startTimestamp = utils_spanUtils_spanTimeInputToSeconds(c.startTime), delete d.startTime, d } return u } function trace_getAcs() { return _sentry_core_build_esm_asyncContext_getAsyncContextStrategy(_sentry_core_build_esm_carrier_getMainCarrier()) } function trace_startRootSpan(c, u, d) { const v = _sentry_core_build_esm_currentScopes_getClient(), E = v && v.getOptions() || {}, { "name": k = "", "attributes": R } = c, [U, H] = u.getScopeData().sdkProcessingMetadata[Ga] ? [!1] : sampling_sampleSpan(E, { "name": k, "parentSampled": d, "attributes": R, "transactionContext": { "name": k, "parentSampled": d } }), G = new sentrySpan_SentrySpan({ ...c, "attributes": { [xa]: "custom", ...c.attributes }, "sampled": U }); return void 0 !== H && G.setAttribute(Aa, H), v && v.emit("spanStart", G), G } function trace_getParentSpan(c) { const u = build_esm_utils_spanOnScope_getSpanForScope(c); if (!u) return; const d = _sentry_core_build_esm_currentScopes_getClient(); return (d ? d.getOptions() : {}).parentSpanIsAlwaysRootSpan ? utils_spanUtils_getRootSpan(u) : u } const Va = it, Wa = 80; function utils_build_esm_browser_htmlTreeAsString(c, u = {}) { if (!c) return "<unknown>"; try { let d = c; const v = 5, E = []; let k = 0, R = 0; const U = " > ", H = U.length; let G; const W = Array.isArray(u) ? u : u.keyAttrs, Z = !Array.isArray(u) && u.maxStringLength || Wa; for (; d && k++ < v && (G = build_esm_browser_htmlElementAsString(d, W), !("html" === G || k > 1 && R + E.length * H + G.length >= Z));)E.push(G), R += G.length, d = d.parentNode; return E.reverse().join(U) } catch (c) { return "<unknown>" } } function build_esm_browser_htmlElementAsString(c, u) { const d = c, v = []; if (!d || !d.tagName) return ""; if (Va.HTMLElement && d instanceof HTMLElement && d.dataset) { if (d.dataset.sentryComponent) return d.dataset.sentryComponent; if (d.dataset.sentryElement) return d.dataset.sentryElement } v.push(d.tagName.toLowerCase()); const E = u && u.length ? u.filter((c => d.getAttribute(c))).map((c => [c, d.getAttribute(c)])) : null; if (E && E.length) E.forEach((c => { v.push(`[${c[0]}="${c[1]}"]`) })); else { d.id && v.push(`#${d.id}`); const c = d.className; if (c && esm_is_isString(c)) { const u = c.split(/\s+/); for (const c of u) v.push(`.${c}`) } } const k = ["aria-label", "type", "name", "title", "alt"]; for (const c of k) { const u = d.getAttribute(c); u && v.push(`[${c}="${u}"]`) } return v.join("") } function build_esm_browser_getComponentName(c) { if (!Va.HTMLElement) return null; let u = c; for (let c = 0; c < 5; c++) { if (!u) return null; if (u instanceof HTMLElement) { if (u.dataset.sentryComponent) return u.dataset.sentryComponent; if (u.dataset.sentryElement) return u.dataset.sentryElement } u = u.parentNode } return null } function buildPolyfills_optionalChain_optionalChain(c) { let u, d = c[0], v = 1; for (; v < c.length;) { const E = c[v], k = c[v + 1]; if (v += 2, ("optionalAccess" === E || "optionalCall" === E) && null == d) return; "access" === E || "optionalAccess" === E ? (u = d, d = k(d)) : "call" !== E && "optionalCall" !== E || (d = k(((...c) => d.call(u, ...c))), u = void 0) } return d } function isMeasurementValue(c) { return "number" == typeof c && isFinite(c) } function startAndEndSpan(c, u, d, { ...v }) { const E = esm_utils_spanUtils_spanToJSON(c).start_timestamp; return E && E > u && "function" == typeof c.updateStartTime && c.updateStartTime(u), trace_withActiveSpan(c, (() => { const c = trace_startInactiveSpan({ "startTime": u, ...v }); return c && c.end(d), c })) } function startStandaloneWebVitalSpan(c) { const u = _sentry_core_build_esm_currentScopes_getClient(); if (!u) return; const { "name": d, "transaction": v, "attributes": E, "startTime": k } = c, { "release": R, "environment": U } = u.getOptions(), H = u.getIntegrationByName("Replay"), G = H && H.getReplayId(), W = _sentry_core_build_esm_currentScopes_getCurrentScope(), Z = W.getUser(), Y = void 0 !== Z ? Z.email || Z.id || Z.ip_address : void 0; let J; try { J = W.getScopeData().contexts.profile.profile_id } catch (c) { } return trace_startInactiveSpan({ "name": d, "attributes": { "release": R, "environment": U, "user": Y || void 0, "profile_id": J || void 0, "replay_id": G || void 0, "transaction": v, "user_agent.original": ht.navigator && ht.navigator.userAgent, ...E }, "startTime": k, "experimental": { "standalone": !0 } }) } function getBrowserPerformanceAPI() { return ht && ht.addEventListener && ht.performance } function msToSec(c) { return c / 1e3 } function trackClsAsStandaloneSpan() { let c, u, d = 0; if (!function supportsLayoutShift() { try { return buildPolyfills_optionalChain_optionalChain([PerformanceObserver, "access", c => c.supportedEntryTypes, "optionalAccess", c => c.includes, "call", c => c("layout-shift")]) } catch (c) { return !1 } }()) return; let v = !1; function _collectClsOnce() { v || (v = !0, u && function sendStandaloneClsSpan(c, u, d) { en && ct.log(`Sending CLS span (${c})`); const v = msToSec((kt || 0) + (buildPolyfills_optionalChain_optionalChain([u, "optionalAccess", c => c.startTime]) || 0)), E = _sentry_core_build_esm_currentScopes_getCurrentScope().getScopeData().transactionName, k = u ? utils_build_esm_browser_htmlTreeAsString(buildPolyfills_optionalChain_optionalChain([u, "access", c => c.sources, "access", c => c[0], "optionalAccess", c => c.node])) : "Layout shift", R = esm_object_dropUndefinedKeys({ [ka]: "auto.http.browser.cls", [Ia]: "ui.webvital.cls", [Ra]: buildPolyfills_optionalChain_optionalChain([u, "optionalAccess", c => c.duration]) || 0, "sentry.pageload.span_id": d }), U = startStandaloneWebVitalSpan({ "name": k, "transaction": E, "attributes": R, "startTime": v }); buildPolyfills_optionalChain_optionalChain([U, "optionalAccess", c => c.addEvent, "call", u => u("cls", { [Oa]: "", [Pa]: c })]), buildPolyfills_optionalChain_optionalChain([U, "optionalAccess", c => c.end, "call", c => c(v)]) }(d, c, u), E()) } const E = addClsInstrumentationHandler((({ "metric": u }) => { const v = u.entries[u.entries.length - 1]; v && (d = u.value, c = v) }), !0); onHidden((() => { _collectClsOnce() })), setTimeout((() => { const c = buildPolyfills_optionalChain_optionalChain([_sentry_core_build_esm_currentScopes_getClient(), "optionalAccess", c => c.on, "call", u => u("startNavigationSpan", (() => { _collectClsOnce(), c && c() }))]), d = utils_spanUtils_getActiveSpan(), v = d && utils_spanUtils_getRootSpan(d), E = v && esm_utils_spanUtils_spanToJSON(v); E && "pageload" === E.op && (u = v.spanContext().spanId) }), 0) } const Za = 2147483647; let Ya, Ja, Ka = 0, Xa = {}; function startTrackingWebVitals({ "recordClsStandaloneSpans": c }) { const u = getBrowserPerformanceAPI(); if (u && kt) { u.mark && ht.performance.mark("sentry-tracing-init"); const d = function _trackFID() { return addFidInstrumentationHandler((({ "metric": c }) => { const u = c.entries[c.entries.length - 1]; if (!u) return; const d = msToSec(kt), v = msToSec(u.startTime); en && ct.log("[Measurements] Adding FID"), Xa.fid = { "value": c.value, "unit": "millisecond" }, Xa["mark.fid"] = { "value": d + v, "unit": "second" } })) }(), v = function _trackLCP() { return addLcpInstrumentationHandler((({ "metric": c }) => { const u = c.entries[c.entries.length - 1]; u && (en && ct.log("[Measurements] Adding LCP"), Xa.lcp = { "value": c.value, "unit": "millisecond" }, Ya = u) }), !0) }(), E = function _trackTtfb() { return function addTtfbInstrumentationHandler(c) { return addMetricObserver("ttfb", c, instrumentTtfb, Br) }((({ "metric": c }) => { c.entries[c.entries.length - 1] && (en && ct.log("[Measurements] Adding TTFB"), Xa.ttfb = { "value": c.value, "unit": "millisecond" }) })) }(), k = c ? trackClsAsStandaloneSpan() : function _trackCLS() { return addClsInstrumentationHandler((({ "metric": c }) => { const u = c.entries[c.entries.length - 1]; u && (en && ct.log(`[Measurements] Adding CLS ${c.value}`), Xa.cls = { "value": c.value, "unit": "" }, Ja = u) }), !0) }(); return () => { d(), v(), E(), k && k() } } return () => { } } function addPerformanceEntries(c, u) { const d = getBrowserPerformanceAPI(); if (!d || !ht.performance.getEntries || !kt) return; en && ct.log("[Tracing] Adding & adjusting spans using Performance API"); const v = msToSec(kt), E = d.getEntries(), { "op": k, "start_timestamp": R } = esm_utils_spanUtils_spanToJSON(c); if (E.slice(Ka).forEach((u => { const d = msToSec(u.startTime), E = msToSec(Math.max(0, u.duration)); if (!("navigation" === k && R && v + d < R)) switch (u.entryType) { case "navigation": !function _addNavigationSpans(c, u, d) { ["unloadEvent", "redirect", "domContentLoadedEvent", "loadEvent", "connect"].forEach((v => { _addPerformanceNavigationTiming(c, u, v, d) })), _addPerformanceNavigationTiming(c, u, "secureConnection", d, "TLS/SSL", "connectEnd"), _addPerformanceNavigationTiming(c, u, "fetch", d, "cache", "domainLookupStart"), _addPerformanceNavigationTiming(c, u, "domainLookup", d, "DNS"), function _addRequest(c, u, d) { const v = d + msToSec(u.requestStart), E = d + msToSec(u.responseEnd), k = d + msToSec(u.responseStart); u.responseEnd && (startAndEndSpan(c, v, E, { "op": "browser", "name": "request", "attributes": { [ka]: "auto.ui.browser.metrics" } }), startAndEndSpan(c, k, E, { "op": "browser", "name": "response", "attributes": { [ka]: "auto.ui.browser.metrics" } })) }(c, u, d) }(c, u, v); break; case "mark": case "paint": case "measure": { !function _addMeasureSpans(c, u, d, v, E) { const k = getNavigationEntry(), R = msToSec(k ? k.requestStart : 0), U = E + Math.max(d, R), H = E + d, G = H + v, W = { [ka]: "auto.resource.browser.metrics" }; U !== H && (W["sentry.browser.measure_happened_before_request"] = !0, W["sentry.browser.measure_start_time"] = U); return startAndEndSpan(c, U, G, { "name": u.name, "op": u.entryType, "attributes": W }), U }(c, u, d, E, v); const k = getVisibilityWatcher(), R = u.startTime < k.firstHiddenTime; "first-paint" === u.name && R && (en && ct.log("[Measurements] Adding FP"), Xa.fp = { "value": u.startTime, "unit": "millisecond" }), "first-contentful-paint" === u.name && R && (en && ct.log("[Measurements] Adding FCP"), Xa.fcp = { "value": u.startTime, "unit": "millisecond" }); break } case "resource": !function _addResourceSpans(c, u, d, v, E, k) { if ("xmlhttprequest" === u.initiatorType || "fetch" === u.initiatorType) return; const R = function esm_url_parseUrl(c) { if (!c) return {}; const u = c.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/); if (!u) return {}; const d = u[6] || "", v = u[8] || ""; return { "host": u[4], "path": u[5], "protocol": u[2], "search": d, "hash": v, "relative": u[5] + d + v } }(d), U = { [ka]: "auto.resource.browser.metrics" }; setResourceEntrySizeData(U, u, "transferSize", "http.response_transfer_size"), setResourceEntrySizeData(U, u, "encodedBodySize", "http.response_content_length"), setResourceEntrySizeData(U, u, "decodedBodySize", "http.decoded_response_content_length"), "renderBlockingStatus" in u && (U["resource.render_blocking_status"] = u.renderBlockingStatus); R.protocol && (U["url.scheme"] = R.protocol.split(":").pop()); R.host && (U["server.address"] = R.host); U["url.same_origin"] = d.includes(ht.location.origin); const H = k + v, G = H + E; startAndEndSpan(c, H, G, { "name": d.replace(ht.location.origin, ""), "op": u.initiatorType ? `resource.${u.initiatorType}` : "resource.other", "attributes": U }) }(c, u, u.name, d, E, v) } })), Ka = Math.max(E.length - 1, 0), function _trackNavigator(c) { const u = ht.navigator; if (!u) return; const d = u.connection; d && (d.effectiveType && c.setAttribute("effectiveConnectionType", d.effectiveType), d.type && c.setAttribute("connectionType", d.type), isMeasurementValue(d.rtt) && (Xa["connection.rtt"] = { "value": d.rtt, "unit": "millisecond" })); isMeasurementValue(u.deviceMemory) && c.setAttribute("deviceMemory", `${u.deviceMemory} GB`); isMeasurementValue(u.hardwareConcurrency) && c.setAttribute("hardwareConcurrency", String(u.hardwareConcurrency)) }(c), "pageload" === k) { !function _addTtfbRequestTimeToMeasurements(c) { const u = getNavigationEntry(); if (!u) return; const { "responseStart": d, "requestStart": v } = u; v <= d && (en && ct.log("[Measurements] Adding TTFB Request Time"), c["ttfb.requestTime"] = { "value": d - v, "unit": "millisecond" }) }(Xa); const d = Xa["mark.fid"]; d && Xa.fid && (startAndEndSpan(c, d.value, d.value + msToSec(Xa.fid.value), { "name": "first input delay", "op": "ui.action", "attributes": { [ka]: "auto.ui.browser.metrics" } }), delete Xa["mark.fid"]), "fcp" in Xa && u.recordClsOnPageloadSpan || delete Xa.cls, Object.entries(Xa).forEach((([c, u]) => { !function measurement_setMeasurement(c, u, d, v = utils_spanUtils_getActiveSpan()) { const E = v && utils_spanUtils_getRootSpan(v); E && E.addEvent(c, { [Pa]: u, [Oa]: d }) }(c, u.value, u.unit) })), c.setAttribute("performance.timeOrigin", v), function _setWebVitalAttributes(c) { Ya && (en && ct.log("[Measurements] Adding LCP Data"), Ya.element && c.setAttribute("lcp.element", utils_build_esm_browser_htmlTreeAsString(Ya.element)), Ya.id && c.setAttribute("lcp.id", Ya.id), Ya.url && c.setAttribute("lcp.url", Ya.url.trim().slice(0, 200)), c.setAttribute("lcp.size", Ya.size)); Ja && Ja.sources && (en && ct.log("[Measurements] Adding CLS Data"), Ja.sources.forEach(((u, d) => c.setAttribute(`cls.source.${d + 1}`, utils_build_esm_browser_htmlTreeAsString(u.node))))) }(c) } Ya = void 0, Ja = void 0, Xa = {} } function _addPerformanceNavigationTiming(c, u, d, v, E, k) { const R = k ? u[k] : u[`${d}End`], U = u[`${d}Start`]; U && R && startAndEndSpan(c, v + msToSec(U), v + msToSec(R), { "op": "browser", "name": E || d, "attributes": { [ka]: "auto.ui.browser.metrics" } }) } function setResourceEntrySizeData(c, u, d, v) { const E = u[d]; null != E && E < Za && (c[v] = E) } const Qa = [], es = new Map; function startTrackingINP() { if (getBrowserPerformanceAPI() && kt) { const c = function _trackINP() { return addInpInstrumentationHandler((({ "metric": c }) => { if (null == c.value) return; const u = c.entries.find((u => u.duration === c.value && ts[u.name])); if (!u) return; const { "interactionId": d } = u, v = ts[u.name], E = msToSec(kt + u.startTime), k = msToSec(c.value), R = utils_spanUtils_getActiveSpan(), U = R ? utils_spanUtils_getRootSpan(R) : void 0, H = (null != d ? es.get(d) : void 0) || U, G = H ? esm_utils_spanUtils_spanToJSON(H).description : _sentry_core_build_esm_currentScopes_getCurrentScope().getScopeData().transactionName, W = startStandaloneWebVitalSpan({ "name": utils_build_esm_browser_htmlTreeAsString(u.target), "transaction": G, "attributes": esm_object_dropUndefinedKeys({ [ka]: "auto.http.browser.inp", [Ia]: `ui.interaction.${v}`, [Ra]: u.duration }), "startTime": E }); buildPolyfills_optionalChain_optionalChain([W, "optionalAccess", c => c.addEvent, "call", u => u("inp", { [Oa]: "millisecond", [Pa]: c.value })]), buildPolyfills_optionalChain_optionalChain([W, "optionalAccess", c => c.end, "call", c => c(E + k)]) })) }(); return () => { c() } } return () => { } } const ts = { "click": "click", "pointerdown": "click", "pointerup": "click", "mousedown": "click", "mouseup": "click", "touchstart": "click", "touchend": "click", "mouseover": "hover", "mouseout": "hover", "mouseenter": "hover", "mouseleave": "hover", "pointerover": "hover", "pointerout": "hover", "pointerenter": "hover", "pointerleave": "hover", "dragstart": "drag", "dragend": "drag", "drag": "drag", "dragenter": "drag", "dragleave": "drag", "dragover": "drag", "drop": "drag", "keydown": "press", "keyup": "press", "keypress": "press", "input": "press" }; const ns = { "idleTimeout": 1e3, "finalTimeout": 3e4, "childSpanTimeout": 15e3 }, rs = "heartbeatFailed", os = "idleTimeout", as = "finalTimeout", ss = "externalFinish"; function startIdleSpan(c, u = {}) { const d = new Map; let v, E = !1, k = ss, R = !u.disableAutoFinish; const U = [], { "idleTimeout": H = ns.idleTimeout, "finalTimeout": G = ns.finalTimeout, "childSpanTimeout": W = ns.childSpanTimeout, "beforeSpanEnd": Z } = u, Y = currentScopes_getClient(); if (!Y || !hasTracingEnabled_hasTracingEnabled()) return new sentryNonRecordingSpan_SentryNonRecordingSpan; const J = currentScopes_getCurrentScope(), K = getActiveSpan(), X = function _startIdleSpan(c) { const u = startInactiveSpan(c); return spanOnScope_setSpanForScope(currentScopes_getCurrentScope(), u), he && ue.log("[Tracing] Started span is an idle span"), u }(c); function _cancelIdleTimeout() { v && (clearTimeout(v), v = void 0) } function _restartIdleTimeout(c) { _cancelIdleTimeout(), v = setTimeout((() => { !E && 0 === d.size && R && (k = os, X.end(c)) }), H) } function _restartChildSpanTimeout(c) { v = setTimeout((() => { !E && R && (k = rs, X.end(c)) }), W) } function onIdleSpanEnded(c) { E = !0, d.clear(), U.forEach((c => c())), spanOnScope_setSpanForScope(J, K); const u = spanUtils_spanToJSON(X), { "start_timestamp": v } = u; if (!v) return; (u.data || {})[Be] || X.setAttribute(Be, k), ue.log(`[Tracing] Idle span "${u.op}" finished`); const R = getSpanDescendants(X).filter((c => c !== X)); let W = 0; R.forEach((u => { u.isRecording() && (u.setStatus({ "code": We, "message": "cancelled" }), u.end(c), he && ue.log("[Tracing] Cancelling span since span ended early", JSON.stringify(u, void 0, 2))); const d = spanUtils_spanToJSON(u), { "timestamp": v = 0, "start_timestamp": E = 0 } = d, k = E <= c, R = v - E <= (G + H) / 1e3; if (he) { const c = JSON.stringify(u, void 0, 2); k ? R || ue.log("[Tracing] Discarding span since it finished after idle span final timeout", c) : ue.log("[Tracing] Discarding span since it happened after idle span was finished", c) } R && k || (!function removeChildSpanFromSpan(c, u) { c[Ye] && c[Ye].delete(u) }(X, u), W++) })), W > 0 && X.setAttribute("sentry.idle_span_discarded_spans", W) } return X.end = new Proxy(X.end, { "apply"(c, u, d) { Z && Z(X); const [v, ...E] = d, k = spanTimeInputToSeconds(v || ge()), R = getSpanDescendants(X).filter((c => c !== X)); if (!R.length) return onIdleSpanEnded(k), Reflect.apply(c, u, [k, ...E]); const U = R.map((c => spanUtils_spanToJSON(c).timestamp)).filter((c => !!c)), H = U.length ? Math.max(...U) : void 0, W = spanUtils_spanToJSON(X).start_timestamp, Y = Math.min(W ? W + G / 1e3 : 1 / 0, Math.max(W || -1 / 0, Math.min(k, H || 1 / 0))); return onIdleSpanEnded(Y), Reflect.apply(c, u, [Y, ...E]) } }), U.push(Y.on("spanStart", (c => { if (E || c === X || spanUtils_spanToJSON(c).timestamp) return; getSpanDescendants(X).includes(c) && function _pushActivity(c) { _cancelIdleTimeout(), d.set(c, !0), _restartChildSpanTimeout(ge() + W / 1e3) }(c.spanContext().spanId) }))), U.push(Y.on("spanEnd", (c => { E || function _popActivity(c) { d.has(c) && d.delete(c), 0 === d.size && _restartIdleTimeout(ge() + H / 1e3) }(c.spanContext().spanId) }))), U.push(Y.on("idleSpanEnableAutoFinish", (c => { c === X && (R = !0, _restartIdleTimeout(), d.size && _restartChildSpanTimeout()) }))), u.disableAutoFinish || _restartIdleTimeout(), setTimeout((() => { E || (X.setStatus({ "code": We, "message": "deadline_exceeded" }), k = as, X.end()) }), G), X } const cs = { ...ns, "instrumentNavigation": !0, "instrumentPageLoad": !0, "markBackgroundSpan": !0, "enableLongTask": !0, "enableLongAnimationFrame": !0, "enableInp": !0, "_experiments": {}, ...wa }, browserTracingIntegration = (c = {}) => { registerSpanErrorInstrumentation(); const { "enableInp": u, "enableLongTask": d, "enableLongAnimationFrame": v, "_experiments": { "enableInteractions": E, "enableStandaloneClsSpans": k }, "beforeStartSpan": R, "idleTimeout": U, "finalTimeout": H, "childSpanTimeout": G, "markBackgroundSpan": W, "traceFetch": Z, "traceXHR": Y, "shouldCreateSpanForRequest": J, "enableHTTPTimings": K, "instrumentPageLoad": X, "instrumentNavigation": Q } = { ...cs, ...c }, ee = startTrackingWebVitals({ "recordClsStandaloneSpans": k || !1 }); u && startTrackingINP(), v && se.PerformanceObserver && PerformanceObserver.supportedEntryTypes && PerformanceObserver.supportedEntryTypes.includes("long-animation-frame") ? function startTrackingLongAnimationFrames() { new PerformanceObserver((c => { if (utils_spanUtils_getActiveSpan()) for (const u of c.getEntries()) { if (!u.scripts[0]) continue; const c = msToSec(kt + u.startTime), d = msToSec(u.duration), v = { [ka]: "auto.ui.browser.metrics" }, E = u.scripts[0], { "invoker": k, "invokerType": R, "sourceURL": U, "sourceFunctionName": H, "sourceCharPosition": G } = E; v["browser.script.invoker"] = k, v["browser.script.invoker_type"] = R, U && (v["code.filepath"] = U), H && (v["code.function"] = H), -1 !== G && (v["browser.script.source_char_position"] = G); const W = trace_startInactiveSpan({ "name": "Main UI thread blocked", "op": "ui.long-animation-frame", "startTime": c, "attributes": v }); W && W.end(c + d) } })).observe({ "type": "long-animation-frame", "buffered": !0 }) }() : d && function startTrackingLongTasks() { addPerformanceInstrumentationHandler("longtask", (({ "entries": c }) => { if (utils_spanUtils_getActiveSpan()) for (const u of c) { const c = msToSec(kt + u.startTime), d = msToSec(u.duration), v = trace_startInactiveSpan({ "name": "Main UI thread blocked", "op": "ui.long-task", "startTime": c, "attributes": { [ka]: "auto.ui.browser.metrics" } }); v && v.end(c + d) } })) }(), E && function startTrackingInteractions() { addPerformanceInstrumentationHandler("event", (({ "entries": c }) => { if (utils_spanUtils_getActiveSpan()) for (const u of c) if ("click" === u.name) { const c = msToSec(kt + u.startTime), d = msToSec(u.duration), v = { "name": utils_build_esm_browser_htmlTreeAsString(u.target), "op": `ui.interaction.${u.name}`, "startTime": c, "attributes": { [ka]: "auto.ui.browser.metrics" } }, E = build_esm_browser_getComponentName(u.target); E && (v.attributes["ui.component_name"] = E); const k = trace_startInactiveSpan(v); k && k.end(c + d) } })) }(); const te = { "name": void 0, "source": void 0 }; function _createRouteSpan(c, u) { const d = "pageload" === u.op, v = R ? R(u) : u, E = v.attributes || {}; u.name !== v.name && (E[$e] = "custom", v.attributes = E), te.name = v.name, te.source = E[$e]; const W = startIdleSpan(v, { "idleTimeout": U, "finalTimeout": H, "childSpanTimeout": G, "disableAutoFinish": d, "beforeSpanEnd": c => { ee(), addPerformanceEntries(c, { "recordClsOnPageloadSpan": !k }) } }); function emitFinish() { ["interactive", "complete"].includes(bt.document.readyState) && c.emit("idleSpanEnableAutoFinish", W) } return d && bt.document && (bt.document.addEventListener("readystatechange", (() => { emitFinish() })), emitFinish()), W } return { "name": "BrowserTracing", "afterAllSetup"(c) { let d, v = bt.location && bt.location.href; c.on("startNavigationSpan", (u => { currentScopes_getClient() === c && (d && !spanUtils_spanToJSON(d).timestamp && (vt && ue.log(`[Tracing] Finishing current root span with op: ${spanUtils_spanToJSON(d).op}`), d.end()), d = _createRouteSpan(c, { "op": "navigation", ...u })) })), c.on("startPageLoadSpan", ((u, v = {}) => { if (currentScopes_getClient() !== c) return; d && !spanUtils_spanToJSON(d).timestamp && (vt && ue.log(`[Tracing] Finishing current root span with op: ${spanUtils_spanToJSON(d).op}`), d.end()); const E = tracing_propagationContextFromHeaders(v.sentryTrace || getMetaContent("sentry-trace"), v.baggage || getMetaContent("baggage")); currentScopes_getCurrentScope().setPropagationContext(E), d = _createRouteSpan(c, { "op": "pageload", ...u }) })), c.on("spanEnd", (c => { const u = spanUtils_spanToJSON(c).op; if (c !== getRootSpan(c) || "navigation" !== u && "pageload" !== u) return; const d = currentScopes_getCurrentScope(), v = d.getPropagationContext(); d.setPropagationContext({ ...v, "sampled": void 0 !== v.sampled ? v.sampled : spanIsSampled(c), "dsc": v.dsc || getDynamicSamplingContextFromSpan(c) }) })), bt.location && (X && startBrowserTracingPageLoadSpan(c, { "name": bt.location.pathname, "startTime": ve ? ve / 1e3 : void 0, "attributes": { [$e]: "url", [je]: "auto.pageload.browser" } }), Q && addHistoryInstrumentationHandler((({ "to": u, "from": d }) => { void 0 === d && v && -1 !== v.indexOf(u) ? v = void 0 : d !== u && (v = void 0, startBrowserTracingNavigationSpan(c, { "name": bt.location.pathname, "attributes": { [$e]: "url", [je]: "auto.navigation.browser" } })) }))), W && function registerBackgroundTabDetection() { bt && bt.document ? bt.document.addEventListener("visibilitychange", (() => { const c = getActiveSpan(); if (!c) return; const u = getRootSpan(c); if (bt.document.hidden && u) { const c = "cancelled", { "op": d, "status": v } = spanUtils_spanToJSON(u); vt && ue.log(`[Tracing] Transaction: ${c} -> since tab moved to the background, op: ${d}`), v || u.setStatus({ "code": We, "message": c }), u.setAttribute("sentry.cancellation_reason", "document.hidden"), u.end() } })) : vt && ue.warn("[Tracing] Could not set up background tab detection due to lack of global document") }(), E && function registerInteractionListener(c, u, d, v) { let E; const registerInteractionTransaction = () => { const k = "ui.action.click", R = getActiveSpan(), U = R && getRootSpan(R); if (U) { const c = spanUtils_spanToJSON(U).op; if (["navigation", "pageload"].includes(c)) return void (vt && ue.warn(`[Tracing] Did not create ${k} span because a pageload or navigation span is in progress.`)) } E && (E.setAttribute(Be, "interactionInterrupted"), E.end(), E = void 0), v.name ? E = startIdleSpan({ "name": v.name, "op": k, "attributes": { [$e]: v.source || "url" } }, { "idleTimeout": c, "finalTimeout": u, "childSpanTimeout": d }) : vt && ue.warn(`[Tracing] Did not create ${k} transaction because _latestRouteName is missing.`) }; bt.document && addEventListener("click", registerInteractionTransaction, { "once": !1, "capture": !0 }) }(U, H, G, te), u && function registerInpInteractionListener(c) { const handleEntries = ({ "entries": c }) => { const u = utils_spanUtils_getActiveSpan(), d = u && utils_spanUtils_getRootSpan(u); c.forEach((c => { if (!function isPerformanceEventTiming(c) { return "duration" in c }(c) || !d) return; const u = c.interactionId; if (null != u && !es.has(u)) { if (Qa.length > 10) { const c = Qa.shift(); es.delete(c) } Qa.push(u), es.set(u, d) } })) }; addPerformanceInstrumentationHandler("event", handleEntries), addPerformanceInstrumentationHandler("first-input", handleEntries) }(), instrumentOutgoingRequests(c, { "traceFetch": Z, "traceXHR": Y, "tracePropagationTargets": c.getOptions().tracePropagationTargets, "shouldCreateSpanForRequest": J, "enableHTTPTimings": K }) } } }; function startBrowserTracingPageLoadSpan(c, u, d) { c.emit("startPageLoadSpan", u, d), currentScopes_getCurrentScope().setTransactionName(u.name); const v = getActiveSpan(); return "pageload" === (v && spanUtils_spanToJSON(v).op) ? v : void 0 } function startBrowserTracingNavigationSpan(c, u) { currentScopes_getIsolationScope().setPropagationContext(propagationContext_generatePropagationContext()), currentScopes_getCurrentScope().setPropagationContext(propagationContext_generatePropagationContext()), c.emit("startNavigationSpan", u), currentScopes_getCurrentScope().setTransactionName(u.name); const d = getActiveSpan(); return "navigation" === (d && spanUtils_spanToJSON(d).op) ? d : void 0 } function getMetaContent(c) { const u = function getDomElement(c) { return pe.document && pe.document.querySelector ? pe.document.querySelector(c) : null }(`meta[name=${c}]`); return u ? u.getAttribute("content") : void 0 } const ls = 100, us = 5e3, ds = 36e5; function makeOfflineTransport(c) { function log(...c) { he && ue.info("[Offline]:", ...c) } return u => { const d = c(u); if (!u.createStore) throw new Error("No `createStore` function was provided"); const v = u.createStore(u); let E, k = us; function flushIn(c) { E && clearTimeout(E), E = setTimeout((async () => { E = void 0; const c = await v.shift(); c && (log("Attempting to send previously queued event"), c[0].sent_at = (new Date).toISOString(), send(c, !0).catch((c => { log("Failed to retry sending", c) }))) }), c), "number" != typeof E && E.unref && E.unref() } function flushWithBackOff() { E || (flushIn(k), k = Math.min(2 * k, ds)) } async function send(c, E = !1) { if (!E && envelopeContainsItemType(c, ["replay_event", "replay_recording"])) return await v.push(c), flushIn(ls), {}; try { const u = await d.send(c); let v = ls; if (u) if (u.headers && u.headers["retry-after"]) v = parseRetryAfterHeader(u.headers["retry-after"]); else if (u.headers && u.headers["x-sentry-rate-limits"]) v = 6e4; else if ((u.statusCode || 0) >= 400) return u; return flushIn(v), k = us, u } catch (d) { if (await function shouldQueue(c, d, v) { return !envelopeContainsItemType(c, ["client_report"]) && (!u.shouldStore || u.shouldStore(c, d, v)) }(c, d, k)) return E ? await v.unshift(c) : await v.push(c), flushWithBackOff(), log("Error sending. Event queued.", d), {}; throw d } } return u.flushAtStartup && flushWithBackOff(), { "send": send, "flush": c => d.flush(c) } } } function promisifyRequest(c) { return new Promise(((u, d) => { c.oncomplete = c.onsuccess = () => u(c.result), c.onabort = c.onerror = () => d(c.error) })) } function keys(c) { return promisifyRequest(c.getAllKeys()) } function createIndexedDbStore(c) { let u; function getStore() { return null == u && (u = function createStore(c, u) { const d = indexedDB.open(c); d.onupgradeneeded = () => d.result.createObjectStore(u); const v = promisifyRequest(d); return c => v.then((d => c(d.transaction(u, "readwrite").objectStore(u)))) }(c.dbName || "sentry-offline", c.storeName || "queue")), u } return { "push": async u => { try { const d = await serializeEnvelope(u); await function push(c, u, d) { return c((c => keys(c).then((v => { if (!(v.length >= d)) return c.put(u, Math.max(...v, 0) + 1), promisifyRequest(c.transaction) })))) }(getStore(), d, c.maxQueueSize || 30) } catch (c) { } }, "unshift": async u => { try { const d = await serializeEnvelope(u); await function unshift(c, u, d) { return c((c => keys(c).then((v => { if (!(v.length >= d)) return c.put(u, Math.min(...v, 0) - 1), promisifyRequest(c.transaction) })))) }(getStore(), d, c.maxQueueSize || 30) } catch (c) { } }, "shift": async () => { try { const c = await function shift(c) { return c((c => keys(c).then((u => { const d = u[0]; if (null != d) return promisifyRequest(c.get(d)).then((u => (c.delete(d), promisifyRequest(c.transaction).then((() => u))))) })))) }(getStore()); if (c) return parseEnvelope(c) } catch (c) { } } } } function makeBrowserOfflineTransport(c = makeFetchTransport) { return function makeIndexedDbOfflineTransport(c) { return u => c({ ...u, "createStore": createIndexedDbStore }) }(makeOfflineTransport(c)) } const ps = 1e6, fs = String(0), hs = "main"; let ms = "", gs = "", _s = "", vs = bt.navigator && bt.navigator.userAgent || "", ys = ""; const bs = bt.navigator && bt.navigator.language || bt.navigator && bt.navigator.languages && bt.navigator.languages[0] || ""; const Ss = bt.navigator && bt.navigator.userAgentData; function enrichWithThreadInformation(c) { return function isProcessedJSSelfProfile(c) { return !("thread_metadata" in c) }(c) ? function convertJSSelfProfileToSampledFormat(c) { let u, d = 0; const v = { "samples": [], "stacks": [], "frames": [], "thread_metadata": { [fs]: { "name": hs } } }, E = c.samples[0]; if (!E) return v; const k = E.timestamp, R = "number" == typeof performance.timeOrigin ? performance.timeOrigin : ve || 0, U = R - (ve || R); return c.samples.forEach(((E, R) => { if (void 0 === E.stackId) return void 0 === u && (u = d, v.stacks[u] = [], d++), void (v.samples[R] = { "elapsed_since_start_ns": ((E.timestamp + U - k) * ps).toFixed(0), "stack_id": u, "thread_id": fs }); let H = c.stacks[E.stackId]; const G = []; for (; H;) { G.push(H.frameId); const u = c.frames[H.frameId]; u && void 0 === v.frames[H.frameId] && (v.frames[H.frameId] = { "function": u.name, "abs_path": "number" == typeof u.resourceId ? c.resources[u.resourceId] : void 0, "lineno": u.line, "colno": u.column }), H = void 0 === H.parentId ? void 0 : c.stacks[H.parentId] } const W = { "elapsed_since_start_ns": ((E.timestamp + U - k) * ps).toFixed(0), "stack_id": d, "thread_id": fs }; v.stacks[d] = G, v.samples[R] = W, d++ })), v }(c) : c } function createProfilePayload(c, u, d, v) { if ("transaction" !== v.type) throw new TypeError("Profiling events may only be attached to transactions, this should never occur."); if (null == d) throw new TypeError(`Cannot construct profiling event envelope without a valid profile. Got ${d} instead.`); const E = function getTraceId(c) { const u = c && c.contexts && c.contexts.trace && c.contexts.trace.trace_id; return "string" == typeof u && 32 !== u.length && vt && ue.log(`[Profiling] Invalid traceId: ${u} on profiled event`), "string" != typeof u ? "" : u }(v), k = enrichWithThreadInformation(d), R = u || ("number" == typeof v.start_timestamp ? 1e3 * v.start_timestamp : 1e3 * ge()), U = "number" == typeof v.timestamp ? 1e3 * v.timestamp : 1e3 * ge(); return { "event_id": c, "timestamp": new Date(R).toISOString(), "platform": "javascript", "version": "1", "release": v.release || "", "environment": v.environment || Oe, "runtime": { "name": "javascript", "version": bt.navigator.userAgent }, "os": { "name": ms, "version": gs, "build_number": vs }, "device": { "locale": bs, "model": ys, "manufacturer": vs, "architecture": _s, "is_emulator": !1 }, "debug_meta": { "images": applyDebugMetadata(d.resources) }, "profile": k, "transactions": [{ "name": v.transaction || "", "id": v.event_id || misc_uuid4(), "trace_id": E, "active_thread_id": fs, "relative_start_ns": "0", "relative_end_ns": (1e6 * (U - R)).toFixed(0) }] } } function isAutomatedPageLoadSpan(c) { return "pageload" === spanUtils_spanToJSON(c).op } (function isUserAgentData(c) { return "object" == typeof c && null !== c && "getHighEntropyValues" in c })(Ss) && Ss.getHighEntropyValues(["architecture", "model", "platform", "platformVersion", "fullVersionList"]).then((c => { if (ms = c.platform || "", _s = c.architecture || "", ys = c.model || "", gs = c.platformVersion || "", c.fullVersionList && c.fullVersionList.length > 0) { const u = c.fullVersionList[c.fullVersionList.length - 1]; vs = `${u.brand} ${u.version}` } })).catch((c => { })); const ws = new WeakMap; function applyDebugMetadata(c) { const u = se._sentryDebugIds; if (!u) return []; const d = currentScopes_getClient(), v = d && d.getOptions(), E = v && v.stackParser; if (!E) return []; let k; const R = ws.get(E); R ? k = R : (k = new Map, ws.set(E, k)); const U = Object.keys(u).reduce(((c, d) => { let v; const R = k.get(d); R ? v = R : (v = E(d), k.set(d, v)); for (let E = v.length - 1; E >= 0; E--) { const k = v[E], R = k && k.filename; if (k && R) { c[R] = u[d]; break } } return c }), {}), H = []; for (const u of c) u && U[u] && H.push({ "type": "sourcemap", "code_file": u, "debug_id": U[u] }); return H } let Es = !1; const Cs = 3e4; function shouldProfileSpan(c) { if (Es) return vt && ue.log("[Profiling] Profiling has been disabled for the duration of the current user session."), !1; if (!c.isRecording()) return vt && ue.log("[Profiling] Discarding profile because transaction was not sampled."), !1; const u = currentScopes_getClient(), d = u && u.getOptions(); if (!d) return vt && ue.log("[Profiling] Profiling disabled, no options found."), !1; const v = d.profilesSampleRate; if (!function isValidSampleRate(c) { return "number" != typeof c && "boolean" != typeof c || "number" == typeof c && isNaN(c) ? (vt && ue.warn(`[Profiling] Invalid sample rate. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(c)} of type ${JSON.stringify(typeof c)}.`), !1) : !0 === c || !1 === c || !(c < 0 || c > 1) || (vt && ue.warn(`[Profiling] Invalid sample rate. Sample rate must be between 0 and 1. Got ${c}.`), !1) }(v)) return vt && ue.warn("[Profiling] Discarding profile because of invalid sample rate."), !1; if (!v) return vt && ue.log("[Profiling] Discarding profile because a negative sampling decision was inherited or profileSampleRate is set to 0"), !1; return !!(!0 === v || Math.random() < v) || (vt && ue.log(`[Profiling] Discarding profile because it's not included in the random sample (sampling rate = ${Number(v)})`), !1) } function createProfilingEvent(c, u, d, v) { return function isValidProfile(c) { return c.samples.length < 2 ? (vt && ue.log("[Profiling] Discarding profile because it contains less than 2 samples"), !1) : !!c.frames.length || (vt && ue.log("[Profiling] Discarding profile because it contains no frames"), !1) }(d) ? createProfilePayload(c, u, d, v) : null } const Ts = new Map; function takeProfileFromGlobalCache(c) { const u = Ts.get(c); return u && Ts.delete(c), u } function startProfileForSpan(c) { let u; isAutomatedPageLoadSpan(c) && (u = 1e3 * ge()); const d = function startJSSelfProfile() { const c = bt.Profiler; if (!function isJSProfilerSupported(c) { return "function" == typeof c }(c)) return void (vt && ue.log("[Profiling] Profiling is not supported by this browser, Profiler interface missing on window object.")); const u = Math.floor(Cs / 10); try { return new c({ "sampleInterval": 10, "maxBufferSize": u }) } catch (c) { vt && (ue.log("[Profiling] Failed to initialize the Profiling constructor, this is likely due to a missing 'Document-Policy': 'js-profiling' header."), ue.log("[Profiling] Disabling profiling for current user session.")), Es = !0 } }(); if (!d) return; vt && ue.log(`[Profiling] started profiling span: ${spanUtils_spanToJSON(c).description}`); const v = misc_uuid4(); async function onProfileHandler() { if (c && d) return d.stop().then((u => { E && (bt.clearTimeout(E), E = void 0), vt && ue.log(`[Profiling] stopped profiling of span: ${spanUtils_spanToJSON(c).description}`), u ? function addProfileToGlobalCache(c, u) { if (Ts.set(c, u), Ts.size > 30) { const c = Ts.keys().next().value; Ts.delete(c) } }(v, u) : vt && ue.log(`[Profiling] profiler returned null profile for: ${spanUtils_spanToJSON(c).description}`, "this may indicate an overlapping span or a call to stopProfiling with a profile title that was never started") })).catch((c => { vt && ue.log("[Profiling] error while stopping profiler:", c) })) } currentScopes_getCurrentScope().setContext("profile", { "profile_id": v, "start_timestamp": u }); let E = bt.setTimeout((() => { vt && ue.log("[Profiling] max profile duration elapsed, stopping profiling for:", spanUtils_spanToJSON(c).description), onProfileHandler() }), Cs); const k = c.end.bind(c); c.end = function profilingWrappedSpanEnd() { return c ? (onProfileHandler().then((() => { k() }), (() => { k() })), c) : k() } } const browserProfilingIntegration = () => ({ "name": "BrowserProfiling", "setup"(c) { const u = getActiveSpan(), d = u && getRootSpan(u); d && isAutomatedPageLoadSpan(d) && shouldProfileSpan(d) && startProfileForSpan(d), c.on("spanStart", (c => { c === getRootSpan(c) && shouldProfileSpan(c) && startProfileForSpan(c) })), c.on("beforeEnvelope", (c => { if (!function getActiveProfilesCount() { return Ts.size }()) return; const u = function findProfiledTransactionsFromEnvelope(c) { const u = []; return forEachEnvelopeItem(c, ((c, d) => { if ("transaction" === d) for (let d = 1; d < c.length; d++) { const v = c[d]; v && v.contexts && v.contexts.profile && v.contexts.profile.profile_id && u.push(c[d]) } })), u }(c); if (!u.length) return; const d = []; for (const c of u) { const u = c && c.contexts, v = u && u.profile && u.profile.profile_id, E = u && u.profile && u.profile.start_timestamp; if ("string" != typeof v) { vt && ue.log("[Profiling] cannot find profile for a span without a profile context"); continue } if (!v) { vt && ue.log("[Profiling] cannot find profile for a span without a profile context"); continue } u && u.profile && delete u.profile; const k = takeProfileFromGlobalCache(v); if (!k) { vt && ue.log(`[Profiling] Could not retrieve profile for span: ${v}`); continue } const R = createProfilingEvent(v, E, k, c); R && d.push(R) } !function addProfilesToEnvelope(c, u) { if (!u.length) return c; for (const d of u) c[1].push([{ "type": "profile" }, d]); return c }(c, d) })) } }), xs = "sentry.source", As = "sentry.op", Is = "sentry.origin", ks = "_sentryMetrics"; function esm_metrics_metric_summary_getMetricSummaryJsonForSpan(c) { const u = c[ks]; if (!u) return; const d = {}; for (const [, [c, v]] of u) { (d[c] || (d[c] = [])).push(utils_build_esm_object_dropUndefinedKeys(v)) } return d } const Os = 0, Ps = 1; function esm_utils_spanUtils_spanTimeInputToSeconds(c) { return "number" == typeof c ? esm_utils_spanUtils_ensureTimestampInSeconds(c) : Array.isArray(c) ? c[0] + c[1] / 1e9 : c instanceof Date ? esm_utils_spanUtils_ensureTimestampInSeconds(c.getTime()) : un() } function esm_utils_spanUtils_ensureTimestampInSeconds(c) { return c > 9999999999 ? c / 1e3 : c } function build_esm_utils_spanUtils_spanToJSON(c) { if (function esm_utils_spanUtils_spanIsSentrySpan(c) { return "function" == typeof c.getSpanJSON }(c)) return c.getSpanJSON(); try { const { "spanId": u, "traceId": d } = c.spanContext(); if (function esm_utils_spanUtils_spanIsOpenTelemetrySdkTraceBaseSpan(c) { const u = c; return !!(u.attributes && u.startTime && u.name && u.endTime && u.status) }(c)) { const { "attributes": v, "startTime": E, "name": k, "endTime": R, "parentSpanId": U, "status": H } = c; return utils_build_esm_object_dropUndefinedKeys({ "span_id": u, "trace_id": d, "data": v, "description": k, "parent_span_id": U, "start_timestamp": esm_utils_spanUtils_spanTimeInputToSeconds(E), "timestamp": esm_utils_spanUtils_spanTimeInputToSeconds(R) || void 0, "status": esm_utils_spanUtils_getStatusMessage(H), "op": v[As], "origin": v[Is], "_metrics_summary": esm_metrics_metric_summary_getMetricSummaryJsonForSpan(c) }) } return { "span_id": u, "trace_id": d } } catch (c) { return {} } } function esm_utils_spanUtils_getStatusMessage(c) { if (c && c.code !== Os) return c.code === Ps ? "ok" : c.message || "unknown_error" } const Rs = "_sentryRootSpan"; function esm_utils_spanUtils_getActiveSpan() { const c = esm_asyncContext_getAsyncContextStrategy(esm_carrier_getMainCarrier()); return c.getActiveSpan ? c.getActiveSpan() : spanOnScope_getSpanForScope(esm_currentScopes_getCurrentScope()) } function instrumentVueRouter(c, u, d) { let v = !0; c.onError((c => captureException(c, { "mechanism": { "handled": !1 } }))), c.beforeEach(((c, E, k) => { const R = null == E.name && 0 === E.matched.length || void 0 === E.name && v; v && (v = !1); const U = { [Is]: "auto.navigation.vue" }; for (const u of Object.keys(c.params)) U[`params.${u}`] = c.params[u]; for (const u of Object.keys(c.query)) { const d = c.query[u]; d && (U[`query.${u}`] = d) } let H = c.path, G = "url"; if (c.name && "path" !== u.routeLabel) H = c.name.toString(), G = "custom"; else if (c.matched.length > 0) { const u = c.matched.length - 1; H = c.matched[u].path, G = "route" } if (esm_currentScopes_getCurrentScope().setTransactionName(H), u.instrumentPageLoad && R) { const c = function getActiveRootSpan() { const c = esm_utils_spanUtils_getActiveSpan(), u = c && function esm_utils_spanUtils_getRootSpan(c) { return c[Rs] || c }(c); if (!u) return; const d = build_esm_utils_spanUtils_spanToJSON(u).op; return "navigation" === d || "pageload" === d ? u : void 0 }(); if (c) { "custom" !== (build_esm_utils_spanUtils_spanToJSON(c).data || {})[xs] && (c.updateName(H), c.setAttribute(xs, G)), c.setAttributes({ ...U, [Is]: "auto.pageload.vue" }) } } u.instrumentNavigation && !R && (U[xs] = G, U[Is] = "auto.navigation.vue", d({ "name": H, "op": "navigation", "attributes": U })), k && k() })) } function browserTracingIntegration_browserTracingIntegration(c = {}) { if (!c.router) return browserTracingIntegration(c); const u = browserTracingIntegration({ ...c, "instrumentNavigation": !1 }), { "router": d, "instrumentNavigation": v = !0, "instrumentPageLoad": E = !0, "routeLabel": k = "name" } = c; return { ...u, "afterAllSetup"(c) { u.afterAllSetup(c); instrumentVueRouter(d, { "routeLabel": k, "instrumentNavigation": v, "instrumentPageLoad": E }, (u => { startBrowserTracingNavigationSpan(c, u) })) } } } let Ms = null, Ns = "test"; try { Ms = `h5_${process.env.VERSION}` } catch (c) { } try { Ns = "production" } catch (c) { } const Ds = { "release": Ms, "environment": Ns, "tracesSampleRate": 1, "replaysSessionSampleRate": .1, "replaysOnErrorSampleRate": 1, "tracePropagationTargets": location?.host ? ["localhost", "127.0.0.1", location.host] : ["localhost", "127.0.0.1"] }; var $s = { "init": function web_esm_init(c) { sdk_init({ ...Ds, ...c }) }, "captureException": function web_esm_captureException(c) { captureException(c) }, "ext": v }, Ls = d(4809), Fs = d(2233); new Error, re.Y.on("nav.detail", (function (c) { var u = c.detailId, d = c.type; 2 === Number(d) ? window.location.href = "/wap/textDetail?detailId=".concat(u) : E.ZP.redirectTo({ "url": "/pages/detail/index?detailId=".concat(u) }) })), console.log("---build test taro----"); var js = (0, G.ri)({ "onLaunch": function onLaunch(c) { this.trackManagerInit(c), this.initOpenId() }, "onError": function onError(c) { $s.captureException(c) }, "onShow": function onShow(c) { var u = this; this.fetchUserInfo(c), ne.Z.checkLoginState({ "successFun": function successFun(c) { var d = c.userId; d && ee.Z.judgeNewUser({ "userId": d }).then((function (c) { 1 === c.code && c.data && u.$bus.emit("showGlobalToast", "我们给你准备了30免费积分，快来试试AI工具吧") })) } }) }, "onPageNotFound": function onPageNotFound(c) { var u = c.path, d = c.query, v = "/wap"; u !== "".concat(v, "/search") && u !== "".concat(v, "/home") && u !== "".concat(v, "/detail") || !d.detailId ? u === "".concat(v, "/mylike") || u === "".concat(v, "/history") || u === "".concat(v, "/workbench") ? E.ZP.redirectTo({ "url": "/pages/mySpace/index" }) : u === "".concat(v, "/generate/byEliminateImg") || u === "".concat(v, "/generate/byCutoutImg") || u === "".concat(v, "/generate/byExtendImg") ? E.ZP.redirectTo({ "url": "/pages/aiDraw/index" }) : (console.warn("Page Not Found:", u), E.ZP.redirectTo({ "url": "/pages/home/index" })) : this.$bus.emit("nav.detail", { "detailId": d.detailId, "type": d.type }) }, "computed": (0, H.Z)({}, (0, K.rn)("base", ["isLogin", "userInfo"])), "watch": { "isLogin": { "immediate": !0, "handler": function handler(c) { var u, d = this; this.getUserPoint(), Q.Z.getMemberDetail({ "userId": null === (u = this.userInfo) || void 0 === u ? void 0 : u.userId }).then((function (c) { var u, v, E, k, R; 1 === c.code ? c.data && d.updateMemberInfo({ "memberLevel": null === (u = c.data) || void 0 === u ? void 0 : u.memberLevel, "memberInfo": (0, H.Z)((0, H.Z)((0, H.Z)({}, null === (v = c.data) || void 0 === v ? void 0 : v.memberInfo), null === (E = c.data) || void 0 === E ? void 0 : E.bpInfo), {}, { "memberName": null === (k = c.data) || void 0 === k ? void 0 : k.memberName, "right": null === (R = c.data) || void 0 === R ? void 0 : R.right }) }) : console.error("member info error", c) })), c && this.handleInterval(), console.log("call handleTrailInterval in app"), !c && this.handleTrailInterval(); var v = te.Z.getItem("trailList"); c && (null == v ? void 0 : v.length) > 0 && (console.log(v, "trailList"), this.mergeArt(v)) } } }, "methods": (0, H.Z)((0, H.Z)((0, H.Z)((0, H.Z)((0, H.Z)({}, (0, K.OI)("base", ["updateMemberInfo"])), (0, K.nv)("base", ["getUserPoint", "mergeArt"])), (0, K.nv)("artDetail", ["intervalMsg", "handleInterval"])), (0, K.nv)("trailDetail", ["handleTrailInterval"])), {}, { "trackManagerInit": function trackManagerInit(c) { var u = J.Z.spmA; u += "-dev", W.dK.setupConfigration({ "appId": J.Z.appId, "appName": J.Z.appName, "appVersion": J.Z.appVersion, "spmA": u, "api": J.Z.api, "ext": { "scene": c.scene }, "requestOptions": J.Z.requestOptions, "isWeb": !0 }) }, "initOpenId": function initOpenId() { var c = function getSuv() { var c = new RegExp("\\bSUV=([^;]*)\\b").exec(document.cookie); return c ? decodeURIComponent(c[1]) : null }() || function initSuv() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "sohu.com"; if (0 > document.cookie.indexOf("SUV=")) { var u = (new Date).getTime() + "ce" + Math.random().toString(36).substring(2, 6); document.cookie = "SUV=" + u + ";path=/;domain=" + c } }(); (0, Z.Fj)("userId", c) }, "fetchUserInfo": function fetchUserInfo(c) { }, "getAppletOpenId": function getAppletOpenId() { (0, Y.x4)({ "success": function success(c) { c.code && (console.log("code", c.code), ee.Z.getUserOpenId({ "code": c.code, "spma": J.Z.spmA }).then((function (c) { c && ((0, Z.Fj)("userId", c), console.log("openId", (0, Z.qu)("userId"))) })).catch((function (c) { console.log("error", c) }))) } }) }, "ttTokenMock": function ttTokenMock() { 0 } }) }); js.config.globalProperties.$bus = re.Y, js.config.globalProperties.localStorage = te.Z, js.use(E.ZP.setGlobalDataPlugin, { "globalData": {} }), js.use(X.Z), $s.init({ "app": js, "dsn": oe.c$, "release": "h5_202412171133", "enabled": !0 }), function requestIntercept() { var c = Ls.WY; E.ZP.request = function (u) { var d = u.success; u.url, u.data; c.apply(E.ZP, [(0, H.Z)((0, H.Z)({}, u), {}, { "success": function successCallback(c) { d(c) } })]) } }(), function uploadIntercept() { var c = Fs.c; E.ZP.uploadFile = function (u) { var d = u.success, v = u.fail, k = (u.url, u.header); c.apply(E.ZP, [(0, H.Z)((0, H.Z)({}, u), {}, { "success": function successCallback(c) { console.log("upload success, requestId:", k.requestId), d(c) }, "fail": function failCallback(c) { console.log("upload fail, requestId:", k.requestId), v(c) } })]) } }(); var Bs = js, Us = d(1576), Hs = d(2726), zs = d(6252), qs = d(8948), Gs = d(2778), Vs = d(4588), Ws = { "router": { "mode": "browser", "basename": "/wap", "customRoutes": { "/pages/detail/index": "/detail", "/pages/textDetail/index": "/textDetail", "/pages/mySpace/index": "/mySpace", "/pages/home/index": ["/home"], "/pages/textHome/index": "/textHome", "/pages/memberDetail/index": ["/memberDetail", "/paySuccess/memberDetail"], "/pages/aiDraw/index": "/imageCreative", "/pages/404/index": "/error", "/pages/generate/index": "/generate", "/pages/imgGenerate/byCardImg/index": "/generate/byCardImg", "/pages/imgGenerate/byClearImg/index": "/generate/byClearImg", "/pages/imgGenerate/byPersonBgImg/index": "/generate/byPersonBgImg", "/pages/imgGenerate/byProImg/index": "/generate/byProImg", "/pages/imgGenerate/imgToImg/index": "/generate/imgToImg", "/pages/imgGenerate/textToImg/index": "/generate/textToImg", "/pages/textGenerate/index": "/textGenerate", "/pages/festivalCard/index": "/festivalCard", "/pages/textResult/index": "/textResult", "/pages/editor/index": "/editor", "/pages/payIntermediate/index": "/payIntermediate", "/pages/orderSuccess/index": "/orderSuccess" } }, "pages": ["pages/home/index", "pages/textHome/index", "pages/mySpace/index", "pages/mySpace/setting", "pages/webview/index", "pages/login/index", "pages/share/index", "pages/saveImg/index", "pages/festivalCard/index", "pages/detail/index", "pages/textDetail/index", "pages/404/index", "pages/mySpace/points", "pages/mySpace/pointsDetail", "pages/memberRule/index", "pages/imgLoading/index", "pages/aiDraw/index", "pages/payIntermediate/index", "pages/orderSuccess/index", "pages/imgGenerate/byCardImg/index", "pages/imgGenerate/byClearImg/index", "pages/imgGenerate/byPersonBgImg/index", "pages/imgGenerate/byProImg/index", "pages/imgGenerate/imgToImg/index", "pages/imgGenerate/textToImg/index", "pages/generate/index", "pages/textGenerate/index", "pages/textResult/index", "pages/memberDetail/index"], "subPackages": [{ "root": "pages/imgGenerate", "pages": ["byCardImg/index", "byClearImg/index", "byPersonBgImg/index", "byProImg/index", "imgToImg/index", "textToImg/index"] }, { "root": "pages/generate", "pages": ["index"] }, { "root": "pages/textGenerate", "pages": ["index"] }, { "root": "pages/textResult", "pages": ["index"] }, { "root": "pages/memberDetail", "pages": ["index"] }], "tabBar": { "custom": !0, "color": "#000000", "selectedColor": "#000000", "backgroundColor": "#000000", "list": [{ "pagePath": "pages/home/index", "text": "主页" }, { "pagePath": "pages/textHome/index", "text": "AI助手" }, { "pagePath": "pages/mySpace/index", "text": "我的" }, { "pagePath": "pages/aiDraw/index", "text": "AI生图" }] }, "window": { "navigationBarTextStyle": "white", "navigationBarTitleText": "简单AI", "navigationBarBackgroundColor": "#141416", "backgroundColor": "#141416" }, "networkTimeout": { "request": 16e3 } }; Us.u9.__taroAppConfig = Ws; var Zs = [], Ys = []; if (Ws.tabBar) for (var Js = Ws.tabBar.list, Ks = 0; Ks < Js.length; Ks++) { var Xs = Js[Ks]; Xs.iconPath && (Xs.iconPath = Zs[Ks]), Xs.selectedIconPath && (Xs.selectedIconPath = Ys[Ks]) } Ws.routes = [Object.assign({ "path": "pages/home/index", "load": function load(c, u) { return [d.e(953).then(d.bind(d, 7953)), c, u] } }, { "navigationBarTitleText": "简单 AI", "onReachBottomDistance": 30 }), Object.assign({ "path": "pages/textHome/index", "load": function load(c, u) { return [d.e(650).then(d.bind(d, 9650)), c, u] } }, { "navigationBarTitleText": "AI助手", "onReachBottomDistance": 30 }), Object.assign({ "path": "pages/mySpace/index", "load": function load(c, u) { return [d.e(328).then(d.bind(d, 4328)), c, u] } }, { "navigationBarTitleText": "我的", "onReachBottomDistance": 30 }), Object.assign({ "path": "pages/mySpace/setting", "load": function load(c, u) { return [d.e(311).then(d.bind(d, 8311)), c, u] } }, { "navigationBarTitleText": "设置" }), Object.assign({ "path": "pages/webview/index", "load": function load(c, u) { return [d.e(157).then(d.bind(d, 157)), c, u] } }, {}), Object.assign({ "path": "pages/login/index", "load": function load(c, u) { return [d.e(929).then(d.bind(d, 2929)), c, u] } }, { "navigationBarTitleText": "登录" }), Object.assign({ "path": "pages/share/index", "load": function load(c, u) { return [d.e(24).then(d.bind(d, 5024)), c, u] } }, { "navigationBarTitleText": "电子贺卡", "navigationBarTextStyle": "black", "navigationBarBackgroundColor": "#FFFFFF", "backgroundColor": "#FFF0DE" }), Object.assign({ "path": "pages/saveImg/index", "load": function load(c, u) { return [d.e(681).then(d.bind(d, 2681)), c, u] } }, { "navigationBarTitleText": "下载图片" }), Object.assign({ "path": "pages/festivalCard/index", "load": function load(c, u) { return [d.e(347).then(d.bind(d, 2347)), c, u] } }, { "navigationBarTitleText": "海报合成", "navigationBarTextStyle": "black", "navigationBarBackgroundColor": "#FFFFFF", "backgroundColor": "#FFF0DE" }), Object.assign({ "path": "pages/detail/index", "load": function load(c, u) { return [d.e(475).then(d.bind(d, 9475)), c, u] } }, { "navigationBarTitleText": "作品详情", "onReachBottomDistance": 30 }), Object.assign({ "path": "pages/textDetail/index", "load": function load(c, u) { return [d.e(333).then(d.bind(d, 143)), c, u] } }, { "navigationBarTitleText": "作品详情", "onReachBottomDistance": 30 }), Object.assign({ "path": "pages/404/index", "load": function load(c, u) { return [d.e(443).then(d.bind(d, 443)), c, u] } }, { "navigationBarTitleText": "出错啦", "onReachBottomDistance": 30 }), Object.assign({ "path": "pages/mySpace/points", "load": function load(c, u) { return [d.e(371).then(d.bind(d, 4371)), c, u] } }, { "navigationBarTitleText": "积分规则" }), Object.assign({ "path": "pages/mySpace/pointsDetail", "load": function load(c, u) { return [d.e(813).then(d.bind(d, 4813)), c, u] } }, { "navigationBarTitleText": "积分明细" }), Object.assign({ "path": "pages/memberRule/index", "load": function load(c, u) { return [d.e(741).then(d.bind(d, 741)), c, u] } }, {}), Object.assign({ "path": "pages/imgLoading/index", "load": function load(c, u) { return [d.e(833).then(d.bind(d, 3833)), c, u] } }, { "navigationBarTitleText": "作品生成" }), Object.assign({ "path": "pages/aiDraw/index", "load": function load(c, u) { return [d.e(518).then(d.bind(d, 8518)), c, u] } }, { "navigationStyle": "custom", "navigationBarTitleText": "简单AI" }), Object.assign({ "path": "pages/payIntermediate/index", "load": function load(c, u) { return [d.e(39).then(d.bind(d, 6039)), c, u] } }, {}), Object.assign({ "path": "pages/orderSuccess/index", "load": function load(c, u) { return [d.e(866).then(d.bind(d, 7866)), c, u] } }, {}), Object.assign({ "path": "pages/imgGenerate/byCardImg/index", "load": function load(c, u) { return [d.e(573).then(d.bind(d, 6573)), c, u] } }, { "navigationBarTitleText": "AI创作", "onReachBottomDistance": 30 }), Object.assign({ "path": "pages/imgGenerate/byClearImg/index", "load": function load(c, u) { return [d.e(267).then(d.bind(d, 9267)), c, u] } }, { "navigationBarTitleText": "AI创作", "onReachBottomDistance": 30 }), Object.assign({ "path": "pages/imgGenerate/byPersonBgImg/index", "load": function load(c, u) { return [d.e(583).then(d.bind(d, 583)), c, u] } }, { "navigationBarTitleText": "AI创作", "onReachBottomDistance": 30 }), Object.assign({ "path": "pages/imgGenerate/byProImg/index", "load": function load(c, u) { return [d.e(224).then(d.bind(d, 5224)), c, u] } }, { "navigationBarTitleText": "AI创作", "onReachBottomDistance": 30 }), Object.assign({ "path": "pages/imgGenerate/imgToImg/index", "load": function load(c, u) { return [d.e(491).then(d.bind(d, 1491)), c, u] } }, { "navigationBarTitleText": "AI创作", "onReachBottomDistance": 30 }), Object.assign({ "path": "pages/imgGenerate/textToImg/index", "load": function load(c, u) { return [d.e(983).then(d.bind(d, 7983)), c, u] } }, { "navigationBarTitleText": "AI创作", "onReachBottomDistance": 30 }), Object.assign({ "path": "pages/generate/index", "load": function load(c, u) { return [d.e(616).then(d.bind(d, 1616)), c, u] } }, { "navigationBarTitleText": "AI创作", "onReachBottomDistance": 30 }), Object.assign({ "path": "pages/textGenerate/index", "load": function load(c, u) { return [d.e(512).then(d.bind(d, 9512)), c, u] } }, {}), Object.assign({ "path": "pages/textResult/index", "load": function load(c, u) { return [d.e(242).then(d.bind(d, 9242)), c, u] } }, {}), Object.assign({ "path": "pages/memberDetail/index", "load": function load(c, u) { return [d.e(318).then(d.bind(d, 7318)), c, u] } }, { "navigationBarTitleText": "购买会员" })], (0, qs.M)(), (0, Gs.K)(Bs, Vs); var Qs = (0, Hs.rj)(Bs, zs.h, Ws), ec = (0, k.lX)({ "window": Us.u9 }); (0, R.Nf)(Ws, ec), (0, U.p)(ec, Qs, Ws, zs.h), (0, E.J1)({ "designWidth": 375, "deviceRatio": { "375": 2, "640": 1.17, "750": 1, "828": .905 }, "baseFontSize": 20, "unitPrecision": void 0, "targetUnit": void 0 }) }, "606": function (c, u, d) { "use strict"; d.d(u, { "OB": function () { return v }, "a9": function () { return R }, "c$": function () { return U }, "uN": function () { return E } }); var v = "test", E = { "appId": "100023", "appName": "h5-简单ai", "spmA": "smwp-ai", "appVersion": "1.0.4" }, k = { "test": { "type": "h5", "appId": "100023", "loginSide": 1, "openKey": "", "platform": "h5", "loginUrl": "https://tst.passport.sohu.com/sapi/login/applet/mlogin", "passportUrl": "https://tst.passport.sohu.com/sapi/g", "passport": { "appid": "116019", "appKey": "IS6589C543EQN8wCZ", "vs": "1.0.0" }, "accessTokenName": "access_token", "refreshAccessTokenName": "refresh_token", "baseInfoUrl": "https://test-uis.mp.sohu.com/v3/uc", "uploadImageUrl": "https://test-uis.mp.sohu.com/api/vpd/file/imgUpload", "getUserInfoUrl": "https://test-uis.mp.sohu.com/v3/uc/login/", "collectUrl": "https://test-uis.mp.sohu.com/v3/collect" }, "development": { "type": "h5", "appId": "100023", "loginSide": 1, "openKey": "", "platform": "h5", "loginUrl": "https://tst.passport.sohu.com/sapi/login/applet/mlogin", "passportUrl": "https://tst.passport.sohu.com/sapi/g", "passport": { "appid": "116019", "appKey": "IS6589C543EQN8wCZ", "vs": "1.0.0" }, "accessTokenName": "access_token", "refreshAccessTokenName": "refresh_token", "baseInfoUrl": "https://test-uis.mp.sohu.com/v3/uc", "uploadImageUrl": "https://test-uis.mp.sohu.com/api/vpd/file/imgUpload", "getUserInfoUrl": "https://test-uis.mp.sohu.com/v3/uc/login/", "collectUrl": "https://test-uis.mp.sohu.com/v3/collect" }, "production": { "type": "h5", "appId": "100023", "loginSide": 1, "form": "smwp-ai", "openKey": "", "platform": "h5", "loginUrl": "https://api.passport.sohu.com/sapi/login/applet/mlogin", "passportUrl": "https://api.passport.sohu.com/sapi/g", "collectUrl": "https://uis.mp.sohu.com/v3/collect", "passport": { "appid": "116019", "testAppKey": "IS6589C543EQN8wCZ", "appKey": "dy2053qL79wQsY1u4e2740733b1G4lJ10VczNjSLJ9y96iKf7F", "vs": "1.0.0" }, "accessTokenName": "access_token", "refreshAccessTokenName": "refresh_token", "lastCreateAtName": "lastCreateAt", "uploadImageUrl": "https://uis.mp.sohu.com/api/vpd/file/imgUpload", "baseInfoUrl": "https://uis.mp.sohu.com/v3/uc", "getUserInfoUrl": "https://uis.mp.sohu.com/v3/uc/login/" } }, R = k[v] || k.production, U = "https://01a427818e2a04d47fbe92e988acad59@sentry.mp.sohu.com/39" }, "5429": function (c, u, d) { "use strict"; d.d(u, { "n": function () { return v }, "o": function () { return E } }); var v = "smwp-ai", E = { "UPLOADCLICK": "10327", "USERCLICK": "10328", "SEARCHINPUTCLICK": "10329", "SEARCHENTER": "10330", "HOTWORDCLICK": "10331", "SORTCLICK": "10332", "LIKECLICK": "10333", "SAMESEARCHCLICK": "10334", "COPYLINKCLICK": "10335", "COPYPROMPTCLICK": "10336", "DOWNLOADCLICK": "10337", "TOOLCHOOSE": "10339", "PUBLISHSUCCESS": "10340", "SAVESUCCESS": "10341", "HOMESHOW": "10363", "LIKESHOW": "10364", "HISTORYSHOW": "10365", "WORKSHOW": "10366", "DETAILSHOW": "10367", "LOGINSUCCESS": "10342", "SENDCOMMENTCLICK": "10439", "COMMENTSUCCESS": "10338", "GENERATE_SUCCESS": "10496", "GENERATE_ERROR": "10559", "USE_POINT": "10588", "USE_ORIGIN_SIZE": "10538", "GENERATE_MSG_SUCCESS": "10665", "GENERATE_MSG_ERROR": "10667", "GENERATE_MSG_TIMEOUT": "10669", "GENERATE_SAME": "10535", "CARDSAVECLICK": "10739", "CARDSHARECLICK": "10740", "USERGETPOINTS": "10587", "JUMPTOPOINTSPAGE": "10642", "CLICKGENERATESAME": "10494", "USERCHANGETAB": "10610", "CLICKGENERATERPIC": "10530", "CLICKGENERATETRAILPIC": "10957", "CLICK_PROMOT": "10640", "CLICK_UPLOAD_EXAMPLE": "10838", "CLICK_UPLOAD_IMAGE": "10537", "CLICK_GENTERATE_IMAGE_ERROR_PROMOT": "10536", "ZERO_POINTS_EXPLOURE_DIALOG": "10641", "CLICK_GET_POINTS": "10582", "CLICK_DOWNLOAD_PIC": "10500", "SWIPER_LEFT_RIGHT": "10639", "SHOW_PIC_PREVIEW": "10634", "DELETE_PIC": "10498", "PICTURE_PUBLIC": "10532", "EXCHANGE_PICTURE": "10635", "CLICK_FILL_BACK": "10636", "CLICK_CREATE": "10637", "CLICK_MY_WORK": "10638", "CLICK_FILTER_TAB": "10633", "CLICK_TEXT_HOME_FILTER_TAB": "10711", "CLICK_SUBMIT_ADVICE": "10713", "CLICK_OPEN_PRIVATE": "10643", "CLIKC_OPEN_SERVICE": "10824", "CLICK_LOG_OUT": "10644", "CLICK_TAKE_PICTURE_EXAMPLE": "10832", "CREATE_Commodity_Portrait_SUCCESS": "10816", "POINTS_DETAIL_NETWORK_FAILD": "10805", "MEMBER_PAGE_EXPLORE": "10784", "MEMBER_PAGE_OPEN_MEMBER": "10785", "MEMBER_PAGE_RENEWAL_MEMBER": "10786", "MEMBER_PAGE_PAY_DIFFERENCE": "10789", "MEMBER_PAGE_OPEN_ERROR": "10787", "RENEWAL_DETAIL_CLICK": "10788", "UPGRADE_DETAIL_CLICK": "10790", "MEMBER_PAGE_LOGIN": "11007", "CLICK_CHANGE_MEMBER_COMMODITY": "11008", "CLICK_OPEN_MEMBER": "11009", "SHOW_DAILOG_OPEN_SUCCESS": "11010", "SHOW_DIALOG_PAY_FAIL": "11011", "CLICK_CONTRACT_TERM": "11015", "CLICK_SAVE_SIGNSTATUS": "11016", "CLICK_UNSAVE_SIGNSTATUS": "11017", "CLICK_UPLOAD_FADEBACK": "11018", "CLICK_GOWEB_SIGNSTATUS": "11019", "CLICK_GOWEB_OPENMEMBER": "11020", "MEMBER_OPEN_RENEWAL": "10783", "TEXT_RESULT_LIKE": "10719", "TEXT_RESULT_DISLIKE": "10722", "BACK_TOP": "10767", "NON_MEMBER_TEXT_IMAGE": 10791, "NON_MEMBER_POPUP_CLICK": 10792, "EXPRESS_LANE_ACCELERATE": 10793, "RENEWAL_CLICK_RENEW": 10795, "NON_MEMBER_QUEUE_IMAGE_POPUP": 10796, "NON_MEMBER_QUEUE_LIMITED_CLICK": 10797, "NON_MEMBER_TEMPLATE_INTRODUCTION": 10798, "MEMBER_IMAGE_SHORTAGE_POPUP": 10799, "MEMBER_LOW_TIER_SHORTAGE_UPGRADE": 10800, "DIAMOND_MEMBER_MAX_8_IMAGE_TOAST": 10801, "HOME_PAGE_SHOW": 10831, "DOWNLOAD_POSTER": 10739, "SHARE_POSTER": 10740, "TEMPLATE_NAV_CHANGE": 10750, "SHOW_STOP_GENERATE": 10820, "CLICK_STOP_GENERATE": 10821, "SHOW_HD_DOWNLOAD_ALERT": 10962, "HD_JUMP_MEMBER": 10963, "HD_DOWNLOAD_SUCCESS": 10964, "HD_DOWNLOAD_ALERT_CLOSE": 10965 } }, "7567": function (c, u, d) { "use strict"; var v = d(3363), E = d(7853), k = { "getArtDetailBatch": function getArtDetailBatch() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return v.Z.get({ "url": "".concat(E.Jl, "/home/art/batch/query"), "data": c, "isRaw": !0 }) }, "getArtDetail": function getArtDetail() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return v.Z.get({ "url": "".concat(E.Jl, "/home/art/detail/query"), "data": c, "isRaw": !0 }) }, "likeArt": function likeArt() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return v.Z.post({ "url": "".concat(E.Jl, "/like/art"), "data": c, "isRaw": !0 }) }, "manageArt": function manageArt() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return v.Z.get({ "url": "".concat(E.Jl, "/home/art/manage"), "data": c, "isRaw": !0 }) }, "getLoadingTip": function getLoadingTip() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return v.Z.get({ "url": "".concat(E.Jl, "/member/pic/produce/loading"), "data": c, "isRaw": !0 }) }, "stopGenerate": function stopGenerate() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return v.Z.post({ "url": "".concat(E.Jl, "/home/art/ai/produce/stop"), "data": c, "isRaw": !0 }) }, "getHighResPicUrl": function getHighResPicUrl() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return v.Z.post({ "url": "".concat(E.Jl, "/member/download/art/pic"), "data": c, "isRaw": !0 }) }, "checkFirstDownloadHD": function checkFirstDownloadHD() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return v.Z.post({ "url": "".concat(E.Jl, "/member/download/art/pic/status"), "data": c }) } }; u.Z = k }, "2264": function (c, u, d) { "use strict"; var v = d(3363), E = d(238), k = d(7853), R = d(7503), U = d(5660), H = E.Z.CancelToken, G = H.source(), W = { "getSmartDetail": function getSmartDetail() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return v.Z.get({ "url": "".concat(k.Jl, "/home/art/ai/smart/paragraph/detail"), "data": c, "isRaw": !0 }) }, "getSmartDetailByUUid": function getSmartDetailByUUid() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return v.Z.get({ "url": "".concat(k.Jl, "/mpcard/info"), "data": c, "isRaw": !0 }) }, "getImgInfo": function getImgInfo() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return v.Z.get({ "url": "".concat(k.Jl, "/activity/card/create/edit/config"), "data": c, "isRaw": !0 }) }, "generateText": function generateText() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, u = (0, R.xu)(); return U.Z.setItem("text_startTime", { "time": (new Date).getTime(), "requestId": u }), v.Z.post({ "url": "".concat(k.Jl, "/home/art/ai/text/produce/v2"), "headers": { "timeout": 26e3, "requestId": u }, "data": c, "cancelToken": G.token, "isRaw": !0 }) }, "generateTrailText": function generateTrailText() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, u = (0, R.xu)(); return U.Z.setItem("text_startTime", { "time": (new Date).getTime(), "requestId": u }), v.Z.post({ "url": "".concat(k.Jl, "/tourist/art/text/produce"), "headers": { "timeout": 26e3 }, "data": c, "cancelToken": G.token, "isRaw": !0 }) }, "cancelGenerate": function cancelGenerate() { G.cancel("用户离开页面，取消请求"), G = H.source() }, "isCancel": function isCancel(c) { return E.Z.isCancel(c) }, "publishArt": function publishArt() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return v.Z.post({ "url": "".concat(k.Jl, "/home/art/publish/v2"), "data": c, "isRaw": !0 }) }, "getGuideInfo": function getGuideInfo() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return v.Z.get({ "url": "".concat(k.Jl, "/wap/art/ai/guide"), "data": c, "isRaw": !0 }) }, "getEditorText": function getEditorText() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return v.Z.get({ "url": "".concat(k.Jl, "/home/art/ai/user/paragraph"), "data": c, "isRaw": !0 }) }, "updateEditorText": function updateEditorText() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return v.Z.post({ "url": "".concat(k.Jl, "/home/art/ai/update/user/paragraph"), "data": c, "isRaw": !0 }) }, "genMaterialBg": function genMaterialBg() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return v.Z.post({ "url": "".concat(k.Jl, "/activity/card/pic/produce"), "data": c, "headers": { "timeout": 26e3 }, "isRaw": !0 }) }, "getDefinitivePreview": function getDefinitivePreview() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return v.Z.post({ "url": "".concat(k.Jl, "/image/art/hd"), "data": c, "isRaw": !0 }) } }; u.Z = W }, "6908": function (c, u, d) { "use strict"; var v = d(7853), E = d(3363), k = { "getMemberDetail": function getMemberDetail() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return E.Z.get({ "url": "".concat(v.Jl, "/member/detail"), "data": c, "isRaw": !0 }) }, "getMemberCommodity": function getMemberCommodity() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return E.Z.get({ "url": "".concat(v.Jl, "/member/commodity/info?selectedPrice=1"), "data": c, "isRaw": !0 }) }, "getServiceQrcode": function getServiceQrcode() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return E.Z.get({ "url": "".concat(v.Jl, "/member/custom/service/qrcode"), "data": c }) }, "getMemberRule": function getMemberRule(c) { return E.Z.get({ "url": c, "data": {}, "customHeaders": {}, "isRaw": !0 }) }, "getAISign": function getAISign() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return E.Z.get({ "url": "".concat(v.Jl, "/member/access/sig"), "data": c }) }, "getOrderStatus": function getOrderStatus() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return E.Z.get({ "url": "".concat(v.Jl, "/member/order"), "data": c }) }, "getPayIntermediateUrl": function getPayIntermediateUrl() { var c, u = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return E.Z.post({ "url": "".concat(v.Jl, "/member/open/redirect/page?userId=").concat(u.userId), "data": u, "headers": { "payQRCodeVersion": u.payQRCodeVersion, "openId": null !== (c = u.openId) && void 0 !== c ? c : "" }, "isRaw": !0 }) }, "contractTerm": function contractTerm() { return E.Z.post({ "url": "".concat(v.Jl, "/member/terminate/contract"), "isRaw": !0 }) }, "getCurrentCommodityInfo": function getCurrentCommodityInfo() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return E.Z.get({ "url": "".concat(v.Jl, "/member/commodity/current"), "data": c, "isRaw": !0 }) } }; u.Z = k }, "6878": function (c, u, d) { "use strict"; var v = d(1413), E = d(3363), k = d(7853), R = d(5429), U = d(4809), H = d(3096), G = { "updateGenSamePoint": function updateGenSamePoint() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return E.Z.get({ "url": "".concat(k.Jl, "/home/art/ai/score/add"), "data": c }) }, "getPointFailTips": function getPointFailTips() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return E.Z.get({ "url": "".concat(k.Jl, "/wap/art/fail/tips"), "data": c, "isRaw": !0 }) }, "getUserPoint": function getUserPoint() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return E.Z.get({ "url": "".concat(k.Jl, "/personal/art/ai/score/query"), "data": c, "isRaw": !0 }) }, "getUserPointDetail": function getUserPointDetail() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return E.Z.get({ "url": "".concat(k.Jl, "/personal/art/ai/score/record/query"), "data": c, "isRaw": !0 }) }, "openMember": function openMember() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, u = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, d = (0, v.Z)((0, v.Z)({}, (0, E.U)()), u); return E.Z.post({ "url": "".concat(k.Jl, "/member/open"), "data": c, "isRaw": !0, "headers": d }) }, "miniProgramPayClick": function miniProgramPayClick(c, u) { var d = this; this.getOpenId((function (v) { v ? d.doPaymentWithOpenId(c, v, u) : u && u(!1) })) }, "getOpenId": function getOpenId(c) { (0, H.x4)({ "success": function success(u) { u.code ? function login(u) { var d = { "spma": R.n, "code": u }; (0, U.WY)({ "url": "".concat(k.Sz, "/v3/uc/user/openId"), "data": d, "success": function success(u) { 1 === u.data.code ? c && c(u.data.data) : c && c(null) }, "fail": function fail(u) { console.log("openId request failed", u), c && c(null) } }) }(u.code) : c && c(null) }, "fail": function fail(u) { console.log("Login request failed", u), c && c(null) } }) }, "getWxOpenId": function getWxOpenId() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return E.Z.get({ "url": "//us.mp.sohu.com/auth/wx/offiaccount/openid", "data": c, "isRaw": !0 }) }, "doPaymentWithOpenId": function doPaymentWithOpenId(c, u, d) { var v = { "memberId": c.memberId, "callBackAddress": "callBackAddress", "payType": 2, "buttonStatus": c.buttonStatus }; this.openMember(v, { "clientType": 2, "openId": u, "aiSig": c.aiSig }).then((function (c) { if (console.log("open memenber success", c), 1 !== c.code) d && d(c.code); else { tt.requestOrder({ "data": c.data.data, "byteAuthorization": c.data.byteAuthorization, "success": function success(c) { var u = c.orderId; tt.getOrderPayment({ "orderId": u, "success": function success() { d && d(!0) }, "fail": function fail(c) { console.log("订单支付失败", c), d && d(!1) } }) }, "fail": function fail(c) { console.log("订单支付失败", c), d && d(!1) } }) } })).catch((function () { d && d(!1) })) } }; u.Z = G }, "9477": function (c, u, d) { "use strict"; var v = d(3363), E = d(7853), k = d(1724), R = d(2233), U = d(238), H = d(7503), G = { "uploadImg": function uploadImg(c) { var u = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { "isBWM": !0 }, d = "?"; for (var v in u) null !== u[v] && void 0 !== u[v] && (d += "".concat(v, "=").concat(u[v], "&")); return d = d.slice(0, d.length - 1), U.Z.post("".concat(E.Jl, "/image/art/upload/image").concat(d), c, { "headers": { "Content-Type": "multipart/form-data", "authorization": (0, k.qu)("access_token"), "requestId": (0, H.xu)() }, "withCredentials": !0, "timeout": 15e3 }) }, "uploadPoster": function uploadPoster(c) { var u = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { "isBWM": !0 }; return v.Z.post({ "url": "".concat(E.Jl, "/image/art/upload/image/1?isBWM=").concat(u.isBWM, "&picProcessType=").concat(u.picProcessType, "&isFaceDetect=").concat(u.isFaceDetect), "data": c, "headers": { "timeout": 15e3 }, "customHeaders": { "authorization": (0, k.qu)("access_token") }, "isRaw": !0 }) }, "uploadMiniImg": function uploadMiniImg(c) { var u = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { "isBWM": !0 }, d = "?"; for (var v in u) null !== u[v] && void 0 !== u[v] && (d += "".concat(v, "=").concat(u[v], "&")); return d = d.slice(0, d.length - 1), new Promise((function (u) { (0, R.c)({ "url": "".concat(E.Jl, "/image/art/upload/image").concat(d), "filePath": c, "timeout": 15e3, "header": { "Authorization": (0, k.qu)("access_token"), "content-type": "multipart/form-data", "openId": (0, k.qu)("userId"), "requestId": (0, H.xu)() }, "name": "imgFile", "success": function success(c) { c.data && "string" == typeof c.data && (c.data = JSON.parse(c.data)), u(c) }, "fail": function fail(c) { console.log(c), u({ "data": null, "code": -1 }) } }) })) }, "checkImageRule": function checkImageRule() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return v.Z.post({ "url": "".concat(E.Jl, "/home/art/check/image/sensitive"), "data": c, "isRaw": !0 }) }, "publishPrompt": function publishPrompt() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return v.Z.post({ "url": "".concat(E.Jl, "/home/art/publish"), "data": c, "isRaw": !0 }) }, "fetchPlatformList": function fetchPlatformList() { return v.Z.get({ "url": "".concat(E.Jl, "/home/art/platform/query"), "isRaw": !0 }) }, "fetchModelList": function fetchModelList() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return v.Z.get({ "url": "".concat(E.Jl, "/home/art/template/v2/list/query"), "data": c, "isRaw": !0 }) }, "fetchHomeCatalogList": function fetchHomeCatalogList() { return v.Z.get({ "url": "".concat(E.Jl, "/home/art/catalog/list/query"), "isRaw": !0 }) }, "generateImgs": function generateImgs() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, u = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; return v.Z.post({ "url": "".concat(E.Jl, "/home/art/ai/produce?picGroupId=").concat(u.requestId), "data": c, "headers": u, "isRaw": !0 }) }, "generateTrailImgs": function generateTrailImgs() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, u = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; return v.Z.post({ "url": "".concat(E.Jl, "/tourist/art/produce?picGroupId=").concat(u.requestId), "data": c, "headers": u, "isRaw": !0 }) }, "getHistoryList": function getHistoryList() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return v.Z.get({ "url": "".concat(E.Jl, "/personal/art/ai/produce/query"), "data": c, "isRaw": !0 }) }, "delImg": function delImg(c) { return v.Z.get({ "url": "".concat(E.Jl, "/personal/art/ai/produce/query"), "data": c, "isRaw": !0 }) }, "getTodayCount": function getTodayCount() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return v.Z.get({ "url": "".concat(E.Jl, "/home/art/ai/produce/count"), "data": c, "isRaw": !0 }) }, "sensitiveText": function sensitiveText() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return v.Z.post({ "url": "".concat(E.Jl, "/home/art/check/sensitive"), "data": c, "isRaw": !0 }) }, "checkWeight": function checkWeight() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return v.Z.get({ "url": "".concat(E.Jl, "/home/art/template/query"), "data": c, "isRaw": !0 }) }, "getTemplateData": function getTemplateData() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return v.Z.get({ "url": "".concat(E.Jl, "/home/art/template/query"), "data": c, "isRaw": !0 }) }, "decodeImg": function decodeImg() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return v.Z.post({ "url": "".concat(E.Jl, "/image/art/decode/image"), "data": c, "isRaw": !0 }) }, "updateImgs": function updateImgs() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return v.Z.post({ "url": "".concat(E.Jl, "/home/art/ai/update"), "data": c, "isRaw": !0 }) }, "getGenerateMsg": function getGenerateMsg() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return v.Z.post({ "url": "".concat(E.Jl, "/home/art/ai/message"), "data": c, "isRaw": !0 }) }, "readGenerateMsg": function readGenerateMsg() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return v.Z.post({ "url": "".concat(E.Jl, "/home/art/ai/message/read/multi"), "data": c, "isRaw": !0 }) }, "getGenerateMsgMulti": function getGenerateMsgMulti() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return v.Z.post({ "url": "".concat(E.Jl, "/home/art/ai/message/multi"), "data": c, "isRaw": !0 }) }, "getTrailGenerateMsgMulti": function getTrailGenerateMsgMulti() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return v.Z.post({ "url": "".concat(E.Jl, "/tourist/art/message/multi"), "data": c, "isRaw": !0 }) } }; u.Z = G }, "5210": function (c, u, d) { "use strict"; var v = d(3363), E = d(7853), k = { "wx": "100022", "bd": "100020", "tt": "100020" }, R = { "getUserInfo": function getUserInfo(c) { var u = { "appId": k["".concat(c)], "device": "MPTCFEMOBILEUSER" }; return v.Z.get({ "url": E.Sz + "/v3/uc/user/info", "data": u }) }, "judgeNewUser": function judgeNewUser() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return v.Z.get({ "url": "".concat(E.Jl, "/home/art/ai/new/user/judge"), "data": c, "isRaw": !0 }) }, "getUserOpenId": function getUserOpenId() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return v.Z.get({ "url": "".concat(E.Sz, "/v3/uc/user/openId"), "data": c }) }, "getTrailCount": function getTrailCount() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return v.Z.get({ "url": "".concat(E.Jl, "/tourist/art/count"), "data": c, "isRaw": !0 }) }, "mergeTrailArt": function mergeTrailArt() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []; return v.Z.post({ "url": "".concat(E.Jl, "/tourist/art/save"), "data": c, "isRaw": !0 }) } }; u.Z = R }, "265": function (c, u, d) { "use strict"; var v = d(5671), E = d(3144), k = d(4809), R = d(7503), U = { "development": "https://test-www.sohu.com/cisapi/cis/feeds", "test": "https://test-www.sohu.com/cisapi/cis/feeds", "pre": "https://pre-www.sohu.com/cis/feeds", "production": "https://cis.sohu.com/cis/feeds" }, H = function () { return (0, E.Z)((function CisService() { (0, v.Z)(this, CisService), this.cis = U.test, this.pvId = R.Wf() }), [{ "key": "getCISFeedData", "value": function getCISFeedData(c) { var u = c.spm, d = c.page, v = c.size, E = R.Wf(), U = [{ "spm": u, "page": d, "size": v }], H = "?clientType=2&pvId=".concat(this.pvId, "&requestId=").concat(E, "&sceneParam=").concat(JSON.stringify(U)), G = this.cis + H; return new Promise((function (c) { (0, k.WY)({ "url": G, "method": "GET", "success": function success(d) { try { if (200 == d.statusCode && d.data["".concat(u)] && d.data["".concat(u)].data) { var v = d.data["".concat(u)].data[0].resourceData.data; c(v) } else c(!1) } catch (u) { console.log("cis error", u), c(!1) } }, "fail": function fail(u) { console.log("cis error", u), c(!1) } }) })) } }]) }(); u.Z = new H }, "4988": function (c, u, d) { "use strict"; d.d(u, { "CE": function () { return E }, "De": function () { return G }, "NU": function () { return W }, "Ok": function () { return ie }, "SH": function () { return Z }, "Tj": function () { return k }, "Ww": function () { return oe }, "ZF": function () { return re }, "eA": function () { return H }, "hr": function () { return te }, "iV": function () { return R }, "mO": function () { return Y }, "tL": function () { return X }, "wF": function () { return ne }, "wi": function () { return ae }, "wn": function () { return K }, "wp": function () { return J }, "yg": function () { return U }, "z2": function () { return Q }, "zO": function () { return ee } }); var v = d(5429), E = [{ "rate": 1, "size": "1:1" }, { "rate": .5, "size": "1:2" }, { "rate": 680 / 512, "size": "4:3" }, { "rate": 4 / 3, "size": "4:3" }, { "rate": 512 / 920, "size": "9:16" }, { "rate": 9 / 16, "size": "9:16" }, { "rate": 16 / 9, "size": "16:9" }, { "rate": 920 / 512, "size": "16:9" }], k = { "TEXT": "byText", "IMG": "byImg", "Commodity": "byCommodity", "Portrait": "byPortrait", "HDZoom": "byHdZoom", "onlyPc": "onlyPc", "personBg": "byPersonBg" }, R = { "0": "0", "10": "10" }, U = { "minWeight": 0, "maxWeight": 10 }, H = [{ "id": "byText", "label": "文字生成图片", "newPath": "textToImg", "spmType": 2, "backEndType": 0 }, { "id": "byImg", "label": "图片生成图片", "newPath": "imgToImg", "spmType": 1, "backEndType": 1 }, { "id": "byCommodity", "label": "AI商品图", "newPath": "byProImg", "spmType": 3, "backEndType": 2 }, { "id": "byPortrait", "label": "AI证件照", "newPath": "byCardImg", "spmType": 4, "backEndType": 2 }, { "id": "byHdZoom", "label": "AI高清放大", "newPath": "byClearImg", "spmType": 8, "backEndType": 5 }, { "id": "byPersonBg", "label": "AI人像换背景", "newPath": "byPersonBgImg", "spmType": 9, "backEndType": 2 }], G = [{ "type": 0, "label": "原图", "imgSrc": "https://g1.itc.cn/lapp-wapai-prod/20240410/common/image/wap/definition_origin.png" }, { "type": 1, "label": "高清", "imgSrc": "https://g1.itc.cn/lapp-wapai-prod/20240410/common/image/wap/definition_hd.png" }, { "type": 2, "label": "超清", "imgSrc": "https://g1.itc.cn/lapp-wapai-prod/20240410/common/image/wap/definition_2k.png" }, { "type": 3, "label": "超高清", "imgSrc": "https://g1.itc.cn/lapp-wapai-prod/20240410/common/image/wap/definition_4k.png" }], W = { "index": 1, "like": 2, "history": 3, "my": 4, "detail-feed": 6 }, Z = { "FEED": 1, "DETAIL": 2, "BACK_RETURN": 3 }, Y = { "LIKE": 1, "GENERATE": 2, "MY": 3, "UPLOAD_IMG": 4 }, J = { "GO_BACK": { "icon": "https://g1.itc.cn/lapp-wapai-prod/20240410/common/image/wap/footer-icon-next.png", "text": "返回" }, "GO_HOME": { "icon": "https://g1.itc.cn/lapp-wapai-prod/20240410/common/image/wap/footer-icon-go-home.png", "text": "去首页", "path": "/home" }, "GO_TEXT_HOME": { "icon": "https://g1.itc.cn/lapp-wapai-prod/20240410/common/image/wap/footer-icon-text-home.png", "text": "AI助手", "path": "/textHome" } }, K = { "HOME": 1, "DETAIL": 2, "MYSPACE": 3 }, X = { "SUCCESS": 1, "PIC_HAS_SUCCESS": 140100, "PIC_HAS_FAILED": 140101, "SCORE_RETURN_FAILED": 140102, "PIC_TASK_HAS_FINISH": 140104 }, Q = { "SUCCESS": { "code": 1, "title": "生图成功", "label": "图片生成成功啦！快来查看吧", "icon": "https://g1.itc.cn/lapp-wapai-prod/20240410/common/image/icon-success.png", "jumpName": "去查看", "spmA": v.o.GENERATE_MSG_SUCCESS }, "STOPPED": { "code": 140103, "title": "停止生图", "label": "停止生图成功了", "icon": "https://g1.itc.cn/lapp-wapai-prod/20240410/common/image/icon-success.png", "jumpName": "去查看", "spmA": v.o.GENERATE_MSG_SUCCESS }, "ERROR": { "code": 140004, "title": "生图失败", "label": "图片生成失败了，积分已退还", "icon": "https://g1.itc.cn/lapp-wapai-prod/20240410/common/image/icon-error.png", "jumpName": "重新试试", "spmA": v.o.GENERATE_MSG_ERROR }, "TIMEOUT": { "code": 140009, "title": "生图失败", "label": "图片生成失败了，平台补偿6积分", "icon": "https://g1.itc.cn/lapp-wapai-prod/20240410/common/image/icon-error.png", "jumpName": "重新试试", "spmA": v.o.GENERATE_MSG_TIMEOUT } }, ee = ["文本有害、不安全", "文本不符合输入的要求", "文本包含事实性错误", "文本逻辑错误、语句不通顺"], te = function textGenerateShareText(c) { var u = ["简单AI的AI助手【".concat(c, "】贼好用！快来试试吧："), "超级实用的AI助手【".concat(c, "】，快来体验一下："), "不可错过的AI神器【".concat(c, "】，快来试试吧！"), "业界领先的AI助手，专注于【".concat(c, "】，即刻体验："), "简单AI的AI助手【".concat(c, "】，功能如此好用，快来感受一下吧！"), "简单AI的AI助手【".concat(c, "】，功能领跑业界，赶紧来试试：")]; return u[Math.floor(Math.random() * u.length)] }, ne = { "MASTER_NOT_PUBLIC": { "_delete": 2, "_copy": 2, "_edit": 2, "_public": 2, "_share": 0, "_like": 0 }, "MASTER_PUBLIC": { "_delete": 2, "_copy": 2, "_edit": 2, "_public": 0, "_share": 2, "_like": 2 }, "MASTER_AUDITING": { "_delete": 1, "_copy": 2, "_edit": 2, "_public": 1, "_share": 0, "_like": 0 }, "MASTER_UN_AUDITED": { "_delete": 2, "_copy": 2, "_edit": 2, "_public": 1, "_share": 0, "_like": 0 }, "GUEST": { "_delete": 0, "_copy": 2, "_edit": 0, "_public": 0, "_share": 2, "_like": 2 } }, re = { "WX_OFFICIAL_ACCOUNT": { "appId": "wxb178dbc77a5f218f" } }, oe = { "3": "AI消除工具", "4": "AI抠图工具", "5": "高清放大", "6": "AI智能扩图" }, ie = { "3": "1", "4": "2", "5": "4", "6": "3" }, ae = { "3": "https://g1.itc.cn/lapp-wapai-prod/20240410/common/image/common/guidePic.png", "4": "https://g1.itc.cn/lapp-wapai-prod/20240410/common/image/common/guidePic.png", "5": "https://g1.itc.cn/lapp-wapai-prod/20240410/common/image/common/guidePicEx.png", "6": "https://g1.itc.cn/lapp-wapai-prod/20240410/common/image/common/guidePicEx.png" } }, "1022": function (c, u, d) { "use strict"; d.d(u, { "Nc": function () { return cutFeedImg }, "c9": function () { return cutPicUrl }, "tT": function () { return cutAvatarUrl }, "y1": function () { return scaleImg } }); var v = d(7853), E = ["p0.itc.cn", "p1.itc.cn", "p2.itc.cn", "p3.itc.cn", "p4.itc.cn", "p5.itc.cn", "p6.itc.cn", "p7.itc.cn", "p8.itc.cn", "p9.itc.cn", "q0.itc.cn", "q1.itc.cn", "q2.itc.cn", "q3.itc.cn", "q4.itc.cn", "q5.itc.cn", "q6.itc.cn", "q7.itc.cn", "q8.itc.cn", "q9.itc.cn"], k = ["5b0988e595225.cdn.sohucs.com", "29e5534ea20a8.cdn.sohucs.com", "img.mp.itc.cn", "img.mp.sohu.com", "mptc-static.itc.cn"], R = ["mobileproduct.cdn.sohu.com", "mobileproducts.cdn.sohu.com"], U = E.concat(k).concat(R); function cutPicUrl(c, u, d) { if (!c || "string" != typeof c) return ""; var v = u || 598, E = d || 336; return processImgUrl(c, "".concat(arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "q_70,c_lfill", ",w_").concat(v, ",h_").concat(E, ",g_face"), v, E) } function cutFeedImg(c, u) { if (!c || "string" != typeof c) return ""; var d = u || 598; return processImgUrl(c, "".concat(arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "q_70,c_zoom", ",w_").concat(d), d) } function processImgUrl(c, u, d, U) { var H = c, G = (H.split("/") || [])[2]; if (!G) return ""; if (E.includes(G)) { var W = new RegExp("".concat(G, "(.*?)/images")); H = H.replace(W, "".concat(G, "/").concat(u, "/images")) } if (k.includes(G) && !u.includes("c_zoom")) { if (/\/q_\d*\//.test(H)) return H; H = -1 === H.indexOf("w_") ? H.replace(G, "".concat(G, "/").concat(u)) : -1 === H.indexOf("c_cut") ? H.replace(/(w_[0-9]*,h_[0-9]*)|(w_[0-9]*|h_[0-9]*)/, "w_" + d + ",h_" + U) : H.replace(/c_cut,x_[0-9]*,y_[0-9]*,((w_[0-9]*,h_[0-9]*)|(w_[0-9]*|h_[0-9]*))/, u) } if (R.includes(G)) { var Z = new RegExp("".concat(G, "(.*?)/img")); H = H.replace(Z, "".concat(G, "/").concat(u, "/").concat(v.qd, "/img")) } return URLPrefix(H.replace(/^http:/, "")) } function URLPrefix(c) { if (!c) return ""; var u = /^\/\//.test(c) ? "https:" : ""; return "".concat(u).concat(c) } function cutAvatarUrl() { return function cutPicUrlNewest(c, u, d) { if (!c || "string" != typeof c) return ""; var v = c, H = u || 226, G = d || 150, W = "".concat(arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "q_70,c_lfill", ",w_").concat(H, ",h_").concat(G, ",g_face"), Z = (v.split("/") || [])[2]; if (!U.includes(Z)) return URLPrefix(v.replace(/^http:/, "")); if (E.includes(Z)) { var Y = new RegExp("".concat(Z, "(.*?)/images")); v = v.replace(Y, "".concat(Z, "/").concat(W, "/images")) } if (k.includes(Z)) { var J = v.split("//")[1] && v.split("//")[1].split("/")[1]; v = /\/q_\d*\//.test(J) ? v.replace(J, W) : -1 === v.indexOf("w_") ? v.replace(Z, "".concat(Z, "/").concat(W)) : -1 === v.indexOf("c_cut") ? v.replace(/(w_[0-9]*,h_[0-9]*)|(w_[0-9]*|h_[0-9]*)/, "w_" + H + ",h_" + G) : v.replace(/c_cut,x_[0-9]*,y_[0-9]*,((w_[0-9]*,h_[0-9]*)|(w_[0-9]*|h_[0-9]*))/, W) } if (R.includes(Z) && (function testUrl(c) { return !!c && c.split("//")[1] && ("test" === c.split("//")[1].split("/")[1] || "prod" === c.split("//")[1].split("/")[1]) }(v) && (v = v.replace(Z, Z + "/" + W)), function _testUrl(c) { return !!c && c.split("//")[1] && ("test" === c.split("//")[1].split("/")[2] || "prod" === c.split("//")[1].split("/")[2]) }(v))) { var K = v.split("//")[1] && v.split("//")[1].split("/")[1]; v = v.replace(K, W) } return URLPrefix(v.replace(/^http:/, "")) }(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "", arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 64, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 64, arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "q_70,c_lfill") } function scaleImg(c, u) { var d = u, v = c.type, E = c.name, k = new FileReader; return k.readAsDataURL(c), new Promise((function (u) { k.onload = function (k) { var R = new Image; R.src = k.target.result, R.onload = function () { var k = R.width, U = R.height; Math.max(k, U) <= d && u({ "scaledFile": c, "isScaled": !1 }); var H = 0, G = 0; k > U ? (H = d, G = Math.round(U * d / k)) : (G = d, H = Math.round(k * d / U)); var W = document.createElement("canvas"); W.width = H, W.height = G, W.getContext("2d").drawImage(R, 0, 0, H, G), W.toBlob((function (c) { var d = new File([c], E, { "type": v }); u({ "scaledFile": d, "isScaled": !0 }) }), v) } } })) } }, "7853": function (c, u, d) { "use strict"; d.d(u, { "G": function () { return W }, "Jl": function () { return k }, "NU": function () { return G }, "Ry": function () { return Z }, "Sz": function () { return E }, "bm": function () { return R }, "e0": function () { return U }, "qd": function () { return H } }); var v = "test", E = "" + { "development": "//test-uis.mp.sohu.com", "test": "//test-uis.mp.sohu.com", "pre": "//pre-uis.mp.sohu.com", "production": "//uis.mp.sohu.com" }[v], k = "" + { "development": "//test-uis.mp.sohu.com/prompt", "test": "//test-uis.mp.sohu.com/prompt", "pre": "//pre-uis.mp.sohu.com/prompt", "production": "//uis.mp.sohu.com/prompt" }[v], R = { "development": "//test-app.sohu.com", "test": "//test-app.sohu.com", "pre": "//pre-app.sohu.com", "production": "//ai.sohu.com" }[v], U = { "development": "//d2.m.sohu.com/wap/search", "test": "//d2.m.sohu.com/wap/search", "pre": "//t2.m.sohu.com/wap/search", "production": "//ai.sohu.com/wap/search" }[v], H = { "development": "test", "test": "test", "pre": "prod", "production": "prod" }[v], G = { "development": { "host": "//test-m.sohu.com", "path": "/wap-article-api/article-author/", "rule": "207052111_130000278", "agreement": "207052117_130000278", "service": "207061303_130000278", "privacy": "207157603_130000278" }, "test": { "host": "//test-m.sohu.com", "path": "/wap-article-api/article-author/", "rule": "207052111_130000278", "agreement": "207052117_130000278", "service": "207061303_130000278", "privacy": "207157603_130000278" }, "pre": { "host": "//v2.sohu.com", "path": "/wap-article-api/article-author/", "rule": "833537091_121798712", "agreement": "833530723_121798712", "service": "783645693_121798712", "privacy": "783630167_121798712" }, "production": { "host": "//v2.sohu.com", "path": "/wap-article-api/article-author/", "rule": "833537091_121798712", "agreement": "833530723_121798712", "service": "783645693_121798712", "privacy": "783630167_121798712" } }[v], W = { "development": "https://test-m.sohu.com", "test": "https://test-m.sohu.com", "pre": "https://pre-m.sohu.com", "production": "https://odin.sohu.com" }[v], Z = { "development": { "bannerMenuId": "772", "creativityFeedId": "2020", "creativityAuditFeedId": "2046", "creativityChooseDrawTextId": "767", "creativityChooseDrawImgId": "768", "creativityCreativeToolsId": "769", "creativityVisualStylesId": "2018", "homeFeedId": "2044", "homeFeedWithWord": "2040", "homeFeedIdWithTop": "2023", "homeFeedWithWordTop": "2036", "homeBannerId": "2019", "homeMenuId": "764", "myLikeFeedId": "2033", "writingFeedId": "2028", "writingFeedNOTopId": "2028", "writingBannerId": "773", "writingMenuId": "765", "recentViewId": "2034" }, "test": { "bannerMenuId": "772", "creativityFeedId": "2020", "creativityAuditFeedId": "2046", "creativityChooseDrawTextId": "767", "creativityChooseDrawImgId": "768", "creativityCreativeToolsId": "769", "creativityVisualStylesId": "2018", "homeFeedId": "2044", "homeFeedWithWord": "2040", "homeFeedIdWithTop": "2023", "homeFeedWithWordTop": "2036", "homeBannerId": "2019", "homeMenuId": "764", "myLikeFeedId": "2033", "writingFeedId": "2028", "writingFeedNOTopId": "2028", "writingBannerId": "773", "writingMenuId": "765", "recentViewId": "2034" }, "pre": { "bannerMenuId": "2661", "creativityFeedId": "7953", "creativityAuditFeedId": "7960", "creativityChooseDrawTextId": "2658", "creativityChooseDrawImgId": "2659", "creativityCreativeToolsId": "2660", "creativityVisualStylesId": "7951", "homeFeedId": "7946", "homeFeedWithWord": "7942", "homeFeedIdWithTop": "7944", "homeFeedWithWordTop": "7938", "homeBannerId": "7949", "homeMenuId": "2655", "myLikeFeedId": "7952", "writingFeedId": "7950", "writingFeedNOTopId": "7956", "writingBannerId": "2653", "writingMenuId": "2656", "recentViewId": "7948" }, "production": { "bannerMenuId": "2661", "creativityFeedId": "7953", "creativityAuditFeedId": "7960", "creativityChooseDrawTextId": "2658", "creativityChooseDrawImgId": "2659", "creativityCreativeToolsId": "2660", "creativityVisualStylesId": "7951", "homeFeedId": "7946", "homeFeedWithWord": "7942", "homeFeedIdWithTop": "7944", "homeFeedWithWordTop": "7938", "homeBannerId": "7949", "homeMenuId": "2655", "myLikeFeedId": "7952", "writingFeedId": "7950", "writingFeedNOTopId": "7956", "writingBannerId": "2653", "writingMenuId": "2656", "recentViewId": "7948" } }[v] }, "3244": function (c, u, d) { "use strict"; d.d(u, { "Y": function () { return v } }); var v = function mitt(c) { return { "all": c = c || new Map, "on": function (u, d) { var v = c.get(u); v ? v.push(d) : c.set(u, [d]) }, "off": function (u, d) { var v = c.get(u); v && (d ? v.splice(v.indexOf(d) >>> 0, 1) : c.set(u, [])) }, "emit": function (u, d) { var v = c.get(u); v && v.slice().map((function (c) { c(d) })), (v = c.get("*")) && v.slice().map((function (c) { c(u, d) })) } } }() }, "5660": function (c, u, d) { "use strict"; var v = d(1724); u.Z = { "setItem": function setItem(c, u) { return this.removeItem(c), (0, v.Fj)(c, u), u }, "getItem": function getItem(c) { return (0, v.qu)(c) }, "removeItem": function removeItem(c) { (0, v.hq)(c) } } }, "9400": function (c, u, d) { "use strict"; d.d(u, { "Z": function () { return ge } }); var v = d(1413); function o(c) { var u = function t(c, u) { if ("object" != typeof c || !c) return c; var d = c[Symbol.toPrimitive]; if (void 0 !== d) { var v = d.call(c, u); if ("object" != typeof v) return v; throw new TypeError("@@toPrimitive must return a primitive value.") } return String(c) }(c, "string"); return "symbol" == typeof u ? u : u + "" } function e(c) { return c && c.__esModule && Object.prototype.hasOwnProperty.call(c, "default") ? c.default : c } var E, k = { "exports": {} }; E = k, function (c, u) { E.exports ? E.exports = u(c) : c.SohuPassport = u(c) }(window, (function (c) { function t(c) { var u = this; c.onekeyId && (Z.autoLoadScript("https://passportv4-web.bjcnc.scs.sohucs.com/crypto-js.min.js", (function (c) { u.cryptoLoaded = c })), Z.autoLoadScript("https://www.cmpassport.com/h5/js/jssdk_auth/jssdk-1.0.0.min.js", (function (c) { u.ydrzLoaded = c }))), this.options = Z.extend({}, W, c || {}), this._id = "passport" + E.replace(/\D/g, ""), this.version = E, this.appid = this.options.appid, this.options.gidinf && this.options.serialno && (l("gidinf", this.options.gidinf), l("srn", this.options.serialno)), R ? l("t", k) : l("t", k, U), this.setCommonCookie() } var u, d, v = (d = (u = c).opera ? opera.version().replace(/\d$/, "") - 0 : parseFloat((/(?:IE |fox\/|ome\/|ion\/)(\d+\.\d)/.exec(navigator.userAgent) || [, 0])[1]), { "ie": !!u.VBArray && Math.max(document.documentMode || 0, d), "firefox": !!u.netscape && d, "opera": !!u.opera && d, "chrome": !!u.chrome && d, "safari": /apple/i.test(navigator.vendor) && d }), E = "4.0.14", k = (new Date).getTime(), R = /\.sohu.com/.test(location.host), U = 2 == document.domain.split(".").length ? document.domain : document.domain.split(".").slice(document.domain.split(".").length - 2).join("."), H = v.ie && v.ie < 9 ? "https://v4.passport.sohu.com/i/".replace("https", "http") : R ? "https://v4.passport.sohu.com/i/" : "https://v4-passport.56.com/i/", G = "https://m.passport.sohu.com", W = { "appid": "", "url": { "commonCookie": H + "cookie/common", "challenge": H + "jf/code", "loginByUserId": H + "login", "loginRequireCaptcha": H + "login/require/captcha", "mobileLogin": H + "login/mobile", "quickLogin": H + "login/quick", "passportLogin": H + "login/passport", "scanCodeLogin": H + "login/token", "pictureCaptcha": H + "captcha/picture", "signInCaptcha": H + "smcode/mobile/signin", "registerCaptcha": H + "smcode/mobile/signup", "newRegisterCaptcha": H + "smcode/mobile/esignup", "bindPhoneCaptcha": H + "smcode/mobile/sblmobile", "logout": H + "logout", "register": H + "register", "registerUp": H + "register/v2", "bindPhone": H + "login/bind/mobile", "checkPhone": H + "verify/mobile/bind", "checkUserPhoneBind": H + "verify/user/mobile", "getPhoneCode": H + "mobile/phonecode", "getMobileCaptcha": H + "smcode/mobile/v2", "verifyMobileCaptcha": H + "verify/smcode/mobile", "getSecmobileCaptcha": H + "smcode/secmobile", "verifySecmobileCaptcha": H + "verify/smcode/secmobile", "queryCertificateStaus": H + "certificate/query/passport", "userCertificate": H + "certificate/create", "getAICaptcha": H + "captcha/npicture", "verifyAICaptcha": H + "captcha/nvalid", "resetPassword": H + "password/reset2", "updatePassword": H + "password/update2", "verifySecmobCaptcha": H + "login/security/secmob" } }, Z = { "extend": function () { var c, u, d, v, E = arguments[0] || {}, k = arguments.length; for (c = 1; c < k; c++)if (null !== (d = arguments[c])) for (u in d) void 0 !== (v = d[u]) && (E[u] = v); return E }, "inArray": function (c, u) { for (var d = 0; d < u.length; d++)if (u[d] === c) return d; return -1 }, "isString": function (c) { return "string" == typeof c }, "isFunction": function (c) { return "function" == typeof c }, "isBool": function (c) { return "boolean" == typeof c }, "bind": function (c, u) { return function () { c.apply(u, arguments) } }, "trim": function (c) { return this.isString(c) ? c.replace(/^\s+/, "").replace(/\s+$/, "") : c }, "param": function (c) { var u = []; for (var d in c) u.push(d + "=" + c[d]); return u.join("&") }, "url": function (c, u) { return c + (/\?/.test(c) ? "&" : "?") + this.param(u) }, "md5": function (c) { function t(c, u, d, v, E, k) { return a((R = a(a(u, c), a(v, k))) << (U = E) | R >>> 32 - U, d); var R, U } function o(c, u, d, v, E, k, R) { return t(u & d | ~u & v, c, u, E, k, R) } function n(c, u, d, v, E, k, R) { return t(u & v | d & ~v, c, u, E, k, R) } function i(c, u, d, v, E, k, R) { return t(u ^ d ^ v, c, u, E, k, R) } function r(c, u, d, v, E, k, R) { return t(d ^ (u | ~v), c, u, E, k, R) } function a(c, u) { var d = (65535 & c) + (65535 & u); return (c >> 16) + (u >> 16) + (d >> 16) << 16 | 65535 & d } var u; return function (c) { for (var u = "0123456789abcdef", d = "", v = 0; v < 4 * c.length; v++)d += u.charAt(c[v >> 2] >> v % 4 * 8 + 4 & 15) + u.charAt(c[v >> 2] >> v % 4 * 8 & 15); return d }(function (c, u) { c[u >> 5] |= 128 << u % 32, c[14 + (u + 64 >>> 9 << 4)] = u; for (var d = 1732584193, v = -271733879, E = -1732584194, k = 271733878, R = 0; R < c.length; R += 16) { var U = d, H = v, G = E, W = k; d = o(d, v, E, k, c[R + 0], 7, -680876936), k = o(k, d, v, E, c[R + 1], 12, -389564586), E = o(E, k, d, v, c[R + 2], 17, 606105819), v = o(v, E, k, d, c[R + 3], 22, -1044525330), d = o(d, v, E, k, c[R + 4], 7, -176418897), k = o(k, d, v, E, c[R + 5], 12, 1200080426), E = o(E, k, d, v, c[R + 6], 17, -1473231341), v = o(v, E, k, d, c[R + 7], 22, -45705983), d = o(d, v, E, k, c[R + 8], 7, 1770035416), k = o(k, d, v, E, c[R + 9], 12, -1958414417), E = o(E, k, d, v, c[R + 10], 17, -42063), v = o(v, E, k, d, c[R + 11], 22, -1990404162), d = o(d, v, E, k, c[R + 12], 7, 1804603682), k = o(k, d, v, E, c[R + 13], 12, -40341101), E = o(E, k, d, v, c[R + 14], 17, -1502002290), d = n(d, v = o(v, E, k, d, c[R + 15], 22, 1236535329), E, k, c[R + 1], 5, -165796510), k = n(k, d, v, E, c[R + 6], 9, -1069501632), E = n(E, k, d, v, c[R + 11], 14, 643717713), v = n(v, E, k, d, c[R + 0], 20, -373897302), d = n(d, v, E, k, c[R + 5], 5, -701558691), k = n(k, d, v, E, c[R + 10], 9, 38016083), E = n(E, k, d, v, c[R + 15], 14, -660478335), v = n(v, E, k, d, c[R + 4], 20, -405537848), d = n(d, v, E, k, c[R + 9], 5, 568446438), k = n(k, d, v, E, c[R + 14], 9, -1019803690), E = n(E, k, d, v, c[R + 3], 14, -187363961), v = n(v, E, k, d, c[R + 8], 20, 1163531501), d = n(d, v, E, k, c[R + 13], 5, -1444681467), k = n(k, d, v, E, c[R + 2], 9, -51403784), E = n(E, k, d, v, c[R + 7], 14, 1735328473), d = i(d, v = n(v, E, k, d, c[R + 12], 20, -1926607734), E, k, c[R + 5], 4, -378558), k = i(k, d, v, E, c[R + 8], 11, -2022574463), E = i(E, k, d, v, c[R + 11], 16, 1839030562), v = i(v, E, k, d, c[R + 14], 23, -35309556), d = i(d, v, E, k, c[R + 1], 4, -1530992060), k = i(k, d, v, E, c[R + 4], 11, 1272893353), E = i(E, k, d, v, c[R + 7], 16, -155497632), v = i(v, E, k, d, c[R + 10], 23, -1094730640), d = i(d, v, E, k, c[R + 13], 4, 681279174), k = i(k, d, v, E, c[R + 0], 11, -358537222), E = i(E, k, d, v, c[R + 3], 16, -722521979), v = i(v, E, k, d, c[R + 6], 23, 76029189), d = i(d, v, E, k, c[R + 9], 4, -640364487), k = i(k, d, v, E, c[R + 12], 11, -421815835), E = i(E, k, d, v, c[R + 15], 16, 530742520), d = r(d, v = i(v, E, k, d, c[R + 2], 23, -995338651), E, k, c[R + 0], 6, -198630844), k = r(k, d, v, E, c[R + 7], 10, 1126891415), E = r(E, k, d, v, c[R + 14], 15, -1416354905), v = r(v, E, k, d, c[R + 5], 21, -57434055), d = r(d, v, E, k, c[R + 12], 6, 1700485571), k = r(k, d, v, E, c[R + 3], 10, -1894986606), E = r(E, k, d, v, c[R + 10], 15, -1051523), v = r(v, E, k, d, c[R + 1], 21, -2054922799), d = r(d, v, E, k, c[R + 8], 6, 1873313359), k = r(k, d, v, E, c[R + 15], 10, -30611744), E = r(E, k, d, v, c[R + 6], 15, -1560198380), v = r(v, E, k, d, c[R + 13], 21, 1309151649), d = r(d, v, E, k, c[R + 4], 6, -145523070), k = r(k, d, v, E, c[R + 11], 10, -1120210379), E = r(E, k, d, v, c[R + 2], 15, 718787259), v = r(v, E, k, d, c[R + 9], 21, -343485551), d = a(d, U), v = a(v, H), E = a(E, G), k = a(k, W) } return Array(d, v, E, k) }(function (c) { for (var u = Array(), d = 0; d < 8 * c.length; d += 8)u[d >> 5] |= (255 & c.charCodeAt(d / 8)) << d % 32; return u }(u = c), 8 * u.length)) }, "autoLoadScript": function (c, u) { var d = document.createElement("script"), v = document.getElementsByTagName("head")[0]; d.charset = "UTF-8", d.async = !0, d.onerror = function () { u && u(!1) }; var E = !1; d.onload = d.onreadystatechange = function () { E || d.readyState && "loaded" !== d.readyState && "complete" !== d.readyState || (E = !0, u && u(!0)) }, d.src = c, v.appendChild(d) } }, m = function (c) { var u, d = new RegExp("(^| )" + c + "=([^;]*)(;|$)"); return (u = document.cookie.match(d)) ? unescape(u[2]) : null }, l = function (c, u, d) { var v = new Date; v.setTime(v.getTime() + 2592e6), document.cookie = d ? c + "=" + escape(u) + ";domain=" + d + ";path=/;expires=" + v.toGMTString() : c + "=" + escape(u) + ";domain=sohu.com;path=/;expires=" + v.toGMTString() }, Y = k + 1, J = k + 2, K = k + 3; return t.prototype = { "onekeyLogin": function (c) { function t(c, u) { var d, v = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""), E = []; if (u = u || v.length, c) for (d = 0; d < c; d++)E[d] = v[0 | Math.random() * u]; return E.join("") } function o(c, u) { for (var d = String(c), v = u - d.length; v > 0; v--)d = "0" + d; return d } function n(u) { var E = { "appid": d, "token": u.token, "traceid": t(32, 32), "userInformation": u.userInformation }; v.quickLogin({ "success": function (u, d) { c.success && c.success(u, d) }, "error": function (u) { c.error && c.error(u) }, "params": E }) } function i(u) { c.getTokenError && c.getTokenError(u) } var u, d = this.appid, v = this, E = { "version": "2.0", "timestamp": (u = new Date, o(u.getFullYear(), 4) + o(u.getMonth() + 1, 2) + o(u.getDate(), 2) + o(u.getHours(), 2) + o(u.getMinutes(), 2) + o(u.getSeconds(), 2) + o(u.getMilliseconds(), 3)), "appId": this.options.onekeyId, "appkey": this.options.onekeyKey, "onekeySwitchBackUrl": this.options.onekeySwitchBackUrl, "onekeySwitchBackInfo": this.options.onekeySwitchBackInfo, "businessType": "8", "openType": 1, "traceId": t(32, 32), "expandParams": "", "isTest": "", "authPageType": 3 }, k = 0; !function e() { if (v.cryptoLoaded && v.ydrzLoaded && CryptoJS && CryptoJS.MD5) { var c = CryptoJS.MD5(E.appId + E.businessType + E.traceId + E.timestamp + E.traceId + E.version + E.appkey).toString(); return E.onekeySwitchBackUrl && YDRZAuthLogin.authPageInit({ "customControlStyle": { "ifShow": !0, "width": "50%", "height": "32px", "high": "85%", "left": "25%", "url": E.onekeySwitchBackUrl, "name": E.onekeySwitchBackInfo }, "returnBtnStyle": { "width": "0.8rem", "height": "1rem" } }), void YDRZAuthLogin.getTokenInfo({ "data": { "version": E.version, "appId": E.appId, "sign": c, "traceId": E.traceId, "timestamp": E.timestamp, "openType": E.openType, "expandParams": E.expandParams, "isTest": E.isTest, "authPageType": E.authPageType }, "success": n, "error": i }) } ++k < 30 && setTimeout(e, 100) }() }, "getNetType": function (c, u) { var d = this, v = 0; !function i() { if (d.cryptoLoaded && d.ydrzLoaded) { var E = YDRZAuthLogin.getConnection(c); u && u({ "netType": E.netType, "platform": navigator.platform, "userAgent": navigator.userAgent }) } else ++v < 30 && setTimeout(i, 100) }() }, "setCommonCookie": function (c) { if (R ? l("t", k) : l("t", k, U), m("gidinf") && m("reqtype")) c && c(); else { var u = this.options.url.commonCookie, d = { "callback": "?" }; R || (d.domain = U), u = Z.url(u, d), this.getJSONP(u, c) } }, "bridging": function (c) { var u = { "error": c.error, "success": c.success }, d = c.params || {}; return c.params && c.params.appid || (d.appid = this.options.appid), d.callback = function (c) { if (c) { var d = c.body; 200 === Number(c.status) || 201 === Number(c.status) || 206 === Number(c.status) ? u.success && u.success(d, c.status) : u.error && u.error(c) } else u.error && u.error(c) }, d }, "randomName": function (c) { return this._id + "_" + c + k++ }, "getJSONP": function (u, d, v) { var E, k = this.randomName("cb"), R = document.getElementsByTagName("head")[0], U = document.createElement("script"), H = (new Date).getTime(); E = (u = u.replace(/(=)\?(?=&|$)|\?\?/, "$1" + k)).replace(/([?&])_=[^&]*/, "$1_=" + H), u = E + (E === u ? (/\?/.test(u) ? "&" : "?") + "_=" + H : ""), c[k] = function (u) { Z.isFunction(d) && d(u), setTimeout((function () { c[k] = void 0, R.removeChild(U) }), 1) }, U.type = "text/javascript", U.charset = v || "UTF-8", U.src = u, U.onerror = function (u) { c[k]({ "status": 500 }) }, R.appendChild(U) }, "getMethod": function (c, u) { var d = this.bridging(c), v = d.callback; d.callback = "?", u = Z.url(u, d), this.getJSONP(u, v) }, "getChallenge": function (u, d) { R ? l("t", k) : l("t", k, U); var v = this; this.setCommonCookie((function () { var E = { "callback": "?", "type": R ? 0 : 1 }, k = Z.url(v.options.url.challenge, E); v.getJSONP(k, (function (v) { c.eval(v), d.params = d.params || {}, !R && document._jv && (d.params._jv = document._jv), u && u(d) })) })) }, "getChallengeWithoutCookieSet": function (u, d) { var v = { "callback": "?", "type": R ? 0 : 1 }, E = Z.url(this.options.url.challenge, v); this.getJSONP(E, (function (v) { c.eval(v), d.params = d.params || {}, !R && document._jv && (d.params._jv = document._jv), u && u(d) })) }, "createIFrame": function (c) { var u; return c = c || this.randomName("passportIframe"), v.ie && v.ie < 9 ? u = document.createElement('<iframe src="about:blank" name="' + c + '"></iframe>') : (u = document.createElement("iframe")).setAttribute("name", c), u.style.display = "none", document.body.appendChild(u), u }, "createForm": function (c, u) { var d, v, E, k = document.createElement("form"); for (v in c) E = c[v], (d = document.createElement("input")).type = "hidden", d.name = v, d.value = E, k.appendChild(d); return k.style.display = "none", u ? u.appendChild(k) : document.body.appendChild(k), k }, "formData": function (c, u) { var d = {}; for (var v in c) c[v] && ("password" === v ? d.password = Z.trim(c.password) : d[v] = Z.trim(c[v])); return d }, "ajax_post": function (u, d, v) { var E = function (c) { var u = []; for (var d in c) u.push(encodeURIComponent(d) + "=" + encodeURIComponent(c[d])); return u.join("&") }(d); if (c.XMLHttpRequest) var k = new XMLHttpRequest; else k = new ActiveXObject("Microsoft.XMLHTTP"); k.onreadystatechange = function () { 4 == k.readyState && v && v(JSON.parse(k.responseText)) }, k.open("POST", u, !0), k.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), k.withCredentials = !0, k.send(E) }, "formToIFrame": function (c, u) { var d; c.nf = 1, c.callback && (d = Z.bind(c.callback, this)), delete c.callback, this.ajax_post(u, this.formData(c), d) }, "createIFrameQRCode": function (c) { var u; return c = c || this.randomName("passportIframe"), v.ie && v.ie < 9 ? u = document.createElement('<iframe src="about:blank" name="' + c + '" width="150px" height="150px"></iframe>') : ((u = document.createElement("iframe")).setAttribute("name", c), u.height = "150px", u.width = "150px", u.setAttribute("frameBorder", 0)), u }, "getQRCode": function (c) { var u = this, d = { "success": function (d) { d.qrurl = "https://usr.mb.hd.sohu.com/pc/getqr.json?qrtoken=cab088c91e9647599dd5dd5eca0bec1c&code=283ffbf7792f1565cbf5a3d927e48822", d.qrtoken = "cab088c91e9647599dd5dd5eca0bec1c"; var v = u.createIFrameQRCode(); v.src = d.qrurl, document.getElementById(c.params.id).appendChild(v), u.queryQRCodeStatus() }, "error": function (c) { }, "params": { "pagetoken": (new Date).getTime() } }; this.createQRCode(d) }, "createQRCode": function (c) { this.getMethod(c, this.options.url.getAICaptcha) }, "queryQRCodeStatus": function (c) { this.getMethod(c, this.options.url.getAICaptcha) }, "verifySecmobCaptcha": function (c) { var u = this, d = u.options.url.verifySecmobCaptcha + "/" + (c.params.appid || u.options.appid); u.getChallenge((function (c) { u.formToIFrame(u.bridging(c), d) }), c) }, "resetPassword": function (c) { if (m("exp")) { var u = this, d = u.options.url.resetPassword; u.formToIFrame(u.bridging(c), d) } }, "updatePassword": function (c) { var u = this, d = u.options.url.updatePassword; u.formToIFrame(u.bridging(c), d) }, "login": function (c) { var u = this, d = u.options.url.loginByUserId + "/" + (c.params.appid || u.options.appid); c.params.password = Z.md5(c.params.password), c.params.captcha && (c.params.pagetoken = Y), u.getChallenge((function (c) { u.formToIFrame(u.bridging(c), d) }), c) }, "loginRequireCaptcha": function (c) { this.getMethod(c, this.options.url.loginRequireCaptcha) }, "mobileLogin": function (c) { var u = this, d = u.options.url.mobileLogin + "/" + u.options.appid; u.getChallenge((function (c) { u.formToIFrame(u.bridging(c), d) }), c) }, "quickLogin": function (c) { var u = this, d = u.options.url.quickLogin + "/" + u.options.appid; u.getChallenge((function (c) { u.formToIFrame(u.bridging(c), d) }), c) }, "getThirdLoginUrl": function (c) { if ("weChat" === c.provider) { var u = ""; return c.wxParams && (u = "&selfRedirect=" + (c.wxParams.self_redirect || "") + "&style=" + (c.wxParams.style || "") + "&href=" + (c.wxParams.href || "")), "https://plus.sohu.com/spassport/bind/" + this.options.appid + "/wechat?ru=" + c.ru + (R ? "" : "&pua=true") + u } return "//passport.sohu.com/openlogin/request.action?provider=" + c.provider + "&appid=" + this.options.appid + "&ru=" + c.ru + (R ? "" : "&pua=true") }, "getWechatMPLoginUrl": function (c) { return H.substring(0, H.length - 2) + "/oauth/loginurl?appid=" + this.options.appid + "&openkey=" + c.openkey + "&platform=wechat&ru=" + c.ru }, "logout": function (c) { var u = this, d = u.options.url.logout + "/" + u.options.appid; u.getChallengeWithoutCookieSet((function (c) { u.formToIFrame(u.bridging(c), d) }), c) }, "getLoginPicture": function () { return this.options.url.pictureCaptcha + "?pagetoken=" + Y + "&random=" + this.randomName("sdk") }, "getPhonePicture": function () { return this.options.url.pictureCaptcha + "?pagetoken=" + J + "&random=" + this.randomName("sdk") }, "getRegisterPicture": function () { return this.options.url.pictureCaptcha + "?pagetoken=" + K + "&random=" + this.randomName("sdk") }, "getSignInCaptcha": function (c) { c.params.pagetoken = J, this.getMethod(c, this.options.url.signInCaptcha) }, "getRegisterCaptcha": function (c) { c.params.pagetoken = K, this.getMethod(c, this.options.url.registerCaptcha) }, "getNewRegisterCaptcha": function (c) { c.params.pagetoken = K, this.getMethod(c, this.options.url.newRegisterCaptcha) }, "getBindPhoneCaptcha": function (c) { this.getMethod(c, this.options.url.bindPhoneCaptcha) }, "register": function (c) { var u = this, d = u.options.url.register + "/" + u.options.appid; u.getChallenge((function (c) { u.formToIFrame(u.bridging(c), d) }), c) }, "registerUp": function (c) { var u = this, d = u.options.url.registerUp + "/" + u.options.appid; u.getChallenge((function (c) { u.formToIFrame(u.bridging(c), d) }), c) }, "bindPhone": function (c) { var u = this, d = u.options.url.bindPhone + "/" + u.options.appid; u.getChallenge((function (c) { u.formToIFrame(u.bridging(c), d) }), c) }, "checkPhone": function (c) { this.getMethod(c, this.options.url.checkPhone) }, "checkUserPhoneBind": function (c) { var u = this.options.url.checkUserPhoneBind + "/" + this.options.appid; this.getMethod(c, u) }, "passportLogin": function (c) { var u = this, d = u.options.url.passportLogin + "/" + u.options.appid; c.params.password = Z.md5(c.params.password), u.getChallenge((function (c) { u.formToIFrame(u.bridging(c), d) }), c) }, "scanCodeLogin": function (c) { var u = this, d = u.options.url.scanCodeLogin + "/" + u.options.appid; c.params.password = Z.md5(c.params.password), u.getChallenge((function (c) { u.formToIFrame(u.bridging(c), d) }), c) }, "getPhoneCode": function (c) { document.domain && "https://" + document.domain === G ? this.getMethod(c, G + "/i/mobile/phonecode") : this.getMethod(c, this.options.url.getPhoneCode) }, "getMobileCaptcha": function (c) { c.params.pagetoken = J; var u = this.options.url.getMobileCaptcha + "/" + c.params.captchaType; this.getMethod(c, u) }, "verifyMobileCaptcha": function (c) { var u = this.options.url.verifyMobileCaptcha; this.getMethod(c, u) }, "getSecmobileCaptcha": function (c) { var u = this.options.url.getSecmobileCaptcha + "/" + c.params.captchaType; this.getMethod(c, u) }, "verifySecmobileCaptcha": function (c) { var u = this.options.url.verifySecmobileCaptcha + "/" + c.params.captchaType; this.getMethod(c, u) }, "queryCertificateStaus": function (c) { this.getMethod(c, this.options.url.queryCertificateStaus) }, "userCertificate": function (c) { this.getMethod(c, this.options.url.userCertificate) }, "getAICaptcha": function (c) { this.getMethod(c, this.options.url.getAICaptcha) }, "verifyAICaptcha": function (c) { var u = this, d = u.options.url.verifyAICaptcha; u.getChallenge((function (c) { u.formToIFrame(u.bridging(c), d) }), c) } }, c.SohuPassport = t, t })); var R, U = e(k.exports), H = { "exports": {} }; R = H, function (c, u) { R.exports ? R.exports = u(c) : c.SohuPassport = u(c) }(window, (function (c) { function t(c) { var u = this; c.onekeyId && (Z.autoLoadScript("https://passportv4-web.bjcnc.scs.sohucs.com/crypto-js.min.js", (function (c) { u.cryptoLoaded = c })), Z.autoLoadScript("https://www.cmpassport.com/h5/js/jssdk_auth/jssdk.min.js", (function (c) { u.ydrzLoaded = c }))), this.options = Z.extend({}, W, c || {}), this._id = "passport" + E.replace(/\D/g, ""), this.version = E, this.appid = this.options.appid, this.options.gidinf && this.options.serialno && (l("gidinf", this.options.gidinf), l("srn", this.options.serialno)), R ? l("t", k) : l("t", k, U), this.setCommonCookie() } var u, d, v = (d = (u = c).opera ? opera.version().replace(/\d$/, "") - 0 : parseFloat((/(?:IE |fox\/|ome\/|ion\/)(\d+\.\d)/.exec(navigator.userAgent) || [, 0])[1]), { "ie": !!u.VBArray && Math.max(document.documentMode || 0, d), "firefox": !!u.netscape && d, "opera": !!u.opera && d, "chrome": !!u.chrome && d, "safari": /apple/i.test(navigator.vendor) && d }), E = "test", k = (new Date).getTime(), R = /\.sohu.com/.test(location.host), U = 2 == document.domain.split(".").length ? document.domain : document.domain.split(".").slice(document.domain.split(".").length - 2).join("."), H = v.ie && v.ie < 9 ? "https://tstm.passport.sohu.com/i/".replace("https", "http") : R ? "https://tstm.passport.sohu.com/i/" : "https://v4-passport.56.com/i/", G = "https://tstm.passport.sohu.com", W = { "appid": "", "url": { "commonCookie": H + "cookie/common", "challenge": H + "jf/code", "loginByUserId": H + "login", "loginRequireCaptcha": H + "login/require/captcha", "mobileLogin": H + "login/mobile", "quickLogin": H + "login/quick", "passportLogin": H + "login/passport", "scanCodeLogin": H + "login/token", "pictureCaptcha": H + "captcha/picture", "signInCaptcha": H + "smcode/mobile/signin", "registerCaptcha": H + "smcode/mobile/signup", "newRegisterCaptcha": H + "smcode/mobile/esignup", "bindPhoneCaptcha": H + "smcode/mobile/sblmobile", "logout": H + "logout", "register": H + "register", "registerUp": H + "register/v2", "bindPhone": H + "login/bind/mobile", "checkPhone": H + "verify/mobile/bind", "checkUserPhoneBind": H + "verify/user/mobile", "getPhoneCode": H + "mobile/phonecode", "getMobileCaptcha": H + "smcode/mobile/v2", "verifyMobileCaptcha": H + "verify/smcode/mobile", "getSecmobileCaptcha": H + "smcode/secmobile", "verifySecmobileCaptcha": H + "verify/smcode/secmobile", "queryCertificateStaus": H + "certificate/query/passport", "userCertificate": H + "certificate/create", "getAICaptcha": H + "captcha/npicture", "verifyAICaptcha": H + "captcha/nvalid", "resetPassword": H + "password/reset2", "updatePassword": H + "password/update2", "verifySecmobCaptcha": H + "login/security/secmob" } }, Z = { "extend": function () { var c, u, d, v, E = arguments[0] || {}, k = arguments.length; for (c = 1; c < k; c++)if (null !== (d = arguments[c])) for (u in d) void 0 !== (v = d[u]) && (E[u] = v); return E }, "inArray": function (c, u) { for (var d = 0; d < u.length; d++)if (u[d] === c) return d; return -1 }, "isString": function (c) { return "string" == typeof c }, "isFunction": function (c) { return "function" == typeof c }, "isBool": function (c) { return "boolean" == typeof c }, "bind": function (c, u) { return function () { c.apply(u, arguments) } }, "trim": function (c) { return this.isString(c) ? c.replace(/^\s+/, "").replace(/\s+$/, "") : c }, "param": function (c) { var u = []; for (var d in c) u.push(d + "=" + c[d]); return u.join("&") }, "url": function (c, u) { return c + (/\?/.test(c) ? "&" : "?") + this.param(u) }, "md5": function (c) { function t(c, u, d, v, E, k) { return a((R = a(a(u, c), a(v, k))) << (U = E) | R >>> 32 - U, d); var R, U } function o(c, u, d, v, E, k, R) { return t(u & d | ~u & v, c, u, E, k, R) } function n(c, u, d, v, E, k, R) { return t(u & v | d & ~v, c, u, E, k, R) } function i(c, u, d, v, E, k, R) { return t(u ^ d ^ v, c, u, E, k, R) } function r(c, u, d, v, E, k, R) { return t(d ^ (u | ~v), c, u, E, k, R) } function a(c, u) { var d = (65535 & c) + (65535 & u); return (c >> 16) + (u >> 16) + (d >> 16) << 16 | 65535 & d } var u; return function (c) { for (var u = "0123456789abcdef", d = "", v = 0; v < 4 * c.length; v++)d += u.charAt(c[v >> 2] >> v % 4 * 8 + 4 & 15) + u.charAt(c[v >> 2] >> v % 4 * 8 & 15); return d }(function (c, u) { c[u >> 5] |= 128 << u % 32, c[14 + (u + 64 >>> 9 << 4)] = u; for (var d = 1732584193, v = -271733879, E = -1732584194, k = 271733878, R = 0; R < c.length; R += 16) { var U = d, H = v, G = E, W = k; d = o(d, v, E, k, c[R + 0], 7, -680876936), k = o(k, d, v, E, c[R + 1], 12, -389564586), E = o(E, k, d, v, c[R + 2], 17, 606105819), v = o(v, E, k, d, c[R + 3], 22, -1044525330), d = o(d, v, E, k, c[R + 4], 7, -176418897), k = o(k, d, v, E, c[R + 5], 12, 1200080426), E = o(E, k, d, v, c[R + 6], 17, -1473231341), v = o(v, E, k, d, c[R + 7], 22, -45705983), d = o(d, v, E, k, c[R + 8], 7, 1770035416), k = o(k, d, v, E, c[R + 9], 12, -1958414417), E = o(E, k, d, v, c[R + 10], 17, -42063), v = o(v, E, k, d, c[R + 11], 22, -1990404162), d = o(d, v, E, k, c[R + 12], 7, 1804603682), k = o(k, d, v, E, c[R + 13], 12, -40341101), E = o(E, k, d, v, c[R + 14], 17, -1502002290), d = n(d, v = o(v, E, k, d, c[R + 15], 22, 1236535329), E, k, c[R + 1], 5, -165796510), k = n(k, d, v, E, c[R + 6], 9, -1069501632), E = n(E, k, d, v, c[R + 11], 14, 643717713), v = n(v, E, k, d, c[R + 0], 20, -373897302), d = n(d, v, E, k, c[R + 5], 5, -701558691), k = n(k, d, v, E, c[R + 10], 9, 38016083), E = n(E, k, d, v, c[R + 15], 14, -660478335), v = n(v, E, k, d, c[R + 4], 20, -405537848), d = n(d, v, E, k, c[R + 9], 5, 568446438), k = n(k, d, v, E, c[R + 14], 9, -1019803690), E = n(E, k, d, v, c[R + 3], 14, -187363961), v = n(v, E, k, d, c[R + 8], 20, 1163531501), d = n(d, v, E, k, c[R + 13], 5, -1444681467), k = n(k, d, v, E, c[R + 2], 9, -51403784), E = n(E, k, d, v, c[R + 7], 14, 1735328473), d = i(d, v = n(v, E, k, d, c[R + 12], 20, -1926607734), E, k, c[R + 5], 4, -378558), k = i(k, d, v, E, c[R + 8], 11, -2022574463), E = i(E, k, d, v, c[R + 11], 16, 1839030562), v = i(v, E, k, d, c[R + 14], 23, -35309556), d = i(d, v, E, k, c[R + 1], 4, -1530992060), k = i(k, d, v, E, c[R + 4], 11, 1272893353), E = i(E, k, d, v, c[R + 7], 16, -155497632), v = i(v, E, k, d, c[R + 10], 23, -1094730640), d = i(d, v, E, k, c[R + 13], 4, 681279174), k = i(k, d, v, E, c[R + 0], 11, -358537222), E = i(E, k, d, v, c[R + 3], 16, -722521979), v = i(v, E, k, d, c[R + 6], 23, 76029189), d = i(d, v, E, k, c[R + 9], 4, -640364487), k = i(k, d, v, E, c[R + 12], 11, -421815835), E = i(E, k, d, v, c[R + 15], 16, 530742520), d = r(d, v = i(v, E, k, d, c[R + 2], 23, -995338651), E, k, c[R + 0], 6, -198630844), k = r(k, d, v, E, c[R + 7], 10, 1126891415), E = r(E, k, d, v, c[R + 14], 15, -1416354905), v = r(v, E, k, d, c[R + 5], 21, -57434055), d = r(d, v, E, k, c[R + 12], 6, 1700485571), k = r(k, d, v, E, c[R + 3], 10, -1894986606), E = r(E, k, d, v, c[R + 10], 15, -1051523), v = r(v, E, k, d, c[R + 1], 21, -2054922799), d = r(d, v, E, k, c[R + 8], 6, 1873313359), k = r(k, d, v, E, c[R + 15], 10, -30611744), E = r(E, k, d, v, c[R + 6], 15, -1560198380), v = r(v, E, k, d, c[R + 13], 21, 1309151649), d = r(d, v, E, k, c[R + 4], 6, -145523070), k = r(k, d, v, E, c[R + 11], 10, -1120210379), E = r(E, k, d, v, c[R + 2], 15, 718787259), v = r(v, E, k, d, c[R + 9], 21, -343485551), d = a(d, U), v = a(v, H), E = a(E, G), k = a(k, W) } return Array(d, v, E, k) }(function (c) { for (var u = Array(), d = 0; d < 8 * c.length; d += 8)u[d >> 5] |= (255 & c.charCodeAt(d / 8)) << d % 32; return u }(u = c), 8 * u.length)) }, "autoLoadScript": function (c, u) { var d = document.createElement("script"), v = document.getElementsByTagName("head")[0]; d.charset = "UTF-8", d.async = !0, d.onerror = function () { u && u(!1) }; var E = !1; d.onload = d.onreadystatechange = function () { E || d.readyState && "loaded" !== d.readyState && "complete" !== d.readyState || (E = !0, u && u(!0)) }, d.src = c, v.appendChild(d) } }, m = function (c) { var u, d = new RegExp("(^| )" + c + "=([^;]*)(;|$)"); return (u = document.cookie.match(d)) ? unescape(u[2]) : null }, l = function (c, u, d) { var v = new Date; v.setTime(v.getTime() + 2592e6), document.cookie = d ? c + "=" + escape(u) + ";domain=" + d + ";path=/;expires=" + v.toGMTString() : c + "=" + escape(u) + ";domain=sohu.com;path=/;expires=" + v.toGMTString() }, Y = k + 1, J = k + 2, K = k + 3; return t.prototype = { "onekeyLogin": function (c) { function t(c, u) { var d, v = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""), E = []; if (u = u || v.length, c) for (d = 0; d < c; d++)E[d] = v[0 | Math.random() * u]; return E.join("") } function o(c, u) { for (var d = String(c), v = u - d.length; v > 0; v--)d = "0" + d; return d } function n(u) { var E = { "appid": d, "token": u.token, "traceid": t(32, 32), "userInformation": u.userInformation }; v.quickLogin({ "success": function (u, d) { c.success && c.success(u, d) }, "error": function (u) { c.error && c.error(u) }, "params": E }) } function i(u) { c.getTokenError && c.getTokenError(u) } var u, d = this.appid, v = this, E = { "version": "2.0", "timestamp": (u = new Date, o(u.getFullYear(), 4) + o(u.getMonth() + 1, 2) + o(u.getDate(), 2) + o(u.getHours(), 2) + o(u.getMinutes(), 2) + o(u.getSeconds(), 2) + o(u.getMilliseconds(), 3)), "appId": this.options.onekeyId, "appkey": this.options.onekeyKey, "businessType": "8", "openType": 1, "traceId": t(32, 32), "expandParams": "", "isTest": "" }, k = 0; !function e() { if (v.cryptoLoaded && v.ydrzLoaded && CryptoJS && CryptoJS.MD5) { var c = CryptoJS.MD5(E.appId + E.businessType + E.traceId + E.timestamp + E.traceId + E.version + E.appkey).toString(); YDRZ.getTokenInfo({ "data": { "version": E.version, "appId": E.appId, "sign": c, "traceId": E.traceId, "timestamp": E.timestamp, "openType": E.openType, "expandParams": E.expandParams, "isTest": E.isTest }, "success": n, "error": i }) } else ++k < 30 && setTimeout(e, 100) }() }, "getNetType": function (c, u) { var d = this, v = 0; !function i() { if (d.cryptoLoaded && d.ydrzLoaded) { var E = YDRZ.getConnection(c); u && u({ "netType": E.netType, "platform": navigator.platform, "userAgent": navigator.userAgent }) } else ++v < 30 && setTimeout(i, 100) }() }, "setCommonCookie": function (c) { if (R ? l("t", k) : l("t", k, U), m("gidinf") && m("reqtype")) c && c(); else { var u = this.options.url.commonCookie, d = { "callback": "?" }; R || (d.domain = U), u = Z.url(u, d), this.getJSONP(u, c) } }, "bridging": function (c) { var u = { "error": c.error, "success": c.success }, d = c.params || {}; return c.params && c.params.appid || (d.appid = this.options.appid), d.callback = function (c) { if (c) { var d = c.body; 200 === Number(c.status) || 201 === Number(c.status) || 206 === Number(c.status) ? u.success && u.success(d, c.status) : u.error && u.error(c) } else u.error && u.error(c) }, d }, "randomName": function (c) { return this._id + "_" + c + k++ }, "getJSONP": function (u, d, v) { var E, k = this.randomName("cb"), R = document.getElementsByTagName("head")[0], U = document.createElement("script"), H = (new Date).getTime(); E = (u = u.replace(/(=)\?(?=&|$)|\?\?/, "$1" + k)).replace(/([?&])_=[^&]*/, "$1_=" + H), u = E + (E === u ? (/\?/.test(u) ? "&" : "?") + "_=" + H : ""), c[k] = function (u) { Z.isFunction(d) && d(u), setTimeout((function () { c[k] = void 0, R.removeChild(U) }), 1) }, U.type = "text/javascript", U.charset = v || "UTF-8", U.src = u, U.onerror = function (u) { c[k]({ "status": 500 }) }, R.appendChild(U) }, "getMethod": function (c, u) { var d = this.bridging(c), v = d.callback; d.callback = "?", u = Z.url(u, d), this.getJSONP(u, v) }, "getChallenge": function (u, d) { R ? l("t", k) : l("t", k, U); var v = this; this.setCommonCookie((function () { var E = { "callback": "?", "type": R ? 0 : 1 }, k = Z.url(v.options.url.challenge, E); v.getJSONP(k, (function (v) { c.eval(v), d.params = d.params || {}, !R && document._jv && (d.params._jv = document._jv), u && u(d) })) })) }, "getChallengeWithoutCookieSet": function (u, d) { var v = { "callback": "?", "type": R ? 0 : 1 }, E = Z.url(this.options.url.challenge, v); this.getJSONP(E, (function (v) { c.eval(v), d.params = d.params || {}, !R && document._jv && (d.params._jv = document._jv), u && u(d) })) }, "createIFrame": function (c) { var u; return c = c || this.randomName("passportIframe"), v.ie && v.ie < 9 ? u = document.createElement('<iframe src="about:blank" name="' + c + '"></iframe>') : (u = document.createElement("iframe")).setAttribute("name", c), u.style.display = "none", document.body.appendChild(u), u }, "createForm": function (c, u) { var d, v, E, k = document.createElement("form"); for (v in c) E = c[v], (d = document.createElement("input")).type = "hidden", d.name = v, d.value = E, k.appendChild(d); return k.style.display = "none", u ? u.appendChild(k) : document.body.appendChild(k), k }, "formData": function (c, u) { var d = {}; for (var v in c) c[v] && ("password" === v ? d.password = Z.trim(c.password) : d[v] = Z.trim(c[v])); return d }, "ajax_post": function (u, d, v) { var E = function (c) { var u = []; for (var d in c) u.push(encodeURIComponent(d) + "=" + encodeURIComponent(c[d])); return u.join("&") }(d); if (c.XMLHttpRequest) var k = new XMLHttpRequest; else k = new ActiveXObject("Microsoft.XMLHTTP"); k.onreadystatechange = function () { 4 == k.readyState && v && v(JSON.parse(k.responseText)) }, k.open("POST", u, !0), k.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), k.withCredentials = !0, k.send(E) }, "formToIFrame": function (u, d) { if (u.ru) { var v = this, E = u.callback; c.addEventListener("message", (function t(u) { "https://sso.56.com" === u.origin && E && (Z.bind(E, v)({ "status": 200, "msg": "success", "body": { "msg": "success", "accountType": 1, "account": "shunm_56122654732", "loginMode": "", "jump": "" } }), E = null, c.removeEventListener("message", t)) })), this._iframe = this.createIFrame(), this._iframeWindow = this._iframe.contentWindow, this._iframeWindow.ajax_post = function (u, d, E) { var k = function (c) { var u = []; for (var d in c) u.push(encodeURIComponent(d) + "=" + encodeURIComponent(c[d])); return u.join("&") }(d); if (c.XMLHttpRequest) var R = new XMLHttpRequest; else R = new ActiveXObject("Microsoft.XMLHTTP"); R.onreadystatechange = function () { 4 == R.readyState && JSON.parse(R.responseText) && JSON.parse(R.responseText).ru && (v._iframeWindow.location.href = JSON.parse(R.responseText).ru) }, R.open("POST", u, !0), R.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), R.withCredentials = !0, R.send(k) }, u.nf = 1, u.callback && (k = Z.bind(u.callback, this)), delete u.callback, this._iframeWindow.ajax_post(d, this.formData(u), k) } else { var k; u.nf = 1, u.callback && (k = Z.bind(u.callback, this)), delete u.callback, this.ajax_post(d, this.formData(u), k) } }, "createIFrameQRCode": function (c) { var u; return c = c || this.randomName("passportIframe"), v.ie && v.ie < 9 ? u = document.createElement('<iframe src="about:blank" name="' + c + '" width="150px" height="150px"></iframe>') : ((u = document.createElement("iframe")).setAttribute("name", c), u.height = "150px", u.width = "150px", u.setAttribute("frameBorder", 0)), u }, "getQRCode": function (c) { var u = this, d = { "success": function (d) { d.qrurl = "https://usr.mb.hd.sohu.com/pc/getqr.json?qrtoken=cab088c91e9647599dd5dd5eca0bec1c&code=283ffbf7792f1565cbf5a3d927e48822", d.qrtoken = "cab088c91e9647599dd5dd5eca0bec1c"; var v = u.createIFrameQRCode(); v.src = d.qrurl, document.getElementById(c.params.id).appendChild(v), u.queryQRCodeStatus() }, "error": function (c) { }, "params": { "pagetoken": (new Date).getTime() } }; this.createQRCode(d) }, "createQRCode": function (c) { this.getMethod(c, this.options.url.getAICaptcha) }, "queryQRCodeStatus": function (c) { this.getMethod(c, this.options.url.getAICaptcha) }, "verifySecmobCaptcha": function (c) { var u = this, d = u.options.url.verifySecmobCaptcha + "/" + (c.params.appid || u.options.appid); u.getChallenge((function (c) { u.formToIFrame(u.bridging(c), d) }), c) }, "resetPassword": function (c) { if (m("exp")) { var u = this, d = u.options.url.resetPassword; u.formToIFrame(u.bridging(c), d) } }, "updatePassword": function (c) { var u = this, d = u.options.url.updatePassword; u.formToIFrame(u.bridging(c), d) }, "login": function (c) { var u = this, d = u.options.url.loginByUserId + "/" + (c.params.appid || u.options.appid); c.params.password = Z.md5(c.params.password), c.params.captcha && (c.params.pagetoken = Y), u.getChallenge((function (c) { u.formToIFrame(u.bridging(c), d) }), c) }, "loginRequireCaptcha": function (c) { this.getMethod(c, this.options.url.loginRequireCaptcha) }, "mobileLogin": function (c) { var u = this, d = u.options.url.mobileLogin + "/" + u.options.appid; u.getChallenge((function (c) { u.formToIFrame(u.bridging(c), d) }), c) }, "quickLogin": function (c) { var u = this, d = u.options.url.quickLogin + "/" + u.options.appid; u.getChallenge((function (c) { u.formToIFrame(u.bridging(c), d) }), c) }, "getThirdLoginUrl": function (c) { if ("weChat" === c.provider) { var u = ""; return c.wxParams && (u = "&selfRedirect=" + (c.wxParams.self_redirect || "") + "&style=" + (c.wxParams.style || "") + "&href=" + (c.wxParams.href || "")), "https://plus.sohu.com/spassport/bind/" + this.options.appid + "/wechat?ru=" + c.ru + (R ? "" : "&pua=true") + u } return "//passport.sohu.com/openlogin/request.action?provider=" + c.provider + "&appid=" + this.options.appid + "&ru=" + c.ru + (R ? "" : "&pua=true") }, "getWechatMPLoginUrl": function (c) { return H.substring(0, H.length - 2) + "/oauth/loginurl?appid=" + this.options.appid + "&openkey=" + c.openkey + "&platform=wechat&ru=" + c.ru }, "logout": function (c) { var u = this, d = u.options.url.logout + "/" + u.options.appid; u.getChallengeWithoutCookieSet((function (c) { u.formToIFrame(u.bridging(c), d) }), c) }, "getLoginPicture": function () { return this.options.url.pictureCaptcha + "?pagetoken=" + Y + "&random=" + this.randomName("sdk") }, "getPhonePicture": function () { return this.options.url.pictureCaptcha + "?pagetoken=" + J + "&random=" + this.randomName("sdk") }, "getRegisterPicture": function () { return this.options.url.pictureCaptcha + "?pagetoken=" + K + "&random=" + this.randomName("sdk") }, "getSignInCaptcha": function (c) { c.params.pagetoken = J, this.getMethod(c, this.options.url.signInCaptcha) }, "getRegisterCaptcha": function (c) { c.params.pagetoken = K, this.getMethod(c, this.options.url.registerCaptcha) }, "getNewRegisterCaptcha": function (c) { c.params.pagetoken = K, this.getMethod(c, this.options.url.newRegisterCaptcha) }, "getBindPhoneCaptcha": function (c) { this.getMethod(c, this.options.url.bindPhoneCaptcha) }, "register": function (c) { var u = this, d = u.options.url.register + "/" + u.options.appid; u.getChallenge((function (c) { u.formToIFrame(u.bridging(c), d) }), c) }, "registerUp": function (c) { var u = this, d = u.options.url.registerUp + "/" + u.options.appid; u.getChallenge((function (c) { u.formToIFrame(u.bridging(c), d) }), c) }, "bindPhone": function (c) { var u = this, d = u.options.url.bindPhone + "/" + u.options.appid; u.getChallenge((function (c) { u.formToIFrame(u.bridging(c), d) }), c) }, "checkPhone": function (c) { this.getMethod(c, this.options.url.checkPhone) }, "checkUserPhoneBind": function (c) { var u = this.options.url.checkUserPhoneBind + "/" + this.options.appid; this.getMethod(c, u) }, "passportLogin": function (c) { var u = this, d = u.options.url.passportLogin + "/" + u.options.appid; c.params.password = Z.md5(c.params.password), u.getChallenge((function (c) { u.formToIFrame(u.bridging(c), d) }), c) }, "scanCodeLogin": function (c) { var u = this, d = u.options.url.scanCodeLogin + "/" + u.options.appid; c.params.password = Z.md5(c.params.password), u.getChallenge((function (c) { u.formToIFrame(u.bridging(c), d) }), c) }, "getPhoneCode": function (c) { document.domain && "https://" + document.domain === G ? this.getMethod(c, G + "/i/mobile/phonecode") : this.getMethod(c, this.options.url.getPhoneCode) }, "getMobileCaptcha": function (c) { c.params.pagetoken = J; var u = this.options.url.getMobileCaptcha + "/" + c.params.captchaType; this.getMethod(c, u) }, "verifyMobileCaptcha": function (c) { var u = this.options.url.verifyMobileCaptcha; this.getMethod(c, u) }, "getSecmobileCaptcha": function (c) { var u = this.options.url.getSecmobileCaptcha + "/" + c.params.captchaType; this.getMethod(c, u) }, "verifySecmobileCaptcha": function (c) { var u = this.options.url.verifySecmobileCaptcha + "/" + c.params.captchaType; this.getMethod(c, u) }, "queryCertificateStaus": function (c) { this.getMethod(c, this.options.url.queryCertificateStaus) }, "userCertificate": function (c) { this.getMethod(c, this.options.url.userCertificate) }, "getAICaptcha": function (c) { this.getMethod(c, this.options.url.getAICaptcha) }, "verifyAICaptcha": function (c) { var u = this, d = u.options.url.verifyAICaptcha; u.getChallenge((function (c) { u.formToIFrame(u.bridging(c), d) }), c) } }, c.SohuPassport = t, t })); var G = e(H.exports), W = function () { var c = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], u = c ? "PROD" : "prod", d = window.location.host; return /^(t3\.m|n\.m|feed\.m|m|pre\.beta\.www|www)\.sohu(\.com)?/.test(d) || (u = c ? "TEST" : "test"), /^(t3\.m|pre\.beta\.www)\.sohu(\.com)?/.test(d) && (u = c ? "PRE" : "pre"), u }(), Z = { "appid": "116006" }, Y = { "dev": "//test-uis.mp.sohu.com/v3/uc", "test": "//test-uis.mp.sohu.com/v3/uc", "pre": "//pre-uis.mp.sohu.com/v3/uc", "prod": "//uis.mp.sohu.com/v3/uc" }, J = "MPTCFEMOBILEUSER", K = 100016, X = { "appkey": "4003", "secret": "395e615ffa1fdc85dd072387d6b75ba4", "loginUrl": Y[W], "loginUrlMap": Y }, Q = d(1748), ee = d.n(Q); function StorageUtil_e(c) { this._store = {}, this.StorageName = c + "Storage" } StorageUtil_e.prototype = { "constructor": StorageUtil_e, "setItem": function (c, u, d) { this.removeItem(c); var v = (new Date).getTime(), E = { "_value": u }; return d && (E._expire = v + d), this.isSupportStorage ? (window[this.StorageName].setItem(c, JSON.stringify(E)), this._store[c] = JSON.stringify(E)) : this._store[c] = JSON.stringify(E), E }, "getItem": function (c) { var u = this.isSupportStorage ? JSON.parse(window[this.StorageName].getItem(c)) : this._store[c] && JSON.parse(this._store[c]), d = (new Date).getTime(); return u ? u._expire && d > u._expire ? null : u._value : null }, "removeItem": function (c) { window[this.StorageName].removeItem(c) }, "isSupportStorage": function () { var c, u = "isSupportStorage"; try { c = window[this.StorageName] } catch (u) { return c = null, !1 } if (c) try { return c.setItem(u, u), c.removeItem(u), !0 } catch (c) { return !1 } return !1 } }; var te = e({ "localStorageUtil": new StorageUtil_e("local") }), ne = e({ "get": function (c) { var u = new RegExp("\\b" + c + "=([^;]*)\\b").exec(document.cookie); return u ? decodeURIComponent(u[1]) : null }, "set": function (c, u, d, v, E, k) { var R = d || null, U = v || "/", H = E || null, G = k || !1, W = new Date; "number" == typeof R && (W.setTime(W.getTime() + Number(R)), R = W), document.cookie = c + "=" + encodeURIComponent(u) + (null === R ? "" : "; expires=" + R.toGMTString()) + (null === U ? "" : "; path=" + U) + (null === H ? "" : "; domain=" + H) + (!0 === G ? "; secure" : "") }, "remove": function (c, u, d) { this.get(c) && (u = u || "/", document.cookie = c + "=; expires=Thu, 01-Jan-70 00:00:01 GMT; path=" + u + (d ? "; domain=" + d : "")) } }), re = ne, oe = te.localStorageUtil, MptcfeLoginUtil_c = function (c) { return { "success": c && c.successFun || c.success || function () { }, "error": c && c.failureFun || c.error || function () { }, "params": c && c.params || {} } }, ie = function r(c, u, d) { return u && function (c, u) { for (var d = 0; d < u.length; d++) { var v = u[d]; v.enumerable = v.enumerable || !1, v.configurable = !0, "value" in v && (v.writable = !0), Object.defineProperty(c, o(v.key), v) } }(c.prototype, u), Object.defineProperty(c, "prototype", { "writable": !1 }), c }((function e(c) { (function _rollupPluginBabelHelpers_e(c, u) { if (!(c instanceof u)) throw new TypeError("Cannot call a class as a function") })(this, e), this.passport = function (c) { return new ("prod" === (c.env || W) ? U : G)(c.passportConfig || Z) }(c || {}) }), [{ "key": "login", "value": function (c) { !function (c) { var u = c.env || W, d = c && c.successFun || function () { }, v = c && c.failureFun || function () { }, E = c && c.device || J, k = c && c.appId || K, R = c && c.loginSide || 4; ee()({ "url": X.loginUrlMap[u] + "/login", "method": "POST", "data": { "appId": k, "device": E, "loginSide": R }, "withCredentials": !0 }).then((function (c) { try { c && c.data && 1 == c.data.code ? d(c.data) : v(c.data) } catch (c) { v(c) } })).catch((function (c) { v(c) })) }(c) } }, { "key": "checkLogin", "value": function (c) { !function (c) { var u = c.env || W, d = c && c.successFun || function () { }, v = c && c.failureFun || function () { }, E = c && c.device || J, k = c && c.appId || K, R = X.loginUrlMap[u] || X.loginUrlMap.prod; ee()({ "url": R + "/user/info?appId=".concat(k, "&device=").concat(E), "method": "GET", "withCredentials": !0 }).then((function (c) { try { c && c.data && 1 == c.data.code ? d(c.data) : c && c.data && (200001 == c.data.code || 200002 == c.data.code || 200003 == c.data.code || 200006 == c.data.code || 200007 == c.data.code) ? ee()({ "url": R + "/refresh/token?appId=".concat(k, "&device=").concat(E), "method": "GET", "withCredentials": !0 }).then((function (c) { try { c && c.data && 1 == c.data.code ? d(c.data) : v(c.data) } catch (c) { v(c) } })).catch((function (c) { v(c) })) : v(c.data) } catch (c) { v(c) } })).catch((function (c) { v(c) })) }(c) } }, { "key": "accountLogin", "value": function (c) { this.passport.login(MptcfeLoginUtil_c(c)) } }, { "key": "getPhonePicture", "value": function () { return this.passport.getPhonePicture() } }, { "key": "getLoginPicture", "value": function () { return this.passport.getLoginPicture() } }, { "key": "getSignInCaptcha", "value": function (c) { this.passport.getSignInCaptcha(MptcfeLoginUtil_c(c)) } }, { "key": "getMobileCaptcha", "value": function (c) { this.passport.getMobileCaptcha(MptcfeLoginUtil_c(c)) } }, { "key": "logout", "value": function (c) { this.passport.logout({ "success": function (u, d) { (c && c.successFun || c.success || function () { })(u, d), re.remove("user_id", "/", ".sohu.com"), re.remove("umab_access_token", "/", ".sohu.com"), re.remove("umab_refresh_token", "/", ".sohu.com"), oe.removeItem("userinfo"), oe.removeItem("userProfile") }, "error": c && c.failureFun || c.error || function () { }, "params": c && c.params || {} }) } }, { "key": "mobileLogin", "value": function (c) { this.passport.mobileLogin(MptcfeLoginUtil_c(c)) } }, { "key": "thirdLogin", "value": function (c) { return this.passport.getThirdLoginUrl({ "provider": c && c.provider || "qq", "ru": c && c.ru || encodeURIComponent("https://m.sohu.com") }) } }, { "key": "getWechatMPLoginUrl", "value": function (c) { var u = { "openkey": c.openkey || "wxb5f6e60eb862aab9", "ru": c && c.ru || encodeURIComponent("https://m.sohu.com") }; return passport.getWechatMPLoginUrl(u) } }, { "key": "onekeyLogin", "value": function (c) { var u = MptcfeLoginUtil_c(c); u.getTokenError = c.getTokenError, this.passport.onekeyLogin(u) } }, { "key": "getNetType", "value": function (c) { this.passport.getNetType(this.passport.options.onekeyId, c) } }]), ae = d(606), se = d(2474), ce = d(7503), le = d(5660), ue = d(1490), de = d(2762), pe = d(4809), fe = d(9033), he = { "development": "test", "test": "test", "production": "prod" }[ae.OB] || "prod", me = new ie({ "passportConfig": { "appid": "100023" }, "env": he }); var ge = { "passport": me.passport, "checkLoginState": function checkLoginState(c) { var u = le.Z.getItem(ae.a9.accessTokenName); if (!(u && u.length > 0)) return me.checkLogin((0, v.Z)((0, v.Z)({ "env": he }, c), {}, { "successFun": function successFun(u) { u && 1 === u.code ? (se.Z.commit("base/updateUserInfo", (0, v.Z)({ "username": u.data.nickname }, u.data)), le.Z.setItem("userInfo", u.data), se.Z.commit("base/updateLoginStatus", !0), "function" == typeof c.successFun && c.successFun((0, v.Z)({ "username": u.data.nickname }, u.data))) : "function" == typeof c.failureFun && c.failureFun(u.msg) }, "failureFun": function failureFun(u) { console.log(u), se.Z.commit("base/updateLoginStatus", !1), se.Z.commit("base/updateUserInfo", {}), le.Z.removeItem("userInfo"), me.logout(), "function" == typeof c.failureFun && c.failureFun(u) } })); (0, pe.WY)({ "url": "".concat(ae.a9.baseInfoUrl, "/user/info"), "header": { "Authorization": u }, "data": { "appId": "100016", "device": fe.O.SUV }, "withCredentials": !0, "success": function success(u) { if (200 == u.statusCode) { var d = u.data.data; se.Z.commit("base/updateUserInfo", (0, v.Z)({ "username": d.nickname }, d)), le.Z.setItem("userInfo", d), se.Z.commit("base/updateLoginStatus", !0), "function" == typeof c.successFun && c.successFun((0, v.Z)({ "username": d.nickname }, u.data)) } else "function" == typeof c.failureFun && c.failureFun(u.msg) } }) }, "logout": me.logout, "loginClickHandler": function goLogin() { var c, u = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).spm, d = window.location.href; !function getFromLoginPath() { var c = window.location, u = window.location.pathname, d = se.Z.state.base.isNotHasLastPage; if (c.search.includes("detailId")) { u += "?detailId=" + (0, ce.SN)(window.location.href).detailId + "&notHasLastPage=" + d } else u += "?notHasLastPage=" + d; console.log("fromLoginPath", u), sessionStorage.setItem("fromLoginPath", u) }(); var v = (null === (c = ue.dK.currentTracker) || void 0 === c ? void 0 : c.getTrackerData()) || "", E = v.spmA, k = v.spmB, R = v.spmE; u = u || "".concat(E || de.Z.spmA, ".").concat(k || "home", ".0.0.").concat(R), le.Z.setItem("fromLoginPath", d), window.location.href = "".concat(function LoginUrl() { return ["dev", "debug", "test", "development"].includes(ae.OB) ? "https://test-m.sohu.com/login" : "https://m.sohu.com/login" }(), "?spm=").concat(u || "", "&r=").concat(encodeURIComponent(d)) } } }, "3363": function (c, u, d) { "use strict"; d.d(u, { "Z": function () { return Z }, "U": function () { return getCommonHeader } }); var v = d(1413), E = d(1724), k = d(4809), R = d(7503); function getSuv() { var c = function getCookie(c) { var u = new RegExp("".concat(c, "=([^;]*)\\b")).exec(document.cookie); return null != u && u.length ? decodeURIComponent(u[1]) : null }("SUV"); return c || Date.now() } var U = d(2843), H = d(606), G = !0, W = { "weapp": 1, "swan": 2, "tt": 3 }; function getCommonHeader(c) { var u = { "clientType": G ? 1 : 2, "requestId": (null == c ? void 0 : c.requestId) || (0, R.xu)() }; if (G) { var d = (0, R.uM)(); u = (0, v.Z)((0, v.Z)({}, u), {}, { "suv": getSuv(), "pvId": (0, R.Wf)(), "referSpm": d.spm, "referScm": (0, R.OD)(document.referrer).scm, "referPath": document.referrer, "refererSpm": (0, U.b3)(), "refererScm": d.scm, "refererPath": window.location.pathname, "trans": d.trans }) } else u = (0, v.Z)((0, v.Z)({}, u), {}, { "appletType": W.h5, "scene": 1129, "openId": (0, E.qu)("userId") }); for (var k in u) null == u[k] && delete u[k]; return u } function httpServer(c, u) { var d = u.url, R = u.data, U = u.headers, G = u.isRaw, W = u.token, Z = u.customHeaders, Y = getCommonHeader(U), J = (0, E.qu)(H.a9.accessTokenName), K = null, X = { "method": c, "url": d, "timeout": (null == U ? void 0 : U.timeout) || 1e4, "dataType": "json", "mode": "cors", "data": R, "credentials": "include", "header": Object.assign({}, { "Content-Type": "application/json; charset=UTF-8", "Authorization": W || J }, Y, U) }, Q = (K = new AbortController).signal; X.signal = Q, Z && (X.header = Z); var ee = null, te = new Promise((function (c, u) { (ee = (0, k.WY)((0, v.Z)((0, v.Z)({}, X), {}, { "success": function success(u) { var d, v; G ? c(u.data) : 200 === u.statusCode && 1 === (null === (d = u.data) || void 0 === d ? void 0 : d.code) ? c(null === (v = u.data) || void 0 === v ? void 0 : v.data) : c(!1) }, "fail": function fail(c) { u(!!G && c) } }))).abort = function () { return K.abort() } })); return te.requestTask = ee, te } var Z = ["get", "post", "put"].reduce((function (c, u) { return c[u] = httpServer.bind(null, u), c }), {}) }, "2762": function (c, u, d) { "use strict"; var v = d(3927), E = { "appId": "", "appName": "简单ai", "spmA": "smwp-ai", "appVersion": "3.1.3", "api": d(8362), "spmb": v.K4, "spmc": v.ff, "acode": v.Eq, "requestOptions": { "keepalive": !0 } }; u.Z = E }, "3927": function (c, u, d) { "use strict"; d.d(u, { "Eq": function () { return H }, "K4": function () { return R }, "ff": function () { return U }, "vX": function () { return G } }); var v = d(902), E = d(5429), k = d(1490), R = v.Z.spmCode.spmb, U = v.Z.spmCode.spmc, H = E.o, G = function reportWindowSA(c) { var u = c.acode, d = c.clkParam; if (u) if (d) { var v = {}; d.split(/[,;]/).map((function (c) { var u = c.indexOf(":"), d = c.slice(0, u), E = c.slice(u + 1); v[d] = "promptCh" == d ? decodeURIComponent(E) : E })), k.dK.trackAction(u, v) } else k.dK.trackAction(u) } }, "902": function (c, u, d) { "use strict"; var v = d(606), E = d(5429), k = v.uN.appId, R = v.uN.appName, U = v.uN.appVersion, H = E.n; u.Z = { "appName": R, "appId": k, "appVersion": U, "spmCode": { "spma": H, "spmb": { "home": "home", "textHome": "ai-assistant", "webview": "webview", "audit-page": "audit-page", "login": "login", "share": "share", "festival-card": "promotion-hc", "save-img": "save-img", "points-detail": "points-detail", "member-introduce": "member", "myspace": "myspace", "text-generate": "text-generate", "text-result": "text-generate", "generate": "generate", "points": "points", "preview": "preview", "setting": "setting", "text-to-image": "text-to-image", "image-to-image": "image-to-image", "product-image": "product-image", "identification-image": "identification-image", "enhance-image": "upscale-image", "eCard-generate": "promotion-bj", "eCard-result": "promotion-hc", "assistant-detail": "assistant-detail" }, "spmc": { "webview": { "": "0" }, "audit-page": { "": "0" }, "login": { "": "0" }, "share": { "": "0" }, "festival-card": { "": "0" }, "save-img": { "": "0" }, "myspace": { "user-info": "user-info", "setting": "setting", "feed-like": "feed-like", "feed-history": "feed-history", "feed-my": "feed-my" }, "generate": { "renew": "renew" } } } } }, "2843": function (c, u, d) { "use strict"; d.d(u, { "C2": function () { return getPageType }, "b3": function () { return generateSpmCode } }); var v = d(902), E = d(7503); function getPageType(c) { var u = c.match(/webview|festival-card|share|save-img|login|audit-page/g), d = ""; if (u && u[0]) switch (u[0]) { case "webview": d = "1001"; break; case "audit-page": d = "1002"; break; case "login": d = "1003"; break; case "share": d = "1004"; break; case "festival-card": d = "1005"; break; case "save-img": d = "1006"; break; default: d = "" }return d } function generateSpmCode(c, u) { return c && u ? "".concat(v.Z.spmCode.spma, ".").concat(v.Z.spmCode.spmb[c], ".").concat(v.Z.spmCode.spmc[c][u], ".0.").concat(function createSpmECode() { return (new Date).getTime() + (0, E.AL)(7) }()) : "" } }, "9033": function (c, u, d) { "use strict"; d.d(u, { "O": function () { return U } }); var v = d(5744), E = d(7503), k = (0, v.xI)(), R = "", U = { "device_brand": k.brand || "", "device_model": k.model || "", "device_res": k.screenWidth + "*" + k.screenHeight, "device_height": k.screenHeight, "device_width": k.screenWidth, "app_version": k.version || "", "os_version": k.system || "", "os_type": k.platform || "", "device_type": "phone", "SUV": function getUUID() { return R || (R = +new Date + (0, E.AL)()) }() } }, "7503": function (c, u, d) { "use strict"; d.d(u, { "V_": function () { return URLPrefix }, "Rz": function () { return addProtocol }, "vQ": function () { return copyToClipboard }, "GN": function () { return downloadImage }, "nV": function () { return formatPoint }, "mr": function () { return formatTime }, "AL": function () { return generateRand }, "_F": function () { return getAuditStatus }, "gu": function () { return getFormatTime }, "Wf": function () { return getPvId }, "An": function () { return getQueryByName }, "xu": function () { return getRequestId }, "SN": function () { return getRequestQuery }, "ah": function () { return getSigReqData }, "Jx": function () { return handleJump }, "s": function () { return isIos }, "pC": function () { return isNoHistoryLengthBrowser }, "SH": function () { return isWxBrowser }, "X0": function () { return jumpTo }, "Rl": function () { return jumpToCompleteUrl }, "sb": function () { return jumpToWebview }, "nZ": function () { return objectToQueryString }, "uM": function () { return queryString }, "OD": function () { return queryStringByUrl }, "P2": function () { return throttle }, "Pe": function () { return transformFeatureCardJson }, "eO": function () { return updateQueryUrl }, "JE": function () { return useNativeDownloadBrowser }, "Vj": function () { return uuid } }); var v = d(7762), E = d(4165), k = d(5861), R = d(885), U = d(5325), H = d(9663), G = d(5671), W = d(3144), Z = function fixNumber(c) { return c.toString().length < 2 ? "0" + c : c.toString() }, Y = function () { return (0, W.Z)((function Moment(c) { (0, G.Z)(this, Moment), this.time = new Date(c) }), [{ "key": "fromNow", "value": function fromNow() { var c = new Date, u = c.getTime() - this.time.getTime(); return u <= 6e5 ? "刚刚" : u <= 36e5 ? Math.round(u / 60 / 1e3) + "分钟前" : u <= 864e5 ? Math.round(u / 60 / 60 / 1e3) + "小时前" : c.getFullYear() == this.time.getFullYear() ? Z(this.time.getMonth() + 1) + "-" + Z(this.time.getDate()) + " " + Z(this.time.getHours()) + ":" + Z(this.time.getMinutes()) : this.time.getFullYear() + "-" + Z(this.time.getMonth() + 1) + "-" + Z(this.time.getDate()) } }, { "key": "format", "value": function format(c) { return c.replace("yyyy", this.time.getFullYear().toString()).replace("MM", Z(this.time.getMonth() + 1)).replace("dd", Z(this.time.getDate())).replace("HH", Z(this.time.getHours())).replace("mm", Z(this.time.getMinutes())).replace("ss", Z(this.time.getSeconds())) } }, { "key": "fixTime", "value": function fixTime() { var c = new Date; if (c.getFullYear() == this.time.getFullYear()) { var u = new Date(c.getFullYear(), c.getMonth(), c.getDate()), d = new Date(this.time.getFullYear(), this.time.getMonth(), this.time.getDate()); return u.getTime() - d.getTime() == 0 ? "今天 " + Z(this.time.getHours()) + ":" + Z(this.time.getMinutes()) : u.getTime() - d.getTime() <= 864e5 ? "昨天 " + Z(this.time.getHours()) + ":" + Z(this.time.getMinutes()) : this.fromNow() } return this.fromNow() } }, { "key": "fixNewTime", "value": function fixNewTime() { var c = new Date - this.time; return c < 0 || 0 == c || c < 6e4 ? "刚刚" : c < 36e5 ? Math.round(c / 6e4) + "分钟前" : c < 864e5 ? Math.round(c / 36e5) + "小时前" : c < 1728e5 ? "昨天" + this.format("HH:mm") : c < 2592e5 ? "前天" + this.format("HH:mm") : c < 6048e5 ? Math.round(c / 864e5) + "天前" : this.format("yyyy.MM.dd") } }]) }(), J = d(7853), K = 0, X = 8; function md5_cmn(c, u, d, v, E, k) { return safe_add(function bit_rol(c, u) { return c << u | c >>> 32 - u }(safe_add(safe_add(u, c), safe_add(v, k)), E), d) } function md5_ff(c, u, d, v, E, k, R) { return md5_cmn(u & d | ~u & v, c, u, E, k, R) } function md5_gg(c, u, d, v, E, k, R) { return md5_cmn(u & v | d & ~v, c, u, E, k, R) } function md5_hh(c, u, d, v, E, k, R) { return md5_cmn(u ^ d ^ v, c, u, E, k, R) } function md5_ii(c, u, d, v, E, k, R) { return md5_cmn(d ^ (u | ~v), c, u, E, k, R) } function safe_add(c, u) { var d = (65535 & c) + (65535 & u); return (c >> 16) + (u >> 16) + (d >> 16) << 16 | 65535 & d } var Q = function hex_md5(c) { return function binl2hex(c) { for (var u = K ? "0123456789ABCDEF" : "0123456789abcdef", d = "", v = 0; v < 4 * c.length; v++)d += u.charAt(c[v >> 2] >> v % 4 * 8 + 4 & 15) + u.charAt(c[v >> 2] >> v % 4 * 8 & 15); return d }(function core_md5(c, u) { c[u >> 5] |= 128 << u % 32, c[14 + (u + 64 >>> 9 << 4)] = u; for (var d = 1732584193, v = -271733879, E = -1732584194, k = 271733878, R = 0; R < c.length; R += 16) { var U = d, H = v, G = E, W = k; d = md5_ff(d, v, E, k, c[R + 0], 7, -680876936), k = md5_ff(k, d, v, E, c[R + 1], 12, -389564586), E = md5_ff(E, k, d, v, c[R + 2], 17, 606105819), v = md5_ff(v, E, k, d, c[R + 3], 22, -1044525330), d = md5_ff(d, v, E, k, c[R + 4], 7, -176418897), k = md5_ff(k, d, v, E, c[R + 5], 12, 1200080426), E = md5_ff(E, k, d, v, c[R + 6], 17, -1473231341), v = md5_ff(v, E, k, d, c[R + 7], 22, -45705983), d = md5_ff(d, v, E, k, c[R + 8], 7, 1770035416), k = md5_ff(k, d, v, E, c[R + 9], 12, -1958414417), E = md5_ff(E, k, d, v, c[R + 10], 17, -42063), v = md5_ff(v, E, k, d, c[R + 11], 22, -1990404162), d = md5_ff(d, v, E, k, c[R + 12], 7, 1804603682), k = md5_ff(k, d, v, E, c[R + 13], 12, -40341101), E = md5_ff(E, k, d, v, c[R + 14], 17, -1502002290), d = md5_gg(d, v = md5_ff(v, E, k, d, c[R + 15], 22, 1236535329), E, k, c[R + 1], 5, -165796510), k = md5_gg(k, d, v, E, c[R + 6], 9, -1069501632), E = md5_gg(E, k, d, v, c[R + 11], 14, 643717713), v = md5_gg(v, E, k, d, c[R + 0], 20, -373897302), d = md5_gg(d, v, E, k, c[R + 5], 5, -701558691), k = md5_gg(k, d, v, E, c[R + 10], 9, 38016083), E = md5_gg(E, k, d, v, c[R + 15], 14, -660478335), v = md5_gg(v, E, k, d, c[R + 4], 20, -405537848), d = md5_gg(d, v, E, k, c[R + 9], 5, 568446438), k = md5_gg(k, d, v, E, c[R + 14], 9, -1019803690), E = md5_gg(E, k, d, v, c[R + 3], 14, -187363961), v = md5_gg(v, E, k, d, c[R + 8], 20, 1163531501), d = md5_gg(d, v, E, k, c[R + 13], 5, -1444681467), k = md5_gg(k, d, v, E, c[R + 2], 9, -51403784), E = md5_gg(E, k, d, v, c[R + 7], 14, 1735328473), d = md5_hh(d, v = md5_gg(v, E, k, d, c[R + 12], 20, -1926607734), E, k, c[R + 5], 4, -378558), k = md5_hh(k, d, v, E, c[R + 8], 11, -2022574463), E = md5_hh(E, k, d, v, c[R + 11], 16, 1839030562), v = md5_hh(v, E, k, d, c[R + 14], 23, -35309556), d = md5_hh(d, v, E, k, c[R + 1], 4, -1530992060), k = md5_hh(k, d, v, E, c[R + 4], 11, 1272893353), E = md5_hh(E, k, d, v, c[R + 7], 16, -155497632), v = md5_hh(v, E, k, d, c[R + 10], 23, -1094730640), d = md5_hh(d, v, E, k, c[R + 13], 4, 681279174), k = md5_hh(k, d, v, E, c[R + 0], 11, -358537222), E = md5_hh(E, k, d, v, c[R + 3], 16, -722521979), v = md5_hh(v, E, k, d, c[R + 6], 23, 76029189), d = md5_hh(d, v, E, k, c[R + 9], 4, -640364487), k = md5_hh(k, d, v, E, c[R + 12], 11, -421815835), E = md5_hh(E, k, d, v, c[R + 15], 16, 530742520), d = md5_ii(d, v = md5_hh(v, E, k, d, c[R + 2], 23, -995338651), E, k, c[R + 0], 6, -198630844), k = md5_ii(k, d, v, E, c[R + 7], 10, 1126891415), E = md5_ii(E, k, d, v, c[R + 14], 15, -1416354905), v = md5_ii(v, E, k, d, c[R + 5], 21, -57434055), d = md5_ii(d, v, E, k, c[R + 12], 6, 1700485571), k = md5_ii(k, d, v, E, c[R + 3], 10, -1894986606), E = md5_ii(E, k, d, v, c[R + 10], 15, -1051523), v = md5_ii(v, E, k, d, c[R + 1], 21, -2054922799), d = md5_ii(d, v, E, k, c[R + 8], 6, 1873313359), k = md5_ii(k, d, v, E, c[R + 15], 10, -30611744), E = md5_ii(E, k, d, v, c[R + 6], 15, -1560198380), v = md5_ii(v, E, k, d, c[R + 13], 21, 1309151649), d = md5_ii(d, v, E, k, c[R + 4], 6, -145523070), k = md5_ii(k, d, v, E, c[R + 11], 10, -1120210379), E = md5_ii(E, k, d, v, c[R + 2], 15, 718787259), v = md5_ii(v, E, k, d, c[R + 9], 21, -343485551), d = safe_add(d, U), v = safe_add(v, H), E = safe_add(E, G), k = safe_add(k, W) } return Array(d, v, E, k) }(function str2binl(c) { for (var u = Array(), d = (1 << X) - 1, v = 0; v < c.length * X; v += X)u[v >> 5] |= (c.charCodeAt(v / X) & d) << v % 32; return u }(c), c.length * X)) }, ee = d(640), te = d.n(ee), ne = d(4988), re = d(265), oe = d(2762); function uuid() { for (var c = [], u = 0; u < 32; u++)c[u] = "0123456789abcdef".substr(Math.floor(16 * Math.random()), 1); return c.join("") } function getSigReqData(c, u) { var d = []; for (var v in c) null != c[v] ? d.push(v + "=" + c[v]) : delete c[v]; return d.sort(), Q(d.join("&") + u) } function generateRand() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 7, u = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"; return Array.from(Array(c)).map((function () { return u[parseInt((62 * Math.random()).toString())] })).join("") } function URLPrefix(c) { if (!c) return ""; var u = /^\/\//.test(c) ? "https:" : ""; return "".concat(u).concat(c) } function getQueryByName(c, u) { var d = new RegExp("[?&]" + u + "=([^&#]+)"), v = c.match(d); return v ? v[1] : null } function getPvId() { var c, u, d = null === (c = window) || void 0 === c || null === (c = c.sessionStorage) || void 0 === c ? void 0 : c.getItem("ai_pvid"); d || (d = getUuid(), null === (u = window) || void 0 === u || null === (u = u.sessionStorage) || void 0 === u || u.setItem("ai_pvid", d)); return d } function getRequestId() { return getUuid() } function getUuid() { return (new Date).getTime() + function generateRand() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 7, u = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"; return Array.from(Array(c)).map((function () { return u[parseInt((62 * Math.random()).toString())] })).join("") }(7) } function jumpTo(c) { U.ZP.navigateTo({ "url": c }) } function jumpToWebview(c) { var u = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; window.location.href = "http:" + (u ? "" : J.bm) + c } function getAuditStatus() { return new Promise((function (c) { re.Z.getCISFeedData({ "spm": "".concat(oe.Z.spmA, ".home.audit"), "page": 1, "size": 1 }).then((function (u) { if (u) { var d = u.content && u.content[0], v = 2 == d.status && oe.Z.appVersion == d.version; c(v) } else c(!1) })) })) } function jumpToCompleteUrl(c) { window.location.href = c } function getRequestQuery(c) { var u = c.split("?")[1]; return u ? u.split("&").reduce((function (c, u) { var d = u.split("="), v = (0, R.Z)(d, 2), E = v[0], k = v[1]; return c[E] = decodeURIComponent(k.replace(/\+/g, " ")), c }), {}) : {} } function getFormatTime(c, u, d) { return Date.now() - c <= 864e5 && d ? new Y(c).fromNow() : new Y(c).format(u) } function formatTime(c) { if (c < 60) return "".concat(Math.floor(c), "秒"); var u = Math.floor(c / 60), d = c % 60; return d ? "".concat(u, "分钟").concat(d, "秒") : "".concat(u, "分钟") } function queryString() { for (var c, u = {}, d = (null === (c = window) || void 0 === c || null === (c = c.location) || void 0 === c || null === (c = c.search) || void 0 === c ? void 0 : c.substring(1)).split("&"), v = 0; v < d.length; v++) { var E = d[v].split("="); if (void 0 === u[E[0]]) u[E[0]] = decodeURIComponent(E[1]); else if ("string" == typeof u[E[0]]) { var k = [u[E[0]], decodeURIComponent(E[1])]; u[E[0]] = k } else u[E[0]].push(decodeURIComponent(E[1])) } return u } function queryStringByUrl() { for (var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "", u = {}, d = (c.split("?").length > 1 ? c.split("?")[1] : "").split("&"), v = 0; v < d.length; v++) { var E = d[v].split("="); if (void 0 === u[E[0]]) u[E[0]] = decodeURIComponent(E[1]); else if ("string" == typeof u[E[0]]) { var k = [u[E[0]], decodeURIComponent(E[1])]; u[E[0]] = k } else u[E[0]].push(decodeURIComponent(E[1])) } return u } function throttle(c, u) { var d = null; return function () { for (var v = this, E = arguments.length, k = new Array(E), R = 0; R < E; R++)k[R] = arguments[R]; d || (d = setTimeout((function () { d = null, c.apply(v, k) }), u)) } } function copyToClipboard(c) { var u = navigator.userAgent.match(/iPad|iPhone|iPod|Macintosh/i); return new Promise((function (d, v) { try { navigator.clipboard && u ? navigator.clipboard.writeText(c).then((function () { d(!0) })).catch((function () { d(!1) })) : d(te()(c)) } catch (c) { console.log("copyToClipboard", c), v(c) } })) } function isIos() { return navigator.userAgent.match(/(iPad|iPhone|iPod)[\w\s]*;(?:[\w\s]+;)*[\w\s]+(?:iPad|iPhone|iPod)?\sOS\s([\d_.]+)/i) } function IsAndroid() { var c = navigator.userAgent; return c.indexOf("Android") > -1 || c.indexOf("adr") > -1 || c.indexOf("linux;") > -1 } function isWxBrowser() { return navigator.userAgent.indexOf("MicroMessenger") > -1 } function useNativeDownloadBrowser() { var c = navigator.userAgent; console.log(IsAndroid(), "33"); var u = isIos(); if (IsAndroid()) { if (c.indexOf("MicroMessenger") > -1) return !1; if (c.indexOf("baiduboxapp") > -1) return !1; if (c.indexOf("MiuiBrowser") > -1) return !0; if (c.indexOf("samsungbrowser/") > -1) return !0; if (c.indexOf("UCBrowser") > -1) return !1; if (c.indexOf("TTWebView") > -1) return !1; if (c.indexOf("HuaweiBrowser") > -1) return !0; if (c.indexOf("VivoBrowser") > -1) return !0; if (c.indexOf("QBrowser") > -1) return !0; if (c.indexOf("Chrome") > -1) return !0 } if (u) { if (navigator.standalone ? /WebKit\/[\d.]+/i.test(c) : /Safari/i.test(c) && !/CriOS/i.test(c) && !/MQQBrowser/i.test(c)) return !0; if (c.indexOf("Chrome") > -1) return !0 } return !1 } function dataURItoBlob(c) { for (var u = c.split(","), d = u[0].match(/:(.*?);/)[1], v = atob(u[1]), E = v.length, k = new Uint8Array(E); E--;)k[E] = v.charCodeAt(E); return new Blob([k], { "type": d }) } function downloadImage(c) { var u = new Image, d = function getImgName(c) { var u = "/", d = c, v = d.slice(c.lastIndexOf(u) + u.length); return v }(c); u.setAttribute("crossOrigin", "anonymous"), u.src = c, u.onload = (0, k.Z)((0, E.Z)().mark((function _callee() { var c, v, k, R, U, G; return (0, E.Z)().wrap((function _callee$(E) { for (; ;)switch (E.prev = E.next) { case 0: return (c = document.createElement("canvas")).width = u.width, c.height = u.height, c.getContext("2d").drawImage(u, 0, 0, u.width, u.height), v = c.toDataURL("image/png"), k = dataURItoBlob(v), console.log(k, URL.createObjectURL, "blobfile"), E.prev = 8, E.next = 11, k.arrayBuffer(); case 11: R = E.sent, U = URL.createObjectURL(new Blob([R])), (G = document.createElement("a")).download = d, G.href = U, G.click(), G.remove(), URL.revokeObjectURL(U), E.next = 25; break; case 21: E.prev = 21, E.t0 = E.catch(8), console.log("download error", E.t0), (0, H.CF)({ "duration": 3e3, "title": "请长按图片，进行保存", "icon": "none" }); case 25: case "end": return E.stop() } }), _callee, null, [[8, 21]]) }))) } function updateQueryUrl(c, u, d) { var v = new RegExp("([?&])" + u + "=.*?(&|$)", "i"), E = -1 !== c.indexOf("?") ? "&" : "?"; return c.match(v) ? c.replace(v, "$1" + u + "=" + d + "$2") : c + E + u + "=" + d } function objectToQueryString(c) { return new URLSearchParams(c).toString() } function formatPoint(c) { if (c <= 0 || !c) return ""; if (c > 0 && c <= 999) return c; if (c > 999 && c < 1e4) { var u = c.toString().split("").slice(0, 2); return u.splice(1, 0, "."), u.join("") + "k" } var d = c.toString().split("").slice(0, -3); return d.splice(-1, 0, "."), d.join("") + "w" } function handleJump(c, u) { window.location.href = "/wap" + c } function addProtocol() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ""; return c && c.indexOf && c.indexOf("http") < 0 ? "".concat("https:").concat(c) : c } function isNoHistoryLengthBrowser() { return ["HuaweiBrowser", "VivoBrowser", "HeyTapBrowser", "NewsArticle"].some((function (c) { return navigator.userAgent.includes(c) })) } function transformFeatureCardJson(c) { var u, d, E, k, R, U, H, G, W, Z, Y, J, K, X, Q, ee, te, re, oe, ie, ae, se, ce, le, ue, de, pe, fe, he, me, ge, _e, ve, ye, be, Se = {}, we = c.selected ? null === (u = c) || void 0 === u ? void 0 : u.uuid : null; return c = null === (d = c) || void 0 === d ? void 0 : d.cardContent, Se.toolSceneTitle = null === (E = c) || void 0 === E || null === (E = E.toolSceneTitle) || void 0 === E ? void 0 : E.toolSceneTitleValue, Se.toolSceneName = null === (k = c) || void 0 === k || null === (k = k.toolScene) || void 0 === k ? void 0 : k.toolSceneName, Se.toolSceneID = null === (R = c) || void 0 === R || null === (R = R.toolScene) || void 0 === R ? void 0 : R.toolSceneID, Se.needPicDescribeValue = null === (U = c) || void 0 === U || null === (U = U.needPicDescribe) || void 0 === U ? void 0 : U.needPicDescribeValue, Se.inputPicDescribeDefaultValue = null === (H = c) || void 0 === H || null === (H = H.inputPicDescribe) || void 0 === H ? void 0 : H.inputPicDescribeDefaultValue, Se.inputPicDescribeTitle = null === (G = c) || void 0 === G || null === (G = G.inputPicDescribe) || void 0 === G ? void 0 : G.inputPicDescribeTitle, Se.inputPicDescribeDesc = null === (W = c) || void 0 === W || null === (W = W.inputPicDescribe) || void 0 === W ? void 0 : W.inputPicDescribeDesc, Se.inputPicDescribeSeq = null === (Z = c) || void 0 === Z || null === (Z = Z.inputPicDescribe) || void 0 === Z ? void 0 : Z.inputPicDescribeSeq, Se.inputImageDescribeIndicateWord = null === (Y = c) || void 0 === Y || null === (Y = Y.inputImageDescribeIndicateWordList) || void 0 === Y || null === (Y = Y.inputImageDescribeIndicateWord) || void 0 === Y ? void 0 : Y.map((function (c) { return { "keywords": null == c ? void 0 : c.inputImageDescribeIndicateWordKeyword, "richKeywords": null == c ? void 0 : c.inputImageDescribeIndicateWordMultiKeyword } })), Se.needChoosePicStyleValue = null === (J = c) || void 0 === J || null === (J = J.needChoosePicStyle) || void 0 === J ? void 0 : J.needChoosePicStyleValue, Se.choosePicStyleDesc = null === (K = c) || void 0 === K || null === (K = K.choosePicStyle) || void 0 === K ? void 0 : K.choosePicStyleDesc, Se.choosePicStyleSeq = null === (X = c) || void 0 === X || null === (X = X.choosePicStyle) || void 0 === X ? void 0 : X.choosePicStyleSeq, Se.choosePicStyleTitle = null === (Q = c) || void 0 === Q || null === (Q = Q.choosePicStyle) || void 0 === Q ? void 0 : Q.choosePicStyleTitle, Se.needBuildRadioValue = null === (ee = c) || void 0 === ee || null === (ee = ee.needBuildRadio) || void 0 === ee ? void 0 : ee.needBuildRadioValue, Se.buildRadioBasicInfoTitle = null === (te = c) || void 0 === te || null === (te = te.buildRadioBasicInfo) || void 0 === te ? void 0 : te.buildRadioBasicInfoTitle, Se.buildRadioBasicInfoSeq = null === (re = c) || void 0 === re || null === (re = re.buildRadioBasicInfo) || void 0 === re ? void 0 : re.buildRadioBasicInfoSeq, Se.buildRadioBasicInfoDesc = null === (oe = c) || void 0 === oe || null === (oe = oe.buildRadioBasicInfo) || void 0 === oe ? void 0 : oe.buildRadioBasicInfoDesc, Se.buildRadio = null === (ie = c) || void 0 === ie || null === (ie = ie.buildRadioList) || void 0 === ie || null === (ie = ie.buildRadio) || void 0 === ie ? void 0 : ie.map((function (c) { var u, d = c.buildRadioLength, E = c.buildRadioWidth, k = "".concat(E, ":").concat(d), R = E / d, U = (0, v.Z)(ne.CE); try { for (U.s(); !(u = U.n()).done;) { var H = u.value; if (H.rate === R) { k = H.size; break } } } catch (c) { U.e(c) } finally { U.f() } var G = Number(k.split(":")[0]), W = Number(k.split(":")[1]), Z = URLPrefix(null == c ? void 0 : c.buildRadioimageUrl); return { "size": k, "high": d, "width": E, "label": null == c ? void 0 : c.buildRadioDesc, "img": Z, "widthProp": G, "highProp": W, "portraitSizeDesc": null == c ? void 0 : c.buildRadioName } })), Se.type = null === (ae = c) || void 0 === ae ? void 0 : ae.type, Se.iconValue = null === (se = c) || void 0 === se || null === (se = se.operatePos) || void 0 === se || null === (se = se.icon) || void 0 === se ? void 0 : se.iconValue, Se.funcDescValue = null === (ce = c) || void 0 === ce || null === (ce = ce.operatePos) || void 0 === ce || null === (ce = ce.funcDesc) || void 0 === ce ? void 0 : ce.funcDescValue, Se.coverSmallUrlValue = null === (le = c) || void 0 === le || null === (le = le.operatePos) || void 0 === le || null === (le = le.coverSmallUrl) || void 0 === le ? void 0 : le.coverSmallUrlValue, Se.toolNameValue = null === (ue = c) || void 0 === ue || null === (ue = ue.operatePos) || void 0 === ue || null === (ue = ue.toolName) || void 0 === ue ? void 0 : ue.toolNameValue, Se.coverBigUrlValue = null === (de = c) || void 0 === de || null === (de = de.operatePos) || void 0 === de || null === (de = de.coverBigUrl) || void 0 === de ? void 0 : de.coverBigUrlValue, Se.styleClassificationValue = null === (pe = c) || void 0 === pe || null === (pe = pe.styleClassification) || void 0 === pe ? void 0 : pe.styleClassificationValue, Se.needUploadSimpleImageValue = null === (fe = c) || void 0 === fe || null === (fe = fe.needUploadSimpleImage) || void 0 === fe ? void 0 : fe.needUploadSimpleImageValue, Se.uploadSimpleImageSeq = null === (he = c) || void 0 === he || null === (he = he.uploadSimpleImage) || void 0 === he ? void 0 : he.uploadSimpleImageSeq, Se.uploadSimpleImageTitle = null === (me = c) || void 0 === me || null === (me = me.uploadSimpleImage) || void 0 === me ? void 0 : me.uploadSimpleImageTitle, Se.uploadSimpleImageDesc = null === (ge = c) || void 0 === ge || null === (ge = ge.uploadSimpleImage) || void 0 === ge ? void 0 : ge.uploadSimpleImageDesc, Se.needAdSettingValue = null === (_e = c) || void 0 === _e || null === (_e = _e.needAdSetting) || void 0 === _e ? void 0 : _e.needAdSettingValue, Se.adSetting = null === (ve = c) || void 0 === ve || null === (ve = ve.adSettingList) || void 0 === ve || null === (ve = ve.adSetting) || void 0 === ve ? void 0 : ve.map((function (c) { var u, d, v, E, k; return { "adSettingSimpleImageSimilarityValue": null == c || null === (u = c.adSettingSimpleImageSimilarity) || void 0 === u ? void 0 : u.adSettingSimpleImageSimilarityValue, "adSettingSimpleImageSimilarityTitle": null == c || null === (d = c.adSettingSimpleImageSimilarity) || void 0 === d ? void 0 : d.adSettingSimpleImageSimilarityTitle, "adSettingInputPicDescTitle": null == c || null === (v = c.adSettingInputPicDesc) || void 0 === v ? void 0 : v.adSettingInputPicDescTitle, "adSettingInputPicDescDefaultValue": null == c || null === (E = c.adSettingInputPicDesc) || void 0 === E ? void 0 : E.adSettingInputPicDescDefaultValue, "adSettingInputPicDescDesc": null == c || null === (k = c.adSettingInputPicDesc) || void 0 === k ? void 0 : k.adSettingInputPicDescDesc } })), Se.needUploadCommodityPortraitImage = null === (ye = c) || void 0 === ye || null === (ye = ye.needOriginalImage) || void 0 === ye ? void 0 : ye.needOriginalImageValue, Se.uploadCommodityPortraitImageTitle = null === (be = c) || void 0 === be || null === (be = be.originalImage) || void 0 === be ? void 0 : be.originalImageTitle, Se.uuid = we, Se } }, "7820": function () { }, "8870": function () { }, "4520": function () { }, "2474": function (c, u, d) { "use strict"; d.d(u, { "Z": function () { return Fe } }); var v = d(989), E = { "isLogin": !1, "userInfo": { "username": "", "avatar": "", "userId": "" }, "memberLevel": 0, "memberInfo": void 0, "isOnline": !0, "isWeixin": !1, "isBaidu": !1, "isToutiao": !1, "requestId": "", "pointInfo": {}, "showDetailDialog": !1, "showNoPointDialog": !1, "isNotHasLastPage": !document.referrer || window.location.history <= 2, "statePageKey": 0, "memberAgreementType": "", "trailCount": 0, "systemCount": 1e3, "trailList": [], "isFirstTrail": !1 }, k = d(1413), R = d(2982), U = d(5660), H = { "updateUserInfo": function updateUserInfo(c, u) { c.userInfo = u }, "updateMemberInfo": function updateMemberInfo(c, u) { var d = u.memberLevel, v = u.memberInfo; c.memberLevel = d, c.memberInfo = v }, "updateLoginStatus": function updateLoginStatus(c, u) { c.isLogin = u }, "updateOnlineStatus": function updateOnlineStatus(c, u) { c.isOnline = u }, "updateRequestId": function updateRequestId(c, u) { c.requestId = u, U.Z.setItem("generateRequestId", u) }, "updatePointInfo": function updatePointInfo(c, u) { c.pointInfo = u }, "updateShowDetailDialog": function updateShowDetailDialog(c, u) { c.showDetailDialog = u }, "getStoredRequestId": function getStoredRequestId(c) { c.requestId || (c.requestId = U.Z.getItem("generateRequestId")) }, "updateXCXEnv": function updateXCXEnv(c, u) { "wx" == u && (c.isWeixin = !0), "bd" == u && (c.isBaidu = !0), "tt" == u && (c.isToutiao = !0) }, "updateShowNoPointDialog": function updateShowNoPointDialog(c, u) { c.showNoPointDialog = u }, "updateIsNotHasLastPage": function updateIsNotHasLastPage(c, u) { c.isNotHasLastPage = u }, "updateStatePageKey": function updateStatePageKey(c, u) { c.statePageKey = u }, "updateMemberAgreementType": function updateMemberAgreementType(c, u) { c.memberAgreementType = u, U.Z.setItem("memberAgreementType", u) }, "updateTrailCount": function updateTrailCount(c, u) { c.trailCount = u }, "updateSystemCount": function updateSystemCount(c, u) { c.systemCount = u }, "addTrailItem": function addTrailItem(c, u) { var d = U.Z.getItem("trailList") || []; u.picGroupId && (c.trailList = d.filter((function (c) { return c.picGroupId !== u.picGroupId }))), u.smartId && (c.trailList = d), c.trailList = [].concat((0, R.Z)(c.trailList), [(0, k.Z)({}, u)]), U.Z.setItem("trailList", c.trailList) }, "deleteTrailItem": function deleteTrailItem(c, u) { var d = U.Z.getItem("trailList") || []; c.trailList = d.filter((function (c) { return !!c.smartId || c.picGroupId !== u })), console.log("deleteTrailItem", c.trailList), U.Z.setItem("trailList", c.trailList) }, "updateTrailStatus": function updateTrailStatus(c, u) { c.isFirstTrail = u } }, G = d(4165); function _objectDestructuringEmpty(c) { if (null == c) throw new TypeError("Cannot destructure " + c) } var W = d(5861), Z = d(6878), Y = d(5210), J = d(9477), K = d(2264), X = d(9663), Q = d(3244), ee = { "getUserPoint": function getUserPoint(c) { var u = c.commit, d = c.state; if (d.isLogin) { var v = { "userId": d.userInfo.userId }; return Z.Z.getUserPoint(v).then((function (c) { 1 === c.code && u("updatePointInfo", c.data) })) } }, "getUserInfo": function getUserInfo(c) { var u = c.commit, d = c.getters, v = c.dispatch; return Y.Z.getUserInfo(d.xcxEnv).then((function (c) { var d, E, k; 1 == c.code && c.data && (u("updateUserInfo", { "username": null === (d = c.data) || void 0 === d ? void 0 : d.nickname, "avatar": null === (E = c.data) || void 0 === E ? void 0 : E.avatar, "userId": null === (k = c.data) || void 0 === k ? void 0 : k.userId }), u("updateLoginStatus", !0), v("getUserPoint")) })) }, "checkIsSensitive": function checkIsSensitive(c, u) { return (0, W.Z)((0, G.Z)().mark((function _callee() { var d; return (0, G.Z)().wrap((function _callee$(v) { for (; ;)switch (v.prev = v.next) { case 0: return _objectDestructuringEmpty(c), v.prev = 1, v.next = 4, J.Z.sensitiveText(u); case 4: if (1 !== (d = v.sent).code) { v.next = 9; break } return v.abrupt("return", d.data); case 9: (0, X.CF)({ "title": "网络出错，请重试", "icon": "none", "duration": 800 }); case 10: v.next = 15; break; case 12: v.prev = 12, v.t0 = v.catch(1), (0, X.CF)({ "title": "网络出错，请重试", "icon": "none", "duration": 800 }); case 15: case "end": return v.stop() } }), _callee, null, [[1, 12]]) })))() }, "getTrailCount": function getTrailCount(c) { var u = c.commit, d = c.getters; if (!c.state.isLogin) return Y.Z.getTrailCount(d.xcxEnv).then((function (c) { 1 == c.code && c.data && (u("updateTrailCount", c.data.residualCountPerTourist), u("updateSystemCount", c.data.residualCountPerDay), u("updateTrailStatus", c.data.residualCountPerTourist === c.data.aiCountPerTourist)) })) }, "mergeArt": function mergeArt(c, u) { return (0, W.Z)((0, G.Z)().mark((function _callee2() { var d, v, E, k, H; return (0, G.Z)().wrap((function _callee2$(G) { for (; ;)switch (G.prev = G.next) { case 0: return d = c.dispatch, v = [], E = [], u.forEach((function (c) { c.picGroupId ? E.push(c) : v.push(c) })), console.log("text", v, "pic", E), G.next = 6, d("mergePicTrail", E); case 6: return k = G.sent, G.next = 9, d("mergeTextTrail", v); case 9: H = G.sent, console.log("residualText", H, "residualPics", k), U.Z.setItem("trailList", [].concat((0, R.Z)(k), (0, R.Z)(H))); case 12: case "end": return G.stop() } }), _callee2) })))() }, "mergePicTrail": function mergePicTrail(c, u) { return _objectDestructuringEmpty(c), u.length <= 0 ? u : new Promise((function (c) { Y.Z.mergeTrailArt(u).then((function (d) { if (1 === d.code) { var v, E = new URLSearchParams(null === (v = window.location) || void 0 === v ? void 0 : v.search).get("taskId"); E && (console.log("updateTrailDetail", d.data[E]), Q.Y.emit("updateTrailDetail", { "id": d.data[E] })), U.Z.setItem("picTrailRes", d.data), Q.Y.emit("refresh"), c([]) } else console.error("merge art fail:", d), c(u) })) })) }, "mergeTextTrail": function mergeTextTrail(c, u) { if (_objectDestructuringEmpty(c), u.length <= 0) return []; var d = [], v = u.map((function (c) { var u, v = { "category": 3, "subCategory": 1, "content": (null == c || null === (u = c.textRes) || void 0 === u ? void 0 : u.join("<br>")) || "", "isDraft": !0, "bizExtInfo": { "mindTemplateId": c.smartId, "mindTemplateMap": c.templateMap, "uuid": c.uuid } }; return new Promise((function (u, E) { K.Z.publishArt(v).then((function (c) { var d; 1 == c.code ? u(null === (d = c.data) || void 0 === d ? void 0 : d.artId) : E(c) })).catch((function (u) { E(u), d.push(c) })) })) })); return new Promise((function (c) { Promise.all(v).then((function (u) { console.log(u, "textList"), Q.Y.emit("saveTextTip"), Q.Y.emit("updateBtnStatus", [{ "type": "save", "status": !0 }]), Q.Y.emit("refresh"), c(d) }), (function () { c(d) })) })) } }, te = { "namespaced": !0, "state": E, "getters": { "isXCX": function isXCX(c) { return c.isWeixin || c.isBaidu || c.isToutiao }, "xcxEnv": function xcxEnv(c) { return c.isWeixin ? "wx" : c.isBaidu ? "bd" : c.isToutiao ? "tt" : "" } }, "mutations": H, "actions": ee }, ne = (0, k.Z)({}, { "publishInfo": { "show": !1, "id": "", "detail": null, "bizExtInfo": {} }, "historyList": [], "activeTab": "byText", "mainTypeInfo": {}, "genFormInfo": { "type": 0, "templateType": "", "templateTypeCode": 0, "templateId": 1, "imageCount": 2, "promptCh": "", "denoising": 0, "backImgUrl": "", "imageUrl": "", "high": 512, "width": 512, "baseImageWidth": 0, "baseImageHeight": 0, "widthProp": null, "highProp": null }, "generateSame": "", "featureCardInfo": {} }), re = { "getHistoryList": function getHistoryList(c) { var u = c.commit, d = c.state; console.log(d.userInfo, "state"); var v = { "userId": d.userInfo.userId, "pageNo": 1, "pageSize": 20 }; return J.Z.getHistoryList(v).then((function (c) { 1 === c.code ? u("updateHistoryList", c.data) : ((0, X.CF)({ "title": "获取历史记录失败", "icon": "none", "duration": 800 }), console.log("get history err", c.msg)) })) } }, oe = d(8870), ie = { "namespaced": !0, "state": ne, "getters": d.n(oe)(), "mutations": { "updatePublishInfo": function updatePublishInfo(c, u) { c.publishInfo = u }, "updateHistoryList": function updateHistoryList(c, u) { c.historyList = u }, "updateActiveTab": function updateActiveTab(c, u) { c.activeTab = u }, "updateMainTypeInfo": function updateMainTypeInfo(c, u) { c.mainTypeInfo = u }, "updateGenFormInfo": function updateGenFormInfo(c, u) { c.genFormInfo = u }, "updateGenerateInfo": function updateGenerateInfo(c, u) { var d = u.key, v = u.value; c[d] = v }, "updateGenerateSame": function updateGenerateSame(c, u) { c.generateSame = u }, "updateFeatureCardInfo": function updateFeatureCardInfo(c, u) { c.featureCardInfo = u } }, "actions": re }, ae = { "changeReplyCommentInfo": function changeReplyCommentInfo(c, u) { c.replyCommentInfo = u }, "receiveParamsFromGenerate": function receiveParamsFromGenerate(c, u) { c.createInfo = { "status": "loading", "couldStop": !1, "createParams": u.params, "creator": u.creator, "picGroupId": u.picGroupId }, U.Z.setItem("createInfo", c.createInfo) }, "resetCreateParams": function resetCreateParams(c, u) { c.createInfo = (0, k.Z)((0, k.Z)({}, c.createInfo), u), U.Z.setItem("createInfo", c.createInfo) }, "updateCreateStatus": function updateCreateStatus(c, u) { c.createInfo = (0, k.Z)((0, k.Z)({}, c.createInfo), {}, { "status": u }), U.Z.setItem("createInfo", (0, k.Z)((0, k.Z)({}, c.createInfo), {}, { "status": u })) }, "getCreateInfo": function getCreateInfo(c) { c.createInfo.status || U.Z.getItem("createInfo") && (c.createInfo = U.Z.getItem("createInfo")) }, "updateTimer": function updateTimer(c, u) { c.timer = u }, "updateRemainTime": function updateRemainTime(c, u) { c.remainTime = u }, "updateIsRead": function updateIsRead(c, u) { c.isRead = u }, "getCreateList": function getCreateList(c) { return c.createList && c.createList.length ? c.createList : U.Z.getItem("createList") }, "addCreateList": function addCreateList(c, u) { c.createList = c.createList.filter((function (c) { return c.picGroupId !== u.picGroupId })), c.createList = [].concat((0, R.Z)(c.createList), [(0, k.Z)((0, k.Z)({}, u), {}, { "spmReport": !1 })]), U.Z.setItem("createList", c.createList) }, "updateCreateList": function updateCreateList(c, u) { Array.isArray(u) ? c.createList = u : -1 === c.createList.findIndex((function (c) { return c.picGroupId === u.picGroupId })) ? this.commit("artDetail/addCreateList", u) : c.createList = c.createList.map((function (c) { return c.picGroupId === u.picGroupId ? (0, k.Z)((0, k.Z)({}, c), u) : c })); U.Z.setItem("createList", c.createList) } }, se = d(7567), ce = d(5429), le = d(4988), ue = d(1490), de = d(2762); function getGenerateMsgInfo(c, u, d) { var v, E = (null === (v = ue.dK.currentTracker) || void 0 === v ? void 0 : v.getTrackerData()) || "", k = E.spmA, R = E.spmB, U = E.spmE, H = "".concat(k || de.Z.spmA, ".").concat(R || "home", ".0.0.").concat(U), G = "/".concat(u.name, "?spm=").concat(H, "&").concat(u.type ? u.type : "detailId", "=").concat(u.id); console.log("ssss", G), "ERROR" !== c && "TIMEOUT" !== c || (G = "/generate/".concat(u.name, "?spm=").concat(H), G = "".concat(G, "&generateObj=").concat(u.genObj), console.log("fail", G)); var W = { "title": le.z2[c].title, "label": le.z2[c].label, "icon": le.z2[c].icon, "jumpHref": G, "jumpName": le.z2[c].jumpName, "picGroupId": d }; console.log("trigger showCreateMsg"), Q.Y.emit("showCreateMsg", { "showMsg": !0, "msgInfo": W }) } var pe = d(1022), fe = d(8450), he = d(3927), me = { "getCreateList": function getCreateList(c) { var u = c.state; return u.createList && u.createList.length ? u.createList : U.Z.getItem("createList") }, "intervalMsg": function intervalMsg(c, u) { var d = c.commit, v = c.state, E = c.dispatch, k = u.isFirstInterval, R = void 0 === k || k, U = u.clkParam, H = void 0 === U ? "" : U, G = v.createList, W = null == G ? void 0 : G.map((function (c) { return c.status })); null != W && W.includes("success") && setTimeout((function () { E("generateSuccess") }), 3e3), null != W && W.includes("fail") && E("generateError", H), null != W && W.includes("stopped") && E("generateStopped"), (null != W && W.includes("loading") || G.filter((function (c) { return !c.spmReport })).length) && d("updateTimer", setTimeout((function () { E("handleInterval") }), R ? 0 : 3e3)) }, "handleInterval": function handleInterval(c) { return (0, W.Z)((0, G.Z)().mark((function _callee2() { var u, d, v, E, k, R; return (0, G.Z)().wrap((function _callee2$(U) { for (; ;)switch (U.prev = U.next) { case 0: return u = c.commit, d = c.dispatch, v = c.state, U.prev = 1, U.next = 4, J.Z.getGenerateMsgMulti(); case 4: if (1 !== (E = U.sent).code && ue.dK.trackAction(ce.o.POINTS_DETAIL_NETWORK_FAILD, { "type": 1 }), E.data) { U.next = 9; break } return u("resetCreateParams", { "status": null, "couldStop": !1, "createParams": {}, "creator": {} }), U.abrupt("return"); case 9: if (k = [], 0 !== E.data.length) { U.next = 15; break } return clearTimeout(v.timer), u("updateTimer", null), u("updateCreateList", k), U.abrupt("return"); case 15: return R = E.data.map(function () { var c = (0, W.Z)((0, G.Z)().mark((function _callee(c, u) { return (0, G.Z)().wrap((function _callee$(v) { for (; ;)switch (v.prev = v.next) { case 0: return v.next = 2, d("getCreateItem", { "createItem": c, "listIndex": u, "couldStop": void 0 === (null == c ? void 0 : c.couldStop) || (null == c ? void 0 : c.couldStop) }); case 2: case "end": return v.stop() } }), _callee) }))); return function (u, d) { return c.apply(this, arguments) } }()), U.next = 18, Promise.all(R); case 18: d("intervalMsg", { "isFirstInterval": !1 }), U.next = 24; break; case 21: U.prev = 21, U.t0 = U.catch(1), ue.dK.trackAction(ce.o.POINTS_DETAIL_NETWORK_FAILD, { "type": 2 }); case 24: case "end": return U.stop() } }), _callee2, null, [[1, 21]]) })))() }, "getCreateItem": function getCreateItem(c, u) { var d, v, E, R, H, G, W, Z, Y, J, K, X, Q, ee, te, ne = c.commit, re = c.dispatch, oe = c.rootState, ie = u.createItem, ae = ie.code, se = ie.data, ce = ie.couldStop; if (se) { var ue = { "picGroupId": se.picGroupId, "remainTime": se.remainTime, "couldStop": ce }; switch (ae) { case le.z2.SUCCESS.code: var de, fe, he; if (null != se && se.artId) ue.createParams = (0, k.Z)((0, k.Z)({}, se.requestParam), {}, { "id": se.artId, "imgList": se.images.map((function (c) { return { "url": c, "coverImg": (0, pe.Nc)(c, 800), "width": se.requestParam.width, "height": se.requestParam.high } })), "templateName": ((null == se || null === (de = se.requestParam) || void 0 === de ? void 0 : de.templateType) || "默认") + "-" + ((null == se || null === (fe = se.requestParam) || void 0 === fe ? void 0 : fe.templateName) || "默认风格"), "templateLevel": (null == se || null === (he = se.requestParam) || void 0 === he ? void 0 : he.templateLevel) || 0 }), ue.creator = oe.base.userInfo, ue.status = "success", ue.couldStop = !1; else if (se && !se.artId) { var me, ge, _e; ue.createParams = (0, k.Z)((0, k.Z)({}, se.requestParam), {}, { "templateName": ((null == se || null === (me = se.requestParam) || void 0 === me ? void 0 : me.templateType) || "默认") + "-" + ((null == se || null === (ge = se.requestParam) || void 0 === ge ? void 0 : ge.templateName) || "默认风格"), "templateLevel": (null == se || null === (_e = se.requestParam) || void 0 === _e ? void 0 : _e.templateLevel) || 0 }), ue.creator = oe.base.userInfo, ue.status = "loading" } break; case le.z2.ERROR.code: var ve = U.Z.getItem("featureCardUUid"); re("updateErrorInfo", { "clkParam": "templateId:".concat(null === (d = se.requestParam) || void 0 === d ? void 0 : d.templateId, ";promptCh:").concat(encodeURIComponent(null === (v = se.requestParam) || void 0 === v ? void 0 : v.promptCh), ";type:1;uuid:").concat(ve), "createItem": ie }), ue = { "picGroupId": (null == ie || null === (E = ie.data) || void 0 === E ? void 0 : E.picGroupId) || (null == ie ? void 0 : ie.picGroupId), "createParams": (0, k.Z)((0, k.Z)({}, se.requestParam), {}, { "templateName": ((null == se || null === (R = se.requestParam) || void 0 === R ? void 0 : R.templateType) || "默认") + "-" + ((null == se || null === (H = se.requestParam) || void 0 === H ? void 0 : H.templateName) || "默认风格") }) || (null == ie ? void 0 : ie.createParams), "creator": oe.base.userInfo, "status": "fail" }; break; case le.z2.STOPPED.code: ue.createParams = (0, k.Z)((0, k.Z)({}, se.requestParam), {}, { "templateName": ((null == se || null === (G = se.requestParam) || void 0 === G ? void 0 : G.templateType) || "默认") + "-" + ((null == se || null === (W = se.requestParam) || void 0 === W ? void 0 : W.templateName) || "默认风格") }), ue.creator = oe.base.userInfo, ue.status = "stopped"; break; case le.z2.TIMEOUT.code: re("updateErrorInfo", { "clkParam": "type:3", "createItem": ie }), ue = { "picGroupId": (null == ie || null === (Z = ie.data) || void 0 === Z ? void 0 : Z.picGroupId) || (null == ie ? void 0 : ie.picGroupId), "createParams": (0, k.Z)((0, k.Z)({}, se.requestParam), {}, { "templateName": ((null == se || null === (Y = se.requestParam) || void 0 === Y ? void 0 : Y.templateType) || "默认") + "-" + ((null == se || null === (J = se.requestParam) || void 0 === J ? void 0 : J.templateName) || "默认风格"), "templateLevel": (null == se || null === (K = se.requestParam) || void 0 === K ? void 0 : K.templateLevel) || 0 }) || (null == ie ? void 0 : ie.createParams), "creator": oe.base.userInfo, "status": "fail" }; break; default: ue = { "picGroupId": (null == ie || null === (X = ie.data) || void 0 === X ? void 0 : X.picGroupId) || (null == ie ? void 0 : ie.picGroupId), "createParams": (0, k.Z)((0, k.Z)({}, se.requestParam), {}, { "templateName": ((null == se || null === (Q = se.requestParam) || void 0 === Q ? void 0 : Q.templateType) || "默认") + "-" + ((null == se || null === (ee = se.requestParam) || void 0 === ee ? void 0 : ee.templateName) || "默认风格"), "templateLevel": (null == se || null === (te = se.requestParam) || void 0 === te ? void 0 : te.templateLevel) || 0 }) || (null == ie ? void 0 : ie.createParams), "creator": oe.base.userInfo, "status": "fail" } }se.scoreInfo && ne("base/updatePointInfo", se.scoreInfo, { "root": !0 }), ne("updateCreateList", ue) } }, "generateSuccess": function generateSuccess(c) { var u, d = c.commit, v = c.state, E = c.dispatch; d("getCreateList"); var k = null === (u = v.createList) || void 0 === u ? void 0 : u.filter((function (c) { return "success" === c.status })); k.length && (null == k || k.forEach(function () { var c = (0, W.Z)((0, G.Z)().mark((function _callee3(c) { var u, k, R, U, H, W, Z; return (0, G.Z)().wrap((function _callee3$(G) { for (; ;)switch (G.prev = G.next) { case 0: return G.next = 2, E("sendSpmACodes", { "createInfo": c }); case 2: d("getCreateInfo"), v.createInfo.picGroupId === c.picGroupId && d("resetCreateParams", c), R = null === (u = (0, fe.FN)().router) || void 0 === u || null === (u = u.path) || void 0 === u ? void 0 : u.includes("/detail"), U = null === (k = (0, fe.FN)().router) || void 0 === k ? void 0 : k.params, R ? JSON.stringify(U).includes(null == c || null === (H = c.createParams) || void 0 === H ? void 0 : H.id) ? E("readMsg", c.picGroupId) : getGenerateMsgInfo("SUCCESS", { "name": "detail", "id": null == c || null === (W = c.createParams) || void 0 === W ? void 0 : W.id }, c.picGroupId) : getGenerateMsgInfo("SUCCESS", { "name": "detail", "id": null == c || null === (Z = c.createParams) || void 0 === Z ? void 0 : Z.id }, c.picGroupId); case 8: case "end": return G.stop() } }), _callee3) }))); return function (u) { return c.apply(this, arguments) } }())) }, "generateStopped": function generateStopped(c) { return (0, W.Z)((0, G.Z)().mark((function _callee5() { var u, d, v, E, k; return (0, G.Z)().wrap((function _callee5$(R) { for (; ;)switch (R.prev = R.next) { case 0: if (d = c.commit, v = c.state, E = c.dispatch, d("getCreateList"), (k = null === (u = v.createList) || void 0 === u ? void 0 : u.filter((function (c) { return ["stopScoreError", "stopped"].includes(c.status) }))).length) { R.next = 5; break } return R.abrupt("return"); case 5: null == k || k.forEach(function () { var c = (0, W.Z)((0, G.Z)().mark((function _callee4(c) { return (0, G.Z)().wrap((function _callee4$(u) { for (; ;)switch (u.prev = u.next) { case 0: d("getCreateInfo"), v.createInfo.picGroupId === c.picGroupId && d("resetCreateParams", c), E("readMsg", c.picGroupId); case 4: case "end": return u.stop() } }), _callee4) }))); return function (u) { return c.apply(this, arguments) } }()); case 6: case "end": return R.stop() } }), _callee5) })))() }, "generateError": function generateError(c) { var u, d = c.state, v = c.dispatch, E = c.commit, R = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ""; E("getCreateList"); var U = null === (u = d.createList) || void 0 === u ? void 0 : u.filter((function (c) { return "fail" === c.status })); U.length && (null == U || U.forEach(function () { var c = (0, W.Z)((0, G.Z)().mark((function _callee6(c) { var u, U, H, W, Z, Y, J, K; return (0, G.Z)().wrap((function _callee6$(G) { for (; ;)switch (G.prev = G.next) { case 0: if (E("getCreateInfo"), (U = d.createInfo).picGroupId === c.picGroupId && E("resetCreateParams", c), !c.spmReport) { G.next = 5; break } return G.abrupt("return"); case 5: H = "ERROR", R.includes("type:1") ? H = "ERROR" : R.includes("type:3") && (H = "TIMEOUT"), (null === (u = (0, fe.FN)().router) || void 0 === u || null === (u = u.path) || void 0 === u ? void 0 : u.includes("/imgLoading")) ? U.picGroupId === c.picGroupId && (Q.Y.emit("getCreateDetail"), !R.includes("type:2") && v("readMsg", c.picGroupId)) : (Z = c.createParams, Y = "byText", 2 === Z.type && (Y = "200" === Z.templateTypeCode ? "byCommodity" : "202" === Z.templateTypeCode ? "byPersonBg" : "byPortrait"), 5 === Z.type && (Y = "byHDZoom"), 1 === Z.type && (Y = "byImg"), J = encodeURIComponent(JSON.stringify((0, k.Z)((0, k.Z)({}, Z), {}, { "imgUrl": Z.imageUrl }))), K = null === (W = le.eA.find((function (c) { return c.id === Y }))) || void 0 === W ? void 0 : W.newPath, getGenerateMsgInfo(H, { "name": K, "genObj": J }, c.picGroupId)), E("updateCreateList", (0, k.Z)((0, k.Z)({}, c), {}, { "spmReport": !0 })); case 10: case "end": return G.stop() } }), _callee6) }))); return function (u) { return c.apply(this, arguments) } }())) }, "readMsg": function readMsg(c, u) { return (0, W.Z)((0, G.Z)().mark((function _callee7() { var d, v, E, k; return (0, G.Z)().wrap((function _callee7$(R) { for (; ;)switch (R.prev = R.next) { case 0: return d = c.commit, v = c.state, R.prev = 1, R.next = 4, J.Z.readGenerateMsg({ "picGroupIds": [u] }); case 4: 1 === (E = R.sent).code ? (console.log("消息已读成功"), d("getCreateList"), k = v.createList.filter((function (c) { return c.picGroupId !== u })), d("updateCreateList", k)) : console.log("消息已读失败", null == E ? void 0 : E.msg), R.next = 11; break; case 8: R.prev = 8, R.t0 = R.catch(1), console.log("消息已读接口异常", R.t0); case 11: case "end": return R.stop() } }), _callee7, null, [[1, 8]]) })))() }, "updateErrorInfo": function updateErrorInfo(c, u) { var d, v = u.clkParam, E = u.createItem; console.log(v, "error clk"), U.Z.removeItem("art_".concat(null == E || null === (d = E.data) || void 0 === d ? void 0 : d.picGroupId, "_startTime")), (0, he.vX)({ "acode": ce.o.GENERATE_ERROR, "clkParam": v }) }, "getDetail": function getDetail(c, u) { return (0, W.Z)((0, G.Z)().mark((function _callee8() { var d, v, E, R; return (0, G.Z)().wrap((function _callee8$(U) { for (; ;)switch (U.prev = U.next) { case 0: return d = c.commit, v = c.rootState, U.prev = 1, U.next = 4, se.Z.getArtDetail({ "blogId": null == u ? void 0 : u.artId }); case 4: 1 == (null == (E = U.sent) ? void 0 : E.code) ? d("resetCreateParams", { "status": "success", "createParams": (0, k.Z)((0, k.Z)({}, null == u ? void 0 : u.requestParam), {}, { "id": null == u ? void 0 : u.artId, "imgList": null === (R = E.data) || void 0 === R || null === (R = R.ext) || void 0 === R || null === (R = R.pics) || void 0 === R ? void 0 : R.map((function (c) { return c.coverImg = (0, pe.Nc)(c.url, 800), c })) }), "creator": v.base.userInfo, "picGroupId": u.picGroupId }) : console.log("查询详情失败", E), U.next = 11; break; case 8: U.prev = 8, U.t0 = U.catch(1), console.log("查询详情接口异常", U.t0); case 11: case "end": return U.stop() } }), _callee8, null, [[1, 8]]) })))() }, "sendSpmACodes": function sendSpmACodes(c, u) { var d, v, E, R, H, G, W, Z, Y, J, K, X, Q, ee, te = c.commit, ne = c.state, re = u.createInfo; if (!re.spmReport && !0 !== location.href.includes("imgLoading")) { console.log("createList", re, ne.createList), te("updateCreateList", (0, k.Z)((0, k.Z)({}, re), {}, { "spmReport": !0 })); var oe = U.Z.getItem("art_".concat(re.picGroupId, "_startTime")), ie = 2; if (1 === (null == re || null === (d = re.createParams) || void 0 === d ? void 0 : d.type)) ie = 1; else if (2 === (null == re || null === (v = re.createParams) || void 0 === v ? void 0 : v.type)) { var ae, se, le; "200" === (null == re || null === (ae = re.createParams) || void 0 === ae ? void 0 : ae.templateTypeCode) ? ie = 3 : "201" === (null == re || null === (se = re.createParams) || void 0 === se ? void 0 : se.templateTypeCode) ? ie = 4 : "202" == (null == re || null === (le = re.createParams) || void 0 === le ? void 0 : le.templateTypeCode) && (ie = 9) } else 5 == (null == re || null === (E = re.createParams) || void 0 === E ? void 0 : E.type) && (ie = 8); var ue, de = U.Z.getItem("featureCardUUid"), pe = re.createParams.templateLevel > 0 ? 1 : 2, fe = (null == re || null === (R = re.createParams) || void 0 === R ? void 0 : R.imageUrl) || "null", me = (null == re || null === (H = re.createParams) || void 0 === H ? void 0 : H.backImgUrl) || "null", ge = (null == re || null === (G = re.createParams) || void 0 === G ? void 0 : G.subType) || 1; if (fe = fe.replace(/^https?:\/\//, ""), me = me.replace(/^https?:\/\//, ""), ue = "templateId:".concat(null == re ? void 0 : re.createParams.templateId, ";templateType:").concat(null == re || null === (W = re.createParams) || void 0 === W ? void 0 : W.templateType, ";imageCount:").concat(null == re || null === (Z = re.createParams) || void 0 === Z ? void 0 : Z.imageCount, ";") + "scale:".concat(null == re || null === (Y = re.createParams) || void 0 === Y ? void 0 : Y.widthProp, ":").concat(null == re || null === (J = re.createParams) || void 0 === J ? void 0 : J.highProp, ";") + "high:".concat(null == re || null === (K = re.createParams) || void 0 === K ? void 0 : K.high, ";width:").concat(null == re || null === (X = re.createParams) || void 0 === X ? void 0 : X.width, ";promptCh:").concat(encodeURIComponent((null == re || null === (Q = re.createParams) || void 0 === Q ? void 0 : Q.promptCh) || "null"), ";userId:").concat((null == re || null === (ee = re.creator) || void 0 === ee ? void 0 : ee.userId) || "null", ";generateType:").concat(ie, ";vip:").concat(pe, ";imageUrl:").concat(fe, ";backImgUrl:").concat(me, ";uuid:").concat(de, ";kind:").concat(ge), 1 === ie || 2 === ie ? (0, he.vX)({ "acode": ce.o.GENERATE_SUCCESS, "clkParam": ue }) : 3 !== ie && 4 !== ie && 8 != ie && 9 != ie || (0, he.vX)({ "acode": ce.o.CREATE_Commodity_Portrait_SUCCESS, "clkParam": ue }), (0, he.vX)({ "acode": 10976, "clkParam": "requestId:".concat(null == oe ? void 0 : oe.requestId, ";timeDiff:").concat((new Date).getTime() - +(null == oe ? void 0 : oe.time), ";").concat(ue) }), U.Z.removeItem("art_".concat(re.picGroupId, "_startTime")), "" !== U.Z.getItem("newSizeMap")) { var _e, ve, ye, be = JSON.parse(U.Z.getItem("newSizeMap")), Se = (null == re || null === (_e = re.createParams) || void 0 === _e ? void 0 : _e.widthProp) + ":" + (null == re || null === (ve = re.createParams) || void 0 === ve ? void 0 : ve.highProp), we = -1 !== be.findIndex((function (c) { return c.size === Se && "原图比例" === c.label })); (null == re || null === (ye = re.createParams) || void 0 === ye ? void 0 : ye.imageUrl) && we && (0, he.vX)({ "acode": ce.o.USE_ORIGIN_SIZE }) } U.Z.getItem("isGenerateSame") && (U.Z.removeItem("isGenerateSame"), (0, he.vX)({ "acode": ce.o.GENERATE_SAME })) } } }, ge = d(7820), _e = { "namespaced": !0, "state": { "replyCommentInfo": { "replyInfo": { "level": 1, "commentInfo": null }, "vm": null }, "createInfo": { "status": null, "createParams": {}, "creator": {}, "picGroupId": "" }, "createList": [], "timer": null, "remainTime": 0, "isRead": !1 }, "getters": d.n(ge)(), "mutations": ae, "actions": me }, ve = d(4520), ye = { "namespaced": !0, "state": { "searchPrompt": "", "searchSimilarId": "" }, "getters": { "getSearchPrompt": function getSearchPrompt(c) { return c.searchPrompt } }, "mutations": { "setSearchPrompt": function setSearchPrompt(c, u) { c.searchPrompt = u }, "updateSearchSimilarId": function updateSearchSimilarId(c, u) { c.searchSimilarId = u } }, "actions": d.n(ve)() }, be = { "updateSmartId": function updateSmartId(c, u) { c.smartId = u, U.Z.setItem("smartId", c.smartId) }, "updateUUid": function updateUUid(c, u) { c.uuid = u, U.Z.setItem("uuid", c.uuid) }, "updateSmartInfo": function updateSmartInfo(c, u) { c.smartInfo = u, U.Z.setItem("smartInfo", c.smartInfo) }, "updateMindTemplateMap": function updateMindTemplateMap(c, u) { c.mindTemplateMap["key".concat(u.index + 1)] = u.inputContent, U.Z.setItem("mindTemplateMap", c.mindTemplateMap) }, "clearMindTemplateMap": function clearMindTemplateMap(c) { c.mindTemplateMap = {}, U.Z.removeItem("mindTemplateMap") }, "updateTextInfo": function updateTextInfo(c, u) { c.textInfo = u, U.Z.setItem("textInfo", c.textInfo) } }, Se = d(7503), we = { "getSmartInfo": function getSmartInfo(c) { var u = c.commit, d = c.state, v = c.dispatch; try { K.Z.getSmartDetail({ "smartId": d.smartId }).then((function (c) { if (1 === c.code) { var d, E = null === (d = c.data) || void 0 === d ? void 0 : d.inner.filter((function (c) { return 1 == c.type })); c.data.inner = E, u("updateSmartInfo", c.data) } else console.log("get smart info error", c.msg), v("jumpError") })).catch((function (c) { console.log("handle smart info error", c), v("jumpError") })) } catch (c) { console.log("handle smart info error", c), v("jumpError") } }, "getSmartInfoByUUid": function getSmartInfoByUUid(c) { var u = c.commit, d = c.state, v = c.dispatch; try { K.Z.getSmartDetailByUUid({ "uuids": d.uuid }).then((function (c) { if (1 === c.code) { var d, E, k, R, U, H, G, W, Z, Y, J, K = null == c || null === (d = c.data) || void 0 === d || null === (d = d[0]) || void 0 === d || null === (d = d.xmlJson) || void 0 === d ? void 0 : d.xml, X = { "id": null == K || null === (E = K.outSide) || void 0 === E || null === (E = E.toolID) || void 0 === E ? void 0 : E.toolIDValue, "typeId": null == K || null === (k = K.outSide) || void 0 === k || null === (k = k.toolScene) || void 0 === k ? void 0 : k.toolSceneID, "uuid": null == c || null === (R = c.data) || void 0 === R || null === (R = R[0]) || void 0 === R ? void 0 : R.uuid, "title": null == K || null === (U = K.outSide) || void 0 === U || null === (U = U.toolTitle) || void 0 === U ? void 0 : U.toolTitleValue, "content": null == K || null === (H = K.outSide) || void 0 === H || null === (H = H.toolDesc) || void 0 === H ? void 0 : H.toolDescValue, "avatar": null == K || null === (G = K.outSide) || void 0 === G || null === (G = G.userId) || void 0 === G ? void 0 : G.authorCover, "picture": null == K || null === (W = K.outSide) || void 0 === W || null === (W = W.toolBackUrl) || void 0 === W ? void 0 : W.toolBackUrlValue, "nickName": null == K || null === (Z = K.outSide) || void 0 === Z || null === (Z = Z.userId) || void 0 === Z ? void 0 : Z.authorName }, Q = null == K || null === (Y = K.inner) || void 0 === Y || null === (Y = Y.userInputStepList) || void 0 === Y || null === (Y = Y.userInputStep) || void 0 === Y ? void 0 : Y.map((function (c) { return { "type": c.inputBoxType, "value": c.inputBoxTitle, "content": c.inputBoxDefaultValue } })).filter((function (c) { return 1 == c.type })); X.inner = Q; var ee = null == K || null === (J = K.inner) || void 0 === J || null === (J = J.userInputSugList) || void 0 === J ? void 0 : J.userInputSug.filter((function (c) { return !!c.tagName })).map((function (c) { return { "tagName": c.tagName, "hints": c.caseWord.split(";") } })); X.suggestions = ee, console.log(X, "smartInfo"), u("updateSmartInfo", X) } else console.log("get smart info error", c.msg), v("jumpError") })).catch((function (c) { console.log("handle smart info error", c), v("jumpError") })) } catch (c) { console.log("handle smart info error", c), v("jumpError") } }, "recordTemplateMap": function recordTemplateMap(c, u) { var d = c.commit, v = c.state; d("updateMindTemplateMap", u); var E = v.mindTemplateMap; E.smartId = u.smartId, U.Z.setItem("generateTemplateMap", E) }, "jumpError": function jumpError() { var c = this.isH5 ? "/error" : "/pages/404/index"; (0, Se.Jx)(c) } }, Ee = d(2396), Ce = { "namespaced": !0, "state": { "smartId": "", "uuid": "", "smartInfo": {}, "mindTemplateMap": {}, "textInfo": { "status": "", "artId": "", "textRes": [] } }, "getters": d.n(Ee)(), "mutations": be, "actions": we }, Te = { "updateActivityId": function updateActivityId(c, u) { c.activityId = u }, "updateGenerateParams": function updateGenerateParams(c, u) { c.generateParams = u }, "updateStaticsParams": function updateStaticsParams(c, u) { c.staticsParams = u }, "updateMaterialImg": function updateMaterialImg(c, u) { c.materialImg = u }, "updateMaterialByImg": function updateMaterialByImg(c, u) { c.materialByImg = u }, "updateMaterialByNormal": function updateMaterialByNormal(c, u) { c.materialByNormal = u }, "updateMaterialBgInfo": function updateMaterialBgInfo(c, u) { var d, v, E; (c.materialBgInfo = u, console.log(c.materialBgInfo, "mm"), null !== (d = c.materialBgInfo) && void 0 !== d && d.imgUrl) && this.commit("eCard/updateMaterialInfo", { "imgUrl": c.materialBgInfo.imgUrl, "blessings": null === (v = c.materialInfo) || void 0 === v ? void 0 : v.blessings, "receiver": null === (E = c.materialInfo) || void 0 === E ? void 0 : E.receiver }) }, "updateTimer": function updateTimer(c, u) { c.timer = u }, "updateIsRead": function updateIsRead(c, u) { c.isRead = u }, "updateMaterialInfo": function updateMaterialInfo(c, u) { c.materialInfo = u }, "updateCount": function updateCount(c, u) { c.count = u }, "updateIsStopInterval": function updateIsStopInterval(c, u) { c.isStopInterval = u } }, xe = d(7853), Ae = d(3363), Ie = { "addProduceCount": function addProduceCount() { return Ae.Z.get({ "url": "".concat(xe.Jl, "/activity/card/pic/produce/count") }) } }, ke = 10745, Oe = { "type": 1, "templateId": 56, "templateTypeCode": "2", "promptCh": "Best quality, masterpiece,bright Eyes,(ultra-detailed face),8k,<lora:add_detail:1>, <lora:LCM_LoRA_Weights_SD15:1> , <lora:weight_slider-LECO-v1:-3>,<lora:S-shape body:-1>", "denoising": 7, "imageCount": 1, "widthProp": 2, "highProp": 3, "baseImageWidth": 512, "baseImageHeight": 768, "width": 512, "high": 768 }, Pe = { "stepOneImg": "//q3.itc.cn/images/20240306/d1de0ef99181479699e399dff8a7cd4f.png", "stepTwoImg": "//q4.itc.cn/images/20240306/3c7a684fee94472eb0297ddd1450f098.png", "toWhomPlaceholder": "想鼓励谁瘦身？", "contentPlaceholder": "你可以从下方选择瘦身flag，或手动输入哦", "genBtnText": "一键合成瘦身海报", "banner": "//q2.itc.cn/images/20240306/1d6b4edff00c4425bda3e3bbb680025f.png", "qrCodeUrl": "//q3.itc.cn/images/20240308/4667eb3f35de4175b00549807408b0a4.png" }, Re = { "intervalMsg": function intervalMsg(c, u) { var d = c.commit, v = c.state, E = c.dispatch, k = u.isFirstInterval, R = void 0 === k || k; if (!v.isStopInterval) { var U = v.materialBgInfo; switch (null == U ? void 0 : U.status) { case "success": case "fail": E("readMsg"); break; default: d("updateTimer", setTimeout((function () { E("handleInterval") }), R ? 0 : 3e3)) } } }, "handleInterval": function handleInterval(c) { return (0, W.Z)((0, G.Z)().mark((function _callee() { var u, d, v, E, k; return (0, G.Z)().wrap((function _callee$(R) { for (; ;)switch (R.prev = R.next) { case 0: return u = c.commit, d = c.dispatch, R.prev = 1, R.next = 4, J.Z.getGenerateMsg(); case 4: v = R.sent, E = v.code, k = v.data, R.t0 = E, R.next = 1 === R.t0 ? 9 : R.t0 === le.z2.ERROR.code ? 14 : R.t0 === le.z2.TIMEOUT.code ? 16 : 200003 === R.t0 ? 18 : 20; break; case 9: if (null == k || !k.artId) { R.next = 12; break } return R.next = 12, d("getDetail", k); case 12: return k && d("intervalMsg", { "isFirstInterval": !1 }), R.abrupt("break", 21); case 14: case 16: return d("genMaterialBgError"), R.abrupt("break", 21); case 18: return u("updateMaterialBgInfo", { "status": "fail", "imgUrl": "" }), R.abrupt("break", 21); case 20: d("genMaterialBgError"); case 21: u("updateIsRead", !1), R.next = 27; break; case 24: R.prev = 24, R.t1 = R.catch(1), d("genMaterialBgError"); case 27: case "end": return R.stop() } }), _callee, null, [[1, 24]]) })))() }, "readMsg": function readMsg(c) { return (0, W.Z)((0, G.Z)().mark((function _callee2() { var u, d; return (0, G.Z)().wrap((function _callee2$(v) { for (; ;)switch (v.prev = v.next) { case 0: return u = c.commit, v.prev = 1, v.next = 4, J.Z.readGenerateMsg(); case 4: 1 === (d = v.sent).code ? (u("updateIsRead", !0), console.log("消息已读成功")) : console.log("消息已读失败", null == d ? void 0 : d.msg), v.next = 11; break; case 8: v.prev = 8, v.t0 = v.catch(1), console.log("消息已读接口异常", v.t0); case 11: case "end": return v.stop() } }), _callee2, null, [[1, 8]]) })))() }, "getDetail": function getDetail(c, u) { return (0, W.Z)((0, G.Z)().mark((function _callee3() { var d, v, E, k, R; return (0, G.Z)().wrap((function _callee3$(U) { for (; ;)switch (U.prev = U.next) { case 0: return d = c.commit, v = c.state, E = c.dispatch, U.prev = 1, U.next = 4, se.Z.getArtDetail({ "blogId": null == u ? void 0 : u.artId }); case 4: if (1 != (null == (k = U.sent) ? void 0 : k.code)) { U.next = 12; break } return d("updateMaterialBgInfo", { "imgUrl": null === (R = k.data) || void 0 === R || null === (R = R.ext) || void 0 === R || null === (R = R.pics[0]) || void 0 === R ? void 0 : R.url, "status": "success" }), U.next = 9, E("getCount"); case 9: ue.dK.trackAction(ke, { "activityId": v.activityId }), U.next = 13; break; case 12: console.log("查询详情失败", k); case 13: U.next = 18; break; case 15: U.prev = 15, U.t0 = U.catch(1), console.log("查询详情接口异常", U.t0); case 18: case "end": return U.stop() } }), _callee3, null, [[1, 15]]) })))() }, "updateECardInfo": function updateECardInfo(c, u) { return (0, W.Z)((0, G.Z)().mark((function _callee4() { var d, v, E, k, R; return (0, G.Z)().wrap((function _callee4$(U) { for (; ;)switch (U.prev = U.next) { case 0: if (d = c.commit, v = c.state, E = c.dispatch, k = u.code, R = u.data, 1 !== k) { U.next = 11; break } if (U.t0 = null == R ? void 0 : R.artId, !U.t0) { U.next = 7; break } return U.next = 7, E("getDetail", R); case 7: clearTimeout(v.timer), d("updateTimer", null), U.next = 12; break; case 11: clearTimeout(v.timer); case 12: R && E("intervalMsg", { "isFirstInterval": !1 }); case 13: case "end": return U.stop() } }), _callee4) })))() }, "genMaterialBgError": function genMaterialBgError(c) { return (0, W.Z)((0, G.Z)().mark((function _callee5() { var u, d; return (0, G.Z)().wrap((function _callee5$(v) { for (; ;)switch (v.prev = v.next) { case 0: return u = c.commit, d = c.dispatch, v.next = 3, d("readMsg"); case 3: return v.next = 5, d("getCount"); case 5: u("updateMaterialBgInfo", { "imgUrl": "", "status": "fail" }); case 6: case "end": return v.stop() } }), _callee5) })))() }, "getCount": function getCount(c) { return (0, W.Z)((0, G.Z)().mark((function _callee6() { var u, d, v, E; return (0, G.Z)().wrap((function _callee6$(k) { for (; ;)switch (k.prev = k.next) { case 0: return u = c.commit, d = c.rootState, k.prev = 1, v = { "userId": d.base.userInfo.userId }, k.next = 5, J.Z.getTodayCount(v); case 5: 1 === (E = k.sent).code ? u("updateCount", E.data || 0) : console.log(E.msg, "获取次数失败"), k.next = 12; break; case 9: k.prev = 9, k.t0 = k.catch(1), console.log(k.t0, "获取次数失败"); case 12: case "end": return k.stop() } }), _callee6, null, [[1, 9]]) })))() }, "getActivityInfo": function getActivityInfo(c) { return (0, W.Z)((0, G.Z)().mark((function _callee7() { var u, d, v, E, k; return (0, G.Z)().wrap((function _callee7$(R) { for (; ;)switch (R.prev = R.next) { case 0: return u = c.commit, d = c.state, R.prev = 1, R.next = 4, Ie.getActivityInfo({ "activityId": d.activityId }); case 4: 1 == (v = R.sent).code ? (u("updateGenerateParams", null === (E = v.data) || void 0 === E ? void 0 : E.generateParams), u("updateStaticsParams", null === (k = v.data) || void 0 === k ? void 0 : k.staticsParams)) : 100004 === v.code ? (console.log(v.msg, "活动id不存在"), (0, Se.Jx)("/error")) : (console.log(v.msg, "获取活动配置信息失败"), u("updateGenerateParams", Oe), u("updateStaticsParams", Pe)), R.next = 12; break; case 8: R.prev = 8, R.t0 = R.catch(1), console.log(R.t0, "获取活动配置信息失败"), (0, Se.Jx)("/error"); case 12: case "end": return R.stop() } }), _callee7, null, [[1, 8]]) })))() } }, Me = { "namespaced": !0, "state": { "activityId": "", "generateParams": {}, "staticsParams": {}, "materialImg": "", "materialInfo": {}, "materialByImg": {}, "materialByNormal": {}, "materialBgInfo": { "imgUrl": "", "status": "init" }, "timer": null, "isRead": !1, "count": 10, "isStopInterval": !1 }, "getters": { "isXCX": function isXCX(c) { return c.isWeixin || c.isBaidu || c.isToutiao }, "xcxEnv": function xcxEnv(c) { return c.isWeixin ? "wx" : c.isBaidu ? "bd" : c.isToutiao ? "tt" : "" } }, "mutations": Te, "actions": Re }, Ne = { "changeReplyCommentInfo": function changeReplyCommentInfo(c, u) { c.replyCommentInfo = u }, "receiveParamsFromGenerate": function receiveParamsFromGenerate(c, u) { c.createInfo = { "status": "loading", "couldStop": !1, "createParams": u.params, "creator": u.creator, "picGroupId": u.picGroupId }, this.commit("artDetail/receiveParamsFromGenerate", u) }, "resetCreateParams": function resetCreateParams(c, u) { c.createInfo = (0, k.Z)((0, k.Z)({}, c.createInfo), u), console.log("resetCreateParams trail", c.createInfo), this.commit("artDetail/resetCreateParams", c.createInfo) }, "updateCreateStatus": function updateCreateStatus(c, u) { c.createInfo = (0, k.Z)((0, k.Z)({}, c.createInfo), {}, { "status": u }), this.commit("artDetail/updateCreateStatus", u) }, "getCreateInfo": function getCreateInfo(c) { c.createInfo.status || U.Z.getItem("createInfo") && (c.createInfo = U.Z.getItem("createInfo")) }, "updateTimer": function updateTimer(c, u) { c.timer = u }, "updateRemainTime": function updateRemainTime(c, u) { c.remainTime = u }, "updateIsRead": function updateIsRead(c, u) { c.isRead = u }, "getCreateList": function getCreateList(c) { return c.trailCreateList && c.trailCreateList.length ? c.trailCreateList : U.Z.getItem("createList") }, "addCreateList": function addCreateList(c, u) { c.trailCreateList = c.trailCreateList.filter((function (c) { return c.picGroupId !== u.picGroupId })), c.trailCreateList = [].concat((0, R.Z)(c.trailCreateList), [(0, k.Z)((0, k.Z)({}, u), {}, { "spmReport": !1 })]), U.Z.setItem("createList", c.trailCreateList) }, "updateCreateList": function updateCreateList(c, u) { Array.isArray(u) ? c.trailCreateList = u : -1 === c.trailCreateList.findIndex((function (c) { return c.picGroupId === u.picGroupId })) ? this.commit("trailDetail/addCreateList", u) : c.trailCreateList = c.trailCreateList.map((function (c) { return c.picGroupId === u.picGroupId ? (0, k.Z)((0, k.Z)({}, c), u) : c })); this.commit("artDetail/updateCreateList", u) } }, De = { "getCreateList": function getCreateList(c) { var u = c.state; return u.trailCreateList && u.trailCreateList.length ? u.trailCreateList : U.Z.getItem("createList") }, "intervalMsg": function intervalMsg(c, u) { var d = c.commit, v = c.state, E = c.dispatch, k = u.isFirstInterval, R = void 0 === k || k, U = u.clkParam, H = void 0 === U ? "" : U, G = v.trailCreateList, W = null == G ? void 0 : G.map((function (c) { return c.status })); null != W && W.includes("success") && setTimeout((function () { E("generateSuccess") }), 3e3), null != W && W.includes("fail") && E("generateError", H), null != W && W.includes("stopped") && E("generateStopped"), (null != W && W.includes("loading") || G.filter((function (c) { return !c.spmReport })).length) && (console.log("call handleTrailInterval in vuex"), d("updateTimer", setTimeout((function () { E("handleTrailInterval") }), R ? 0 : 3e3))) }, "handleTrailInterval": function handleTrailInterval(c) { return (0, W.Z)((0, G.Z)().mark((function _callee2() { var u, d, v, E, k, R; return (0, G.Z)().wrap((function _callee2$(U) { for (; ;)switch (U.prev = U.next) { case 0: return u = c.commit, d = c.dispatch, v = c.state, U.prev = 1, U.next = 4, J.Z.getTrailGenerateMsgMulti(); case 4: if (1 !== (E = U.sent).code && ue.dK.trackAction(ce.o.POINTS_DETAIL_NETWORK_FAILD, { "type": 1 }), E.data) { U.next = 9; break } return u("resetCreateParams", { "status": null, "couldStop": !1, "createParams": {}, "creator": {} }), U.abrupt("return"); case 9: if (k = [], 0 !== E.data.length) { U.next = 15; break } return clearTimeout(v.timer), u("updateTimer", null), u("updateCreateList", k), U.abrupt("return"); case 15: return R = E.data.map(function () { var c = (0, W.Z)((0, G.Z)().mark((function _callee(c, u) { return (0, G.Z)().wrap((function _callee$(v) { for (; ;)switch (v.prev = v.next) { case 0: return v.next = 2, d("getCreateItem", { "createItem": c, "listIndex": u, "couldStop": void 0 === (null == c ? void 0 : c.couldStop) || (null == c ? void 0 : c.couldStop) }); case 2: case "end": return v.stop() } }), _callee) }))); return function (u, d) { return c.apply(this, arguments) } }()), U.next = 18, Promise.all(R); case 18: d("intervalMsg", { "isFirstInterval": !1 }), U.next = 24; break; case 21: U.prev = 21, U.t0 = U.catch(1), ue.dK.trackAction(ce.o.POINTS_DETAIL_NETWORK_FAILD, { "type": 2 }); case 24: case "end": return U.stop() } }), _callee2, null, [[1, 21]]) })))() }, "getCreateItem": function getCreateItem(c, u) { var d, v, E, R, H, G, W, Z, Y, J, K, X, Q, ee, te, ne = c.commit, re = c.dispatch, oe = c.rootState, ie = u.createItem, ae = ie.code, se = ie.data, ce = ie.couldStop; if (se) { var ue = se.picGroupId, de = se.remainTime, fe = se.aiProduceResp, he = { "picGroupId": ue, "remainTime": de, "couldStop": ce }; switch (ae) { case le.z2.SUCCESS.code: var me, ge, _e; if (null != se && se.taskId) he.createParams = (0, k.Z)((0, k.Z)({}, se.requestParam), {}, { "id": se.picGroupId, "imgList": se.images.map((function (c) { return { "url": c, "coverImg": (0, pe.Nc)(c, 800), "width": se.requestParam.width, "height": se.requestParam.high } })), "templateName": ((null == se || null === (me = se.requestParam) || void 0 === me ? void 0 : me.templateType) || "默认") + "-" + ((null == se || null === (ge = se.requestParam) || void 0 === ge ? void 0 : ge.templateName) || "默认风格"), "templateLevel": (null == se || null === (_e = se.requestParam) || void 0 === _e ? void 0 : _e.templateLevel) || 0 }), he.creator = oe.base.userInfo, he.status = "success", he.couldStop = !1, ne("base/addTrailItem", (0, k.Z)((0, k.Z)({}, fe), {}, { "taskId": se.taskId, "picGroupId": se.picGroupId, "publishTime": (new Date).getTime() }), { "root": !0 }); else if (se && !se.taskId) { var ve, ye, be; he.createParams = (0, k.Z)((0, k.Z)({}, se.requestParam), {}, { "templateName": ((null == se || null === (ve = se.requestParam) || void 0 === ve ? void 0 : ve.templateType) || "默认") + "-" + ((null == se || null === (ye = se.requestParam) || void 0 === ye ? void 0 : ye.templateName) || "默认风格"), "templateLevel": (null == se || null === (be = se.requestParam) || void 0 === be ? void 0 : be.templateLevel) || 0 }), he.creator = oe.base.userInfo, he.status = "loading" } break; case le.z2.ERROR.code: var Se = U.Z.getItem("featureCardUUid"); re("updateErrorInfo", { "clkParam": "templateId:".concat(null === (d = se.requestParam) || void 0 === d ? void 0 : d.templateId, ";promptCh:").concat(encodeURIComponent(null === (v = se.requestParam) || void 0 === v ? void 0 : v.promptCh), ";type:1;uuid:").concat(Se), "createItem": ie }), he = { "picGroupId": (null == ie || null === (E = ie.data) || void 0 === E ? void 0 : E.picGroupId) || (null == ie ? void 0 : ie.picGroupId), "createParams": (0, k.Z)((0, k.Z)({}, se.requestParam), {}, { "templateName": ((null == se || null === (R = se.requestParam) || void 0 === R ? void 0 : R.templateType) || "默认") + "-" + ((null == se || null === (H = se.requestParam) || void 0 === H ? void 0 : H.templateName) || "默认风格") }) || (null == ie ? void 0 : ie.createParams), "creator": oe.base.userInfo, "status": "fail" }; break; case le.z2.STOPPED.code: he.createParams = (0, k.Z)((0, k.Z)({}, se.requestParam), {}, { "templateName": ((null == se || null === (G = se.requestParam) || void 0 === G ? void 0 : G.templateType) || "默认") + "-" + ((null == se || null === (W = se.requestParam) || void 0 === W ? void 0 : W.templateName) || "默认风格") }), he.creator = oe.base.userInfo, he.status = "stopped"; break; case le.z2.TIMEOUT.code: re("updateErrorInfo", { "clkParam": "type:3", "createItem": ie }), he = { "picGroupId": (null == ie || null === (Z = ie.data) || void 0 === Z ? void 0 : Z.picGroupId) || (null == ie ? void 0 : ie.picGroupId), "createParams": (0, k.Z)((0, k.Z)({}, se.requestParam), {}, { "templateName": ((null == se || null === (Y = se.requestParam) || void 0 === Y ? void 0 : Y.templateType) || "默认") + "-" + ((null == se || null === (J = se.requestParam) || void 0 === J ? void 0 : J.templateName) || "默认风格"), "templateLevel": (null == se || null === (K = se.requestParam) || void 0 === K ? void 0 : K.templateLevel) || 0 }) || (null == ie ? void 0 : ie.createParams), "creator": oe.base.userInfo, "status": "fail" }; break; default: he = { "picGroupId": (null == ie || null === (X = ie.data) || void 0 === X ? void 0 : X.picGroupId) || (null == ie ? void 0 : ie.picGroupId), "createParams": (0, k.Z)((0, k.Z)({}, se.requestParam), {}, { "templateName": ((null == se || null === (Q = se.requestParam) || void 0 === Q ? void 0 : Q.templateType) || "默认") + "-" + ((null == se || null === (ee = se.requestParam) || void 0 === ee ? void 0 : ee.templateName) || "默认风格"), "templateLevel": (null == se || null === (te = se.requestParam) || void 0 === te ? void 0 : te.templateLevel) || 0 }) || (null == ie ? void 0 : ie.createParams), "creator": oe.base.userInfo, "status": "fail" } }ne("updateCreateList", he) } }, "generateSuccess": function generateSuccess(c) { var u, d = c.commit, v = c.state, E = c.dispatch; d("getCreateList"); var k = null === (u = v.trailCreateList) || void 0 === u ? void 0 : u.filter((function (c) { return "success" === c.status })); k.length && (null == k || k.forEach(function () { var c = (0, W.Z)((0, G.Z)().mark((function _callee3(c) { var u, k, R, U, H, W, Z, Y; return (0, G.Z)().wrap((function _callee3$(G) { for (; ;)switch (G.prev = G.next) { case 0: return G.next = 2, E("sendSpmACodes", { "createInfo": c }); case 2: d("getCreateInfo"), R = v.createInfo, console.log(R, "createInfo"), R.picGroupId === c.picGroupId && d("resetCreateParams", c), U = null === (u = (0, fe.FN)().router) || void 0 === u || null === (u = u.path) || void 0 === u ? void 0 : u.includes("/detail"), H = null === (k = (0, fe.FN)().router) || void 0 === k ? void 0 : k.params, U ? JSON.stringify(H).includes(null == c || null === (W = c.createParams) || void 0 === W ? void 0 : W.id) ? E("readMsg", c.picGroupId) : getGenerateMsgInfo("SUCCESS", { "name": "detail", "id": null == c || null === (Z = c.createParams) || void 0 === Z ? void 0 : Z.id, "type": "taskId" }, c.picGroupId) : getGenerateMsgInfo("SUCCESS", { "name": "detail", "id": null == c || null === (Y = c.createParams) || void 0 === Y ? void 0 : Y.id, "type": "taskId" }, c.picGroupId); case 9: case "end": return G.stop() } }), _callee3) }))); return function (u) { return c.apply(this, arguments) } }())) }, "generateStopped": function generateStopped(c) { return (0, W.Z)((0, G.Z)().mark((function _callee5() { var u, d, v, E, k; return (0, G.Z)().wrap((function _callee5$(R) { for (; ;)switch (R.prev = R.next) { case 0: if (d = c.commit, v = c.state, E = c.dispatch, d("getCreateList"), (k = null === (u = v.trailCreateList) || void 0 === u ? void 0 : u.filter((function (c) { return ["stopScoreError", "stopped"].includes(c.status) }))).length) { R.next = 5; break } return R.abrupt("return"); case 5: null == k || k.forEach(function () { var c = (0, W.Z)((0, G.Z)().mark((function _callee4(c) { return (0, G.Z)().wrap((function _callee4$(u) { for (; ;)switch (u.prev = u.next) { case 0: d("getCreateInfo"), v.createInfo.picGroupId === c.picGroupId && d("resetCreateParams", c), E("readMsg", c.picGroupId); case 4: case "end": return u.stop() } }), _callee4) }))); return function (u) { return c.apply(this, arguments) } }()); case 6: case "end": return R.stop() } }), _callee5) })))() }, "generateError": function generateError(c) { var u, d = c.state, v = c.dispatch, E = c.commit, R = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ""; E("getCreateList"); var U = null === (u = d.trailCreateList) || void 0 === u ? void 0 : u.filter((function (c) { return "fail" === c.status })); U.length && (null == U || U.forEach(function () { var c = (0, W.Z)((0, G.Z)().mark((function _callee6(c) { var u, U, H, W, Z, Y, J, K; return (0, G.Z)().wrap((function _callee6$(G) { for (; ;)switch (G.prev = G.next) { case 0: if (E("getCreateInfo"), (U = d.createInfo).picGroupId === c.picGroupId && E("resetCreateParams", c), !c.spmReport) { G.next = 5; break } return G.abrupt("return"); case 5: H = "ERROR", R.includes("type:1") ? H = "ERROR" : R.includes("type:3") && (H = "TIMEOUT"), (null === (u = (0, fe.FN)().router) || void 0 === u || null === (u = u.path) || void 0 === u ? void 0 : u.includes("/imgLoading")) ? U.picGroupId === c.picGroupId && (Q.Y.emit("getCreateDetail"), !R.includes("type:2") && v("readMsg", c.picGroupId)) : (Z = c.createParams, Y = "byText", 2 === Z.type && (Y = "200" === Z.templateTypeCode ? "byCommodity" : "202" === Z.templateTypeCode ? "byPersonBg" : "byPortrait"), 5 === Z.type && (Y = "byHDZoom"), 1 === Z.type && (Y = "byImg"), J = encodeURIComponent(JSON.stringify((0, k.Z)((0, k.Z)({}, Z), {}, { "genType": Y, "imgUrl": Z.imageUrl }))), K = null === (W = le.eA.find((function (c) { return c.id === Y }))) || void 0 === W ? void 0 : W.newPath, getGenerateMsgInfo(H, { "name": K, "genObj": J }, c.picGroupId)), E("updateCreateList", (0, k.Z)((0, k.Z)({}, c), {}, { "spmReport": !0 })); case 10: case "end": return G.stop() } }), _callee6) }))); return function (u) { return c.apply(this, arguments) } }())) }, "readMsg": function readMsg(c, u) { return (0, W.Z)((0, G.Z)().mark((function _callee7() { var d, v, E, k; return (0, G.Z)().wrap((function _callee7$(R) { for (; ;)switch (R.prev = R.next) { case 0: return d = c.commit, v = c.state, R.prev = 1, R.next = 4, J.Z.readGenerateMsg({ "picGroupIds": [u] }); case 4: 1 === (E = R.sent).code ? (console.log("消息已读成功"), d("getCreateList"), k = v.trailCreateList.filter((function (c) { return c.picGroupId !== u })), d("updateCreateList", k)) : console.log("消息已读失败", null == E ? void 0 : E.msg), R.next = 11; break; case 8: R.prev = 8, R.t0 = R.catch(1), console.log("消息已读接口异常", R.t0); case 11: case "end": return R.stop() } }), _callee7, null, [[1, 8]]) })))() }, "updateErrorInfo": function updateErrorInfo(c, u) { var d, v = c.dispatch, E = u.clkParam, k = u.createItem; U.Z.removeItem("art_".concat(null == k || null === (d = k.data) || void 0 === d ? void 0 : d.picGroupId, "_startTime")), v("base/getTrailCount", {}, { "root": !0 }), (0, he.vX)({ "acode": ce.o.GENERATE_ERROR, "clkParam": E }) }, "sendSpmACodes": function sendSpmACodes(c, u) { var d, v, E, R, H, G, W, Z, Y, J, K, X, Q, ee, te, ne, re, oe = c.commit, ie = c.rootState, ae = c.dispatch, se = u.createInfo; if (!se.spmReport && !0 !== location.href.includes("imgLoading")) { ie.base.isLogin && (console.log("merge trail when login", U.Z.getItem("trailList")), ae("base/mergeArt", U.Z.getItem("trailList"), { "root": !0 })), oe("updateCreateList", (0, k.Z)((0, k.Z)({}, se), {}, { "spmReport": !0 })); var le = U.Z.getItem("art_".concat(se.picGroupId, "_startTime")), ue = 2; if (1 === (null == se || null === (d = se.createParams) || void 0 === d ? void 0 : d.type)) ue = 1; else if (2 === (null == se || null === (v = se.createParams) || void 0 === v ? void 0 : v.type)) { var de, pe, fe; "200" === (null == se || null === (de = se.createParams) || void 0 === de ? void 0 : de.templateTypeCode) ? ue = 3 : "201" === (null == se || null === (pe = se.createParams) || void 0 === pe ? void 0 : pe.templateTypeCode) ? ue = 4 : "202" == (null == se || null === (fe = se.createParams) || void 0 === fe ? void 0 : fe.templateTypeCode) && (ue = 9) } else 5 == (null == se || null === (E = se.createParams) || void 0 === E ? void 0 : E.type) && (ue = 8); var me, ge = U.Z.getItem("featureCardUUid"), _e = se.createParams.templateLevel > 0 ? 1 : 2, ve = (null == se || null === (R = se.createParams) || void 0 === R ? void 0 : R.imageUrl) || "null", ye = (null == se || null === (H = se.createParams) || void 0 === H ? void 0 : H.backImgUrl) || "null", be = (null == se || null === (G = se.createParams) || void 0 === G ? void 0 : G.subType) || 1; ve = ve.replace(/^https?:\/\//, ""), ye = ye.replace(/^https?:\/\//, ""), me = "templateId:".concat(null == se ? void 0 : se.createParams.templateId, ";templateType:").concat(null == se || null === (W = se.createParams) || void 0 === W ? void 0 : W.templateType, ";imageCount:").concat(null == se || null === (Z = se.createParams) || void 0 === Z ? void 0 : Z.imageCount, ";") + "scale:".concat(null == se || null === (Y = se.createParams) || void 0 === Y ? void 0 : Y.widthProp, ":").concat(null == se || null === (J = se.createParams) || void 0 === J ? void 0 : J.highProp, ";") + "high:".concat(null == se || null === (K = se.createParams) || void 0 === K ? void 0 : K.high, ";width:").concat(null == se || null === (X = se.createParams) || void 0 === X ? void 0 : X.width, ";promptCh:").concat(encodeURIComponent((null == se || null === (Q = se.createParams) || void 0 === Q ? void 0 : Q.promptCh) || "null"), ";userId:").concat((null == se || null === (ee = se.creator) || void 0 === ee ? void 0 : ee.userId) || "null", ";generateType:").concat(ue, ";vip:").concat(_e, ";imageUrl:").concat(ve, ";backImgUrl:").concat(ye, ";uuid:").concat(ge, ";kind:").concat(be), 1 === ue || 2 === ue ? (0, he.vX)({ "acode": ce.o.GENERATE_SUCCESS, "clkParam": me }) : 3 !== ue && 4 !== ue && 8 != ue && 9 != ue || (0, he.vX)({ "acode": ce.o.CREATE_Commodity_Portrait_SUCCESS, "clkParam": me }), (0, he.vX)({ "acode": 10976, "clkParam": "requestId:".concat(null == le ? void 0 : le.requestId, ";timeDiff:").concat((new Date).getTime() - +(null == le ? void 0 : le.time), ";").concat(me) }), U.Z.removeItem("art_".concat(se.picGroupId, "_startTime")); var Se = JSON.parse(U.Z.getItem("newSizeMap")), we = (null == se || null === (te = se.createParams) || void 0 === te ? void 0 : te.widthProp) + ":" + (null == se || null === (ne = se.createParams) || void 0 === ne ? void 0 : ne.highProp), Ee = -1 !== Se.findIndex((function (c) { return c.size === we && "原图比例" === c.label })); (null == se || null === (re = se.createParams) || void 0 === re ? void 0 : re.imageUrl) && Ee && (0, he.vX)({ "acode": ce.o.USE_ORIGIN_SIZE }), U.Z.getItem("isGenerateSame") && (U.Z.removeItem("isGenerateSame"), (0, he.vX)({ "acode": ce.o.GENERATE_SAME })) } } }, $e = d(9922), Le = { "namespaced": !0, "state": { "replyCommentInfo": { "replyInfo": { "level": 1, "commentInfo": null }, "vm": null }, "createInfo": { "status": null, "createParams": {}, "creator": {}, "picGroupId": "" }, "trailCreateList": [], "timer": null, "remainTime": 0, "isRead": !1 }, "getters": d.n($e)(), "mutations": Ne, "actions": De }, Fe = (0, v.MT)({ "modules": { "base": te, "artDetail": _e, "trailDetail": Le, "generate": ie, "homeSearch": ye, "textGenerate": Ce, "eCard": Me } }) }, "2396": function () { }, "9922": function () { }, "6252": function (c, u, d) { "use strict"; d.d(u, { "$d": function () { return callWithAsyncErrorHandling }, "Ah": function () { return he }, "FN": function () { return getCurrentInstance }, "Fl": function () { return computed }, "HY": function () { return xe }, "JJ": function () { return provide }, "Ko": function () { return renderList }, "LL": function () { return resolveDynamicComponent }, "Nv": function () { return createSlots }, "P$": function () { return ce }, "Q2": function () { return resolveDirective }, "Q6": function () { return getTransitionRawChildren }, "Rr": function () { return useSlots }, "U2": function () { return resolveTransitionHooks }, "Uk": function () { return createTextVNode }, "Us": function () { return createRenderer }, "WI": function () { return renderSlot }, "Wm": function () { return Me }, "Y3": function () { return nextTick }, "Y8": function () { return useTransitionState }, "YP": function () { return watch }, "_": function () { return createBaseVNode }, "aZ": function () { return defineComponent }, "bv": function () { return ue }, "f3": function () { return inject }, "h": function () { return h }, "iD": function () { return createElementBlock }, "ic": function () { return pe }, "j4": function () { return createBlock }, "kq": function () { return createCommentVNode }, "l1": function () { return useAttrs }, "nJ": function () { return se }, "nK": function () { return setTransitionHooks }, "uE": function () { return createStaticVNode }, "up": function () { return resolveComponent }, "w5": function () { return withCtx }, "wg": function () { return openBlock }, "wy": function () { return withDirectives } }); var v = d(2610), E = d(3577); function callWithErrorHandling(c, u, d, v) { try { return v ? c(...v) : c() } catch (c) { handleError(c, u, d) } } function callWithAsyncErrorHandling(c, u, d, v) { if ((0, E.mf)(c)) { const k = callWithErrorHandling(c, u, d, v); return k && (0, E.tI)(k) && k.catch((c => { handleError(c, u, d) })), k } if ((0, E.kJ)(c)) { const E = []; for (let k = 0; k < c.length; k++)E.push(callWithAsyncErrorHandling(c[k], u, d, v)); return E } } function handleError(c, u, d, E = !0) { u && u.vnode; if (u) { let E = u.parent; const k = u.proxy, R = `https://vuejs.org/error-reference/#runtime-${d}`; for (; E;) { const u = E.ec; if (u) for (let d = 0; d < u.length; d++)if (!1 === u[d](c, k, R)) return; E = E.parent } const U = u.appContext.config.errorHandler; if (U) return (0, v.Jd)(), callWithErrorHandling(U, null, 10, [c, k, R]), void (0, v.lk)() } !function logError(c, u, d, v = !0) { console.error(c) }(c, 0, 0, E) } let k = !1, R = !1; const U = []; let H = 0; const G = []; let W = null, Z = 0; const Y = Promise.resolve(); let J = null; function nextTick(c) { const u = J || Y; return c ? u.then(this ? c.bind(this) : c) : u } function queueJob(c) { U.length && U.includes(c, k && c.allowRecurse ? H + 1 : H) || (null == c.id ? U.push(c) : U.splice(function findInsertionIndex(c) { let u = H + 1, d = U.length; for (; u < d;) { const v = u + d >>> 1, E = U[v], k = getId(E); k < c || k === c && E.pre ? u = v + 1 : d = v } return u }(c.id), 0, c), queueFlush()) } function queueFlush() { k || R || (R = !0, J = Y.then(flushJobs)) } function queuePostFlushCb(c) { (0, E.kJ)(c) ? G.push(...c) : W && W.includes(c, c.allowRecurse ? Z + 1 : Z) || G.push(c), queueFlush() } function flushPreFlushCbs(c, u, d = (k ? H + 1 : 0)) { for (0; d < U.length; d++) { const u = U[d]; if (u && u.pre) { if (c && u.id !== c.uid) continue; 0, U.splice(d, 1), d--, u() } } } function flushPostFlushCbs(c) { if (G.length) { const c = [...new Set(G)].sort(((c, u) => getId(c) - getId(u))); if (G.length = 0, W) return void W.push(...c); for (W = c, Z = 0; Z < W.length; Z++)W[Z](); W = null, Z = 0 } } const getId = c => null == c.id ? 1 / 0 : c.id, comparator = (c, u) => { const d = getId(c) - getId(u); if (0 === d) { if (c.pre && !u.pre) return -1; if (u.pre && !c.pre) return 1 } return d }; function flushJobs(c) { R = !1, k = !0, U.sort(comparator); E.dG; try { for (H = 0; H < U.length; H++) { const c = U[H]; c && !1 !== c.active && callWithErrorHandling(c, null, 14) } } finally { H = 0, U.length = 0, flushPostFlushCbs(), k = !1, J = null, (U.length || G.length) && flushJobs(c) } } function emit(c, u, ...d) { if (c.isUnmounted) return; const v = c.vnode.props || E.kT; let k = d; const R = u.startsWith("update:"), U = R && u.slice(7); if (U && U in v) { const c = `${"modelValue" === U ? "model" : U}Modifiers`, { "number": u, "trim": R } = v[c] || E.kT; R && (k = d.map((c => (0, E.HD)(c) ? c.trim() : c))), u && (k = d.map(E.h5)) } let H; let G = v[H = (0, E.hR)(u)] || v[H = (0, E.hR)((0, E._A)(u))]; !G && R && (G = v[H = (0, E.hR)((0, E.rs)(u))]), G && callWithAsyncErrorHandling(G, c, 6, k); const W = v[H + "Once"]; if (W) { if (c.emitted) { if (c.emitted[H]) return } else c.emitted = {}; c.emitted[H] = !0, callWithAsyncErrorHandling(W, c, 6, k) } } function normalizeEmitsOptions(c, u, d = !1) { const v = u.emitsCache, k = v.get(c); if (void 0 !== k) return k; const R = c.emits; let U = {}, H = !1; if (!(0, E.mf)(c)) { const extendEmits = c => { const d = normalizeEmitsOptions(c, u, !0); d && (H = !0, (0, E.l7)(U, d)) }; !d && u.mixins.length && u.mixins.forEach(extendEmits), c.extends && extendEmits(c.extends), c.mixins && c.mixins.forEach(extendEmits) } return R || H ? ((0, E.kJ)(R) ? R.forEach((c => U[c] = null)) : (0, E.l7)(U, R), (0, E.Kn)(c) && v.set(c, U), U) : ((0, E.Kn)(c) && v.set(c, null), null) } function isEmitListener(c, u) { return !(!c || !(0, E.F7)(u)) && (u = u.slice(2).replace(/Once$/, ""), (0, E.RI)(c, u[0].toLowerCase() + u.slice(1)) || (0, E.RI)(c, (0, E.rs)(u)) || (0, E.RI)(c, u)) } let K = null, X = null; function setCurrentRenderingInstance(c) { const u = K; return K = c, X = c && c.type.__scopeId || null, u } function withCtx(c, u = K, d) { if (!u) return c; if (c._n) return c; const renderFnWithContext = (...d) => { renderFnWithContext._d && setBlockTracking(-1); const v = setCurrentRenderingInstance(u); let E; try { E = c(...d) } finally { setCurrentRenderingInstance(v), renderFnWithContext._d && setBlockTracking(1) } return E }; return renderFnWithContext._n = !0, renderFnWithContext._c = !0, renderFnWithContext._d = !0, renderFnWithContext } function renderComponentRoot(c) { const { "type": u, "vnode": d, "proxy": v, "withProxy": k, "propsOptions": [R], "slots": U, "attrs": H, "emit": G, "render": W, "renderCache": Z, "props": Y, "data": J, "setupState": K, "ctx": X, "inheritAttrs": Q } = c, ee = setCurrentRenderingInstance(c); let te, ne; try { if (4 & d.shapeFlag) { const c = k || v, u = c; te = normalizeVNode(W.call(u, c, Z, Y, K, J, X)), ne = H } else { const c = u; 0, te = normalizeVNode(c.length > 1 ? c(Y, { "attrs": H, "slots": U, "emit": G }) : c(Y, null)), ne = u.props ? H : getFunctionalFallthrough(H) } } catch (u) { Oe.length = 0, handleError(u, c, 1), te = Me(Ie) } let re = te; if (ne && !1 !== Q) { const c = Object.keys(ne), { "shapeFlag": u } = re; c.length && 7 & u && (R && c.some(E.tR) && (ne = filterModelListeners(ne, R)), re = cloneVNode(re, ne, !1, !0)) } return d.dirs && (re = cloneVNode(re, null, !1, !0), re.dirs = re.dirs ? re.dirs.concat(d.dirs) : d.dirs), d.transition && (re.transition = d.transition), te = re, setCurrentRenderingInstance(ee), te } const getFunctionalFallthrough = c => { let u; for (const d in c) ("class" === d || "style" === d || (0, E.F7)(d)) && ((u || (u = {}))[d] = c[d]); return u }, filterModelListeners = (c, u) => { const d = {}; for (const v in c) (0, E.tR)(v) && v.slice(9) in u || (d[v] = c[v]); return d }; function hasPropsChanged(c, u, d) { const v = Object.keys(u); if (v.length !== Object.keys(c).length) return !0; for (let E = 0; E < v.length; E++) { const k = v[E]; if (u[k] !== c[k] && !isEmitListener(d, k)) return !0 } return !1 } function updateHOCHostEl({ "vnode": c, "parent": u }, d) { for (; u;) { const v = u.subTree; if (v.suspense && v.suspense.activeBranch === c && (v.el = c.el), v !== c) break; (c = u.vnode).el = d, u = u.parent } } const Q = "components", ee = "directives"; function resolveComponent(c, u) { return resolveAsset(Q, c, !0, u) || c } const te = Symbol.for("v-ndc"); function resolveDynamicComponent(c) { return (0, E.HD)(c) ? resolveAsset(Q, c, !1) || c : c || te } function resolveDirective(c) { return resolveAsset(ee, c) } function resolveAsset(c, u, d = !0, v = !1) { const k = K || $e; if (k) { const d = k.type; if (c === Q) { const c = getComponentName(d, !1); if (c && (c === u || c === (0, E._A)(u) || c === (0, E.kC)((0, E._A)(u)))) return d } const R = resolve(k[c] || d[c], u) || resolve(k.appContext[c], u); return !R && v ? d : R } } function resolve(c, u) { return c && (c[u] || c[(0, E._A)(u)] || c[(0, E.kC)((0, E._A)(u))]) } const isSuspense = c => c.__isSuspense; function queueEffectWithSuspense(c, u) { u && u.pendingBranch ? (0, E.kJ)(c) ? u.effects.push(...c) : u.effects.push(c) : queuePostFlushCb(c) } const ne = Symbol.for("v-scx"), useSSRContext = () => { { const c = inject(ne); return c } }; const re = {}; function watch(c, u, d) { return doWatch(c, u, d) } function doWatch(c, u, { "immediate": d, "deep": k, "flush": R, "once": U, "onTrack": H, "onTrigger": G } = E.kT) { if (u && U) { const c = u; u = (...u) => { c(...u), unwatch() } } const W = $e, reactiveGetter = c => !0 === k ? c : traverse(c, !1 === k ? 1 : void 0); let Z, Y, J = !1, K = !1; if ((0, v.dq)(c) ? (Z = () => c.value, J = (0, v.yT)(c)) : (0, v.PG)(c) ? (Z = () => reactiveGetter(c), J = !0) : (0, E.kJ)(c) ? (K = !0, J = c.some((c => (0, v.PG)(c) || (0, v.yT)(c))), Z = () => c.map((c => (0, v.dq)(c) ? c.value : (0, v.PG)(c) ? reactiveGetter(c) : (0, E.mf)(c) ? callWithErrorHandling(c, W, 2) : void 0))) : Z = (0, E.mf)(c) ? u ? () => callWithErrorHandling(c, W, 2) : () => (Y && Y(), callWithAsyncErrorHandling(c, W, 3, [onCleanup])) : E.dG, u && k) { const c = Z; Z = () => traverse(c()) } let X, onCleanup = c => { Y = te.onStop = () => { callWithErrorHandling(c, W, 4), Y = te.onStop = void 0 } }; if (Ue) { if (onCleanup = E.dG, u ? d && callWithAsyncErrorHandling(u, W, 3, [Z(), K ? [] : void 0, onCleanup]) : Z(), "sync" !== R) return E.dG; { const c = useSSRContext(); X = c.__watcherHandles || (c.__watcherHandles = []) } } let Q = K ? new Array(c.length).fill(re) : re; const job = () => { if (te.active && te.dirty) if (u) { const c = te.run(); (k || J || (K ? c.some(((c, u) => (0, E.aU)(c, Q[u]))) : (0, E.aU)(c, Q))) && (Y && Y(), callWithAsyncErrorHandling(u, W, 3, [c, Q === re ? void 0 : K && Q[0] === re ? [] : Q, onCleanup]), Q = c) } else te.run() }; let ee; job.allowRecurse = !!u, "sync" === R ? ee = job : "post" === R ? ee = () => Te(job, W && W.suspense) : (job.pre = !0, W && (job.id = W.uid), ee = () => queueJob(job)); const te = new v.qq(Z, E.dG, ee), ne = (0, v.nZ)(), unwatch = () => { te.stop(), ne && (0, E.Od)(ne.effects, te) }; return u ? d ? job() : Q = te.run() : "post" === R ? Te(te.run.bind(te), W && W.suspense) : te.run(), X && X.push(unwatch), unwatch } function instanceWatch(c, u, d) { const v = this.proxy, k = (0, E.HD)(c) ? c.includes(".") ? createPathGetter(v, c) : () => v[c] : c.bind(v, v); let R; (0, E.mf)(u) ? R = u : (R = u.handler, d = u); const U = setCurrentInstance(this), H = doWatch(k, R.bind(v), d); return U(), H } function createPathGetter(c, u) { const d = u.split("."); return () => { let u = c; for (let c = 0; c < d.length && u; c++)u = u[d[c]]; return u } } function traverse(c, u = 1 / 0, d) { if (u <= 0 || !(0, E.Kn)(c) || c.__v_skip) return c; if ((d = d || new Set).has(c)) return c; if (d.add(c), u--, (0, v.dq)(c)) traverse(c.value, u, d); else if ((0, E.kJ)(c)) for (let v = 0; v < c.length; v++)traverse(c[v], u, d); else if ((0, E.DM)(c) || (0, E._N)(c)) c.forEach((c => { traverse(c, u, d) })); else if ((0, E.PO)(c)) for (const v in c) traverse(c[v], u, d); return c } function withDirectives(c, u) { if (null === K) return c; const d = getExposeProxy(K) || K.proxy, v = c.dirs || (c.dirs = []); for (let c = 0; c < u.length; c++) { let [k, R, U, H = E.kT] = u[c]; k && ((0, E.mf)(k) && (k = { "mounted": k, "updated": k }), k.deep && traverse(R), v.push({ "dir": k, "instance": d, "value": R, "oldValue": void 0, "arg": U, "modifiers": H })) } return c } function invokeDirectiveHook(c, u, d, E) { const k = c.dirs, R = u && u.dirs; for (let U = 0; U < k.length; U++) { const H = k[U]; R && (H.oldValue = R[U].value); let G = H.dir[E]; G && ((0, v.Jd)(), callWithAsyncErrorHandling(G, d, 8, [c.el, H, c, u]), (0, v.lk)()) } } const oe = Symbol("_leaveCb"), ie = Symbol("_enterCb"); function useTransitionState() { const c = { "isMounted": !1, "isLeaving": !1, "isUnmounting": !1, "leavingVNodes": new Map }; return ue((() => { c.isMounted = !0 })), fe((() => { c.isUnmounting = !0 })), c } const ae = [Function, Array], se = { "mode": String, "appear": Boolean, "persisted": Boolean, "onBeforeEnter": ae, "onEnter": ae, "onAfterEnter": ae, "onEnterCancelled": ae, "onBeforeLeave": ae, "onLeave": ae, "onAfterLeave": ae, "onLeaveCancelled": ae, "onBeforeAppear": ae, "onAppear": ae, "onAfterAppear": ae, "onAppearCancelled": ae }, ce = { "name": "BaseTransition", "props": se, "setup"(c, { "slots": u }) { const d = getCurrentInstance(), E = useTransitionState(); return () => { const k = u.default && getTransitionRawChildren(u.default(), !0); if (!k || !k.length) return; let R = k[0]; if (k.length > 1) { let c = !1; for (const u of k) if (u.type !== Ie) { 0, R = u, c = !0; break } } const U = (0, v.IU)(c), { "mode": H } = U; if (E.isLeaving) return emptyPlaceholder(R); const G = getKeepAliveChild(R); if (!G) return emptyPlaceholder(R); const W = resolveTransitionHooks(G, U, E, d); setTransitionHooks(G, W); const Z = d.subTree, Y = Z && getKeepAliveChild(Z); if (Y && Y.type !== Ie && !isSameVNodeType(G, Y)) { const c = resolveTransitionHooks(Y, U, E, d); if (setTransitionHooks(Y, c), "out-in" === H && G.type !== Ie) return E.isLeaving = !0, c.afterLeave = () => { E.isLeaving = !1, !1 !== d.update.active && (d.effect.dirty = !0, d.update()) }, emptyPlaceholder(R); "in-out" === H && G.type !== Ie && (c.delayLeave = (c, u, d) => { getLeavingNodesForType(E, Y)[String(Y.key)] = Y, c[oe] = () => { u(), c[oe] = void 0, delete W.delayedLeave }, W.delayedLeave = d }) } return R } } }; function getLeavingNodesForType(c, u) { const { "leavingVNodes": d } = c; let v = d.get(u.type); return v || (v = Object.create(null), d.set(u.type, v)), v } function resolveTransitionHooks(c, u, d, v) { const { "appear": k, "mode": R, "persisted": U = !1, "onBeforeEnter": H, "onEnter": G, "onAfterEnter": W, "onEnterCancelled": Z, "onBeforeLeave": Y, "onLeave": J, "onAfterLeave": K, "onLeaveCancelled": X, "onBeforeAppear": Q, "onAppear": ee, "onAfterAppear": te, "onAppearCancelled": ne } = u, re = String(c.key), ae = getLeavingNodesForType(d, c), callHook = (c, u) => { c && callWithAsyncErrorHandling(c, v, 9, u) }, callAsyncHook = (c, u) => { const d = u[1]; callHook(c, u), (0, E.kJ)(c) ? c.every((c => c.length <= 1)) && d() : c.length <= 1 && d() }, se = { "mode": R, "persisted": U, "beforeEnter"(u) { let v = H; if (!d.isMounted) { if (!k) return; v = Q || H } u[oe] && u[oe](!0); const E = ae[re]; E && isSameVNodeType(c, E) && E.el[oe] && E.el[oe](), callHook(v, [u]) }, "enter"(c) { let u = G, v = W, E = Z; if (!d.isMounted) { if (!k) return; u = ee || G, v = te || W, E = ne || Z } let R = !1; const U = c[ie] = u => { R || (R = !0, callHook(u ? E : v, [c]), se.delayedLeave && se.delayedLeave(), c[ie] = void 0) }; u ? callAsyncHook(u, [c, U]) : U() }, "leave"(u, v) { const E = String(c.key); if (u[ie] && u[ie](!0), d.isUnmounting) return v(); callHook(Y, [u]); let k = !1; const R = u[oe] = d => { k || (k = !0, v(), callHook(d ? X : K, [u]), u[oe] = void 0, ae[E] === c && delete ae[E]) }; ae[E] = c, J ? callAsyncHook(J, [u, R]) : R() }, "clone"(c) { return resolveTransitionHooks(c, u, d, v) } }; return se } function emptyPlaceholder(c) { if (isKeepAlive(c)) return (c = cloneVNode(c)).children = null, c } function getKeepAliveChild(c) { if (!isKeepAlive(c)) return c; const { "shapeFlag": u, "children": d } = c; if (d) { if (16 & u) return d[0]; if (32 & u && (0, E.mf)(d.default)) return d.default() } } function setTransitionHooks(c, u) { 6 & c.shapeFlag && c.component ? setTransitionHooks(c.component.subTree, u) : 128 & c.shapeFlag ? (c.ssContent.transition = u.clone(c.ssContent), c.ssFallback.transition = u.clone(c.ssFallback)) : c.transition = u } function getTransitionRawChildren(c, u = !1, d) { let v = [], E = 0; for (let k = 0; k < c.length; k++) { let R = c[k]; const U = null == d ? R.key : String(d) + String(null != R.key ? R.key : k); R.type === xe ? (128 & R.patchFlag && E++, v = v.concat(getTransitionRawChildren(R.children, u, U))) : (u || R.type !== Ie) && v.push(null != U ? cloneVNode(R, { "key": U }) : R) } if (E > 1) for (let c = 0; c < v.length; c++)v[c].patchFlag = -2; return v } function defineComponent(c, u) { return (0, E.mf)(c) ? (() => (0, E.l7)({ "name": c.name }, u, { "setup": c }))() : c } const isAsyncWrapper = c => !!c.type.__asyncLoader; const isKeepAlive = c => c.type.__isKeepAlive; RegExp, RegExp; function matches(c, u) { return (0, E.kJ)(c) ? c.some((c => matches(c, u))) : (0, E.HD)(c) ? c.split(",").includes(u) : !!(0, E.Kj)(c) && c.test(u) } function onActivated(c, u) { registerKeepAliveHook(c, "a", u) } function onDeactivated(c, u) { registerKeepAliveHook(c, "da", u) } function registerKeepAliveHook(c, u, d = $e) { const v = c.__wdc || (c.__wdc = () => { let u = d; for (; u;) { if (u.isDeactivated) return; u = u.parent } return c() }); if (injectHook(u, v, d), d) { let c = d.parent; for (; c && c.parent;)isKeepAlive(c.parent.vnode) && injectToKeepAliveRoot(v, u, d, c), c = c.parent } } function injectToKeepAliveRoot(c, u, d, v) { const k = injectHook(u, c, v, !0); he((() => { (0, E.Od)(v[u], k) }), d) } function resetShapeFlag(c) { c.shapeFlag &= -257, c.shapeFlag &= -513 } function getInnerChild(c) { return 128 & c.shapeFlag ? c.ssContent : c } function injectHook(c, u, d = $e, E = !1) { if (d) { const k = d[c] || (d[c] = []), R = u.__weh || (u.__weh = (...E) => { if (d.isUnmounted) return; (0, v.Jd)(); const k = setCurrentInstance(d), R = callWithAsyncErrorHandling(u, d, c, E); return k(), (0, v.lk)(), R }); return E ? k.unshift(R) : k.push(R), R } } const createHook = c => (u, d = $e) => (!Ue || "sp" === c) && injectHook(c, ((...c) => u(...c)), d), le = createHook("bm"), ue = createHook("m"), de = createHook("bu"), pe = createHook("u"), fe = createHook("bum"), he = createHook("um"), me = createHook("sp"), ge = createHook("rtg"), _e = createHook("rtc"); function onErrorCaptured(c, u = $e) { injectHook("ec", c, u) } function renderList(c, u, d, v) { let k; const R = d && d[v]; if ((0, E.kJ)(c) || (0, E.HD)(c)) { k = new Array(c.length); for (let d = 0, v = c.length; d < v; d++)k[d] = u(c[d], d, void 0, R && R[d]) } else if ("number" == typeof c) { 0, k = new Array(c); for (let d = 0; d < c; d++)k[d] = u(d + 1, d, void 0, R && R[d]) } else if ((0, E.Kn)(c)) if (c[Symbol.iterator]) k = Array.from(c, ((c, d) => u(c, d, void 0, R && R[d]))); else { const d = Object.keys(c); k = new Array(d.length); for (let v = 0, E = d.length; v < E; v++) { const E = d[v]; k[v] = u(c[E], E, v, R && R[v]) } } else k = []; return d && (d[v] = k), k } function createSlots(c, u) { for (let d = 0; d < u.length; d++) { const v = u[d]; if ((0, E.kJ)(v)) for (let u = 0; u < v.length; u++)c[v[u].name] = v[u].fn; else v && (c[v.name] = v.key ? (...c) => { const u = v.fn(...c); return u && (u.key = v.key), u } : v.fn) } return c } function renderSlot(c, u, d = {}, v, E) { if (K.isCE || K.parent && isAsyncWrapper(K.parent) && K.parent.isCE) return "default" !== u && (d.name = u), Me("slot", d, v && v()); let k = c[u]; k && k._c && (k._d = !1), openBlock(); const R = k && ensureValidVNode(k(d)), U = createBlock(xe, { "key": d.key || R && R.key || `_${u}` }, R || (v ? v() : []), R && 1 === c._ ? 64 : -2); return !E && U.scopeId && (U.slotScopeIds = [U.scopeId + "-s"]), k && k._c && (k._d = !0), U } function ensureValidVNode(c) { return c.some((c => !isVNode(c) || c.type !== Ie && !(c.type === xe && !ensureValidVNode(c.children)))) ? c : null } const getPublicInstance = c => c ? isStatefulComponent(c) ? getExposeProxy(c) || c.proxy : getPublicInstance(c.parent) : null, ve = (0, E.l7)(Object.create(null), { "$": c => c, "$el": c => c.vnode.el, "$data": c => c.data, "$props": c => c.props, "$attrs": c => c.attrs, "$slots": c => c.slots, "$refs": c => c.refs, "$parent": c => getPublicInstance(c.parent), "$root": c => getPublicInstance(c.root), "$emit": c => c.emit, "$options": c => resolveMergedOptions(c), "$forceUpdate": c => c.f || (c.f = () => { c.effect.dirty = !0, queueJob(c.update) }), "$nextTick": c => c.n || (c.n = nextTick.bind(c.proxy)), "$watch": c => instanceWatch.bind(c) }), hasSetupBinding = (c, u) => c !== E.kT && !c.__isScriptSetup && (0, E.RI)(c, u), ye = { "get"({ "_": c }, u) { if ("__v_skip" === u) return !0; const { "ctx": d, "setupState": k, "data": R, "props": U, "accessCache": H, "type": G, "appContext": W } = c; let Z; if ("$" !== u[0]) { const v = H[u]; if (void 0 !== v) switch (v) { case 1: return k[u]; case 2: return R[u]; case 4: return d[u]; case 3: return U[u] } else { if (hasSetupBinding(k, u)) return H[u] = 1, k[u]; if (R !== E.kT && (0, E.RI)(R, u)) return H[u] = 2, R[u]; if ((Z = c.propsOptions[0]) && (0, E.RI)(Z, u)) return H[u] = 3, U[u]; if (d !== E.kT && (0, E.RI)(d, u)) return H[u] = 4, d[u]; be && (H[u] = 0) } } const Y = ve[u]; let J, K; return Y ? ("$attrs" === u && (0, v.j)(c.attrs, "get", ""), Y(c)) : (J = G.__cssModules) && (J = J[u]) ? J : d !== E.kT && (0, E.RI)(d, u) ? (H[u] = 4, d[u]) : (K = W.config.globalProperties, (0, E.RI)(K, u) ? K[u] : void 0) }, "set"({ "_": c }, u, d) { const { "data": v, "setupState": k, "ctx": R } = c; return hasSetupBinding(k, u) ? (k[u] = d, !0) : v !== E.kT && (0, E.RI)(v, u) ? (v[u] = d, !0) : !(0, E.RI)(c.props, u) && (("$" !== u[0] || !(u.slice(1) in c)) && (R[u] = d, !0)) }, "has"({ "_": { "data": c, "setupState": u, "accessCache": d, "ctx": v, "appContext": k, "propsOptions": R } }, U) { let H; return !!d[U] || c !== E.kT && (0, E.RI)(c, U) || hasSetupBinding(u, U) || (H = R[0]) && (0, E.RI)(H, U) || (0, E.RI)(v, U) || (0, E.RI)(ve, U) || (0, E.RI)(k.config.globalProperties, U) }, "defineProperty"(c, u, d) { return null != d.get ? c._.accessCache[u] = 0 : (0, E.RI)(d, "value") && this.set(c, u, d.value, null), Reflect.defineProperty(c, u, d) } }; function useSlots() { return getContext().slots } function useAttrs() { return getContext().attrs } function getContext() { const c = getCurrentInstance(); return c.setupContext || (c.setupContext = createSetupContext(c)) } function normalizePropsOrEmits(c) { return (0, E.kJ)(c) ? c.reduce(((c, u) => (c[u] = null, c)), {}) : c } let be = !0; function applyOptions(c) { const u = resolveMergedOptions(c), d = c.proxy, k = c.ctx; be = !1, u.beforeCreate && callHook(u.beforeCreate, c, "bc"); const { "data": R, "computed": U, "methods": H, "watch": G, "provide": W, "inject": Z, "created": Y, "beforeMount": J, "mounted": K, "beforeUpdate": X, "updated": Q, "activated": ee, "deactivated": te, "beforeDestroy": ne, "beforeUnmount": re, "destroyed": oe, "unmounted": ie, "render": ae, "renderTracked": se, "renderTriggered": ce, "errorCaptured": ve, "serverPrefetch": ye, "expose": Se, "inheritAttrs": we, "components": Ee, "directives": Ce, "filters": Te } = u; if (Z && function resolveInjections(c, u, d = E.dG) { (0, E.kJ)(c) && (c = normalizeInject(c)); for (const d in c) { const k = c[d]; let R; R = (0, E.Kn)(k) ? "default" in k ? inject(k.from || d, k.default, !0) : inject(k.from || d) : inject(k), (0, v.dq)(R) ? Object.defineProperty(u, d, { "enumerable": !0, "configurable": !0, "get": () => R.value, "set": c => R.value = c }) : u[d] = R } }(Z, k, null), H) for (const c in H) { const u = H[c]; (0, E.mf)(u) && (k[c] = u.bind(d)) } if (R) { 0; const u = R.call(d, d); 0, (0, E.Kn)(u) && (c.data = (0, v.qj)(u)) } if (be = !0, U) for (const c in U) { const u = U[c], v = (0, E.mf)(u) ? u.bind(d, d) : (0, E.mf)(u.get) ? u.get.bind(d, d) : E.dG; 0; const R = !(0, E.mf)(u) && (0, E.mf)(u.set) ? u.set.bind(d) : E.dG, H = computed({ "get": v, "set": R }); Object.defineProperty(k, c, { "enumerable": !0, "configurable": !0, "get": () => H.value, "set": c => H.value = c }) } if (G) for (const c in G) createWatcher(G[c], k, d, c); if (W) { const c = (0, E.mf)(W) ? W.call(d) : W; Reflect.ownKeys(c).forEach((u => { provide(u, c[u]) })) } function registerLifecycleHook(c, u) { (0, E.kJ)(u) ? u.forEach((u => c(u.bind(d)))) : u && c(u.bind(d)) } if (Y && callHook(Y, c, "c"), registerLifecycleHook(le, J), registerLifecycleHook(ue, K), registerLifecycleHook(de, X), registerLifecycleHook(pe, Q), registerLifecycleHook(onActivated, ee), registerLifecycleHook(onDeactivated, te), registerLifecycleHook(onErrorCaptured, ve), registerLifecycleHook(_e, se), registerLifecycleHook(ge, ce), registerLifecycleHook(fe, re), registerLifecycleHook(he, ie), registerLifecycleHook(me, ye), (0, E.kJ)(Se)) if (Se.length) { const u = c.exposed || (c.exposed = {}); Se.forEach((c => { Object.defineProperty(u, c, { "get": () => d[c], "set": u => d[c] = u }) })) } else c.exposed || (c.exposed = {}); ae && c.render === E.dG && (c.render = ae), null != we && (c.inheritAttrs = we), Ee && (c.components = Ee), Ce && (c.directives = Ce) } function callHook(c, u, d) { callWithAsyncErrorHandling((0, E.kJ)(c) ? c.map((c => c.bind(u.proxy))) : c.bind(u.proxy), u, d) } function createWatcher(c, u, d, v) { const k = v.includes(".") ? createPathGetter(d, v) : () => d[v]; if ((0, E.HD)(c)) { const d = u[c]; (0, E.mf)(d) && watch(k, d) } else if ((0, E.mf)(c)) watch(k, c.bind(d)); else if ((0, E.Kn)(c)) if ((0, E.kJ)(c)) c.forEach((c => createWatcher(c, u, d, v))); else { const v = (0, E.mf)(c.handler) ? c.handler.bind(d) : u[c.handler]; (0, E.mf)(v) && watch(k, v, c) } else 0 } function resolveMergedOptions(c) { const u = c.type, { "mixins": d, "extends": v } = u, { "mixins": k, "optionsCache": R, "config": { "optionMergeStrategies": U } } = c.appContext, H = R.get(u); let G; return H ? G = H : k.length || d || v ? (G = {}, k.length && k.forEach((c => mergeOptions(G, c, U, !0))), mergeOptions(G, u, U)) : G = u, (0, E.Kn)(u) && R.set(u, G), G } function mergeOptions(c, u, d, v = !1) { const { "mixins": E, "extends": k } = u; k && mergeOptions(c, k, d, !0), E && E.forEach((u => mergeOptions(c, u, d, !0))); for (const E in u) if (v && "expose" === E); else { const v = Se[E] || d && d[E]; c[E] = v ? v(c[E], u[E]) : u[E] } return c } const Se = { "data": mergeDataFn, "props": mergeEmitsOrPropsOptions, "emits": mergeEmitsOrPropsOptions, "methods": mergeObjectOptions, "computed": mergeObjectOptions, "beforeCreate": mergeAsArray, "created": mergeAsArray, "beforeMount": mergeAsArray, "mounted": mergeAsArray, "beforeUpdate": mergeAsArray, "updated": mergeAsArray, "beforeDestroy": mergeAsArray, "beforeUnmount": mergeAsArray, "destroyed": mergeAsArray, "unmounted": mergeAsArray, "activated": mergeAsArray, "deactivated": mergeAsArray, "errorCaptured": mergeAsArray, "serverPrefetch": mergeAsArray, "components": mergeObjectOptions, "directives": mergeObjectOptions, "watch": function mergeWatchOptions(c, u) { if (!c) return u; if (!u) return c; const d = (0, E.l7)(Object.create(null), c); for (const v in u) d[v] = mergeAsArray(c[v], u[v]); return d }, "provide": mergeDataFn, "inject": function mergeInject(c, u) { return mergeObjectOptions(normalizeInject(c), normalizeInject(u)) } }; function mergeDataFn(c, u) { return u ? c ? function mergedDataFn() { return (0, E.l7)((0, E.mf)(c) ? c.call(this, this) : c, (0, E.mf)(u) ? u.call(this, this) : u) } : u : c } function normalizeInject(c) { if ((0, E.kJ)(c)) { const u = {}; for (let d = 0; d < c.length; d++)u[c[d]] = c[d]; return u } return c } function mergeAsArray(c, u) { return c ? [...new Set([].concat(c, u))] : u } function mergeObjectOptions(c, u) { return c ? (0, E.l7)(Object.create(null), c, u) : u } function mergeEmitsOrPropsOptions(c, u) { return c ? (0, E.kJ)(c) && (0, E.kJ)(u) ? [...new Set([...c, ...u])] : (0, E.l7)(Object.create(null), normalizePropsOrEmits(c), normalizePropsOrEmits(null != u ? u : {})) : u } function createAppContext() { return { "app": null, "config": { "isNativeTag": E.NO, "performance": !1, "globalProperties": {}, "optionMergeStrategies": {}, "errorHandler": void 0, "warnHandler": void 0, "compilerOptions": {} }, "mixins": [], "components": {}, "directives": {}, "provides": Object.create(null), "optionsCache": new WeakMap, "propsCache": new WeakMap, "emitsCache": new WeakMap } } let we = 0; function createAppAPI(c, u) { return function createApp(d, v = null) { (0, E.mf)(d) || (d = (0, E.l7)({}, d)), null == v || (0, E.Kn)(v) || (v = null); const k = createAppContext(), R = new WeakSet; let U = !1; const H = k.app = { "_uid": we++, "_component": d, "_props": v, "_container": null, "_context": k, "_instance": null, "version": ze, get "config"() { return k.config }, set "config"(c) { 0 }, "use"(c, ...u) { return R.has(c) || (c && (0, E.mf)(c.install) ? (R.add(c), c.install(H, ...u)) : (0, E.mf)(c) && (R.add(c), c(H, ...u))), H }, "mixin"(c) { return k.mixins.includes(c) || k.mixins.push(c), H }, "component"(c, u) { return u ? (k.components[c] = u, H) : k.components[c] }, "directive"(c, u) { return u ? (k.directives[c] = u, H) : k.directives[c] }, "mount"(E, R, G) { if (!U) { 0; const W = Me(d, v); return W.appContext = k, !0 === G ? G = "svg" : !1 === G && (G = void 0), R && u ? u(W, E) : c(W, E, G), U = !0, H._container = E, E.__vue_app__ = H, getExposeProxy(W.component) || W.component.proxy } }, "unmount"() { U && (c(null, H._container), delete H._container.__vue_app__) }, "provide"(c, u) { return k.provides[c] = u, H }, "runWithContext"(c) { const u = Ee; Ee = H; try { return c() } finally { Ee = u } } }; return H } } let Ee = null; function provide(c, u) { if ($e) { let d = $e.provides; const v = $e.parent && $e.parent.provides; v === d && (d = $e.provides = Object.create(v)), d[c] = u } else 0 } function inject(c, u, d = !1) { const v = $e || K; if (v || Ee) { const k = v ? null == v.parent ? v.vnode.appContext && v.vnode.appContext.provides : v.parent.provides : Ee._context.provides; if (k && c in k) return k[c]; if (arguments.length > 1) return d && (0, E.mf)(u) ? u.call(v && v.proxy) : u } else 0 } const Ce = {}, createInternalObject = () => Object.create(Ce), isInternalObject = c => Object.getPrototypeOf(c) === Ce; function setFullProps(c, u, d, k) { const [R, U] = c.propsOptions; let H, G = !1; if (u) for (let v in u) { if ((0, E.Gg)(v)) continue; const W = u[v]; let Z; R && (0, E.RI)(R, Z = (0, E._A)(v)) ? U && U.includes(Z) ? (H || (H = {}))[Z] = W : d[Z] = W : isEmitListener(c.emitsOptions, v) || v in k && W === k[v] || (k[v] = W, G = !0) } if (U) { const u = (0, v.IU)(d), k = H || E.kT; for (let v = 0; v < U.length; v++) { const H = U[v]; d[H] = resolvePropValue(R, u, H, k[H], c, !(0, E.RI)(k, H)) } } return G } function resolvePropValue(c, u, d, v, k, R) { const U = c[d]; if (null != U) { const c = (0, E.RI)(U, "default"); if (c && void 0 === v) { const c = U.default; if (U.type !== Function && !U.skipFactory && (0, E.mf)(c)) { const { "propsDefaults": E } = k; if (d in E) v = E[d]; else { const R = setCurrentInstance(k); v = E[d] = c.call(null, u), R() } } else v = c } U[0] && (R && !c ? v = !1 : !U[1] || "" !== v && v !== (0, E.rs)(d) || (v = !0)) } return v } function normalizePropsOptions(c, u, d = !1) { const v = u.propsCache, k = v.get(c); if (k) return k; const R = c.props, U = {}, H = []; let G = !1; if (!(0, E.mf)(c)) { const extendProps = c => { G = !0; const [d, v] = normalizePropsOptions(c, u, !0); (0, E.l7)(U, d), v && H.push(...v) }; !d && u.mixins.length && u.mixins.forEach(extendProps), c.extends && extendProps(c.extends), c.mixins && c.mixins.forEach(extendProps) } if (!R && !G) return (0, E.Kn)(c) && v.set(c, E.Z6), E.Z6; if ((0, E.kJ)(R)) for (let c = 0; c < R.length; c++) { 0; const u = (0, E._A)(R[c]); validatePropName(u) && (U[u] = E.kT) } else if (R) { 0; for (const c in R) { const u = (0, E._A)(c); if (validatePropName(u)) { const d = R[c], v = U[u] = (0, E.kJ)(d) || (0, E.mf)(d) ? { "type": d } : (0, E.l7)({}, d); if (v) { const c = getTypeIndex(Boolean, v.type), d = getTypeIndex(String, v.type); v[0] = c > -1, v[1] = d < 0 || c < d, (c > -1 || (0, E.RI)(v, "default")) && H.push(u) } } } } const W = [U, H]; return (0, E.Kn)(c) && v.set(c, W), W } function validatePropName(c) { return "$" !== c[0] && !(0, E.Gg)(c) } function getType(c) { if (null === c) return "null"; if ("function" == typeof c) return c.name || ""; if ("object" == typeof c) { return c.constructor && c.constructor.name || "" } return "" } function isSameType(c, u) { return getType(c) === getType(u) } function getTypeIndex(c, u) { return (0, E.kJ)(u) ? u.findIndex((u => isSameType(u, c))) : (0, E.mf)(u) && isSameType(u, c) ? 0 : -1 } const isInternalKey = c => "_" === c[0] || "$stable" === c, normalizeSlotValue = c => (0, E.kJ)(c) ? c.map(normalizeVNode) : [normalizeVNode(c)], normalizeSlot = (c, u, d) => { if (u._n) return u; const v = withCtx(((...c) => normalizeSlotValue(u(...c))), d); return v._c = !1, v }, normalizeObjectSlots = (c, u, d) => { const v = c._ctx; for (const d in c) { if (isInternalKey(d)) continue; const k = c[d]; if ((0, E.mf)(k)) u[d] = normalizeSlot(0, k, v); else if (null != k) { 0; const c = normalizeSlotValue(k); u[d] = () => c } } }, normalizeVNodeSlots = (c, u) => { const d = normalizeSlotValue(u); c.slots.default = () => d }, initSlots = (c, u) => { const d = c.slots = createInternalObject(); if (32 & c.vnode.shapeFlag) { const c = u._; c ? ((0, E.l7)(d, u), (0, E.Nj)(d, "_", c, !0)) : normalizeObjectSlots(u, d) } else u && normalizeVNodeSlots(c, u) }, updateSlots = (c, u, d) => { const { "vnode": v, "slots": k } = c; let R = !0, U = E.kT; if (32 & v.shapeFlag) { const c = u._; c ? d && 1 === c ? R = !1 : ((0, E.l7)(k, u), d || 1 !== c || delete k._) : (R = !u.$stable, normalizeObjectSlots(u, k)), U = u } else u && (normalizeVNodeSlots(c, u), U = { "default": 1 }); if (R) for (const c in k) isInternalKey(c) || null != U[c] || delete k[c] }; function setRef(c, u, d, k, R = !1) { if ((0, E.kJ)(c)) return void c.forEach(((c, v) => setRef(c, u && ((0, E.kJ)(u) ? u[v] : u), d, k, R))); if (isAsyncWrapper(k) && !R) return; const U = 4 & k.shapeFlag ? getExposeProxy(k.component) || k.component.proxy : k.el, H = R ? null : U, { "i": G, "r": W } = c; const Z = u && u.r, Y = G.refs === E.kT ? G.refs = {} : G.refs, J = G.setupState; if (null != Z && Z !== W && ((0, E.HD)(Z) ? (Y[Z] = null, (0, E.RI)(J, Z) && (J[Z] = null)) : (0, v.dq)(Z) && (Z.value = null)), (0, E.mf)(W)) callWithErrorHandling(W, G, 12, [H, Y]); else { const u = (0, E.HD)(W), k = (0, v.dq)(W); if (u || k) { const doSet = () => { if (c.f) { const d = u ? (0, E.RI)(J, W) ? J[W] : Y[W] : W.value; R ? (0, E.kJ)(d) && (0, E.Od)(d, U) : (0, E.kJ)(d) ? d.includes(U) || d.push(U) : u ? (Y[W] = [U], (0, E.RI)(J, W) && (J[W] = Y[W])) : (W.value = [U], c.k && (Y[c.k] = W.value)) } else u ? (Y[W] = H, (0, E.RI)(J, W) && (J[W] = H)) : k && (W.value = H, c.k && (Y[c.k] = H)) }; H ? (doSet.id = -1, Te(doSet, d)) : doSet() } else 0 } } const Te = queueEffectWithSuspense; function createRenderer(c) { return baseCreateRenderer(c) } function baseCreateRenderer(c, u) { !function initFeatureFlags() { "boolean" != typeof __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ && ((0, E.E9)().__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ = !1) }(); (0, E.E9)().__VUE__ = !0; const { "insert": d, "remove": k, "patchProp": R, "createElement": G, "createText": W, "createComment": Z, "setText": Y, "setElementText": J, "parentNode": K, "nextSibling": X, "setScopeId": Q = E.dG, "insertStaticContent": ee } = c, patch = (c, u, d, v = null, E = null, k = null, R = void 0, U = null, H = !!u.dynamicChildren) => { if (c === u) return; c && !isSameVNodeType(c, u) && (v = getNextHostNode(c), unmount(c, E, k, !0), c = null), -2 === u.patchFlag && (H = !1, u.dynamicChildren = null); const { "type": G, "ref": W, "shapeFlag": Z } = u; switch (G) { case Ae: processText(c, u, d, v); break; case Ie: processCommentNode(c, u, d, v); break; case ke: null == c && mountStaticNode(u, d, v, R); break; case xe: processFragment(c, u, d, v, E, k, R, U, H); break; default: 1 & Z ? processElement(c, u, d, v, E, k, R, U, H) : 6 & Z ? processComponent(c, u, d, v, E, k, R, U, H) : (64 & Z || 128 & Z) && G.process(c, u, d, v, E, k, R, U, H, ne) }null != W && E && setRef(W, c && c.ref, k, u || c, !u) }, processText = (c, u, v, E) => { if (null == c) d(u.el = W(u.children), v, E); else { const d = u.el = c.el; u.children !== c.children && Y(d, u.children) } }, processCommentNode = (c, u, v, E) => { null == c ? d(u.el = Z(u.children || ""), v, E) : u.el = c.el }, mountStaticNode = (c, u, d, v) => { [c.el, c.anchor] = ee(c.children, u, d, v, c.el, c.anchor) }, removeStaticNode = ({ "el": c, "anchor": u }) => { let d; for (; c && c !== u;)d = X(c), k(c), c = d; k(u) }, processElement = (c, u, d, v, E, k, R, U, H) => { "svg" === u.type ? R = "svg" : "math" === u.type && (R = "mathml"), null == c ? mountElement(u, d, v, E, k, R, U, H) : patchElement(c, u, E, k, R, U, H) }, mountElement = (c, u, v, k, U, H, W, Z) => { let Y, K; const { "props": X, "shapeFlag": Q, "transition": ee, "dirs": te } = c; if (Y = c.el = G(c.type, H, X && X.is, X), 8 & Q ? J(Y, c.children) : 16 & Q && mountChildren(c.children, Y, null, k, U, resolveChildrenNamespace(c, H), W, Z), te && invokeDirectiveHook(c, null, k, "created"), setScopeId(Y, c, c.scopeId, W, k), X) { for (const u in X) "value" === u || (0, E.Gg)(u) || R(Y, u, null, X[u], H, c.children, k, U, unmountChildren); "value" in X && R(Y, "value", null, X.value, H), (K = X.onVnodeBeforeMount) && invokeVNodeHook(K, k, c) } te && invokeDirectiveHook(c, null, k, "beforeMount"); const ne = needTransition(U, ee); ne && ee.beforeEnter(Y), d(Y, u, v), ((K = X && X.onVnodeMounted) || ne || te) && Te((() => { K && invokeVNodeHook(K, k, c), ne && ee.enter(Y), te && invokeDirectiveHook(c, null, k, "mounted") }), U) }, setScopeId = (c, u, d, v, E) => { if (d && Q(c, d), v) for (let u = 0; u < v.length; u++)Q(c, v[u]); if (E) { if (u === E.subTree) { const u = E.vnode; setScopeId(c, u, u.scopeId, u.slotScopeIds, E.parent) } } }, mountChildren = (c, u, d, v, E, k, R, U, H = 0) => { for (let G = H; G < c.length; G++) { const H = c[G] = U ? cloneIfMounted(c[G]) : normalizeVNode(c[G]); patch(null, H, u, d, v, E, k, R, U) } }, patchElement = (c, u, d, v, k, U, H) => { const G = u.el = c.el; let { "patchFlag": W, "dynamicChildren": Z, "dirs": Y } = u; W |= 16 & c.patchFlag; const K = c.props || E.kT, X = u.props || E.kT; let Q; if (d && toggleRecurse(d, !1), (Q = X.onVnodeBeforeUpdate) && invokeVNodeHook(Q, d, u, c), Y && invokeDirectiveHook(u, c, d, "beforeUpdate"), d && toggleRecurse(d, !0), Z ? patchBlockChildren(c.dynamicChildren, Z, G, d, v, resolveChildrenNamespace(u, k), U) : H || patchChildren(c, u, G, null, d, v, resolveChildrenNamespace(u, k), U, !1), W > 0) { if (16 & W) patchProps(G, u, K, X, d, v, k); else if (2 & W && K.class !== X.class && R(G, "class", null, X.class, k), 4 & W && R(G, "style", K.style, X.style, k), 8 & W) { const E = u.dynamicProps; for (let u = 0; u < E.length; u++) { const U = E[u], H = K[U], W = X[U]; W === H && "value" !== U || R(G, U, H, W, k, c.children, d, v, unmountChildren) } } 1 & W && c.children !== u.children && J(G, u.children) } else H || null != Z || patchProps(G, u, K, X, d, v, k); ((Q = X.onVnodeUpdated) || Y) && Te((() => { Q && invokeVNodeHook(Q, d, u, c), Y && invokeDirectiveHook(u, c, d, "updated") }), v) }, patchBlockChildren = (c, u, d, v, E, k, R) => { for (let U = 0; U < u.length; U++) { const H = c[U], G = u[U], W = H.el && (H.type === xe || !isSameVNodeType(H, G) || 70 & H.shapeFlag) ? K(H.el) : d; patch(H, G, W, null, v, E, k, R, !0) } }, patchProps = (c, u, d, v, k, U, H) => { if (d !== v) { if (d !== E.kT) for (const G in d) (0, E.Gg)(G) || G in v || R(c, G, d[G], null, H, u.children, k, U, unmountChildren); for (const G in v) { if ((0, E.Gg)(G)) continue; const W = v[G], Z = d[G]; W !== Z && "value" !== G && R(c, G, Z, W, H, u.children, k, U, unmountChildren) } "value" in v && R(c, "value", d.value, v.value, H) } }, processFragment = (c, u, v, E, k, R, U, H, G) => { const Z = u.el = c ? c.el : W(""), Y = u.anchor = c ? c.anchor : W(""); let { "patchFlag": J, "dynamicChildren": K, "slotScopeIds": X } = u; X && (H = H ? H.concat(X) : X), null == c ? (d(Z, v, E), d(Y, v, E), mountChildren(u.children || [], v, Y, k, R, U, H, G)) : J > 0 && 64 & J && K && c.dynamicChildren ? (patchBlockChildren(c.dynamicChildren, K, v, k, R, U, H), (null != u.key || k && u === k.subTree) && traverseStaticChildren(c, u, !0)) : patchChildren(c, u, v, Y, k, R, U, H, G) }, processComponent = (c, u, d, v, E, k, R, U, H) => { u.slotScopeIds = U, null == c ? 512 & u.shapeFlag ? E.ctx.activate(u, d, v, R, H) : mountComponent(u, d, v, E, k, R, H) : updateComponent(c, u, H) }, mountComponent = (c, u, d, v, E, k, R) => { const U = c.component = createComponentInstance(c, v, E); if (isKeepAlive(c) && (U.ctx.renderer = ne), setupComponent(U), U.asyncDep) { if (E && E.registerDep(U, setupRenderEffect), !c.el) { const c = U.subTree = Me(Ie); processCommentNode(null, c, u, d) } } else setupRenderEffect(U, c, u, d, E, k, R) }, updateComponent = (c, u, d) => { const v = u.component = c.component; if (function shouldUpdateComponent(c, u, d) { const { "props": v, "children": E, "component": k } = c, { "props": R, "children": U, "patchFlag": H } = u, G = k.emitsOptions; if (u.dirs || u.transition) return !0; if (!(d && H >= 0)) return !(!E && !U || U && U.$stable) || v !== R && (v ? !R || hasPropsChanged(v, R, G) : !!R); if (1024 & H) return !0; if (16 & H) return v ? hasPropsChanged(v, R, G) : !!R; if (8 & H) { const c = u.dynamicProps; for (let u = 0; u < c.length; u++) { const d = c[u]; if (R[d] !== v[d] && !isEmitListener(G, d)) return !0 } } return !1 }(c, u, d)) { if (v.asyncDep && !v.asyncResolved) return void updateComponentPreRender(v, u, d); v.next = u, function invalidateJob(c) { const u = U.indexOf(c); u > H && U.splice(u, 1) }(v.update), v.effect.dirty = !0, v.update() } else u.el = c.el, v.vnode = u }, setupRenderEffect = (c, u, d, k, R, U, H) => { const componentUpdateFn = () => { if (c.isMounted) { let { "next": u, "bu": d, "u": v, "parent": k, "vnode": G } = c; { const d = locateNonHydratedAsyncRoot(c); if (d) return u && (u.el = G.el, updateComponentPreRender(c, u, H)), void d.asyncDep.then((() => { c.isUnmounted || componentUpdateFn() })) } let W, Z = u; 0, toggleRecurse(c, !1), u ? (u.el = G.el, updateComponentPreRender(c, u, H)) : u = G, d && (0, E.ir)(d), (W = u.props && u.props.onVnodeBeforeUpdate) && invokeVNodeHook(W, k, u, G), toggleRecurse(c, !0); const Y = renderComponentRoot(c); 0; const J = c.subTree; c.subTree = Y, patch(J, Y, K(J.el), getNextHostNode(J), c, R, U), u.el = Y.el, null === Z && updateHOCHostEl(c, Y.el), v && Te(v, R), (W = u.props && u.props.onVnodeUpdated) && Te((() => invokeVNodeHook(W, k, u, G)), R) } else { let v; const { "el": H, "props": G } = u, { "bm": W, "m": Z, "parent": Y } = c, J = isAsyncWrapper(u); if (toggleRecurse(c, !1), W && (0, E.ir)(W), !J && (v = G && G.onVnodeBeforeMount) && invokeVNodeHook(v, Y, u), toggleRecurse(c, !0), H && oe) { const hydrateSubTree = () => { c.subTree = renderComponentRoot(c), oe(H, c.subTree, c, R, null) }; J ? u.type.__asyncLoader().then((() => !c.isUnmounted && hydrateSubTree())) : hydrateSubTree() } else { 0; const v = c.subTree = renderComponentRoot(c); 0, patch(null, v, d, k, c, R, U), u.el = v.el } if (Z && Te(Z, R), !J && (v = G && G.onVnodeMounted)) { const c = u; Te((() => invokeVNodeHook(v, Y, c)), R) } (256 & u.shapeFlag || Y && isAsyncWrapper(Y.vnode) && 256 & Y.vnode.shapeFlag) && c.a && Te(c.a, R), c.isMounted = !0, u = d = k = null } }, G = c.effect = new v.qq(componentUpdateFn, E.dG, (() => queueJob(W)), c.scope), W = c.update = () => { G.dirty && G.run() }; W.id = c.uid, toggleRecurse(c, !0), W() }, updateComponentPreRender = (c, u, d) => { u.component = c; const k = c.vnode.props; c.vnode = u, c.next = null, function updateProps(c, u, d, k) { const { "props": R, "attrs": U, "vnode": { "patchFlag": H } } = c, G = (0, v.IU)(R), [W] = c.propsOptions; let Z = !1; if (!(k || H > 0) || 16 & H) { let v; setFullProps(c, u, R, U) && (Z = !0); for (const k in G) u && ((0, E.RI)(u, k) || (v = (0, E.rs)(k)) !== k && (0, E.RI)(u, v)) || (W ? !d || void 0 === d[k] && void 0 === d[v] || (R[k] = resolvePropValue(W, G, k, void 0, c, !0)) : delete R[k]); if (U !== G) for (const c in U) u && (0, E.RI)(u, c) || (delete U[c], Z = !0) } else if (8 & H) { const d = c.vnode.dynamicProps; for (let v = 0; v < d.length; v++) { let k = d[v]; if (isEmitListener(c.emitsOptions, k)) continue; const H = u[k]; if (W) if ((0, E.RI)(U, k)) H !== U[k] && (U[k] = H, Z = !0); else { const u = (0, E._A)(k); R[u] = resolvePropValue(W, G, u, H, c, !1) } else H !== U[k] && (U[k] = H, Z = !0) } } Z && (0, v.X$)(c.attrs, "set", "") }(c, u.props, k, d), updateSlots(c, u.children, d), (0, v.Jd)(), flushPreFlushCbs(c), (0, v.lk)() }, patchChildren = (c, u, d, v, E, k, R, U, H = !1) => { const G = c && c.children, W = c ? c.shapeFlag : 0, Z = u.children, { "patchFlag": Y, "shapeFlag": K } = u; if (Y > 0) { if (128 & Y) return void patchKeyedChildren(G, Z, d, v, E, k, R, U, H); if (256 & Y) return void patchUnkeyedChildren(G, Z, d, v, E, k, R, U, H) } 8 & K ? (16 & W && unmountChildren(G, E, k), Z !== G && J(d, Z)) : 16 & W ? 16 & K ? patchKeyedChildren(G, Z, d, v, E, k, R, U, H) : unmountChildren(G, E, k, !0) : (8 & W && J(d, ""), 16 & K && mountChildren(Z, d, v, E, k, R, U, H)) }, patchUnkeyedChildren = (c, u, d, v, k, R, U, H, G) => { c = c || E.Z6, u = u || E.Z6; const W = c.length, Z = u.length, Y = Math.min(W, Z); let J; for (J = 0; J < Y; J++) { const v = u[J] = G ? cloneIfMounted(u[J]) : normalizeVNode(u[J]); patch(c[J], v, d, null, k, R, U, H, G) } W > Z ? unmountChildren(c, k, R, !0, !1, Y) : mountChildren(u, d, v, k, R, U, H, G, Y) }, patchKeyedChildren = (c, u, d, v, k, R, U, H, G) => { let W = 0; const Z = u.length; let Y = c.length - 1, J = Z - 1; for (; W <= Y && W <= J;) { const v = c[W], E = u[W] = G ? cloneIfMounted(u[W]) : normalizeVNode(u[W]); if (!isSameVNodeType(v, E)) break; patch(v, E, d, null, k, R, U, H, G), W++ } for (; W <= Y && W <= J;) { const v = c[Y], E = u[J] = G ? cloneIfMounted(u[J]) : normalizeVNode(u[J]); if (!isSameVNodeType(v, E)) break; patch(v, E, d, null, k, R, U, H, G), Y--, J-- } if (W > Y) { if (W <= J) { const c = J + 1, E = c < Z ? u[c].el : v; for (; W <= J;)patch(null, u[W] = G ? cloneIfMounted(u[W]) : normalizeVNode(u[W]), d, E, k, R, U, H, G), W++ } } else if (W > J) for (; W <= Y;)unmount(c[W], k, R, !0), W++; else { const K = W, X = W, Q = new Map; for (W = X; W <= J; W++) { const c = u[W] = G ? cloneIfMounted(u[W]) : normalizeVNode(u[W]); null != c.key && Q.set(c.key, W) } let ee, te = 0; const ne = J - X + 1; let re = !1, oe = 0; const ie = new Array(ne); for (W = 0; W < ne; W++)ie[W] = 0; for (W = K; W <= Y; W++) { const v = c[W]; if (te >= ne) { unmount(v, k, R, !0); continue } let E; if (null != v.key) E = Q.get(v.key); else for (ee = X; ee <= J; ee++)if (0 === ie[ee - X] && isSameVNodeType(v, u[ee])) { E = ee; break } void 0 === E ? unmount(v, k, R, !0) : (ie[E - X] = W + 1, E >= oe ? oe = E : re = !0, patch(v, u[E], d, null, k, R, U, H, G), te++) } const ae = re ? function getSequence(c) { const u = c.slice(), d = [0]; let v, E, k, R, U; const H = c.length; for (v = 0; v < H; v++) { const H = c[v]; if (0 !== H) { if (E = d[d.length - 1], c[E] < H) { u[v] = E, d.push(v); continue } for (k = 0, R = d.length - 1; k < R;)U = k + R >> 1, c[d[U]] < H ? k = U + 1 : R = U; H < c[d[k]] && (k > 0 && (u[v] = d[k - 1]), d[k] = v) } } k = d.length, R = d[k - 1]; for (; k-- > 0;)d[k] = R, R = u[R]; return d }(ie) : E.Z6; for (ee = ae.length - 1, W = ne - 1; W >= 0; W--) { const c = X + W, E = u[c], Y = c + 1 < Z ? u[c + 1].el : v; 0 === ie[W] ? patch(null, E, d, Y, k, R, U, H, G) : re && (ee < 0 || W !== ae[ee] ? move(E, d, Y, 2) : ee--) } } }, move = (c, u, v, E, k = null) => { const { "el": R, "type": U, "transition": H, "children": G, "shapeFlag": W } = c; if (6 & W) return void move(c.component.subTree, u, v, E); if (128 & W) return void c.suspense.move(u, v, E); if (64 & W) return void U.move(c, u, v, ne); if (U === xe) { d(R, u, v); for (let c = 0; c < G.length; c++)move(G[c], u, v, E); return void d(c.anchor, u, v) } if (U === ke) return void (({ "el": c, "anchor": u }, v, E) => { let k; for (; c && c !== u;)k = X(c), d(c, v, E), c = k; d(u, v, E) })(c, u, v); if (2 !== E && 1 & W && H) if (0 === E) H.beforeEnter(R), d(R, u, v), Te((() => H.enter(R)), k); else { const { "leave": c, "delayLeave": E, "afterLeave": k } = H, remove2 = () => d(R, u, v), performLeave = () => { c(R, (() => { remove2(), k && k() })) }; E ? E(R, remove2, performLeave) : performLeave() } else d(R, u, v) }, unmount = (c, u, d, v = !1, E = !1) => { const { "type": k, "props": R, "ref": U, "children": H, "dynamicChildren": G, "shapeFlag": W, "patchFlag": Z, "dirs": Y } = c; if (null != U && setRef(U, null, d, c, !0), 256 & W) return void u.ctx.deactivate(c); const J = 1 & W && Y, K = !isAsyncWrapper(c); let X; if (K && (X = R && R.onVnodeBeforeUnmount) && invokeVNodeHook(X, u, c), 6 & W) unmountComponent(c.component, d, v); else { if (128 & W) return void c.suspense.unmount(d, v); J && invokeDirectiveHook(c, null, u, "beforeUnmount"), 64 & W ? c.type.remove(c, u, d, E, ne, v) : G && (k !== xe || Z > 0 && 64 & Z) ? unmountChildren(G, u, d, !1, !0) : (k === xe && 384 & Z || !E && 16 & W) && unmountChildren(H, u, d), v && remove(c) } (K && (X = R && R.onVnodeUnmounted) || J) && Te((() => { X && invokeVNodeHook(X, u, c), J && invokeDirectiveHook(c, null, u, "unmounted") }), d) }, remove = c => { const { "type": u, "el": d, "anchor": v, "transition": E } = c; if (u === xe) return void removeFragment(d, v); if (u === ke) return void removeStaticNode(c); const performRemove = () => { k(d), E && !E.persisted && E.afterLeave && E.afterLeave() }; if (1 & c.shapeFlag && E && !E.persisted) { const { "leave": u, "delayLeave": v } = E, performLeave = () => u(d, performRemove); v ? v(c.el, performRemove, performLeave) : performLeave() } else performRemove() }, removeFragment = (c, u) => { let d; for (; c !== u;)d = X(c), k(c), c = d; k(u) }, unmountComponent = (c, u, d) => { const { "bum": v, "scope": k, "update": R, "subTree": U, "um": H } = c; v && (0, E.ir)(v), k.stop(), R && (R.active = !1, unmount(U, c, u, d)), H && Te(H, u), Te((() => { c.isUnmounted = !0 }), u), u && u.pendingBranch && !u.isUnmounted && c.asyncDep && !c.asyncResolved && c.suspenseId === u.pendingId && (u.deps--, 0 === u.deps && u.resolve()) }, unmountChildren = (c, u, d, v = !1, E = !1, k = 0) => { for (let R = k; R < c.length; R++)unmount(c[R], u, d, v, E) }, getNextHostNode = c => 6 & c.shapeFlag ? getNextHostNode(c.component.subTree) : 128 & c.shapeFlag ? c.suspense.next() : X(c.anchor || c.el); let te = !1; const render = (c, u, d) => { null == c ? u._vnode && unmount(u._vnode, null, null, !0) : patch(u._vnode || null, c, u, null, null, null, d), te || (te = !0, flushPreFlushCbs(), flushPostFlushCbs(), te = !1), u._vnode = c }, ne = { "p": patch, "um": unmount, "m": move, "r": remove, "mt": mountComponent, "mc": mountChildren, "pc": patchChildren, "pbc": patchBlockChildren, "n": getNextHostNode, "o": c }; let re, oe; return u && ([re, oe] = u(ne)), { "render": render, "hydrate": re, "createApp": createAppAPI(render, re) } } function resolveChildrenNamespace({ "type": c, "props": u }, d) { return "svg" === d && "foreignObject" === c || "mathml" === d && "annotation-xml" === c && u && u.encoding && u.encoding.includes("html") ? void 0 : d } function toggleRecurse({ "effect": c, "update": u }, d) { c.allowRecurse = u.allowRecurse = d } function needTransition(c, u) { return (!c || c && !c.pendingBranch) && u && !u.persisted } function traverseStaticChildren(c, u, d = !1) { const v = c.children, k = u.children; if ((0, E.kJ)(v) && (0, E.kJ)(k)) for (let c = 0; c < v.length; c++) { const u = v[c]; let E = k[c]; 1 & E.shapeFlag && !E.dynamicChildren && ((E.patchFlag <= 0 || 32 === E.patchFlag) && (E = k[c] = cloneIfMounted(k[c]), E.el = u.el), d || traverseStaticChildren(u, E)), E.type === Ae && (E.el = u.el) } } function locateNonHydratedAsyncRoot(c) { const u = c.subTree.component; if (u) return u.asyncDep && !u.asyncResolved ? u : locateNonHydratedAsyncRoot(u) } const xe = Symbol.for("v-fgt"), Ae = Symbol.for("v-txt"), Ie = Symbol.for("v-cmt"), ke = Symbol.for("v-stc"), Oe = []; let Pe = null; function openBlock(c = !1) { Oe.push(Pe = c ? null : []) } function closeBlock() { Oe.pop(), Pe = Oe[Oe.length - 1] || null } let Re = 1; function setBlockTracking(c) { Re += c } function setupBlock(c) { return c.dynamicChildren = Re > 0 ? Pe || E.Z6 : null, closeBlock(), Re > 0 && Pe && Pe.push(c), c } function createElementBlock(c, u, d, v, E, k) { return setupBlock(createBaseVNode(c, u, d, v, E, k, !0)) } function createBlock(c, u, d, v, E) { return setupBlock(Me(c, u, d, v, E, !0)) } function isVNode(c) { return !!c && !0 === c.__v_isVNode } function isSameVNodeType(c, u) { return c.type === u.type && c.key === u.key } const normalizeKey = ({ "key": c }) => null != c ? c : null, normalizeRef = ({ "ref": c, "ref_key": u, "ref_for": d }) => ("number" == typeof c && (c = "" + c), null != c ? (0, E.HD)(c) || (0, v.dq)(c) || (0, E.mf)(c) ? { "i": K, "r": c, "k": u, "f": !!d } : c : null); function createBaseVNode(c, u = null, d = null, v = 0, k = null, R = (c === xe ? 0 : 1), U = !1, H = !1) { const G = { "__v_isVNode": !0, "__v_skip": !0, "type": c, "props": u, "key": u && normalizeKey(u), "ref": u && normalizeRef(u), "scopeId": X, "slotScopeIds": null, "children": d, "component": null, "suspense": null, "ssContent": null, "ssFallback": null, "dirs": null, "transition": null, "el": null, "anchor": null, "target": null, "targetAnchor": null, "staticCount": 0, "shapeFlag": R, "patchFlag": v, "dynamicProps": k, "dynamicChildren": null, "appContext": null, "ctx": K }; return H ? (normalizeChildren(G, d), 128 & R && c.normalize(G)) : d && (G.shapeFlag |= (0, E.HD)(d) ? 8 : 16), Re > 0 && !U && Pe && (G.patchFlag > 0 || 6 & R) && 32 !== G.patchFlag && Pe.push(G), G } const Me = _createVNode; function _createVNode(c, u = null, d = null, k = 0, R = null, U = !1) { if (c && c !== te || (c = Ie), isVNode(c)) { const v = cloneVNode(c, u, !0); return d && normalizeChildren(v, d), Re > 0 && !U && Pe && (6 & v.shapeFlag ? Pe[Pe.indexOf(c)] = v : Pe.push(v)), v.patchFlag |= -2, v } if (isClassComponent(c) && (c = c.__vccOpts), u) { u = function guardReactiveProps(c) { return c ? (0, v.X3)(c) || isInternalObject(c) ? (0, E.l7)({}, c) : c : null }(u); let { "class": c, "style": d } = u; c && !(0, E.HD)(c) && (u.class = (0, E.C_)(c)), (0, E.Kn)(d) && ((0, v.X3)(d) && !(0, E.kJ)(d) && (d = (0, E.l7)({}, d)), u.style = (0, E.j5)(d)) } return createBaseVNode(c, u, d, k, R, (0, E.HD)(c) ? 1 : isSuspense(c) ? 128 : (c => c.__isTeleport)(c) ? 64 : (0, E.Kn)(c) ? 4 : (0, E.mf)(c) ? 2 : 0, U, !0) } function cloneVNode(c, u, d = !1, v = !1) { const { "props": k, "ref": R, "patchFlag": U, "children": H, "transition": G } = c, W = u ? function mergeProps(...c) { const u = {}; for (let d = 0; d < c.length; d++) { const v = c[d]; for (const c in v) if ("class" === c) u.class !== v.class && (u.class = (0, E.C_)([u.class, v.class])); else if ("style" === c) u.style = (0, E.j5)([u.style, v.style]); else if ((0, E.F7)(c)) { const d = u[c], k = v[c]; !k || d === k || (0, E.kJ)(d) && d.includes(k) || (u[c] = d ? [].concat(d, k) : k) } else "" !== c && (u[c] = v[c]) } return u }(k || {}, u) : k, Z = { "__v_isVNode": !0, "__v_skip": !0, "type": c.type, "props": W, "key": W && normalizeKey(W), "ref": u && u.ref ? d && R ? (0, E.kJ)(R) ? R.concat(normalizeRef(u)) : [R, normalizeRef(u)] : normalizeRef(u) : R, "scopeId": c.scopeId, "slotScopeIds": c.slotScopeIds, "children": H, "target": c.target, "targetAnchor": c.targetAnchor, "staticCount": c.staticCount, "shapeFlag": c.shapeFlag, "patchFlag": u && c.type !== xe ? -1 === U ? 16 : 16 | U : U, "dynamicProps": c.dynamicProps, "dynamicChildren": c.dynamicChildren, "appContext": c.appContext, "dirs": c.dirs, "transition": G, "component": c.component, "suspense": c.suspense, "ssContent": c.ssContent && cloneVNode(c.ssContent), "ssFallback": c.ssFallback && cloneVNode(c.ssFallback), "el": c.el, "anchor": c.anchor, "ctx": c.ctx, "ce": c.ce }; return G && v && (Z.transition = G.clone(Z)), Z } function createTextVNode(c = " ", u = 0) { return Me(Ae, null, c, u) } function createStaticVNode(c, u) { const d = Me(ke, null, c); return d.staticCount = u, d } function createCommentVNode(c = "", u = !1) { return u ? (openBlock(), createBlock(Ie, null, c)) : Me(Ie, null, c) } function normalizeVNode(c) { return null == c || "boolean" == typeof c ? Me(Ie) : (0, E.kJ)(c) ? Me(xe, null, c.slice()) : "object" == typeof c ? cloneIfMounted(c) : Me(Ae, null, String(c)) } function cloneIfMounted(c) { return null === c.el && -1 !== c.patchFlag || c.memo ? c : cloneVNode(c) } function normalizeChildren(c, u) { let d = 0; const { "shapeFlag": v } = c; if (null == u) u = null; else if ((0, E.kJ)(u)) d = 16; else if ("object" == typeof u) { if (65 & v) { const d = u.default; return void (d && (d._c && (d._d = !1), normalizeChildren(c, d()), d._c && (d._d = !0))) } { d = 32; const v = u._; v || isInternalObject(u) ? 3 === v && K && (1 === K.slots._ ? u._ = 1 : (u._ = 2, c.patchFlag |= 1024)) : u._ctx = K } } else (0, E.mf)(u) ? (u = { "default": u, "_ctx": K }, d = 32) : (u = String(u), 64 & v ? (d = 16, u = [createTextVNode(u)]) : d = 8); c.children = u, c.shapeFlag |= d } function invokeVNodeHook(c, u, d, v = null) { callWithAsyncErrorHandling(c, u, 7, [d, v]) } const Ne = createAppContext(); let De = 0; function createComponentInstance(c, u, d) { const k = c.type, R = (u ? u.appContext : c.appContext) || Ne, U = { "uid": De++, "vnode": c, "type": k, "parent": u, "appContext": R, "root": null, "next": null, "subTree": null, "effect": null, "update": null, "scope": new v.Bj(!0), "render": null, "proxy": null, "exposed": null, "exposeProxy": null, "withProxy": null, "provides": u ? u.provides : Object.create(R.provides), "accessCache": null, "renderCache": [], "components": null, "directives": null, "propsOptions": normalizePropsOptions(k, R), "emitsOptions": normalizeEmitsOptions(k, R), "emit": null, "emitted": null, "propsDefaults": E.kT, "inheritAttrs": k.inheritAttrs, "ctx": E.kT, "data": E.kT, "props": E.kT, "attrs": E.kT, "slots": E.kT, "refs": E.kT, "setupState": E.kT, "setupContext": null, "attrsProxy": null, "slotsProxy": null, "suspense": d, "suspenseId": d ? d.pendingId : 0, "asyncDep": null, "asyncResolved": !1, "isMounted": !1, "isUnmounted": !1, "isDeactivated": !1, "bc": null, "c": null, "bm": null, "m": null, "bu": null, "u": null, "um": null, "bum": null, "da": null, "a": null, "rtg": null, "rtc": null, "ec": null, "sp": null }; return U.ctx = { "_": U }, U.root = u ? u.root : U, U.emit = emit.bind(null, U), c.ce && c.ce(U), U } let $e = null; const getCurrentInstance = () => $e || K; let Le, Fe; { const c = (0, E.E9)(), registerGlobalSetter = (u, d) => { let v; return (v = c[u]) || (v = c[u] = []), v.push(d), c => { v.length > 1 ? v.forEach((u => u(c))) : v[0](c) } }; Le = registerGlobalSetter("__VUE_INSTANCE_SETTERS__", (c => $e = c)), Fe = registerGlobalSetter("__VUE_SSR_SETTERS__", (c => Ue = c)) } const setCurrentInstance = c => { const u = $e; return Le(c), c.scope.on(), () => { c.scope.off(), Le(u) } }, unsetCurrentInstance = () => { $e && $e.scope.off(), Le(null) }; function isStatefulComponent(c) { return 4 & c.vnode.shapeFlag } let je, Be, Ue = !1; function setupComponent(c, u = !1) { u && Fe(u); const { "props": d, "children": k } = c.vnode, R = isStatefulComponent(c); !function initProps(c, u, d, E = !1) { const k = {}, R = createInternalObject(); c.propsDefaults = Object.create(null), setFullProps(c, u, k, R); for (const u in c.propsOptions[0]) u in k || (k[u] = void 0); d ? c.props = E ? k : (0, v.Um)(k) : c.type.props ? c.props = k : c.props = R, c.attrs = R }(c, d, R, u), initSlots(c, k); const U = R ? function setupStatefulComponent(c, u) { const d = c.type; 0; c.accessCache = Object.create(null), c.proxy = new Proxy(c.ctx, ye), !1; const { "setup": k } = d; if (k) { const d = c.setupContext = k.length > 1 ? createSetupContext(c) : null, R = setCurrentInstance(c); (0, v.Jd)(); const U = callWithErrorHandling(k, c, 0, [c.props, d]); if ((0, v.lk)(), R(), (0, E.tI)(U)) { if (U.then(unsetCurrentInstance, unsetCurrentInstance), u) return U.then((d => { handleSetupResult(c, d, u) })).catch((u => { handleError(u, c, 0) })); c.asyncDep = U } else handleSetupResult(c, U, u) } else finishComponentSetup(c, u) }(c, u) : void 0; return u && Fe(!1), U } function handleSetupResult(c, u, d) { (0, E.mf)(u) ? c.type.__ssrInlineRender ? c.ssrRender = u : c.render = u : (0, E.Kn)(u) && (c.setupState = (0, v.WL)(u)), finishComponentSetup(c, d) } function finishComponentSetup(c, u, d) { const k = c.type; if (!c.render) { if (!u && je && !k.render) { const u = k.template || resolveMergedOptions(c).template; if (u) { 0; const { "isCustomElement": d, "compilerOptions": v } = c.appContext.config, { "delimiters": R, "compilerOptions": U } = k, H = (0, E.l7)((0, E.l7)({ "isCustomElement": d, "delimiters": R }, v), U); k.render = je(u, H) } } c.render = k.render || E.dG, Be && Be(c) } { const u = setCurrentInstance(c); (0, v.Jd)(); try { applyOptions(c) } finally { (0, v.lk)(), u() } } } const He = { "get"(c, u) { return (0, v.j)(c, "get", ""), c[u] } }; function createSetupContext(c) { const expose = u => { c.exposed = u || {} }; return { "attrs": new Proxy(c.attrs, He), "slots": c.slots, "emit": c.emit, "expose": expose } } function getExposeProxy(c) { if (c.exposed) return c.exposeProxy || (c.exposeProxy = new Proxy((0, v.WL)((0, v.Xl)(c.exposed)), { "get"(u, d) { return d in u ? u[d] : d in ve ? ve[d](c) : void 0 }, "has"(c, u) { return u in c || u in ve } })) } function getComponentName(c, u = !0) { return (0, E.mf)(c) ? c.displayName || c.name : c.name || u && c.__name } function isClassComponent(c) { return (0, E.mf)(c) && "__vccOpts" in c } const computed = (c, u) => (0, v.Fl)(c, u, Ue); function h(c, u, d) { const v = arguments.length; return 2 === v ? (0, E.Kn)(u) && !(0, E.kJ)(u) ? isVNode(u) ? Me(c, null, [u]) : Me(c, u) : Me(c, null, u) : (v > 3 ? d = Array.prototype.slice.call(arguments, 2) : 3 === v && isVNode(d) && (d = [d]), Me(c, u, d)) } const ze = "3.4.27" }, "2610": function (c, u, d) { "use strict"; d.d(u, { "B": function () { return effectScope }, "Bj": function () { return EffectScope }, "Fl": function () { return computed }, "IU": function () { return toRaw }, "Jd": function () { return pauseTracking }, "PG": function () { return isReactive }, "Um": function () { return shallowReactive }, "WL": function () { return proxyRefs }, "X$": function () { return trigger }, "X3": function () { return isProxy }, "Xl": function () { return markRaw }, "dq": function () { return isRef }, "iH": function () { return ref }, "j": function () { return track }, "lk": function () { return resetTracking }, "nZ": function () { return getCurrentScope }, "qj": function () { return reactive }, "qq": function () { return ReactiveEffect }, "yT": function () { return isShallow } }); var v = d(3577); let E, k; class EffectScope { "constructor"(c = !1) { this.detached = c, this._active = !0, this.effects = [], this.cleanups = [], this.parent = E, !c && E && (this.index = (E.scopes || (E.scopes = [])).push(this) - 1) } get "active"() { return this._active } "run"(c) { if (this._active) { const u = E; try { return E = this, c() } finally { E = u } } else 0 } "on"() { E = this } "off"() { E = this.parent } "stop"(c) { if (this._active) { let u, d; for (u = 0, d = this.effects.length; u < d; u++)this.effects[u].stop(); for (u = 0, d = this.cleanups.length; u < d; u++)this.cleanups[u](); if (this.scopes) for (u = 0, d = this.scopes.length; u < d; u++)this.scopes[u].stop(!0); if (!this.detached && this.parent && !c) { const c = this.parent.scopes.pop(); c && c !== this && (this.parent.scopes[this.index] = c, c.index = this.index) } this.parent = void 0, this._active = !1 } } } function effectScope(c) { return new EffectScope(c) } function recordEffectScope(c, u = E) { u && u.active && u.effects.push(c) } function getCurrentScope() { return E } class ReactiveEffect { "constructor"(c, u, d, v) { this.fn = c, this.trigger = u, this.scheduler = d, this.active = !0, this.deps = [], this._dirtyLevel = 4, this._trackId = 0, this._runnings = 0, this._shouldSchedule = !1, this._depsLength = 0, recordEffectScope(this, v) } get "dirty"() { if (2 === this._dirtyLevel || 3 === this._dirtyLevel) { this._dirtyLevel = 1, pauseTracking(); for (let c = 0; c < this._depsLength; c++) { const u = this.deps[c]; if (u.computed && (triggerComputed(u.computed), this._dirtyLevel >= 4)) break } 1 === this._dirtyLevel && (this._dirtyLevel = 0), resetTracking() } return this._dirtyLevel >= 4 } set "dirty"(c) { this._dirtyLevel = c ? 4 : 0 } "run"() { if (this._dirtyLevel = 0, !this.active) return this.fn(); let c = R, u = k; try { return R = !0, k = this, this._runnings++, preCleanupEffect(this), this.fn() } finally { postCleanupEffect(this), this._runnings--, k = u, R = c } } "stop"() { this.active && (preCleanupEffect(this), postCleanupEffect(this), this.onStop && this.onStop(), this.active = !1) } } function triggerComputed(c) { return c.value } function preCleanupEffect(c) { c._trackId++, c._depsLength = 0 } function postCleanupEffect(c) { if (c.deps.length > c._depsLength) { for (let u = c._depsLength; u < c.deps.length; u++)cleanupDepEffect(c.deps[u], c); c.deps.length = c._depsLength } } function cleanupDepEffect(c, u) { const d = c.get(u); void 0 !== d && u._trackId !== d && (c.delete(u), 0 === c.size && c.cleanup()) } let R = !0, U = 0; const H = []; function pauseTracking() { H.push(R), R = !1 } function resetTracking() { const c = H.pop(); R = void 0 === c || c } function pauseScheduling() { U++ } function resetScheduling() { for (U--; !U && G.length;)G.shift()() } function trackEffect(c, u, d) { if (u.get(c) !== c._trackId) { u.set(c, c._trackId); const d = c.deps[c._depsLength]; d !== u ? (d && cleanupDepEffect(d, c), c.deps[c._depsLength++] = u) : c._depsLength++ } } const G = []; function triggerEffects(c, u, d) { pauseScheduling(); for (const d of c.keys()) { let v; d._dirtyLevel < u && (null != v ? v : v = c.get(d) === d._trackId) && (d._shouldSchedule || (d._shouldSchedule = 0 === d._dirtyLevel), d._dirtyLevel = u), d._shouldSchedule && (null != v ? v : v = c.get(d) === d._trackId) && (d.trigger(), d._runnings && !d.allowRecurse || 2 === d._dirtyLevel || (d._shouldSchedule = !1, d.scheduler && G.push(d.scheduler))) } resetScheduling() } const createDep = (c, u) => { const d = new Map; return d.cleanup = c, d.computed = u, d }, W = new WeakMap, Z = Symbol(""), Y = Symbol(""); function track(c, u, d) { if (R && k) { let u = W.get(c); u || W.set(c, u = new Map); let v = u.get(d); v || u.set(d, v = createDep((() => u.delete(d)))), trackEffect(k, v) } } function trigger(c, u, d, E, k, R) { const U = W.get(c); if (!U) return; let H = []; if ("clear" === u) H = [...U.values()]; else if ("length" === d && (0, v.kJ)(c)) { const c = Number(E); U.forEach(((u, d) => { ("length" === d || !(0, v.yk)(d) && d >= c) && H.push(u) })) } else switch (void 0 !== d && H.push(U.get(d)), u) { case "add": (0, v.kJ)(c) ? (0, v.S0)(d) && H.push(U.get("length")) : (H.push(U.get(Z)), (0, v._N)(c) && H.push(U.get(Y))); break; case "delete": (0, v.kJ)(c) || (H.push(U.get(Z)), (0, v._N)(c) && H.push(U.get(Y))); break; case "set": (0, v._N)(c) && H.push(U.get(Z)) }pauseScheduling(); for (const c of H) c && triggerEffects(c, 4); resetScheduling() } const J = (0, v.fY)("__proto__,__v_isRef,__isVue"), K = new Set(Object.getOwnPropertyNames(Symbol).filter((c => "arguments" !== c && "caller" !== c)).map((c => Symbol[c])).filter(v.yk)), X = createArrayInstrumentations(); function createArrayInstrumentations() { const c = {}; return ["includes", "indexOf", "lastIndexOf"].forEach((u => { c[u] = function (...c) { const d = toRaw(this); for (let c = 0, u = this.length; c < u; c++)track(d, 0, c + ""); const v = d[u](...c); return -1 === v || !1 === v ? d[u](...c.map(toRaw)) : v } })), ["push", "pop", "shift", "unshift", "splice"].forEach((u => { c[u] = function (...c) { pauseTracking(), pauseScheduling(); const d = toRaw(this)[u].apply(this, c); return resetScheduling(), resetTracking(), d } })), c } function hasOwnProperty(c) { (0, v.yk)(c) || (c = String(c)); const u = toRaw(this); return track(u, 0, c), u.hasOwnProperty(c) } class BaseReactiveHandler { "constructor"(c = !1, u = !1) { this._isReadonly = c, this._isShallow = u } "get"(c, u, d) { const E = this._isReadonly, k = this._isShallow; if ("__v_isReactive" === u) return !E; if ("__v_isReadonly" === u) return E; if ("__v_isShallow" === u) return k; if ("__v_raw" === u) return d === (E ? k ? pe : de : k ? ue : le).get(c) || Object.getPrototypeOf(c) === Object.getPrototypeOf(d) ? c : void 0; const R = (0, v.kJ)(c); if (!E) { if (R && (0, v.RI)(X, u)) return Reflect.get(X, u, d); if ("hasOwnProperty" === u) return hasOwnProperty } const U = Reflect.get(c, u, d); return ((0, v.yk)(u) ? K.has(u) : J(u)) ? U : (E || track(c, 0, u), k ? U : isRef(U) ? R && (0, v.S0)(u) ? U : U.value : (0, v.Kn)(U) ? E ? readonly(U) : reactive(U) : U) } } class MutableReactiveHandler extends BaseReactiveHandler { "constructor"(c = !1) { super(!1, c) } "set"(c, u, d, E) { let k = c[u]; if (!this._isShallow) { const u = isReadonly(k); if (isShallow(d) || isReadonly(d) || (k = toRaw(k), d = toRaw(d)), !(0, v.kJ)(c) && isRef(k) && !isRef(d)) return !u && (k.value = d, !0) } const R = (0, v.kJ)(c) && (0, v.S0)(u) ? Number(u) < c.length : (0, v.RI)(c, u), U = Reflect.set(c, u, d, E); return c === toRaw(E) && (R ? (0, v.aU)(d, k) && trigger(c, "set", u, d) : trigger(c, "add", u, d)), U } "deleteProperty"(c, u) { const d = (0, v.RI)(c, u), E = (c[u], Reflect.deleteProperty(c, u)); return E && d && trigger(c, "delete", u, void 0), E } "has"(c, u) { const d = Reflect.has(c, u); return (0, v.yk)(u) && K.has(u) || track(c, 0, u), d } "ownKeys"(c) { return track(c, 0, (0, v.kJ)(c) ? "length" : Z), Reflect.ownKeys(c) } } class ReadonlyReactiveHandler extends BaseReactiveHandler { "constructor"(c = !1) { super(!0, c) } "set"(c, u) { return !0 } "deleteProperty"(c, u) { return !0 } } const Q = new MutableReactiveHandler, ee = new ReadonlyReactiveHandler, te = new MutableReactiveHandler(!0), toShallow = c => c, getProto = c => Reflect.getPrototypeOf(c); function get(c, u, d = !1, E = !1) { const k = toRaw(c = c.__v_raw), R = toRaw(u); d || ((0, v.aU)(u, R) && track(k, 0, u), track(k, 0, R)); const { "has": U } = getProto(k), H = E ? toShallow : d ? toReadonly : toReactive; return U.call(k, u) ? H(c.get(u)) : U.call(k, R) ? H(c.get(R)) : void (c !== k && c.get(u)) } function has(c, u = !1) { const d = this.__v_raw, E = toRaw(d), k = toRaw(c); return u || ((0, v.aU)(c, k) && track(E, 0, c), track(E, 0, k)), c === k ? d.has(c) : d.has(c) || d.has(k) } function size(c, u = !1) { return c = c.__v_raw, !u && track(toRaw(c), 0, Z), Reflect.get(c, "size", c) } function add(c) { c = toRaw(c); const u = toRaw(this); return getProto(u).has.call(u, c) || (u.add(c), trigger(u, "add", c, c)), this } function set(c, u) { u = toRaw(u); const d = toRaw(this), { "has": E, "get": k } = getProto(d); let R = E.call(d, c); R || (c = toRaw(c), R = E.call(d, c)); const U = k.call(d, c); return d.set(c, u), R ? (0, v.aU)(u, U) && trigger(d, "set", c, u) : trigger(d, "add", c, u), this } function deleteEntry(c) { const u = toRaw(this), { "has": d, "get": v } = getProto(u); let E = d.call(u, c); E || (c = toRaw(c), E = d.call(u, c)); v && v.call(u, c); const k = u.delete(c); return E && trigger(u, "delete", c, void 0), k } function clear() { const c = toRaw(this), u = 0 !== c.size, d = c.clear(); return u && trigger(c, "clear", void 0, void 0), d } function createForEach(c, u) { return function forEach(d, v) { const E = this, k = E.__v_raw, R = toRaw(k), U = u ? toShallow : c ? toReadonly : toReactive; return !c && track(R, 0, Z), k.forEach(((c, u) => d.call(v, U(c), U(u), E))) } } function createIterableMethod(c, u, d) { return function (...E) { const k = this.__v_raw, R = toRaw(k), U = (0, v._N)(R), H = "entries" === c || c === Symbol.iterator && U, G = "keys" === c && U, W = k[c](...E), J = d ? toShallow : u ? toReadonly : toReactive; return !u && track(R, 0, G ? Y : Z), { "next"() { const { "value": c, "done": u } = W.next(); return u ? { "value": c, "done": u } : { "value": H ? [J(c[0]), J(c[1])] : J(c), "done": u } }, [Symbol.iterator]() { return this } } } } function createReadonlyMethod(c) { return function (...u) { return "delete" !== c && ("clear" === c ? void 0 : this) } } function createInstrumentations() { const c = { "get"(c) { return get(this, c) }, get "size"() { return size(this) }, "has": has, "add": add, "set": set, "delete": deleteEntry, "clear": clear, "forEach": createForEach(!1, !1) }, u = { "get"(c) { return get(this, c, !1, !0) }, get "size"() { return size(this) }, "has": has, "add": add, "set": set, "delete": deleteEntry, "clear": clear, "forEach": createForEach(!1, !0) }, d = { "get"(c) { return get(this, c, !0) }, get "size"() { return size(this, !0) }, "has"(c) { return has.call(this, c, !0) }, "add": createReadonlyMethod("add"), "set": createReadonlyMethod("set"), "delete": createReadonlyMethod("delete"), "clear": createReadonlyMethod("clear"), "forEach": createForEach(!0, !1) }, v = { "get"(c) { return get(this, c, !0, !0) }, get "size"() { return size(this, !0) }, "has"(c) { return has.call(this, c, !0) }, "add": createReadonlyMethod("add"), "set": createReadonlyMethod("set"), "delete": createReadonlyMethod("delete"), "clear": createReadonlyMethod("clear"), "forEach": createForEach(!0, !0) }; return ["keys", "values", "entries", Symbol.iterator].forEach((E => { c[E] = createIterableMethod(E, !1, !1), d[E] = createIterableMethod(E, !0, !1), u[E] = createIterableMethod(E, !1, !0), v[E] = createIterableMethod(E, !0, !0) })), [c, d, u, v] } const [ne, re, oe, ie] = createInstrumentations(); function createInstrumentationGetter(c, u) { const d = u ? c ? ie : oe : c ? re : ne; return (u, E, k) => "__v_isReactive" === E ? !c : "__v_isReadonly" === E ? c : "__v_raw" === E ? u : Reflect.get((0, v.RI)(d, E) && E in u ? d : u, E, k) } const ae = { "get": createInstrumentationGetter(!1, !1) }, se = { "get": createInstrumentationGetter(!1, !0) }, ce = { "get": createInstrumentationGetter(!0, !1) }; const le = new WeakMap, ue = new WeakMap, de = new WeakMap, pe = new WeakMap; function reactive(c) { return isReadonly(c) ? c : createReactiveObject(c, !1, Q, ae, le) } function shallowReactive(c) { return createReactiveObject(c, !1, te, se, ue) } function readonly(c) { return createReactiveObject(c, !0, ee, ce, de) } function createReactiveObject(c, u, d, E, k) { if (!(0, v.Kn)(c)) return c; if (c.__v_raw && (!u || !c.__v_isReactive)) return c; const R = k.get(c); if (R) return R; const U = function getTargetType(c) { return c.__v_skip || !Object.isExtensible(c) ? 0 : function targetTypeMap(c) { switch (c) { case "Object": case "Array": return 1; case "Map": case "Set": case "WeakMap": case "WeakSet": return 2; default: return 0 } }((0, v.W7)(c)) }(c); if (0 === U) return c; const H = new Proxy(c, 2 === U ? E : d); return k.set(c, H), H } function isReactive(c) { return isReadonly(c) ? isReactive(c.__v_raw) : !(!c || !c.__v_isReactive) } function isReadonly(c) { return !(!c || !c.__v_isReadonly) } function isShallow(c) { return !(!c || !c.__v_isShallow) } function isProxy(c) { return !!c && !!c.__v_raw } function toRaw(c) { const u = c && c.__v_raw; return u ? toRaw(u) : c } function markRaw(c) { return Object.isExtensible(c) && (0, v.Nj)(c, "__v_skip", !0), c } const toReactive = c => (0, v.Kn)(c) ? reactive(c) : c, toReadonly = c => (0, v.Kn)(c) ? readonly(c) : c; class ComputedRefImpl { "constructor"(c, u, d, v) { this.getter = c, this._setter = u, this.dep = void 0, this.__v_isRef = !0, this.__v_isReadonly = !1, this.effect = new ReactiveEffect((() => c(this._value)), (() => triggerRefValue(this, 2 === this.effect._dirtyLevel ? 2 : 3))), this.effect.computed = this, this.effect.active = this._cacheable = !v, this.__v_isReadonly = d } get "value"() { const c = toRaw(this); return c._cacheable && !c.effect.dirty || !(0, v.aU)(c._value, c._value = c.effect.run()) || triggerRefValue(c, 4), trackRefValue(c), c.effect._dirtyLevel >= 2 && triggerRefValue(c, 2), c._value } set "value"(c) { this._setter(c) } get "_dirty"() { return this.effect.dirty } set "_dirty"(c) { this.effect.dirty = c } } function computed(c, u, d = !1) { let E, k; const R = (0, v.mf)(c); R ? (E = c, k = v.dG) : (E = c.get, k = c.set); return new ComputedRefImpl(E, k, R || !k, d) } function trackRefValue(c) { var u; R && k && (c = toRaw(c), trackEffect(k, null != (u = c.dep) ? u : c.dep = createDep((() => c.dep = void 0), c instanceof ComputedRefImpl ? c : void 0))) } function triggerRefValue(c, u = 4, d) { const v = (c = toRaw(c)).dep; v && triggerEffects(v, u) } function isRef(c) { return !(!c || !0 !== c.__v_isRef) } function ref(c) { return createRef(c, !1) } function createRef(c, u) { return isRef(c) ? c : new RefImpl(c, u) } class RefImpl { "constructor"(c, u) { this.__v_isShallow = u, this.dep = void 0, this.__v_isRef = !0, this._rawValue = u ? c : toRaw(c), this._value = u ? c : toReactive(c) } get "value"() { return trackRefValue(this), this._value } set "value"(c) { const u = this.__v_isShallow || isShallow(c) || isReadonly(c); c = u ? c : toRaw(c), (0, v.aU)(c, this._rawValue) && (this._rawValue = c, this._value = u ? c : toReactive(c), triggerRefValue(this, 4)) } } function unref(c) { return isRef(c) ? c.value : c } const fe = { "get": (c, u, d) => unref(Reflect.get(c, u, d)), "set": (c, u, d, v) => { const E = c[u]; return isRef(E) && !isRef(d) ? (E.value = d, !0) : Reflect.set(c, u, d, v) } }; function proxyRefs(c) { return isReactive(c) ? c : new Proxy(c, fe) } }, "9963": function (c, u, d) { "use strict"; d.d(u, { "F8": function () { return Q }, "iM": function () { return withModifiers }, "ri": function () { return createApp }, "uT": function () { return Transition } }); var v = d(6252), E = d(3577); d(2610); const k = "undefined" != typeof document ? document : null, R = k && k.createElement("template"), U = { "insert": (c, u, d) => { u.insertBefore(c, d || null) }, "remove": c => { const u = c.parentNode; u && u.removeChild(c) }, "createElement": (c, u, d, v) => { const E = "svg" === u ? k.createElementNS("http://www.w3.org/2000/svg", c) : "mathml" === u ? k.createElementNS("http://www.w3.org/1998/Math/MathML", c) : k.createElement(c, d ? { "is": d } : void 0); return "select" === c && v && null != v.multiple && E.setAttribute("multiple", v.multiple), E }, "createText": c => k.createTextNode(c), "createComment": c => k.createComment(c), "setText": (c, u) => { c.nodeValue = u }, "setElementText": (c, u) => { c.textContent = u }, "parentNode": c => c.parentNode, "nextSibling": c => c.nextSibling, "querySelector": c => k.querySelector(c), "setScopeId"(c, u) { c.setAttribute(u, "") }, "insertStaticContent"(c, u, d, v, E, k) { const U = d ? d.previousSibling : u.lastChild; if (E && (E === k || E.nextSibling)) for (; u.insertBefore(E.cloneNode(!0), d), E !== k && (E = E.nextSibling);); else { R.innerHTML = "svg" === v ? `<svg>${c}</svg>` : "mathml" === v ? `<math>${c}</math>` : c; const E = R.content; if ("svg" === v || "mathml" === v) { const c = E.firstChild; for (; c.firstChild;)E.appendChild(c.firstChild); E.removeChild(c) } u.insertBefore(E, d) } return [U ? U.nextSibling : u.firstChild, d ? d.previousSibling : u.lastChild] } }, H = "transition", G = "animation", W = Symbol("_vtc"), Transition = (c, { "slots": u }) => (0, v.h)(v.P$, resolveTransitionProps(c), u); Transition.displayName = "Transition"; const Z = { "name": String, "type": String, "css": { "type": Boolean, "default": !0 }, "duration": [String, Number, Object], "enterFromClass": String, "enterActiveClass": String, "enterToClass": String, "appearFromClass": String, "appearActiveClass": String, "appearToClass": String, "leaveFromClass": String, "leaveActiveClass": String, "leaveToClass": String }, Y = (Transition.props = (0, E.l7)({}, v.nJ, Z), (c, u = []) => { (0, E.kJ)(c) ? c.forEach((c => c(...u))) : c && c(...u) }), hasExplicitCallback = c => !!c && ((0, E.kJ)(c) ? c.some((c => c.length > 1)) : c.length > 1); function resolveTransitionProps(c) { const u = {}; for (const d in c) d in Z || (u[d] = c[d]); if (!1 === c.css) return u; const { "name": d = "v", "type": v, "duration": k, "enterFromClass": R = `${d}-enter-from`, "enterActiveClass": U = `${d}-enter-active`, "enterToClass": H = `${d}-enter-to`, "appearFromClass": G = R, "appearActiveClass": W = U, "appearToClass": J = H, "leaveFromClass": K = `${d}-leave-from`, "leaveActiveClass": X = `${d}-leave-active`, "leaveToClass": Q = `${d}-leave-to` } = c, ee = function normalizeDuration(c) { if (null == c) return null; if ((0, E.Kn)(c)) return [NumberOf(c.enter), NumberOf(c.leave)]; { const u = NumberOf(c); return [u, u] } }(k), te = ee && ee[0], ne = ee && ee[1], { "onBeforeEnter": re, "onEnter": oe, "onEnterCancelled": ie, "onLeave": ae, "onLeaveCancelled": se, "onBeforeAppear": ce = re, "onAppear": le = oe, "onAppearCancelled": ue = ie } = u, finishEnter = (c, u, d) => { removeTransitionClass(c, u ? J : H), removeTransitionClass(c, u ? W : U), d && d() }, finishLeave = (c, u) => { c._isLeaving = !1, removeTransitionClass(c, K), removeTransitionClass(c, Q), removeTransitionClass(c, X), u && u() }, makeEnterHook = c => (u, d) => { const E = c ? le : oe, resolve = () => finishEnter(u, c, d); Y(E, [u, resolve]), nextFrame((() => { removeTransitionClass(u, c ? G : R), addTransitionClass(u, c ? J : H), hasExplicitCallback(E) || whenTransitionEnds(u, v, te, resolve) })) }; return (0, E.l7)(u, { "onBeforeEnter"(c) { Y(re, [c]), addTransitionClass(c, R), addTransitionClass(c, U) }, "onBeforeAppear"(c) { Y(ce, [c]), addTransitionClass(c, G), addTransitionClass(c, W) }, "onEnter": makeEnterHook(!1), "onAppear": makeEnterHook(!0), "onLeave"(c, u) { c._isLeaving = !0; const resolve = () => finishLeave(c, u); addTransitionClass(c, K), addTransitionClass(c, X), forceReflow(), nextFrame((() => { c._isLeaving && (removeTransitionClass(c, K), addTransitionClass(c, Q), hasExplicitCallback(ae) || whenTransitionEnds(c, v, ne, resolve)) })), Y(ae, [c, resolve]) }, "onEnterCancelled"(c) { finishEnter(c, !1), Y(ie, [c]) }, "onAppearCancelled"(c) { finishEnter(c, !0), Y(ue, [c]) }, "onLeaveCancelled"(c) { finishLeave(c), Y(se, [c]) } }) } function NumberOf(c) { return (0, E.He)(c) } function addTransitionClass(c, u) { u.split(/\s+/).forEach((u => u && c.classList.add(u))), (c[W] || (c[W] = new Set)).add(u) } function removeTransitionClass(c, u) { u.split(/\s+/).forEach((u => u && c.classList.remove(u))); const d = c[W]; d && (d.delete(u), d.size || (c[W] = void 0)) } function nextFrame(c) { requestAnimationFrame((() => { requestAnimationFrame(c) })) } let J = 0; function whenTransitionEnds(c, u, d, v) { const E = c._endId = ++J, resolveIfNotStale = () => { E === c._endId && v() }; if (d) return setTimeout(resolveIfNotStale, d); const { "type": k, "timeout": R, "propCount": U } = getTransitionInfo(c, u); if (!k) return v(); const H = k + "end"; let G = 0; const end = () => { c.removeEventListener(H, onEnd), resolveIfNotStale() }, onEnd = u => { u.target === c && ++G >= U && end() }; setTimeout((() => { G < U && end() }), R + 1), c.addEventListener(H, onEnd) } function getTransitionInfo(c, u) { const d = window.getComputedStyle(c), getStyleProperties = c => (d[c] || "").split(", "), v = getStyleProperties(`${H}Delay`), E = getStyleProperties(`${H}Duration`), k = getTimeout(v, E), R = getStyleProperties(`${G}Delay`), U = getStyleProperties(`${G}Duration`), W = getTimeout(R, U); let Z = null, Y = 0, J = 0; u === H ? k > 0 && (Z = H, Y = k, J = E.length) : u === G ? W > 0 && (Z = G, Y = W, J = U.length) : (Y = Math.max(k, W), Z = Y > 0 ? k > W ? H : G : null, J = Z ? Z === H ? E.length : U.length : 0); return { "type": Z, "timeout": Y, "propCount": J, "hasTransform": Z === H && /\b(transform|all)(,|$)/.test(getStyleProperties(`${H}Property`).toString()) } } function getTimeout(c, u) { for (; c.length < u.length;)c = c.concat(c); return Math.max(...u.map(((u, d) => toMs(u) + toMs(c[d])))) } function toMs(c) { return "auto" === c ? 0 : 1e3 * Number(c.slice(0, -1).replace(",", ".")) } function forceReflow() { return document.body.offsetHeight } const K = Symbol("_vod"), X = Symbol("_vsh"), Q = { "beforeMount"(c, { "value": u }, { "transition": d }) { c[K] = "none" === c.style.display ? "" : c.style.display, d && u ? d.beforeEnter(c) : setDisplay(c, u) }, "mounted"(c, { "value": u }, { "transition": d }) { d && u && d.enter(c) }, "updated"(c, { "value": u, "oldValue": d }, { "transition": v }) { !u != !d && (v ? u ? (v.beforeEnter(c), setDisplay(c, !0), v.enter(c)) : v.leave(c, (() => { setDisplay(c, !1) })) : setDisplay(c, u)) }, "beforeUnmount"(c, { "value": u }) { setDisplay(c, u) } }; function setDisplay(c, u) { c.style.display = u ? c[K] : "none", c[X] = !u } const ee = Symbol(""); const te = /(^|;)\s*display\s*:/; const ne = /\s*!important$/; function setStyle(c, u, d) { if ((0, E.kJ)(d)) d.forEach((d => setStyle(c, u, d))); else if (null == d && (d = ""), u.startsWith("--")) c.setProperty(u, d); else { const v = function autoPrefix(c, u) { const d = oe[u]; if (d) return d; let v = (0, E._A)(u); if ("filter" !== v && v in c) return oe[u] = v; v = (0, E.kC)(v); for (let d = 0; d < re.length; d++) { const E = re[d] + v; if (E in c) return oe[u] = E } return u }(c, u); ne.test(d) ? c.setProperty((0, E.rs)(v), d.replace(ne, ""), "important") : c[v] = d } } const re = ["Webkit", "Moz", "ms"], oe = {}; const ie = "http://www.w3.org/1999/xlink"; function addEventListener(c, u, d, v) { c.addEventListener(u, d, v) } const ae = Symbol("_vei"); function patchEvent(c, u, d, k, R = null) { const U = c[ae] || (c[ae] = {}), H = U[u]; if (k && H) H.value = k; else { const [d, G] = function parseName(c) { let u; if (se.test(c)) { let d; for (u = {}; d = c.match(se);)c = c.slice(0, c.length - d[0].length), u[d[0].toLowerCase()] = !0 } const d = ":" === c[2] ? c.slice(3) : (0, E.rs)(c.slice(2)); return [d, u] }(u); if (k) { const H = U[u] = function createInvoker(c, u) { const invoker = c => { if (c._vts) { if (c._vts <= invoker.attached) return } else c._vts = Date.now(); (0, v.$d)(function patchStopImmediatePropagation(c, u) { if ((0, E.kJ)(u)) { const d = c.stopImmediatePropagation; return c.stopImmediatePropagation = () => { d.call(c), c._stopped = !0 }, u.map((c => u => !u._stopped && c && c(u))) } return u }(c, invoker.value), u, 5, [c]) }; return invoker.value = c, invoker.attached = getNow(), invoker }(k, R); addEventListener(c, d, H, G) } else H && (!function removeEventListener(c, u, d, v) { c.removeEventListener(u, d, v) }(c, d, H, G), U[u] = void 0) } } const se = /(?:Once|Passive|Capture)$/; let ce = 0; const le = Promise.resolve(), getNow = () => ce || (le.then((() => ce = 0)), ce = Date.now()); const isNativeOn = c => 111 === c.charCodeAt(0) && 110 === c.charCodeAt(1) && c.charCodeAt(2) > 96 && c.charCodeAt(2) < 123; "undefined" != typeof HTMLElement && HTMLElement; Symbol("_moveCb"), Symbol("_enterCb"); Symbol("_assign"); const ue = ["ctrl", "shift", "alt", "meta"], de = { "stop": c => c.stopPropagation(), "prevent": c => c.preventDefault(), "self": c => c.target !== c.currentTarget, "ctrl": c => !c.ctrlKey, "shift": c => !c.shiftKey, "alt": c => !c.altKey, "meta": c => !c.metaKey, "left": c => "button" in c && 0 !== c.button, "middle": c => "button" in c && 1 !== c.button, "right": c => "button" in c && 2 !== c.button, "exact": (c, u) => ue.some((d => c[`${d}Key`] && !u.includes(d))) }, withModifiers = (c, u) => { const d = c._withMods || (c._withMods = {}), v = u.join("."); return d[v] || (d[v] = (d, ...v) => { for (let c = 0; c < u.length; c++) { const v = de[u[c]]; if (v && v(d, u)) return } return c(d, ...v) }) }, pe = (0, E.l7)({ "patchProp": (c, u, d, v, k, R, U, H, G) => { const Z = "svg" === k; "class" === u ? function patchClass(c, u, d) { const v = c[W]; v && (u = (u ? [u, ...v] : [...v]).join(" ")), null == u ? c.removeAttribute("class") : d ? c.setAttribute("class", u) : c.className = u }(c, v, Z) : "style" === u ? function patchStyle(c, u, d) { const v = c.style, k = (0, E.HD)(d); let R = !1; if (d && !k) { if (u) if ((0, E.HD)(u)) for (const c of u.split(";")) { const u = c.slice(0, c.indexOf(":")).trim(); null == d[u] && setStyle(v, u, "") } else for (const c in u) null == d[c] && setStyle(v, c, ""); for (const c in d) "display" === c && (R = !0), setStyle(v, c, d[c]) } else if (k) { if (u !== d) { const c = v[ee]; c && (d += ";" + c), v.cssText = d, R = te.test(d) } } else u && c.removeAttribute("style"); K in c && (c[K] = R ? v.display : "", c[X] && (v.display = "none")) }(c, d, v) : (0, E.F7)(u) ? (0, E.tR)(u) || patchEvent(c, u, 0, v, U) : ("." === u[0] ? (u = u.slice(1), 1) : "^" === u[0] ? (u = u.slice(1), 0) : function shouldSetAsProp(c, u, d, v) { if (v) return "innerHTML" === u || "textContent" === u || !!(u in c && isNativeOn(u) && (0, E.mf)(d)); if ("spellcheck" === u || "draggable" === u || "translate" === u) return !1; if ("form" === u) return !1; if ("list" === u && "INPUT" === c.tagName) return !1; if ("type" === u && "TEXTAREA" === c.tagName) return !1; if ("width" === u || "height" === u) { const u = c.tagName; if ("IMG" === u || "VIDEO" === u || "CANVAS" === u || "SOURCE" === u) return !1 } if (isNativeOn(u) && (0, E.HD)(d)) return !1; return u in c }(c, u, v, Z)) ? function patchDOMProp(c, u, d, v, k, R, U) { if ("innerHTML" === u || "textContent" === u) return v && U(v, k, R), void (c[u] = null == d ? "" : d); const H = c.tagName; if ("value" === u && "PROGRESS" !== H && !H.includes("-")) { const v = null == d ? "" : d; return ("OPTION" === H ? c.getAttribute("value") || "" : c.value) === v && "_value" in c || (c.value = v), null == d && c.removeAttribute(u), void (c._value = d) } let G = !1; if ("" === d || null == d) { const v = typeof c[u]; "boolean" === v ? d = (0, E.yA)(d) : null == d && "string" === v ? (d = "", G = !0) : "number" === v && (d = 0, G = !0) } try { c[u] = d } catch (c) { } G && c.removeAttribute(u) }(c, u, v, R, U, H, G) : ("true-value" === u ? c._trueValue = v : "false-value" === u && (c._falseValue = v), function patchAttr(c, u, d, v, k) { if (v && u.startsWith("xlink:")) null == d ? c.removeAttributeNS(ie, u.slice(6, u.length)) : c.setAttributeNS(ie, u, d); else { const v = (0, E.Pq)(u); null == d || v && !(0, E.yA)(d) ? c.removeAttribute(u) : c.setAttribute(u, v ? "" : d) } }(c, u, v, Z)) } }, U); let fe; function ensureRenderer() { return fe || (fe = (0, v.Us)(pe)) } const createApp = (...c) => { const u = ensureRenderer().createApp(...c); const { "mount": d } = u; return u.mount = c => { const v = normalizeContainer(c); if (!v) return; const k = u._component; (0, E.mf)(k) || k.render || k.template || (k.template = v.innerHTML), v.innerHTML = ""; const R = d(v, !1, resolveRootNamespace(v)); return v instanceof Element && (v.removeAttribute("v-cloak"), v.setAttribute("data-v-app", "")), R }, u }; function resolveRootNamespace(c) { return c instanceof SVGElement ? "svg" : "function" == typeof MathMLElement && c instanceof MathMLElement ? "mathml" : void 0 } function normalizeContainer(c) { if ((0, E.HD)(c)) { return document.querySelector(c) } return c } }, "3577": function (c, u, d) { "use strict"; function makeMap(c, u) { const d = new Set(c.split(",")); return u ? c => d.has(c.toLowerCase()) : c => d.has(c) } d.d(u, { "C_": function () { return normalizeClass }, "DM": function () { return isSet }, "E9": function () { return getGlobalThis }, "F7": function () { return isOn }, "Gg": function () { return G }, "HD": function () { return isString }, "He": function () { return toNumber }, "Kj": function () { return isRegExp }, "Kn": function () { return isObject }, "NO": function () { return NO }, "Nj": function () { return def }, "Od": function () { return remove }, "PO": function () { return isPlainObject }, "Pq": function () { return ie }, "RI": function () { return hasOwn }, "S0": function () { return isIntegerKey }, "W7": function () { return toRawType }, "WV": function () { return looseEqual }, "Z6": function () { return E }, "_A": function () { return Z }, "_N": function () { return isMap }, "aU": function () { return hasChanged }, "dG": function () { return NOOP }, "fY": function () { return makeMap }, "h5": function () { return looseToNumber }, "hR": function () { return X }, "hq": function () { return looseIndexOf }, "ir": function () { return invokeArrayFns }, "j5": function () { return normalizeStyle }, "kC": function () { return K }, "kJ": function () { return U }, "kT": function () { return v }, "l7": function () { return k }, "mf": function () { return isFunction }, "rs": function () { return J }, "tI": function () { return isPromise }, "tR": function () { return isModelListener }, "yA": function () { return includeBooleanAttr }, "yk": function () { return isSymbol }, "yl": function () { return ee }, "zw": function () { return toDisplayString } }); const v = {}, E = [], NOOP = () => { }, NO = () => !1, isOn = c => 111 === c.charCodeAt(0) && 110 === c.charCodeAt(1) && (c.charCodeAt(2) > 122 || c.charCodeAt(2) < 97), isModelListener = c => c.startsWith("onUpdate:"), k = Object.assign, remove = (c, u) => { const d = c.indexOf(u); d > -1 && c.splice(d, 1) }, R = Object.prototype.hasOwnProperty, hasOwn = (c, u) => R.call(c, u), U = Array.isArray, isMap = c => "[object Map]" === toTypeString(c), isSet = c => "[object Set]" === toTypeString(c), isDate = c => "[object Date]" === toTypeString(c), isRegExp = c => "[object RegExp]" === toTypeString(c), isFunction = c => "function" == typeof c, isString = c => "string" == typeof c, isSymbol = c => "symbol" == typeof c, isObject = c => null !== c && "object" == typeof c, isPromise = c => (isObject(c) || isFunction(c)) && isFunction(c.then) && isFunction(c.catch), H = Object.prototype.toString, toTypeString = c => H.call(c), toRawType = c => toTypeString(c).slice(8, -1), isPlainObject = c => "[object Object]" === toTypeString(c), isIntegerKey = c => isString(c) && "NaN" !== c && "-" !== c[0] && "" + parseInt(c, 10) === c, G = makeMap(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"), cacheStringFunction = c => { const u = Object.create(null); return d => u[d] || (u[d] = c(d)) }, W = /-(\w)/g, Z = cacheStringFunction((c => c.replace(W, ((c, u) => u ? u.toUpperCase() : "")))), Y = /\B([A-Z])/g, J = cacheStringFunction((c => c.replace(Y, "-$1").toLowerCase())), K = cacheStringFunction((c => c.charAt(0).toUpperCase() + c.slice(1))), X = cacheStringFunction((c => c ? `on${K(c)}` : "")), hasChanged = (c, u) => !Object.is(c, u), invokeArrayFns = (c, u) => { for (let d = 0; d < c.length; d++)c[d](u) }, def = (c, u, d, v = !1) => { Object.defineProperty(c, u, { "configurable": !0, "enumerable": !1, "writable": v, "value": d }) }, looseToNumber = c => { const u = parseFloat(c); return isNaN(u) ? c : u }, toNumber = c => { const u = isString(c) ? Number(c) : NaN; return isNaN(u) ? c : u }; let Q; const getGlobalThis = () => Q || (Q = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : void 0 !== d.g ? d.g : {}); const ee = makeMap("Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error"); function normalizeStyle(c) { if (U(c)) { const u = {}; for (let d = 0; d < c.length; d++) { const v = c[d], E = isString(v) ? parseStringStyle(v) : normalizeStyle(v); if (E) for (const c in E) u[c] = E[c] } return u } if (isString(c) || isObject(c)) return c } const te = /;(?![^(]*\))/g, ne = /:([^]+)/, re = /\/\*[^]*?\*\//g; function parseStringStyle(c) { const u = {}; return c.replace(re, "").split(te).forEach((c => { if (c) { const d = c.split(ne); d.length > 1 && (u[d[0].trim()] = d[1].trim()) } })), u } function normalizeClass(c) { let u = ""; if (isString(c)) u = c; else if (U(c)) for (let d = 0; d < c.length; d++) { const v = normalizeClass(c[d]); v && (u += v + " ") } else if (isObject(c)) for (const d in c) c[d] && (u += d + " "); return u.trim() } const oe = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", ie = makeMap(oe); function includeBooleanAttr(c) { return !!c || "" === c } function looseEqual(c, u) { if (c === u) return !0; let d = isDate(c), v = isDate(u); if (d || v) return !(!d || !v) && c.getTime() === u.getTime(); if (d = isSymbol(c), v = isSymbol(u), d || v) return c === u; if (d = U(c), v = U(u), d || v) return !(!d || !v) && function looseCompareArrays(c, u) { if (c.length !== u.length) return !1; let d = !0; for (let v = 0; d && v < c.length; v++)d = looseEqual(c[v], u[v]); return d }(c, u); if (d = isObject(c), v = isObject(u), d || v) { if (!d || !v) return !1; if (Object.keys(c).length !== Object.keys(u).length) return !1; for (const d in c) { const v = c.hasOwnProperty(d), E = u.hasOwnProperty(d); if (v && !E || !v && E || !looseEqual(c[d], u[d])) return !1 } } return String(c) === String(u) } function looseIndexOf(c, u) { return c.findIndex((c => looseEqual(c, u))) } const toDisplayString = c => isString(c) ? c : null == c ? "" : U(c) || isObject(c) && (c.toString === H || !isFunction(c.toString)) ? JSON.stringify(c, replacer, 2) : String(c), replacer = (c, u) => u && u.__v_isRef ? replacer(c, u.value) : isMap(u) ? { [`Map(${u.size})`]: [...u.entries()].reduce(((c, [u, d], v) => (c[stringifySymbol(u, v) + " =>"] = d, c)), {}) } : isSet(u) ? { [`Set(${u.size})`]: [...u.values()].map((c => stringifySymbol(c))) } : isSymbol(u) ? stringifySymbol(u) : !isObject(u) || U(u) || isPlainObject(u) ? u : String(u), stringifySymbol = (c, u = "") => { var d; return isSymbol(c) ? `Symbol(${null != (d = c.description) ? d : u})` : c } }, "6486": function (c, u, d) { var v, E; v = function () { "use strict"; function _classCallCheck(c, u) { if (!(c instanceof u)) throw new TypeError("Cannot call a class as a function") } function _defineProperties(c, u) { for (var d = 0; d < u.length; d++) { var v = u[d]; v.enumerable = v.enumerable || !1, v.configurable = !0, "value" in v && (v.writable = !0), Object.defineProperty(c, v.key, v) } } function _createClass(c, u, d) { return u && _defineProperties(c.prototype, u), d && _defineProperties(c, d), Object.defineProperty(c, "prototype", { "writable": !1 }), c } function _inherits(c, u) { if ("function" != typeof u && null !== u) throw new TypeError("Super expression must either be null or a function"); c.prototype = Object.create(u && u.prototype, { "constructor": { "value": c, "writable": !0, "configurable": !0 } }), Object.defineProperty(c, "prototype", { "writable": !1 }), u && _setPrototypeOf(c, u) } function _getPrototypeOf(c) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(c) { return c.__proto__ || Object.getPrototypeOf(c) }, _getPrototypeOf(c) } function _setPrototypeOf(c, u) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(c, u) { return c.__proto__ = u, c }, _setPrototypeOf(c, u) } function _isNativeReflectConstruct() { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (c) { return !1 } } function _assertThisInitialized(c) { if (void 0 === c) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return c } function _possibleConstructorReturn(c, u) { if (u && ("object" == typeof u || "function" == typeof u)) return u; if (void 0 !== u) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(c) } function _createSuper(c) { var u = _isNativeReflectConstruct(); return function _createSuperInternal() { var d, v = _getPrototypeOf(c); if (u) { var E = _getPrototypeOf(this).constructor; d = Reflect.construct(v, arguments, E) } else d = v.apply(this, arguments); return _possibleConstructorReturn(this, d) } } function _superPropBase(c, u) { for (; !Object.prototype.hasOwnProperty.call(c, u) && null !== (c = _getPrototypeOf(c));); return c } function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function _get(c, u, d) { var v = _superPropBase(c, u); if (v) { var E = Object.getOwnPropertyDescriptor(v, u); return E.get ? E.get.call(arguments.length < 3 ? c : d) : E.value } }, _get.apply(this, arguments) } var c = function () { function Emitter() { _classCallCheck(this, Emitter), Object.defineProperty(this, "listeners", { "value": {}, "writable": !0, "configurable": !0 }) } return _createClass(Emitter, [{ "key": "addEventListener", "value": function addEventListener(c, u, d) { c in this.listeners || (this.listeners[c] = []), this.listeners[c].push({ "callback": u, "options": d }) } }, { "key": "removeEventListener", "value": function removeEventListener(c, u) { if (c in this.listeners) for (var d = this.listeners[c], v = 0, E = d.length; v < E; v++)if (d[v].callback === u) return void d.splice(v, 1) } }, { "key": "dispatchEvent", "value": function dispatchEvent(c) { if (c.type in this.listeners) { for (var u = this.listeners[c.type].slice(), d = 0, v = u.length; d < v; d++) { var E = u[d]; try { E.callback.call(this, c) } catch (c) { Promise.resolve().then((function () { throw c })) } E.options && E.options.once && this.removeEventListener(c.type, E.callback) } return !c.defaultPrevented } } }]), Emitter }(), u = function (u) { _inherits(AbortSignal, u); var d = _createSuper(AbortSignal); function AbortSignal() { var u; return _classCallCheck(this, AbortSignal), (u = d.call(this)).listeners || c.call(_assertThisInitialized(u)), Object.defineProperty(_assertThisInitialized(u), "aborted", { "value": !1, "writable": !0, "configurable": !0 }), Object.defineProperty(_assertThisInitialized(u), "onabort", { "value": null, "writable": !0, "configurable": !0 }), Object.defineProperty(_assertThisInitialized(u), "reason", { "value": void 0, "writable": !0, "configurable": !0 }), u } return _createClass(AbortSignal, [{ "key": "toString", "value": function toString() { return "[object AbortSignal]" } }, { "key": "dispatchEvent", "value": function dispatchEvent(c) { "abort" === c.type && (this.aborted = !0, "function" == typeof this.onabort && this.onabort.call(this, c)), _get(_getPrototypeOf(AbortSignal.prototype), "dispatchEvent", this).call(this, c) } }]), AbortSignal }(c), v = function () { function AbortController() { _classCallCheck(this, AbortController), Object.defineProperty(this, "signal", { "value": new u, "writable": !0, "configurable": !0 }) } return _createClass(AbortController, [{ "key": "abort", "value": function abort(c) { var u; try { u = new Event("abort") } catch (c) { "undefined" != typeof document ? document.createEvent ? (u = document.createEvent("Event")).initEvent("abort", !1, !1) : (u = document.createEventObject()).type = "abort" : u = { "type": "abort", "bubbles": !1, "cancelable": !1 } } var d = c; if (void 0 === d) if ("undefined" == typeof document) (d = new Error("This operation was aborted")).name = "AbortError"; else try { d = new DOMException("signal is aborted without reason") } catch (c) { (d = new Error("This operation was aborted")).name = "AbortError" } this.signal.reason = d, this.signal.dispatchEvent(u) } }, { "key": "toString", "value": function toString() { return "[object AbortController]" } }]), AbortController }(); function polyfillNeeded(c) { return c.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL ? (console.log("__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL=true is set, will force install polyfill"), !0) : "function" == typeof c.Request && !c.Request.prototype.hasOwnProperty("signal") || !c.AbortController } "undefined" != typeof Symbol && Symbol.toStringTag && (v.prototype[Symbol.toStringTag] = "AbortController", u.prototype[Symbol.toStringTag] = "AbortSignal"), function (c) { polyfillNeeded(c) && (c.AbortController = v, c.AbortSignal = u) }("undefined" != typeof self ? self : d.g) }, void 0 === (E = "function" == typeof v ? v.call(u, d, u, c) : v) || (c.exports = E) }, "9742": function (c, u) { "use strict"; u.b$ = function toByteArray(c) { var u, d, k = getLens(c), R = k[0], U = k[1], H = new E(function _byteLength(c, u, d) { return 3 * (u + d) / 4 - d }(0, R, U)), G = 0, W = U > 0 ? R - 4 : R; for (d = 0; d < W; d += 4)u = v[c.charCodeAt(d)] << 18 | v[c.charCodeAt(d + 1)] << 12 | v[c.charCodeAt(d + 2)] << 6 | v[c.charCodeAt(d + 3)], H[G++] = u >> 16 & 255, H[G++] = u >> 8 & 255, H[G++] = 255 & u; 2 === U && (u = v[c.charCodeAt(d)] << 2 | v[c.charCodeAt(d + 1)] >> 4, H[G++] = 255 & u); 1 === U && (u = v[c.charCodeAt(d)] << 10 | v[c.charCodeAt(d + 1)] << 4 | v[c.charCodeAt(d + 2)] >> 2, H[G++] = u >> 8 & 255, H[G++] = 255 & u); return H }, u.JQ = function fromByteArray(c) { for (var u, v = c.length, E = v % 3, k = [], R = 16383, U = 0, H = v - E; U < H; U += R)k.push(encodeChunk(c, U, U + R > H ? H : U + R)); 1 === E ? (u = c[v - 1], k.push(d[u >> 2] + d[u << 4 & 63] + "==")) : 2 === E && (u = (c[v - 2] << 8) + c[v - 1], k.push(d[u >> 10] + d[u >> 4 & 63] + d[u << 2 & 63] + "=")); return k.join("") }; for (var d = [], v = [], E = "undefined" != typeof Uint8Array ? Uint8Array : Array, k = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", R = 0; R < 64; ++R)d[R] = k[R], v[k.charCodeAt(R)] = R; function getLens(c) { var u = c.length; if (u % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4"); var d = c.indexOf("="); return -1 === d && (d = u), [d, d === u ? 0 : 4 - d % 4] } function encodeChunk(c, u, v) { for (var E, k, R = [], U = u; U < v; U += 3)E = (c[U] << 16 & 16711680) + (c[U + 1] << 8 & 65280) + (255 & c[U + 2]), R.push(d[(k = E) >> 18 & 63] + d[k >> 12 & 63] + d[k >> 6 & 63] + d[63 & k]); return R.join("") } v["-".charCodeAt(0)] = 62, v["_".charCodeAt(0)] = 63 }, "640": function (c, u, d) { "use strict"; var v = d(1742), E = { "text/plain": "Text", "text/html": "Url", "default": "Text" }; c.exports = function copy(c, u) { var d, k, R, U, H, G, W = !1; u || (u = {}), d = u.debug || !1; try { if (R = v(), U = document.createRange(), H = document.getSelection(), (G = document.createElement("span")).textContent = c, G.ariaHidden = "true", G.style.all = "unset", G.style.position = "fixed", G.style.top = 0, G.style.clip = "rect(0, 0, 0, 0)", G.style.whiteSpace = "pre", G.style.webkitUserSelect = "text", G.style.MozUserSelect = "text", G.style.msUserSelect = "text", G.style.userSelect = "text", G.addEventListener("copy", (function (v) { if (v.stopPropagation(), u.format) if (v.preventDefault(), void 0 === v.clipboardData) { d && console.warn("unable to use e.clipboardData"), d && console.warn("trying IE specific stuff"), window.clipboardData.clearData(); var k = E[u.format] || E.default; window.clipboardData.setData(k, c) } else v.clipboardData.clearData(), v.clipboardData.setData(u.format, c); u.onCopy && (v.preventDefault(), u.onCopy(v.clipboardData)) })), document.body.appendChild(G), U.selectNodeContents(G), H.addRange(U), !document.execCommand("copy")) throw new Error("copy command was unsuccessful"); W = !0 } catch (v) { d && console.error("unable to copy using execCommand: ", v), d && console.warn("trying IE specific stuff"); try { window.clipboardData.setData(u.format || "text", c), u.onCopy && u.onCopy(window.clipboardData), W = !0 } catch (v) { d && console.error("unable to copy using clipboardData: ", v), d && console.error("falling back to prompt"), k = function format(c) { var u = (/mac os x/i.test(navigator.userAgent) ? "⌘" : "Ctrl") + "+C"; return c.replace(/#{\s*key\s*}/g, u) }("message" in u ? u.message : "Copy to clipboard: #{key}, Enter"), window.prompt(k, c) } } finally { H && ("function" == typeof H.removeRange ? H.removeRange(U) : H.removeAllRanges()), G && document.body.removeChild(G), R() } return W } }, "4020": function (c) { "use strict"; var u = "%[a-f0-9]{2}", d = new RegExp("(" + u + ")|([^%]+?)", "gi"), v = new RegExp("(" + u + ")+", "gi"); function decodeComponents(c, u) { try { return [decodeURIComponent(c.join(""))] } catch (c) { } if (1 === c.length) return c; u = u || 1; var d = c.slice(0, u), v = c.slice(u); return Array.prototype.concat.call([], decodeComponents(d), decodeComponents(v)) } function decode(c) { try { return decodeURIComponent(c) } catch (E) { for (var u = c.match(d) || [], v = 1; v < u.length; v++)u = (c = decodeComponents(u, v).join("")).match(d) || []; return c } } c.exports = function (c) { if ("string" != typeof c) throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof c + "`"); try { return c = c.replace(/\+/g, " "), decodeURIComponent(c) } catch (u) { return function customDecodeURIComponent(c) { for (var u = { "%FE%FF": "��", "%FF%FE": "��" }, d = v.exec(c); d;) { try { u[d[0]] = decodeURIComponent(d[0]) } catch (c) { var E = decode(d[0]); E !== d[0] && (u[d[0]] = E) } d = v.exec(c) } u["%C2"] = "�"; for (var k = Object.keys(u), R = 0; R < k.length; R++) { var U = k[R]; c = c.replace(new RegExp(U, "g"), u[U]) } return c }(c) } } }, "2806": function (c) { "use strict"; c.exports = function (c, u) { for (var d = {}, v = Object.keys(c), E = Array.isArray(u), k = 0; k < v.length; k++) { var R = v[k], U = c[R]; (E ? -1 !== u.indexOf(R) : u(R, U, c)) && (d[R] = U) } return d } }, "840": function (c, u, d) { var v; !function (E, k, R, U) { "use strict"; var H, G = ["", "webkit", "Moz", "MS", "ms", "o"], W = k.createElement("div"), Z = "function", Y = Math.round, J = Math.abs, K = Date.now; function setTimeoutContext(c, u, d) { return setTimeout(bindFn(c, d), u) } function invokeArrayArg(c, u, d) { return !!Array.isArray(c) && (each(c, d[u], d), !0) } function each(c, u, d) { var v; if (c) if (c.forEach) c.forEach(u, d); else if (c.length !== U) for (v = 0; v < c.length;)u.call(d, c[v], v, c), v++; else for (v in c) c.hasOwnProperty(v) && u.call(d, c[v], v, c) } function deprecate(c, u, d) { var v = "DEPRECATED METHOD: " + u + "\n" + d + " AT \n"; return function () { var u = new Error("get-stack-trace"), d = u && u.stack ? u.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace", k = E.console && (E.console.warn || E.console.log); return k && k.call(E.console, v, d), c.apply(this, arguments) } } H = "function" != typeof Object.assign ? function assign(c) { if (c === U || null === c) throw new TypeError("Cannot convert undefined or null to object"); for (var u = Object(c), d = 1; d < arguments.length; d++) { var v = arguments[d]; if (v !== U && null !== v) for (var E in v) v.hasOwnProperty(E) && (u[E] = v[E]) } return u } : Object.assign; var X = deprecate((function extend(c, u, d) { for (var v = Object.keys(u), E = 0; E < v.length;)(!d || d && c[v[E]] === U) && (c[v[E]] = u[v[E]]), E++; return c }), "extend", "Use `assign`."), Q = deprecate((function merge(c, u) { return X(c, u, !0) }), "merge", "Use `assign`."); function inherit(c, u, d) { var v, E = u.prototype; (v = c.prototype = Object.create(E)).constructor = c, v._super = E, d && H(v, d) } function bindFn(c, u) { return function boundFn() { return c.apply(u, arguments) } } function boolOrFn(c, u) { return typeof c == Z ? c.apply(u && u[0] || U, u) : c } function ifUndefined(c, u) { return c === U ? u : c } function addEventListeners(c, u, d) { each(splitStr(u), (function (u) { c.addEventListener(u, d, !1) })) } function removeEventListeners(c, u, d) { each(splitStr(u), (function (u) { c.removeEventListener(u, d, !1) })) } function hasParent(c, u) { for (; c;) { if (c == u) return !0; c = c.parentNode } return !1 } function inStr(c, u) { return c.indexOf(u) > -1 } function splitStr(c) { return c.trim().split(/\s+/g) } function inArray(c, u, d) { if (c.indexOf && !d) return c.indexOf(u); for (var v = 0; v < c.length;) { if (d && c[v][d] == u || !d && c[v] === u) return v; v++ } return -1 } function toArray(c) { return Array.prototype.slice.call(c, 0) } function uniqueArray(c, u, d) { for (var v = [], E = [], k = 0; k < c.length;) { var R = u ? c[k][u] : c[k]; inArray(E, R) < 0 && v.push(c[k]), E[k] = R, k++ } return d && (v = u ? v.sort((function sortUniqueArray(c, d) { return c[u] > d[u] })) : v.sort()), v } function prefixed(c, u) { for (var d, v, E = u[0].toUpperCase() + u.slice(1), k = 0; k < G.length;) { if ((v = (d = G[k]) ? d + E : u) in c) return v; k++ } return U } var ee = 1; function getWindowForElement(c) { var u = c.ownerDocument || c; return u.defaultView || u.parentWindow || E } var te = "ontouchstart" in E, ne = prefixed(E, "PointerEvent") !== U, re = te && /mobile|tablet|ip(ad|hone|od)|android/i.test(navigator.userAgent), oe = "touch", ie = "mouse", ae = 25, se = 1, ce = 4, le = 8, ue = 1, de = 2, pe = 4, fe = 8, he = 16, me = de | pe, ge = fe | he, _e = me | ge, ve = ["x", "y"], ye = ["clientX", "clientY"]; function Input(c, u) { var d = this; this.manager = c, this.callback = u, this.element = c.element, this.target = c.options.inputTarget, this.domHandler = function (u) { boolOrFn(c.options.enable, [c]) && d.handler(u) }, this.init() } function inputHandler(c, u, d) { var v = d.pointers.length, E = d.changedPointers.length, k = u & se && v - E == 0, R = u & (ce | le) && v - E == 0; d.isFirst = !!k, d.isFinal = !!R, k && (c.session = {}), d.eventType = u, function computeInputData(c, u) { var d = c.session, v = u.pointers, E = v.length; d.firstInput || (d.firstInput = simpleCloneInputData(u)); E > 1 && !d.firstMultiple ? d.firstMultiple = simpleCloneInputData(u) : 1 === E && (d.firstMultiple = !1); var k = d.firstInput, R = d.firstMultiple, H = R ? R.center : k.center, G = u.center = getCenter(v); u.timeStamp = K(), u.deltaTime = u.timeStamp - k.timeStamp, u.angle = getAngle(H, G), u.distance = getDistance(H, G), function computeDeltaXY(c, u) { var d = u.center, v = c.offsetDelta || {}, E = c.prevDelta || {}, k = c.prevInput || {}; u.eventType !== se && k.eventType !== ce || (E = c.prevDelta = { "x": k.deltaX || 0, "y": k.deltaY || 0 }, v = c.offsetDelta = { "x": d.x, "y": d.y }); u.deltaX = E.x + (d.x - v.x), u.deltaY = E.y + (d.y - v.y) }(d, u), u.offsetDirection = getDirection(u.deltaX, u.deltaY); var W = getVelocity(u.deltaTime, u.deltaX, u.deltaY); u.overallVelocityX = W.x, u.overallVelocityY = W.y, u.overallVelocity = J(W.x) > J(W.y) ? W.x : W.y, u.scale = R ? function getScale(c, u) { return getDistance(u[0], u[1], ye) / getDistance(c[0], c[1], ye) }(R.pointers, v) : 1, u.rotation = R ? function getRotation(c, u) { return getAngle(u[1], u[0], ye) + getAngle(c[1], c[0], ye) }(R.pointers, v) : 0, u.maxPointers = d.prevInput ? u.pointers.length > d.prevInput.maxPointers ? u.pointers.length : d.prevInput.maxPointers : u.pointers.length, function computeIntervalInputData(c, u) { var d, v, E, k, R = c.lastInterval || u, H = u.timeStamp - R.timeStamp; if (u.eventType != le && (H > ae || R.velocity === U)) { var G = u.deltaX - R.deltaX, W = u.deltaY - R.deltaY, Z = getVelocity(H, G, W); v = Z.x, E = Z.y, d = J(Z.x) > J(Z.y) ? Z.x : Z.y, k = getDirection(G, W), c.lastInterval = u } else d = R.velocity, v = R.velocityX, E = R.velocityY, k = R.direction; u.velocity = d, u.velocityX = v, u.velocityY = E, u.direction = k }(d, u); var Z = c.element; hasParent(u.srcEvent.target, Z) && (Z = u.srcEvent.target); u.target = Z }(c, d), c.emit("hammer.input", d), c.recognize(d), c.session.prevInput = d } function simpleCloneInputData(c) { for (var u = [], d = 0; d < c.pointers.length;)u[d] = { "clientX": Y(c.pointers[d].clientX), "clientY": Y(c.pointers[d].clientY) }, d++; return { "timeStamp": K(), "pointers": u, "center": getCenter(u), "deltaX": c.deltaX, "deltaY": c.deltaY } } function getCenter(c) { var u = c.length; if (1 === u) return { "x": Y(c[0].clientX), "y": Y(c[0].clientY) }; for (var d = 0, v = 0, E = 0; E < u;)d += c[E].clientX, v += c[E].clientY, E++; return { "x": Y(d / u), "y": Y(v / u) } } function getVelocity(c, u, d) { return { "x": u / c || 0, "y": d / c || 0 } } function getDirection(c, u) { return c === u ? ue : J(c) >= J(u) ? c < 0 ? de : pe : u < 0 ? fe : he } function getDistance(c, u, d) { d || (d = ve); var v = u[d[0]] - c[d[0]], E = u[d[1]] - c[d[1]]; return Math.sqrt(v * v + E * E) } function getAngle(c, u, d) { d || (d = ve); var v = u[d[0]] - c[d[0]], E = u[d[1]] - c[d[1]]; return 180 * Math.atan2(E, v) / Math.PI } Input.prototype = { "handler": function () { }, "init": function () { this.evEl && addEventListeners(this.element, this.evEl, this.domHandler), this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler), this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler) }, "destroy": function () { this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler), this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler), this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler) } }; var be = { "mousedown": se, "mousemove": 2, "mouseup": ce }, Se = "mousedown", we = "mousemove mouseup"; function MouseInput() { this.evEl = Se, this.evWin = we, this.pressed = !1, Input.apply(this, arguments) } inherit(MouseInput, Input, { "handler": function MEhandler(c) { var u = be[c.type]; u & se && 0 === c.button && (this.pressed = !0), 2 & u && 1 !== c.which && (u = ce), this.pressed && (u & ce && (this.pressed = !1), this.callback(this.manager, u, { "pointers": [c], "changedPointers": [c], "pointerType": ie, "srcEvent": c })) } }); var Ee = { "pointerdown": se, "pointermove": 2, "pointerup": ce, "pointercancel": le, "pointerout": le }, Ce = { "2": oe, "3": "pen", "4": ie, "5": "kinect" }, Te = "pointerdown", xe = "pointermove pointerup pointercancel"; function PointerEventInput() { this.evEl = Te, this.evWin = xe, Input.apply(this, arguments), this.store = this.manager.session.pointerEvents = [] } E.MSPointerEvent && !E.PointerEvent && (Te = "MSPointerDown", xe = "MSPointerMove MSPointerUp MSPointerCancel"), inherit(PointerEventInput, Input, { "handler": function PEhandler(c) { var u = this.store, d = !1, v = c.type.toLowerCase().replace("ms", ""), E = Ee[v], k = Ce[c.pointerType] || c.pointerType, R = k == oe, U = inArray(u, c.pointerId, "pointerId"); E & se && (0 === c.button || R) ? U < 0 && (u.push(c), U = u.length - 1) : E & (ce | le) && (d = !0), U < 0 || (u[U] = c, this.callback(this.manager, E, { "pointers": u, "changedPointers": [c], "pointerType": k, "srcEvent": c }), d && u.splice(U, 1)) } }); var Ae = { "touchstart": se, "touchmove": 2, "touchend": ce, "touchcancel": le }; function SingleTouchInput() { this.evTarget = "touchstart", this.evWin = "touchstart touchmove touchend touchcancel", this.started = !1, Input.apply(this, arguments) } function normalizeSingleTouches(c, u) { var d = toArray(c.touches), v = toArray(c.changedTouches); return u & (ce | le) && (d = uniqueArray(d.concat(v), "identifier", !0)), [d, v] } inherit(SingleTouchInput, Input, { "handler": function TEhandler(c) { var u = Ae[c.type]; if (u === se && (this.started = !0), this.started) { var d = normalizeSingleTouches.call(this, c, u); u & (ce | le) && d[0].length - d[1].length == 0 && (this.started = !1), this.callback(this.manager, u, { "pointers": d[0], "changedPointers": d[1], "pointerType": oe, "srcEvent": c }) } } }); var Ie = { "touchstart": se, "touchmove": 2, "touchend": ce, "touchcancel": le }, ke = "touchstart touchmove touchend touchcancel"; function TouchInput() { this.evTarget = ke, this.targetIds = {}, Input.apply(this, arguments) } function getTouches(c, u) { var d = toArray(c.touches), v = this.targetIds; if (u & (2 | se) && 1 === d.length) return v[d[0].identifier] = !0, [d, d]; var E, k, R = toArray(c.changedTouches), U = [], H = this.target; if (k = d.filter((function (c) { return hasParent(c.target, H) })), u === se) for (E = 0; E < k.length;)v[k[E].identifier] = !0, E++; for (E = 0; E < R.length;)v[R[E].identifier] && U.push(R[E]), u & (ce | le) && delete v[R[E].identifier], E++; return U.length ? [uniqueArray(k.concat(U), "identifier", !0), U] : void 0 } inherit(TouchInput, Input, { "handler": function MTEhandler(c) { var u = Ie[c.type], d = getTouches.call(this, c, u); d && this.callback(this.manager, u, { "pointers": d[0], "changedPointers": d[1], "pointerType": oe, "srcEvent": c }) } }); var Oe = 2500; function TouchMouseInput() { Input.apply(this, arguments); var c = bindFn(this.handler, this); this.touch = new TouchInput(this.manager, c), this.mouse = new MouseInput(this.manager, c), this.primaryTouch = null, this.lastTouches = [] } function recordTouches(c, u) { c & se ? (this.primaryTouch = u.changedPointers[0].identifier, setLastTouch.call(this, u)) : c & (ce | le) && setLastTouch.call(this, u) } function setLastTouch(c) { var u = c.changedPointers[0]; if (u.identifier === this.primaryTouch) { var d = { "x": u.clientX, "y": u.clientY }; this.lastTouches.push(d); var v = this.lastTouches; setTimeout((function () { var c = v.indexOf(d); c > -1 && v.splice(c, 1) }), Oe) } } function isSyntheticEvent(c) { for (var u = c.srcEvent.clientX, d = c.srcEvent.clientY, v = 0; v < this.lastTouches.length; v++) { var E = this.lastTouches[v], k = Math.abs(u - E.x), R = Math.abs(d - E.y); if (k <= 25 && R <= 25) return !0 } return !1 } inherit(TouchMouseInput, Input, { "handler": function TMEhandler(c, u, d) { var v = d.pointerType == oe, E = d.pointerType == ie; if (!(E && d.sourceCapabilities && d.sourceCapabilities.firesTouchEvents)) { if (v) recordTouches.call(this, u, d); else if (E && isSyntheticEvent.call(this, d)) return; this.callback(c, u, d) } }, "destroy": function destroy() { this.touch.destroy(), this.mouse.destroy() } }); var Pe = prefixed(W.style, "touchAction"), Re = Pe !== U, Me = "compute", Ne = "auto", De = "manipulation", $e = "none", Le = "pan-x", Fe = "pan-y", je = function getTouchActionProps() { if (!Re) return !1; var c = {}, u = E.CSS && E.CSS.supports; return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach((function (d) { c[d] = !u || E.CSS.supports("touch-action", d) })), c }(); function TouchAction(c, u) { this.manager = c, this.set(u) } TouchAction.prototype = { "set": function (c) { c == Me && (c = this.compute()), Re && this.manager.element.style && je[c] && (this.manager.element.style[Pe] = c), this.actions = c.toLowerCase().trim() }, "update": function () { this.set(this.manager.options.touchAction) }, "compute": function () { var c = []; return each(this.manager.recognizers, (function (u) { boolOrFn(u.options.enable, [u]) && (c = c.concat(u.getTouchAction())) })), function cleanTouchActions(c) { if (inStr(c, $e)) return $e; var u = inStr(c, Le), d = inStr(c, Fe); if (u && d) return $e; if (u || d) return u ? Le : Fe; if (inStr(c, De)) return De; return Ne }(c.join(" ")) }, "preventDefaults": function (c) { var u = c.srcEvent, d = c.offsetDirection; if (this.manager.session.prevented) u.preventDefault(); else { var v = this.actions, E = inStr(v, $e) && !je[$e], k = inStr(v, Fe) && !je[Fe], R = inStr(v, Le) && !je[Le]; if (E) { var U = 1 === c.pointers.length, H = c.distance < 2, G = c.deltaTime < 250; if (U && H && G) return } if (!R || !k) return E || k && d & me || R && d & ge ? this.preventSrc(u) : void 0 } }, "preventSrc": function (c) { this.manager.session.prevented = !0, c.preventDefault() } }; var Be = 1, Ue = 32; function Recognizer(c) { this.options = H({}, this.defaults, c || {}), this.id = function uniqueId() { return ee++ }(), this.manager = null, this.options.enable = ifUndefined(this.options.enable, !0), this.state = Be, this.simultaneous = {}, this.requireFail = [] } function stateStr(c) { return 16 & c ? "cancel" : 8 & c ? "end" : 4 & c ? "move" : 2 & c ? "start" : "" } function directionStr(c) { return c == he ? "down" : c == fe ? "up" : c == de ? "left" : c == pe ? "right" : "" } function getRecognizerByNameIfManager(c, u) { var d = u.manager; return d ? d.get(c) : c } function AttrRecognizer() { Recognizer.apply(this, arguments) } function PanRecognizer() { AttrRecognizer.apply(this, arguments), this.pX = null, this.pY = null } function PinchRecognizer() { AttrRecognizer.apply(this, arguments) } function PressRecognizer() { Recognizer.apply(this, arguments), this._timer = null, this._input = null } function RotateRecognizer() { AttrRecognizer.apply(this, arguments) } function SwipeRecognizer() { AttrRecognizer.apply(this, arguments) } function TapRecognizer() { Recognizer.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0 } function Hammer(c, u) { return (u = u || {}).recognizers = ifUndefined(u.recognizers, Hammer.defaults.preset), new Manager(c, u) } Recognizer.prototype = { "defaults": {}, "set": function (c) { return H(this.options, c), this.manager && this.manager.touchAction.update(), this }, "recognizeWith": function (c) { if (invokeArrayArg(c, "recognizeWith", this)) return this; var u = this.simultaneous; return u[(c = getRecognizerByNameIfManager(c, this)).id] || (u[c.id] = c, c.recognizeWith(this)), this }, "dropRecognizeWith": function (c) { return invokeArrayArg(c, "dropRecognizeWith", this) || (c = getRecognizerByNameIfManager(c, this), delete this.simultaneous[c.id]), this }, "requireFailure": function (c) { if (invokeArrayArg(c, "requireFailure", this)) return this; var u = this.requireFail; return -1 === inArray(u, c = getRecognizerByNameIfManager(c, this)) && (u.push(c), c.requireFailure(this)), this }, "dropRequireFailure": function (c) { if (invokeArrayArg(c, "dropRequireFailure", this)) return this; c = getRecognizerByNameIfManager(c, this); var u = inArray(this.requireFail, c); return u > -1 && this.requireFail.splice(u, 1), this }, "hasRequireFailures": function () { return this.requireFail.length > 0 }, "canRecognizeWith": function (c) { return !!this.simultaneous[c.id] }, "emit": function (c) { var u = this, d = this.state; function emit(d) { u.manager.emit(d, c) } d < 8 && emit(u.options.event + stateStr(d)), emit(u.options.event), c.additionalEvent && emit(c.additionalEvent), d >= 8 && emit(u.options.event + stateStr(d)) }, "tryEmit": function (c) { if (this.canEmit()) return this.emit(c); this.state = Ue }, "canEmit": function () { for (var c = 0; c < this.requireFail.length;) { if (!(this.requireFail[c].state & (Ue | Be))) return !1; c++ } return !0 }, "recognize": function (c) { var u = H({}, c); if (!boolOrFn(this.options.enable, [this, u])) return this.reset(), void (this.state = Ue); 56 & this.state && (this.state = Be), this.state = this.process(u), 30 & this.state && this.tryEmit(u) }, "process": function (c) { }, "getTouchAction": function () { }, "reset": function () { } }, inherit(AttrRecognizer, Recognizer, { "defaults": { "pointers": 1 }, "attrTest": function (c) { var u = this.options.pointers; return 0 === u || c.pointers.length === u }, "process": function (c) { var u = this.state, d = c.eventType, v = 6 & u, E = this.attrTest(c); return v && (d & le || !E) ? 16 | u : v || E ? d & ce ? 8 | u : 2 & u ? 4 | u : 2 : Ue } }), inherit(PanRecognizer, AttrRecognizer, { "defaults": { "event": "pan", "threshold": 10, "pointers": 1, "direction": _e }, "getTouchAction": function () { var c = this.options.direction, u = []; return c & me && u.push(Fe), c & ge && u.push(Le), u }, "directionTest": function (c) { var u = this.options, d = !0, v = c.distance, E = c.direction, k = c.deltaX, R = c.deltaY; return E & u.direction || (u.direction & me ? (E = 0 === k ? ue : k < 0 ? de : pe, d = k != this.pX, v = Math.abs(c.deltaX)) : (E = 0 === R ? ue : R < 0 ? fe : he, d = R != this.pY, v = Math.abs(c.deltaY))), c.direction = E, d && v > u.threshold && E & u.direction }, "attrTest": function (c) { return AttrRecognizer.prototype.attrTest.call(this, c) && (2 & this.state || !(2 & this.state) && this.directionTest(c)) }, "emit": function (c) { this.pX = c.deltaX, this.pY = c.deltaY; var u = directionStr(c.direction); u && (c.additionalEvent = this.options.event + u), this._super.emit.call(this, c) } }), inherit(PinchRecognizer, AttrRecognizer, { "defaults": { "event": "pinch", "threshold": 0, "pointers": 2 }, "getTouchAction": function () { return [$e] }, "attrTest": function (c) { return this._super.attrTest.call(this, c) && (Math.abs(c.scale - 1) > this.options.threshold || 2 & this.state) }, "emit": function (c) { if (1 !== c.scale) { var u = c.scale < 1 ? "in" : "out"; c.additionalEvent = this.options.event + u } this._super.emit.call(this, c) } }), inherit(PressRecognizer, Recognizer, { "defaults": { "event": "press", "pointers": 1, "time": 251, "threshold": 9 }, "getTouchAction": function () { return [Ne] }, "process": function (c) { var u = this.options, d = c.pointers.length === u.pointers, v = c.distance < u.threshold, E = c.deltaTime > u.time; if (this._input = c, !v || !d || c.eventType & (ce | le) && !E) this.reset(); else if (c.eventType & se) this.reset(), this._timer = setTimeoutContext((function () { this.state = 8, this.tryEmit() }), u.time, this); else if (c.eventType & ce) return 8; return Ue }, "reset": function () { clearTimeout(this._timer) }, "emit": function (c) { 8 === this.state && (c && c.eventType & ce ? this.manager.emit(this.options.event + "up", c) : (this._input.timeStamp = K(), this.manager.emit(this.options.event, this._input))) } }), inherit(RotateRecognizer, AttrRecognizer, { "defaults": { "event": "rotate", "threshold": 0, "pointers": 2 }, "getTouchAction": function () { return [$e] }, "attrTest": function (c) { return this._super.attrTest.call(this, c) && (Math.abs(c.rotation) > this.options.threshold || 2 & this.state) } }), inherit(SwipeRecognizer, AttrRecognizer, { "defaults": { "event": "swipe", "threshold": 10, "velocity": .3, "direction": me | ge, "pointers": 1 }, "getTouchAction": function () { return PanRecognizer.prototype.getTouchAction.call(this) }, "attrTest": function (c) { var u, d = this.options.direction; return d & (me | ge) ? u = c.overallVelocity : d & me ? u = c.overallVelocityX : d & ge && (u = c.overallVelocityY), this._super.attrTest.call(this, c) && d & c.offsetDirection && c.distance > this.options.threshold && c.maxPointers == this.options.pointers && J(u) > this.options.velocity && c.eventType & ce }, "emit": function (c) { var u = directionStr(c.offsetDirection); u && this.manager.emit(this.options.event + u, c), this.manager.emit(this.options.event, c) } }), inherit(TapRecognizer, Recognizer, { "defaults": { "event": "tap", "pointers": 1, "taps": 1, "interval": 300, "time": 250, "threshold": 9, "posThreshold": 10 }, "getTouchAction": function () { return [De] }, "process": function (c) { var u = this.options, d = c.pointers.length === u.pointers, v = c.distance < u.threshold, E = c.deltaTime < u.time; if (this.reset(), c.eventType & se && 0 === this.count) return this.failTimeout(); if (v && E && d) { if (c.eventType != ce) return this.failTimeout(); var k = !this.pTime || c.timeStamp - this.pTime < u.interval, R = !this.pCenter || getDistance(this.pCenter, c.center) < u.posThreshold; if (this.pTime = c.timeStamp, this.pCenter = c.center, R && k ? this.count += 1 : this.count = 1, this._input = c, 0 === this.count % u.taps) return this.hasRequireFailures() ? (this._timer = setTimeoutContext((function () { this.state = 8, this.tryEmit() }), u.interval, this), 2) : 8 } return Ue }, "failTimeout": function () { return this._timer = setTimeoutContext((function () { this.state = Ue }), this.options.interval, this), Ue }, "reset": function () { clearTimeout(this._timer) }, "emit": function () { 8 == this.state && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input)) } }), Hammer.VERSION = "2.0.7", Hammer.defaults = { "domEvents": !1, "touchAction": Me, "enable": !0, "inputTarget": null, "inputClass": null, "preset": [[RotateRecognizer, { "enable": !1 }], [PinchRecognizer, { "enable": !1 }, ["rotate"]], [SwipeRecognizer, { "direction": me }], [PanRecognizer, { "direction": me }, ["swipe"]], [TapRecognizer], [TapRecognizer, { "event": "doubletap", "taps": 2 }, ["tap"]], [PressRecognizer]], "cssProps": { "userSelect": "none", "touchSelect": "none", "touchCallout": "none", "contentZooming": "none", "userDrag": "none", "tapHighlightColor": "rgba(0,0,0,0)" } }; function Manager(c, u) { this.options = H({}, Hammer.defaults, u || {}), this.options.inputTarget = this.options.inputTarget || c, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = c, this.input = function createInputInstance(c) { return new (c.options.inputClass || (ne ? PointerEventInput : re ? TouchInput : te ? TouchMouseInput : MouseInput))(c, inputHandler) }(this), this.touchAction = new TouchAction(this, this.options.touchAction), toggleCssProps(this, !0), each(this.options.recognizers, (function (c) { var u = this.add(new c[0](c[1])); c[2] && u.recognizeWith(c[2]), c[3] && u.requireFailure(c[3]) }), this) } function toggleCssProps(c, u) { var d, v = c.element; v.style && (each(c.options.cssProps, (function (E, k) { d = prefixed(v.style, k), u ? (c.oldCssProps[d] = v.style[d], v.style[d] = E) : v.style[d] = c.oldCssProps[d] || "" })), u || (c.oldCssProps = {})) } Manager.prototype = { "set": function (c) { return H(this.options, c), c.touchAction && this.touchAction.update(), c.inputTarget && (this.input.destroy(), this.input.target = c.inputTarget, this.input.init()), this }, "stop": function (c) { this.session.stopped = c ? 2 : 1 }, "recognize": function (c) { var u = this.session; if (!u.stopped) { var d; this.touchAction.preventDefaults(c); var v = this.recognizers, E = u.curRecognizer; (!E || E && 8 & E.state) && (E = u.curRecognizer = null); for (var k = 0; k < v.length;)d = v[k], 2 === u.stopped || E && d != E && !d.canRecognizeWith(E) ? d.reset() : d.recognize(c), !E && 14 & d.state && (E = u.curRecognizer = d), k++ } }, "get": function (c) { if (c instanceof Recognizer) return c; for (var u = this.recognizers, d = 0; d < u.length; d++)if (u[d].options.event == c) return u[d]; return null }, "add": function (c) { if (invokeArrayArg(c, "add", this)) return this; var u = this.get(c.options.event); return u && this.remove(u), this.recognizers.push(c), c.manager = this, this.touchAction.update(), c }, "remove": function (c) { if (invokeArrayArg(c, "remove", this)) return this; if (c = this.get(c)) { var u = this.recognizers, d = inArray(u, c); -1 !== d && (u.splice(d, 1), this.touchAction.update()) } return this }, "on": function (c, u) { if (c !== U && u !== U) { var d = this.handlers; return each(splitStr(c), (function (c) { d[c] = d[c] || [], d[c].push(u) })), this } }, "off": function (c, u) { if (c !== U) { var d = this.handlers; return each(splitStr(c), (function (c) { u ? d[c] && d[c].splice(inArray(d[c], u), 1) : delete d[c] })), this } }, "emit": function (c, u) { this.options.domEvents && function triggerDomEvent(c, u) { var d = k.createEvent("Event"); d.initEvent(c, !0, !0), d.gesture = u, u.target.dispatchEvent(d) }(c, u); var d = this.handlers[c] && this.handlers[c].slice(); if (d && d.length) { u.type = c, u.preventDefault = function () { u.srcEvent.preventDefault() }; for (var v = 0; v < d.length;)d[v](u), v++ } }, "destroy": function () { this.element && toggleCssProps(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null } }, H(Hammer, { "INPUT_START": se, "INPUT_MOVE": 2, "INPUT_END": ce, "INPUT_CANCEL": le, "STATE_POSSIBLE": Be, "STATE_BEGAN": 2, "STATE_CHANGED": 4, "STATE_ENDED": 8, "STATE_RECOGNIZED": 8, "STATE_CANCELLED": 16, "STATE_FAILED": Ue, "DIRECTION_NONE": ue, "DIRECTION_LEFT": de, "DIRECTION_RIGHT": pe, "DIRECTION_UP": fe, "DIRECTION_DOWN": he, "DIRECTION_HORIZONTAL": me, "DIRECTION_VERTICAL": ge, "DIRECTION_ALL": _e, "Manager": Manager, "Input": Input, "TouchAction": TouchAction, "TouchInput": TouchInput, "MouseInput": MouseInput, "PointerEventInput": PointerEventInput, "TouchMouseInput": TouchMouseInput, "SingleTouchInput": SingleTouchInput, "Recognizer": Recognizer, "AttrRecognizer": AttrRecognizer, "Tap": TapRecognizer, "Pan": PanRecognizer, "Swipe": SwipeRecognizer, "Pinch": PinchRecognizer, "Rotate": RotateRecognizer, "Press": PressRecognizer, "on": addEventListeners, "off": removeEventListeners, "each": each, "merge": Q, "extend": X, "assign": H, "inherit": inherit, "bindFn": bindFn, "prefixed": prefixed }), (void 0 !== E ? E : "undefined" != typeof self ? self : {}).Hammer = Hammer, (v = function () { return Hammer }.call(u, d, u, c)) === U || (c.exports = v) }(window, document) }, "1682": function (c, u, d) { "use strict"; function extends_extends() { return extends_extends = Object.assign ? Object.assign.bind() : function (c) { for (var u = 1; u < arguments.length; u++) { var d = arguments[u]; for (var v in d) ({}).hasOwnProperty.call(d, v) && (c[v] = d[v]) } return c }, extends_extends.apply(null, arguments) } var v; d.d(u, { "aU": function () { return v }, "lX": function () { return createBrowserHistory }, "cP": function () { return parsePath } }), function (c) { c.Pop = "POP", c.Push = "PUSH", c.Replace = "REPLACE" }(v || (v = {})); var readOnly = function (c) { return c }; var E = "beforeunload", k = "popstate"; function createBrowserHistory(c) { void 0 === c && (c = {}); var u = c.window, d = void 0 === u ? document.defaultView : u, R = d.history; function getIndexAndLocation() { var c = d.location, u = c.pathname, v = c.search, E = c.hash, k = R.state || {}; return [k.idx, readOnly({ "pathname": u, "search": v, "hash": E, "state": k.usr || null, "key": k.key || "default" })] } var U = null; d.addEventListener(k, (function handlePop() { if (U) J.call(U), U = null; else { var c = v.Pop, u = getIndexAndLocation(), d = u[0], E = u[1]; if (J.length) { if (null != d) { var k = W - d; k && (U = { "action": c, "location": E, "retry": function retry() { go(-1 * k) } }, go(k)) } } else applyTx(c) } })); var H = v.Pop, G = getIndexAndLocation(), W = G[0], Z = G[1], Y = createEvents(), J = createEvents(); function createHref(c) { return "string" == typeof c ? c : createPath(c) } function getNextLocation(c, u) { return void 0 === u && (u = null), readOnly(extends_extends({ "pathname": Z.pathname, "hash": "", "search": "" }, "string" == typeof c ? parsePath(c) : c, { "state": u, "key": createKey() })) } function getHistoryStateAndUrl(c, u) { return [{ "usr": c.state, "key": c.key, "idx": u }, createHref(c)] } function allowTx(c, u, d) { return !J.length || (J.call({ "action": c, "location": u, "retry": d }), !1) } function applyTx(c) { H = c; var u = getIndexAndLocation(); W = u[0], Z = u[1], Y.call({ "action": H, "location": Z }) } function go(c) { R.go(c) } null == W && (W = 0, R.replaceState(extends_extends({}, R.state, { "idx": W }), "")); var K = { get "action"() { return H }, get "location"() { return Z }, "createHref": createHref, "push": function push(c, u) { var E = v.Push, k = getNextLocation(c, u); if (allowTx(E, k, (function retry() { push(c, u) }))) { var U = getHistoryStateAndUrl(k, W + 1), H = U[0], G = U[1]; try { R.pushState(H, "", G) } catch (c) { d.location.assign(G) } applyTx(E) } }, "replace": function replace(c, u) { var d = v.Replace, E = getNextLocation(c, u); if (allowTx(d, E, (function retry() { replace(c, u) }))) { var k = getHistoryStateAndUrl(E, W), U = k[0], H = k[1]; R.replaceState(U, "", H), applyTx(d) } }, "go": go, "back": function back() { go(-1) }, "forward": function forward() { go(1) }, "listen": function listen(c) { return Y.push(c) }, "block": function block(c) { var u = J.push(c); return 1 === J.length && d.addEventListener(E, promptBeforeUnload), function () { u(), J.length || d.removeEventListener(E, promptBeforeUnload) } } }; return K } function promptBeforeUnload(c) { c.preventDefault(), c.returnValue = "" } function createEvents() { var c = []; return { get "length"() { return c.length }, "push": function push(u) { return c.push(u), function () { c = c.filter((function (c) { return c !== u })) } }, "call": function call(u) { c.forEach((function (c) { return c && c(u) })) } } } function createKey() { return Math.random().toString(36).substr(2, 8) } function createPath(c) { var u = c.pathname, d = void 0 === u ? "/" : u, v = c.search, E = void 0 === v ? "" : v, k = c.hash, R = void 0 === k ? "" : k; return E && "?" !== E && (d += "?" === E.charAt(0) ? E : "?" + E), R && "#" !== R && (d += "#" === R.charAt(0) ? R : "#" + R), d } function parsePath(c) { var u = {}; if (c) { var d = c.indexOf("#"); d >= 0 && (u.hash = c.substr(d), c = c.substr(0, d)); var v = c.indexOf("?"); v >= 0 && (u.search = c.substr(v), c = c.substr(0, v)), c && (u.pathname = c) } return u } }, "4370": function (c, u, d) { "use strict"; Object.defineProperty(u, "__esModule", { "value": !0 }), u.headerDefaults = u.eventDefaults = void 0; var v = d(4296); u.headerDefaults = function headerDefaults() { return { "productId": "adamgibbons/ics", "method": "PUBLISH" } }, u.eventDefaults = function eventDefaults() { return { "title": "Untitled event", "uid": (0, v.nanoid)(), "timestamp": Date.now() } } }, "4276": function (c, u, d) { "use strict"; u.yM = function createEvent(c, u) { return createEvents([c], u) }; var v = d(3165); function _typeof(c) { return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (c) { return typeof c } : function (c) { return c && "function" == typeof Symbol && c.constructor === Symbol && c !== Symbol.prototype ? "symbol" : typeof c }, _typeof(c) } function ownKeys(c, u) { var d = Object.keys(c); if (Object.getOwnPropertySymbols) { var v = Object.getOwnPropertySymbols(c); u && (v = v.filter((function (u) { return Object.getOwnPropertyDescriptor(c, u).enumerable }))), d.push.apply(d, v) } return d } function _objectSpread(c) { for (var u = 1; u < arguments.length; u++) { var d = null != arguments[u] ? arguments[u] : {}; u % 2 ? ownKeys(Object(d), !0).forEach((function (u) { _defineProperty(c, u, d[u]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(c, Object.getOwnPropertyDescriptors(d)) : ownKeys(Object(d)).forEach((function (u) { Object.defineProperty(c, u, Object.getOwnPropertyDescriptor(d, u)) })) } return c } function _defineProperty(c, u, d) { return (u = function _toPropertyKey(c) { var u = function _toPrimitive(c, u) { if ("object" !== _typeof(c) || null === c) return c; var d = c[Symbol.toPrimitive]; if (void 0 !== d) { var v = d.call(c, u || "default"); if ("object" !== _typeof(v)) return v; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === u ? String : Number)(c) }(c, "string"); return "symbol" === _typeof(u) ? u : String(u) }(u)) in c ? Object.defineProperty(c, u, { "value": d, "enumerable": !0, "configurable": !0, "writable": !0 }) : c[u] = d, c } function buildHeaderAndEventAndValidate(c) { return (0, v.validateHeaderAndEvent)(_objectSpread(_objectSpread({}, (0, v.buildHeader)(c)), (0, v.buildEvent)(c))) } function createEvents(c, u, d) { var E, k = "object" === _typeof(u) ? u : {}, R = 3 === arguments.length ? d : "function" == typeof u ? u : null; try { E = function run() { if (!c) return { "error": new Error("one argument is required"), "value": null }; var u = 0 === c.length ? function buildHeaderAndValidate(c) { return (0, v.validateHeader)((0, v.buildHeader)(c)) }(k) : buildHeaderAndEventAndValidate(_objectSpread(_objectSpread({}, c[0]), k)), d = u.error, E = u.value; if (d) return { "error": d, "value": null }; var R = ""; R += (0, v.formatHeader)(E); for (var U = 0; U < c.length; U++) { var H = buildHeaderAndEventAndValidate(c[U]), G = H.error, W = H.value; if (G) return { "error": G, "value": null }; R += (0, v.formatEvent)(W) } return { "error": null, "value": R += (0, v.formatFooter)() } }() } catch (c) { E = { "error": c, "value": null } } return R ? R(E.error, E.value) : E } }, "3269": function (c, u, d) { "use strict"; Object.defineProperty(u, "__esModule", { "value": !0 }), u.buildEvent = function buildEvent() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return removeUndefined(Object.assign({}, (0, v.eventDefaults)(), c)) }, u.buildHeader = function buildHeader() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return removeUndefined(Object.assign({}, (0, v.headerDefaults)(), c)) }; var v = d(4370); function _typeof(c) { return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (c) { return typeof c } : function (c) { return c && "function" == typeof Symbol && c.constructor === Symbol && c !== Symbol.prototype ? "symbol" : typeof c }, _typeof(c) } function _defineProperty(c, u, d) { return (u = function _toPropertyKey(c) { var u = function _toPrimitive(c, u) { if ("object" !== _typeof(c) || null === c) return c; var d = c[Symbol.toPrimitive]; if (void 0 !== d) { var v = d.call(c, u || "default"); if ("object" !== _typeof(v)) return v; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === u ? String : Number)(c) }(c, "string"); return "symbol" === _typeof(u) ? u : String(u) }(u)) in c ? Object.defineProperty(c, u, { "value": d, "enumerable": !0, "configurable": !0, "writable": !0 }) : c[u] = d, c } function removeUndefined(c) { return Object.entries(c).reduce((function (c, u) { return void 0 !== u[1] ? Object.assign(c, _defineProperty({}, u[0], u[1])) : c }), {}) } }, "6167": function (c, u, d) { "use strict"; Object.defineProperty(u, "__esModule", { "value": !0 }), u.formatEvent = function formatEvent() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, u = c.title, d = c.uid, k = c.sequence, R = c.timestamp, U = c.start, H = c.startType, G = c.startInputType, W = c.startOutputType, Z = c.duration, Y = c.end, J = c.endInputType, K = c.endOutputType, X = c.description, Q = c.url, ee = c.geo, te = c.location, ne = c.status, re = c.categories, oe = c.organizer, ie = c.attendees, ae = c.alarms, se = c.recurrenceRule, ce = c.exclusionDates, le = c.busyStatus, ue = c.transp, de = c.classification, pe = c.created, fe = c.lastModified, he = c.htmlContent, me = ""; me += "BEGIN:VEVENT\r\n", me += (0, v.foldLine)("UID:".concat((0, E.default)(d))) + "\r\n", me += u ? (0, v.foldLine)("SUMMARY:".concat((0, E.default)((0, v.setSummary)(u)))) + "\r\n" : "", me += (0, v.foldLine)("DTSTAMP:".concat((0, E.default)((0, v.formatDate)(R)))) + "\r\n", me += (0, v.foldLine)("DTSTART".concat(U && 3 == U.length ? ";VALUE=DATE" : "", ":").concat((0, E.default)((0, v.formatDate)(U, W || H, G)))) + "\r\n", (!Y || 3 !== Y.length || U.length !== Y.length || U.some((function (c, u) { return c !== Y[u] }))) && Y && (me += (0, v.foldLine)("DTEND".concat(3 === Y.length ? ";VALUE=DATE" : "", ":").concat((0, E.default)((0, v.formatDate)(Y, K || W || H, J || G)))) + "\r\n"); me += void 0 !== k ? "SEQUENCE:".concat(k, "\r\n") : "", me += X ? (0, v.foldLine)("DESCRIPTION:".concat((0, E.default)((0, v.setDescription)(X)))) + "\r\n" : "", me += Q ? (0, v.foldLine)("URL:".concat((0, E.default)(Q))) + "\r\n" : "", me += ee ? (0, v.foldLine)("GEO:".concat((0, v.setGeolocation)(ee))) + "\r\n" : "", me += te ? (0, v.foldLine)("LOCATION:".concat((0, E.default)((0, v.setLocation)(te)))) + "\r\n" : "", me += ne ? (0, v.foldLine)("STATUS:".concat((0, E.default)(ne))) + "\r\n" : "", me += re ? (0, v.foldLine)("CATEGORIES:".concat((0, E.default)(re.join(",")))) + "\r\n" : "", me += oe ? (0, v.foldLine)("ORGANIZER;".concat((0, v.setOrganizer)(oe))) + "\r\n" : "", me += le ? (0, v.foldLine)("X-MICROSOFT-CDO-BUSYSTATUS:".concat((0, E.default)(le))) + "\r\n" : "", me += ue ? (0, v.foldLine)("TRANSP:".concat((0, E.default)(ue))) + "\r\n" : "", me += de ? (0, v.foldLine)("CLASS:".concat((0, E.default)(de))) + "\r\n" : "", me += pe ? "CREATED:" + (0, E.default)((0, v.formatDate)(pe)) + "\r\n" : "", me += fe ? "LAST-MODIFIED:" + (0, E.default)((0, v.formatDate)(fe)) + "\r\n" : "", me += he ? (0, v.foldLine)("X-ALT-DESC;FMTTYPE=text/html:".concat((0, E.default)(he))) + "\r\n" : "", ie && ie.forEach((function (c) { me += (0, v.foldLine)("ATTENDEE;".concat((0, E.default)((0, v.setContact)(c)))) + "\r\n" })); me += se ? (0, v.foldLine)("RRULE:".concat((0, E.default)(se))) + "\r\n" : "", me += ce ? (0, v.foldLine)("EXDATE:".concat((0, E.default)(ce.map((function (c) { return (0, v.formatDate)(c) })).join(",")))) + "\r\n" : "", me += Z ? (0, v.foldLine)("DURATION:".concat((0, v.formatDuration)(Z))) + "\r\n" : "", ae && ae.forEach((function (c) { me += (0, v.setAlarm)(c) })); return me += "END:VEVENT\r\n" }, u.formatFooter = function formatFooter() { return "END:VCALENDAR\r\n" }, u.formatHeader = function formatHeader() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, u = c.productId, d = c.method, k = c.calName, R = ""; return R += "BEGIN:VCALENDAR\r\n", R += "VERSION:2.0\r\n", R += "CALSCALE:GREGORIAN\r\n", R += (0, v.foldLine)("PRODID:".concat((0, E.default)(u))) + "\r\n", R += (0, v.foldLine)("METHOD:".concat((0, E.default)(d))) + "\r\n", R += k ? (0, v.foldLine)("X-WR-CALNAME:".concat((0, E.default)(k))) + "\r\n" : "", R += "X-PUBLISHED-TTL:PT1H\r\n" }; var v = d(6851), E = function _interopRequireDefault(c) { return c && c.__esModule ? c : { "default": c } }(d(9364)) }, "3165": function (c, u, d) { "use strict"; Object.defineProperty(u, "__esModule", { "value": !0 }), Object.defineProperty(u, "buildEvent", { "enumerable": !0, "get": function get() { return v.buildEvent } }), Object.defineProperty(u, "buildHeader", { "enumerable": !0, "get": function get() { return v.buildHeader } }), Object.defineProperty(u, "formatEvent", { "enumerable": !0, "get": function get() { return E.formatEvent } }), Object.defineProperty(u, "formatFooter", { "enumerable": !0, "get": function get() { return E.formatFooter } }), Object.defineProperty(u, "formatHeader", { "enumerable": !0, "get": function get() { return E.formatHeader } }), Object.defineProperty(u, "validateHeader", { "enumerable": !0, "get": function get() { return k.validateHeader } }), Object.defineProperty(u, "validateHeaderAndEvent", { "enumerable": !0, "get": function get() { return k.validateHeaderAndEvent } }); var v = d(3269), E = d(6167), k = d(36) }, "36": function (c, u, d) { "use strict"; Object.defineProperty(u, "__esModule", { "value": !0 }); var v = d(7468); Object.keys(v).forEach((function (c) { "default" !== c && "__esModule" !== c && (c in u && u[c] === v[c] || Object.defineProperty(u, c, { "enumerable": !0, "get": function get() { return v[c] } })) })) }, "7468": function (c, u, d) { "use strict"; Object.defineProperty(u, "__esModule", { "value": !0 }), u.validateHeader = function validateHeader(c) { try { return { "error": null, "value": Z.validateSync(c, { "abortEarly": !1, "strict": !0 }) } } catch (c) { return { "error": Object.assign({}, c), "value": void 0 } } }, u.validateHeaderAndEvent = function validateHeaderAndEvent(c) { try { return { "error": null, "value": J.validateSync(c, { "abortEarly": !1, "strict": !0 }) } } catch (c) { return { "error": Object.assign({}, c), "value": void 0 } } }; var v = function _interopRequireWildcard(c, u) { if (!u && c && c.__esModule) return c; if (null === c || "object" !== _typeof(c) && "function" != typeof c) return { "default": c }; var d = _getRequireWildcardCache(u); if (d && d.has(c)) return d.get(c); var v = {}, E = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var k in c) if ("default" !== k && Object.prototype.hasOwnProperty.call(c, k)) { var R = E ? Object.getOwnPropertyDescriptor(c, k) : null; R && (R.get || R.set) ? Object.defineProperty(v, k, R) : v[k] = c[k] } v.default = c, d && d.set(c, v); return v }(d(6310)); function _getRequireWildcardCache(c) { if ("function" != typeof WeakMap) return null; var u = new WeakMap, d = new WeakMap; return (_getRequireWildcardCache = function _getRequireWildcardCache(c) { return c ? d : u })(c) } function _typeof(c) { return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (c) { return typeof c } : function (c) { return c && "function" == typeof Symbol && c.constructor === Symbol && c !== Symbol.prototype ? "symbol" : typeof c }, _typeof(c) } function ownKeys(c, u) { var d = Object.keys(c); if (Object.getOwnPropertySymbols) { var v = Object.getOwnPropertySymbols(c); u && (v = v.filter((function (u) { return Object.getOwnPropertyDescriptor(c, u).enumerable }))), d.push.apply(d, v) } return d } function _objectSpread(c) { for (var u = 1; u < arguments.length; u++) { var d = null != arguments[u] ? arguments[u] : {}; u % 2 ? ownKeys(Object(d), !0).forEach((function (u) { _defineProperty(c, u, d[u]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(c, Object.getOwnPropertyDescriptors(d)) : ownKeys(Object(d)).forEach((function (u) { Object.defineProperty(c, u, Object.getOwnPropertyDescriptor(d, u)) })) } return c } function _defineProperty(c, u, d) { return (u = function _toPropertyKey(c) { var u = function _toPrimitive(c, u) { if ("object" !== _typeof(c) || null === c) return c; var d = c[Symbol.toPrimitive]; if (void 0 !== d) { var v = d.call(c, u || "default"); if ("object" !== _typeof(v)) return v; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === u ? String : Number)(c) }(c, "string"); return "symbol" === _typeof(u) ? u : String(u) }(u)) in c ? Object.defineProperty(c, u, { "value": d, "enumerable": !0, "configurable": !0, "writable": !0 }) : c[u] = d, c } var E = /^(?:([a-z0-9+.-]+):\/\/)(?:\S+(?::\S*)?@)?(?:(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*\.?)(?::\d{2,5})?(?:[/?#]\S*)?$/, k = function dateTimeSchema(c) { var u = c.required; return v.lazy((function (c) { return "number" == typeof c ? v.number().integer().min(0) : "string" == typeof c ? v.string().required() : u || void 0 !== c ? v.array().required().min(3).max(7).of(v.lazy((function (c, u) { var d = u.parent.indexOf(u.value); return [v.number().integer(), v.number().integer().min(1).max(12), v.number().integer().min(1).max(31), v.number().integer().min(0).max(23), v.number().integer().min(0).max(60), v.number().integer().min(0).max(60)][d] }))) : v.mixed().oneOf([void 0]) })) }, R = v.object().shape({ "before": v.boolean(), "weeks": v.number(), "days": v.number(), "hours": v.number(), "minutes": v.number(), "seconds": v.number() }).noUnknown(), U = v.object().shape({ "name": v.string(), "email": v.string().email(), "rsvp": v.boolean(), "dir": v.string().matches(E), "partstat": v.string(), "role": v.string(), "cutype": v.string(), "xNumGuests": v.number() }).noUnknown(), H = v.object().shape({ "name": v.string(), "email": v.string().email(), "dir": v.string(), "sentBy": v.string() }).noUnknown(), G = v.object().shape({ "action": v.string().matches(/^(audio|display|email)$/).required(), "trigger": v.mixed().required(), "description": v.string(), "duration": R, "repeat": v.number(), "attach": v.string(), "attachType": v.string(), "summary": v.string(), "attendee": U, "x-prop": v.mixed(), "iana-prop": v.mixed() }).noUnknown(), W = { "productId": v.string(), "method": v.string(), "calName": v.string() }, Z = v.object().shape(W).noUnknown(), Y = { "summary": v.string(), "timestamp": k({ "required": !1 }), "title": v.string(), "uid": v.string(), "sequence": v.number().integer().max(2147483647), "start": k({ "required": !0 }), "duration": R, "startType": v.string().matches(/^(utc|local)$/), "startInputType": v.string().matches(/^(utc|local)$/), "startOutputType": v.string().matches(/^(utc|local)$/), "end": k({ "required": !1 }), "endInputType": v.string().matches(/^(utc|local)$/), "endOutputType": v.string().matches(/^(utc|local)$/), "description": v.string(), "url": v.string().matches(E), "geo": v.object().shape({ "lat": v.number(), "lon": v.number() }), "location": v.string(), "status": v.string().matches(/^(TENTATIVE|CANCELLED|CONFIRMED)$/i), "categories": v.array().of(v.string()), "organizer": H, "attendees": v.array().of(U), "alarms": v.array().of(G), "recurrenceRule": v.string(), "busyStatus": v.string().matches(/^(TENTATIVE|FREE|BUSY|OOF)$/i), "transp": v.string().matches(/^(TRANSPARENT|OPAQUE)$/i), "classification": v.string(), "created": k({ "required": !1 }), "lastModified": k({ "required": !1 }), "exclusionDates": v.array().of(k({ "required": !0 })), "htmlContent": v.string() }, J = v.object().shape(_objectSpread(_objectSpread({}, W), Y)).test("xor", "object should have end or duration (but not both)", (function (c) { var u = !!c.end, d = !!c.duration; return u && !d || !u && d || !u && !d })).noUnknown() }, "9364": function (c, u) { "use strict"; Object.defineProperty(u, "__esModule", { "value": !0 }), u.default = function encodeNewLines(c) { return c.replace(/\r?\n/gm, "\\n") } }, "6444": function (c, u) { "use strict"; Object.defineProperty(u, "__esModule", { "value": !0 }), u.default = function encodeParamValue(c) { return '"'.concat(c.replaceAll('"', '\\"'), '"') } }, "4561": function (c, u, d) { "use strict"; Object.defineProperty(u, "__esModule", { "value": !0 }), u.default = function foldLine(c) { var u = [], d = 75; for (; (0, v.runes)(c).length > d;)u.push((0, v.substring)(c, 0, d)), c = (0, v.substring)(c, d), d = 74; return u.push(c), u.join("\r\n\t") }; var v = d(4285) }, "1966": function (c, u) { "use strict"; function _slicedToArray(c, u) { return function _arrayWithHoles(c) { if (Array.isArray(c)) return c }(c) || function _iterableToArrayLimit(c, u) { var d = null == c ? null : "undefined" != typeof Symbol && c[Symbol.iterator] || c["@@iterator"]; if (null != d) { var v, E, k, R, U = [], H = !0, G = !1; try { if (k = (d = d.call(c)).next, 0 === u) { if (Object(d) !== d) return; H = !1 } else for (; !(H = (v = k.call(d)).done) && (U.push(v.value), U.length !== u); H = !0); } catch (c) { G = !0, E = c } finally { try { if (!H && null != d.return && (R = d.return(), Object(R) !== R)) return } finally { if (G) throw E } } return U } }(c, u) || function _unsupportedIterableToArray(c, u) { if (!c) return; if ("string" == typeof c) return _arrayLikeToArray(c, u); var d = Object.prototype.toString.call(c).slice(8, -1); "Object" === d && c.constructor && (d = c.constructor.name); if ("Map" === d || "Set" === d) return Array.from(c); if ("Arguments" === d || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(d)) return _arrayLikeToArray(c, u) }(c, u) || function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }() } function _arrayLikeToArray(c, u) { (null == u || u > c.length) && (u = c.length); for (var d = 0, v = new Array(u); d < u; d++)v[d] = c[d]; return v } Object.defineProperty(u, "__esModule", { "value": !0 }), u.default = function formatDate() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], u = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "utc", v = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "local"; if ("string" == typeof c) return c; if (Array.isArray(c) && 3 === c.length) { var E = _slicedToArray(c, 3), k = E[0], R = E[1], U = E[2]; return "".concat(k).concat(d(R)).concat(d(U)) } var H = new Date; if (Array.isArray(c) && c.length > 0 && c[0]) { var G = _slicedToArray(c, 6), W = G[0], Z = G[1], Y = G[2], J = G[3], K = void 0 === J ? 0 : J, X = G[4], Q = void 0 === X ? 0 : X, ee = G[5], te = void 0 === ee ? 0 : ee; H = "local" === v ? new Date(W, Z - 1, Y, K, Q, te) : new Date(Date.UTC(W, Z - 1, Y, K, Q, te)) } else Array.isArray(c) || (H = new Date(c)); if ("local" === u) return [H.getFullYear(), d(H.getMonth() + 1), d(H.getDate()), "T", d(H.getHours()), d(H.getMinutes()), d(H.getSeconds())].join(""); return [H.getUTCFullYear(), d(H.getUTCMonth() + 1), d(H.getUTCDate()), "T", d(H.getUTCHours()), d(H.getUTCMinutes()), d(H.getUTCSeconds()), "Z"].join("") }; var d = function pad(c) { return c < 10 ? "0".concat(c) : "".concat(c) } }, "4671": function (c, u) { "use strict"; Object.defineProperty(u, "__esModule", { "value": !0 }), u.default = function formatDuration() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, u = c.weeks, d = c.days, v = c.hours, E = c.minutes, k = c.seconds, R = "P"; return R += u ? "".concat(u, "W") : "", R += d ? "".concat(d, "D") : "", R += "T", R += v ? "".concat(v, "H") : "", R += E ? "".concat(E, "M") : "", R += k ? "".concat(k, "S") : "" } }, "2257": function (c, u) { "use strict"; Object.defineProperty(u, "__esModule", { "value": !0 }), u.default = function formatText(c) { return c.replace(/\\/gm, "\\\\").replace(/\r?\n/gm, "\\n").replace(/;/gm, "\\;").replace(/,/gm, "\\,") } }, "6851": function (c, u, d) { "use strict"; Object.defineProperty(u, "__esModule", { "value": !0 }), Object.defineProperty(u, "encodeParamValue", { "enumerable": !0, "get": function get() { return J.default } }), Object.defineProperty(u, "foldLine", { "enumerable": !0, "get": function get() { return Z.default } }), Object.defineProperty(u, "formatDate", { "enumerable": !0, "get": function get() { return v.default } }), Object.defineProperty(u, "formatDuration", { "enumerable": !0, "get": function get() { return W.default } }), Object.defineProperty(u, "setAlarm", { "enumerable": !0, "get": function get() { return U.default } }), Object.defineProperty(u, "setContact", { "enumerable": !0, "get": function get() { return k.default } }), Object.defineProperty(u, "setDescription", { "enumerable": !0, "get": function get() { return H.default } }), Object.defineProperty(u, "setGeolocation", { "enumerable": !0, "get": function get() { return E.default } }), Object.defineProperty(u, "setLocation", { "enumerable": !0, "get": function get() { return Y.default } }), Object.defineProperty(u, "setOrganizer", { "enumerable": !0, "get": function get() { return R.default } }), Object.defineProperty(u, "setSummary", { "enumerable": !0, "get": function get() { return G.default } }); var v = _interopRequireDefault(d(1966)), E = _interopRequireDefault(d(5735)), k = _interopRequireDefault(d(6382)), R = _interopRequireDefault(d(4884)), U = _interopRequireDefault(d(8433)), H = _interopRequireDefault(d(4209)), G = _interopRequireDefault(d(4521)), W = _interopRequireDefault(d(4671)), Z = _interopRequireDefault(d(4561)), Y = _interopRequireDefault(d(9017)), J = _interopRequireDefault(d(6444)); function _interopRequireDefault(c) { return c && c.__esModule ? c : { "default": c } } }, "8433": function (c, u, d) { "use strict"; Object.defineProperty(u, "__esModule", { "value": !0 }), u.default = function setAlarm() { var c = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, u = c.action, d = c.repeat, R = c.description, U = c.duration, H = c.attach, G = c.attachType, W = c.trigger, Z = c.summary, Y = "BEGIN:VALARM\r\n"; Y += (0, E.default)("ACTION:".concat((0, k.default)(function setAction(c) { return c.toUpperCase() }(u)))) + "\r\n", Y += d ? (0, E.default)("REPEAT:".concat(d)) + "\r\n" : "", Y += R ? (0, E.default)("DESCRIPTION:".concat((0, k.default)(R))) + "\r\n" : "", Y += U ? (0, E.default)("DURATION:".concat(setDuration(U))) + "\r\n" : ""; var J = G || "FMTTYPE=audio/basic"; return Y += H ? (0, E.default)((0, k.default)("ATTACH;".concat(J, ":").concat(H))) + "\r\n" : "", Y += W ? function setTrigger(c) { var u = ""; if (Array.isArray(c) || "number" == typeof c || "string" == typeof c) u = "TRIGGER;VALUE=DATE-TIME:".concat((0, k.default)((0, v.default)(c)), "\r\n"); else { var d = c.before ? "-" : ""; u = "TRIGGER:".concat((0, k.default)(d + setDuration(c)), "\r\n") } return u }(W) : "", Y += Z ? (0, E.default)("SUMMARY:".concat((0, k.default)(Z))) + "\r\n" : "", Y += "END:VALARM\r\n" }; var v = _interopRequireDefault(d(1966)), E = _interopRequireDefault(d(4561)), k = _interopRequireDefault(d(9364)); function _interopRequireDefault(c) { return c && c.__esModule ? c : { "default": c } } function setDuration(c) { var u = c.weeks, d = c.days, v = c.hours, E = c.minutes, k = c.seconds, R = "P"; return R += u ? "".concat(u, "W") : "", R += d ? "".concat(d, "D") : "", R += "T", R += v ? "".concat(v, "H") : "", R += E ? "".concat(E, "M") : "", R += k ? "".concat(k, "S") : "" } }, "6382": function (c, u, d) { "use strict"; Object.defineProperty(u, "__esModule", { "value": !0 }), u.default = function setContact(c) { var u = c.name, d = c.email, E = c.rsvp, k = c.dir, R = c.partstat, U = c.role, H = c.cutype, G = c.xNumGuests, W = []; void 0 !== E && W.push(E ? "RSVP=TRUE" : "RSVP=FALSE"); H && W.push("CUTYPE=".concat((0, v.default)(H))); void 0 !== G && W.push("X-NUM-GUESTS=".concat(G)); U && W.push("ROLE=".concat((0, v.default)(U))); R && W.push("PARTSTAT=".concat((0, v.default)(R))); k && W.push("DIR=".concat((0, v.default)(k))); return W.push("CN=".concat((0, v.default)(u || "Unnamed attendee"))), W.join(";").concat(d ? ":mailto:".concat(d) : "") }; var v = function _interopRequireDefault(c) { return c && c.__esModule ? c : { "default": c } }(d(6444)) }, "4209": function (c, u, d) { "use strict"; Object.defineProperty(u, "__esModule", { "value": !0 }), u.default = function setDescription(c) { return (0, v.default)(c) }; var v = function _interopRequireDefault(c) { return c && c.__esModule ? c : { "default": c } }(d(2257)) }, "5735": function (c, u) { "use strict"; Object.defineProperty(u, "__esModule", { "value": !0 }), u.default = function setGeolocation(c) { var u = c.lat, d = c.lon; return "".concat(u, ";").concat(d) } }, "9017": function (c, u, d) { "use strict"; Object.defineProperty(u, "__esModule", { "value": !0 }), u.default = function setLocation(c) { return (0, v.default)(c) }; var v = function _interopRequireDefault(c) { return c && c.__esModule ? c : { "default": c } }(d(2257)) }, "4884": function (c, u, d) { "use strict"; Object.defineProperty(u, "__esModule", { "value": !0 }), u.default = function setOrganizer(c) { var u = c.name, d = c.email, E = c.dir, k = c.sentBy, R = ""; return R += E ? "DIR=".concat((0, v.default)(E), ";") : "", R += k ? "SENT-BY=".concat((0, v.default)("MAILTO:".concat(k)), ";") : "", R += "CN=", R += (0, v.default)(u || "Organizer"), R += d ? ":MAILTO:".concat(d) : "" }; var v = function _interopRequireDefault(c) { return c && c.__esModule ? c : { "default": c } }(d(6444)) }, "4521": function (c, u, d) { "use strict"; Object.defineProperty(u, "__esModule", { "value": !0 }), u.default = function setSummary(c) { return (0, v.default)(c) }; var v = function _interopRequireDefault(c) { return c && c.__esModule ? c : { "default": c } }(d(2257)) }, "3805": function (c) { "use strict"; c.exports = isMobile, c.exports.isMobile = isMobile, c.exports.default = isMobile; const u = /(android|bb\d+|meego).+mobile|armv7l|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series[46]0|samsungbrowser.*mobile|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i, d = /CrOS/, v = /android|ipad|playbook|silk/i; function isMobile(c) { c || (c = {}); let E = c.ua; if (E || "undefined" == typeof navigator || (E = navigator.userAgent), E && E.headers && "string" == typeof E.headers["user-agent"] && (E = E.headers["user-agent"]), "string" != typeof E) return !1; let k = u.test(E) && !d.test(E) || !!c.tablet && v.test(E); return !k && c.tablet && c.featureDetect && navigator && navigator.maxTouchPoints > 1 && -1 !== E.indexOf("Macintosh") && -1 !== E.indexOf("Safari") && (k = !0), k } }, "6829": function (c, u, d) { "use strict"; var v = Object.getOwnPropertySymbols, E = Object.prototype.hasOwnProperty, k = Object.prototype.propertyIsEnumerable; var R = function shouldUseNative() { try { if (!Object.assign) return !1; var c = new String("abc"); if (c[5] = "de", "5" === Object.getOwnPropertyNames(c)[0]) return !1; for (var u = {}, d = 0; d < 10; d++)u["_" + String.fromCharCode(d)] = d; if ("0123456789" !== Object.getOwnPropertyNames(u).map((function (c) { return u[c] })).join("")) return !1; var v = {}; return "abcdefghijklmnopqrst".split("").forEach((function (c) { v[c] = c })), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, v)).join("") } catch (c) { return !1 } }() ? Object.assign : function (c, u) { for (var d, R, U = function toObject(c) { if (null == c) throw new TypeError("Object.assign cannot be called with null or undefined"); return Object(c) }(c), H = 1; H < arguments.length; H++) { for (var G in d = Object(arguments[H])) E.call(d, G) && (U[G] = d[G]); if (v) { R = v(d); for (var W = 0; W < R.length; W++)k.call(d, R[W]) && (U[R[W]] = d[R[W]]) } } return U }, U = encodeURIComponent; function isFunction(c) { return "function" == typeof c } var H = ("undefined" != typeof window ? window : d.g).localStorage, G = { "disabled": !1, "set": function set(c, u) { return void 0 === u ? G.remove(c) : (H.setItem(c, G.serialize(u)), u) }, "get": function get(c, u) { var d = G.deserialize(H.getItem(c)); return void 0 === d ? u : d }, "remove": function remove(c) { H.removeItem(c) }, "clear": function clear() { H.clear() }, "has": function has(c) { return void 0 !== G.get(c) }, "forEach": function forEach(c) { for (var u = 0; u < H.length; u++) { var d = H.key(u); c(d, G.get(d)) } }, "getAll": function getAll() { var c = {}; return G.forEach((function (u, d) { c[u] = d })), c }, "serialize": function serialize(c) { return JSON.stringify(c) }, "deserialize": function deserialize(c) { if ("string" == typeof c) try { return JSON.parse(c) } catch (u) { return c || void 0 } } }; try { var W = "__store__"; G.set(W, W), G.get(W) !== W && (G.disabled = !0), G.remove(W) } catch (c) { G.disabled = !0 } G.enabled = !G.disabled; var Z = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (c) { return typeof c } : function (c) { return c && "function" == typeof Symbol && c.constructor === Symbol && c !== Symbol.prototype ? "symbol" : typeof c }, Y = "undefined" != typeof window ? window : d.g, J = "Promise" in Y && Z(isFunction(Promise)), K = function noop() { }, X = encodeURIComponent, Q = Y.document, ee = Q ? Q.head || Q.getElementsByTagName("head")[0] : null, te = 2e3, ne = { "timeout": te, "retryTimes": 2, "backup": null, "params": {}, "jsonp": "callback", "name": null, "cache": !1, "useStore": !1, "storeCheck": null, "storeSign": null, "storeCheckKey": null, "dataCheck": null, "charset": "UTF-8" }, re = (new Date).getTime(); function generateJsonpUrlWithParams(c, u) { return u = "string" == typeof u ? u : function serializeParams(c) { return c ? Object.keys(c).map((function (u) { return u + "=" + U(c[u]) })).join("&") : "" }(u), c = (c += (~c.indexOf("?") ? "&" : "?") + u).replace("?&", "?") } function fetchData(c, u, d) { var v = u.originalUrl, E = u.charset, k = function getUrlQueryParamByName(c, u) { c || (c = window.location.href), u = u.replace(/[[]]/g, "\\$&"); var d = new RegExp("[?&]" + u + "(=([^&#]*)|&|#|$)").exec(c); return d ? d[2] ? decodeURIComponent(d[2].replace(/\+/g, " ")) : "" : null }(c, u.jsonp), R = "?" !== k && k || u.name || "__jsonp" + re++, U = arguments[3] || null; k ? "?" === k && (c = function updateQueryStringParamByName(c, u, d) { var v = new RegExp("([?&])" + u + "=.*?(&|$)", "i"), E = -1 !== c.indexOf("?") ? "&" : "?"; return c.match(v) ? c.replace(v, "$1" + u + "=" + d + "$2") : c + E + u + "=" + d }(c, u.jsonp, X(R))) : c += ("&" === c.split("").pop() ? "" : "&") + u.jsonp + "=" + X(R), u.cache || (c += ("&" === c.split("").pop() ? "" : "&") + "_=" + (new Date).getTime()), clearTimeout(Y["timer_" + R]); var H = Y[R]; Y[R] = function (c) { if (H && H(c), cleanup(R), U && (c.__$$backupCall = U), u.dataCheck) { if (!1 !== u.dataCheck(c)) return setDataToStore({ "useStore": u.useStore, "storeKey": v, "data": c }), d(null, c); !1 === fallback(v, u, d) && d(new Error("Data check error, and no fallback")) } else setDataToStore({ "useStore": u.useStore, "storeKey": v, "data": c }), d(null, c) }; var G = function appendScriptTagToHead(c) { var u = c.url, d = c.charset; if (!Q) return; var v = Q.createElement("script"); v.type = "text/javascript", d && (v.charset = d); return v.src = u, ee.appendChild(v), v }({ "url": c, "charset": E }), W = null != u.timeout ? u.timeout : te; function cleanup(c) { G.parentNode && G.parentNode.removeChild(G), Y[c] = K, clearTimeout(Y["timer_" + c]) } Y["timer_" + R] = setTimeout((function () { return cleanup(R), "number" == typeof u.retryTimes && u.retryTimes > 0 ? (u.retryTimes--, fetchData(v, u, d)) : !1 === fallback(v, u, d) ? d(new Error("Timeout and no data return")) : void 0 }), W) } function storeCheckFn(c, u, d) { return !!(c && u && d) && (c[u] && c[u] === d) } function setDataToStore(c) { var u = c.useStore, d = c.storeKey, v = c.data; (u = !!u && G.enabled) && G.set(d, v) } function fallback(c, u, d) { var v = u.backup; if (v) { if ("string" == typeof v) return delete u.backup, fetchData(generateJsonpUrlWithParams(v, u.params), u, d, { "backup": v }); if (Array.isArray(v) && v.length) { var E = v.shift(); return fetchData(generateJsonpUrlWithParams(E, u.params), u, d, { "backup": E }) } } var k = function getDataFromStoreWithoutCheck(c) { var u = c.useStore, d = c.storeKey, v = c.dataCheck; if (u = !!u && G.enabled) { var E = G.get(d); if (!v || E && v && !1 !== v(E)) return E } return null }({ "useStore": u.useStore, "storeKey": c, "dataCheck": u.dataCheck }); return !!k && (d(null, k), !0) } u.Z = function jsonp$1(c, u, d) { if (isFunction(c) ? (d = c, u = {}) : c && "object" === (void 0 === c ? "undefined" : Z(c)) && (d = u, c = (u = c || {}).url), isFunction(u) && (d = u, u = {}), u || (u = {}), u = R({}, ne, u), c = c || u.url, d = d || K, !c || "string" != typeof c) return d(new Error("Param url is needed!")), !jsonp$1.promiseClose && J ? new Promise((function (c, u) { return u(new Error("Param url is needed!")) })) : void 0; var v = generateJsonpUrlWithParams(c, u.params), E = function getDataFromStore(c) { var u = c.useStore, d = c.storeKey, v = c.storeCheck, E = c.storeCheckKey, k = c.storeSign, R = c.dataCheck; if (u = !!u && G.enabled) { var U = G.get(d); if ((v = v || storeCheckFn)(U, E, k) && (!R || U && R && !1 !== R(U))) return U } return null }({ "useStore": u.useStore, "storeKey": v, "storeCheck": u.storeCheck, "storeCheckKey": u.storeCheckKey, "storeSign": u.storeSign, "dataCheck": u.dataCheck }); return E ? (d(null, E), !jsonp$1.promiseClose && J ? new Promise((function (c) { return c(E) })) : void 0) : (u.originalUrl = v, !jsonp$1.promiseClose && J ? new Promise((function (c, E) { fetchData(v, u, (function (u, v) { if (u) return d(u), E(u); d(null, v), c(v) })) })) : void fetchData(v, u, d)) } }, "9942": function (c, u) { "use strict"; Object.defineProperty(u, "__esModule", { "value": !0 }), u.GetAPI = u.APIReady = u.setupAPI = void 0; var d = void 0, v = []; u.setupAPI = function (c) { d = c, v.forEach((function (c) { c() })), v = [] }; u.APIReady = function (c) { v.push(c) }; u.GetAPI = function () { return d } }, "4287": function (c, u, d) { "use strict"; Object.defineProperty(u, "__esModule", { "value": !0 }), u.GetVstUserId = u.GetUserId = u.GetDeviceInfo = u.getSUV = void 0; var v = d(9942), E = d(2665); u.getSUV = function () { var c, u, d, k, R = (null === (c = (0, v.GetAPI)()) || void 0 === c ? void 0 : c.getStorageSync) && (null === (u = (0, v.GetAPI)()) || void 0 === u ? void 0 : u.getStorageSync("SUV")); return R || (R = (0, E.CreateUUID)(), (null === (d = (0, v.GetAPI)()) || void 0 === d ? void 0 : d.setStorageSync) && (null === (k = (0, v.GetAPI)()) || void 0 === k || k.setStorageSync("SUV", R))), R }; var getDefaultDeviceInfo = function () { var c, d, E = (null === (c = (0, v.GetAPI)()) || void 0 === c ? void 0 : c.getSystemInfoSync) && (null === (d = (0, v.GetAPI)()) || void 0 === d ? void 0 : d.getSystemInfoSync()); return { "os_type": (null == E ? void 0 : E.system.split(" ")[0]) || "", "os_version": (null == E ? void 0 : E.system.split(" ")[1]) || "", "device_type": (null == E ? void 0 : E.platform) || "", "device_brand": (null == E ? void 0 : E.brand) || "", "device_model": (null == E ? void 0 : E.model) || "", "device_res": (null == E ? void 0 : E.screenWidth) + "*" + (null == E ? void 0 : E.screenHeight), "device_pixrat": (null == E ? void 0 : E.pixelRatio) || 0, "SUV": (0, u.getSUV)() } }; u.GetDeviceInfo = function (c) { return c ? Object.assign(getDefaultDeviceInfo(), c) : getDefaultDeviceInfo() }; var k = ""; "undefined" != typeof __root && __root.getUserId && __root.getUserId((function (c) { k = c }), "userId"); u.GetUserId = function () { var c, u; return k || (k = (null === (c = (0, v.GetAPI)()) || void 0 === c ? void 0 : c.setStorageSync) && (null === (u = (0, v.GetAPI)()) || void 0 === u ? void 0 : u.getStorageSync("userId"))), k }; u.GetVstUserId = function () { var c, u, d = (null === (c = (0, v.GetAPI)()) || void 0 === c ? void 0 : c.getStorageSync) && (null === (u = (0, v.GetAPI)()) || void 0 === u ? void 0 : u.getStorageSync("userInfo")); return d && d.userId ? d.userId : "" } }, "1490": function (c, u, d) { "use strict"; u.dK = void 0; var v = new (d(3978).TrackerManager); u.dK = v; var E = d(3566); var k = d(4287) }, "3978": function (c, u, d) { "use strict"; Object.defineProperty(u, "__esModule", { "value": !0 }), u.TrackerManager = void 0; var v = d(2665), E = d(3566), k = d(794), R = d(9907), U = d(9942), H = function () { function TrackerManager() { var c = this; this.maxEVGroupCount = 20, this.sessionId = (0, v.CreateSessionId)(), this.backFromBackground = !1, this.EVQueue = [], this.SendEVWithThrottle = (0, v.throttle)((function () { c.sendEVReport() }), 1e3) } return Object.defineProperty(TrackerManager.prototype, "currentTracker", { "get": function () { return this._currentTracker }, "enumerable": !1, "configurable": !0 }), Object.defineProperty(TrackerManager.prototype, "configration", { "get": function () { return this._configration || { "appName": "", "appId": "", "appVersion": "", "spmA": "0", "vst_user_id": "" } }, "enumerable": !1, "configurable": !0 }), TrackerManager.prototype.setupConfigration = function (c) { var u = this.configration; c.appName && (u.appName = c.appName), c.appId && (u.appId = c.appId), c.appVersion && (u.appVersion = c.appVersion), c.spmA && (u.spmA = c.spmA), c.vst_user_id && (u.vst_user_id = c.vst_user_id), c.ext && (u.ext = c.ext), c.requestOptions && (u.requestOptions = c.requestOptions), c.isWeb && (u.isWeb = c.isWeb), this._configration = u, c.api && (0, U.setupAPI)(c.api) }, TrackerManager.prototype.trackStart = function (c, u) { c.becomeCurrent(u), this.updateTrackerLink(c) }, TrackerManager.prototype.onAppHide = function () { var c; this.trackPVEnd(), this.updateTrackerLink(null === (c = this.currentTracker) || void 0 === c ? void 0 : c.copy()), this.backFromBackground = !0 }, TrackerManager.prototype.onAppShow = function () { }, TrackerManager.prototype.resetBackFromStatus = function () { this.backFromBackground = !1 }, TrackerManager.prototype.updateTrackerLink = function (c) { var u; this.previousTracker = null === (u = this.currentTracker) || void 0 === u ? void 0 : u.previousStatus, this._currentTracker = c }, TrackerManager.prototype.createPageTracker = function (c, u, d, v) { return new E.PageTracker(String(this.configration.spmA), c, u, d, v) }, TrackerManager.prototype.trackPV = function () { this.needTrackPVEnd() ? this.trackPVEnd() : this.resetBackFromStatus() }, TrackerManager.prototype.trackPVEnd = function () { this.currentTracker && this.sendPVReport() }, TrackerManager.prototype.sendPVReport = function () { if (this.currentTracker) { var c = (0, k.CreateTrackModel)(this.configration), u = (0, k.CreatePVModel)(this.sessionId, this.currentTracker, this.previousTracker); this.configration.isWeb && (u.refer_page_info = (null === document || void 0 === document ? void 0 : document.referrer) || ""), (0, R.SendPV)(Object.assign(c, { "pv_modules": [u] }), this.configration.requestOptions) } }, TrackerManager.prototype.needTrackPVEnd = function () { return !this.backFromBackground }, TrackerManager.prototype.trackEV = function (c, u, d, v, E) { if (void 0 === c && (c = "0"), void 0 === u && (u = "0"), void 0 === d && (d = ""), this.currentTracker) { var R = this.currentTracker.createExposeTracker(c, u, d, v, E), U = (0, k.CreateEVModel)(this.sessionId, R, this.previousTracker); this.configration.isWeb && (U.refer_page_info = (null === document || void 0 === document ? void 0 : document.referrer) || ""), this.EVQueue.push(U), this.SendEVWithThrottle() } }, TrackerManager.prototype.sendEVReport = function () { var c = this; if (0 != this.EVQueue.length) { var u = (0, k.CreateTrackModel)(this.configration), d = this.EVQueue.splice(0, this.maxEVGroupCount); (0, R.SendEV)(Object.assign(u, { "exp_info": d }), this.configration.requestOptions).then((function () { c.SendEVWithThrottle() })).catch((function () { c.EVQueue = d.concat(c.EVQueue) })) } }, TrackerManager.prototype.trackAction = function () { if (this.currentTracker) { var c = arguments[0], u = arguments[arguments.length - 1], d = "object" == typeof u ? u : void 0, v = this.currentTracker.createActionTracker(c, d), E = arguments[1]; v.spmC = "string" == typeof E ? E : "0"; var k = arguments[2]; v.spmD = "string" == typeof k ? k : "0", this.sendActionReport(v) } }, TrackerManager.prototype.sendActionReport = function (c) { var u = (0, k.CreateTrackModel)(this.configration), d = (0, k.CreateActionModel)(this.sessionId, c, this.previousTracker); this.configration.isWeb && (d.refer_page_info = (null === document || void 0 === document ? void 0 : document.referrer) || ""), (0, R.SendAction)(Object.assign(u, { "action_info": [d] }), this.configration.requestOptions) }, TrackerManager }(); u.TrackerManager = H }, "7911": function (c, u, d) { "use strict"; Object.defineProperty(u, "__esModule", { "value": !0 }), u.GetNetworkType = void 0; var v = d(9942), E = "unknown"; (0, v.APIReady)((function () { var c, u, d, k; (null === (c = (0, v.GetAPI)()) || void 0 === c ? void 0 : c.onNetworkStatusChange) && (null === (u = (0, v.GetAPI)()) || void 0 === u || u.onNetworkStatusChange((function (c) { E = c.networkType }))), (null === (d = (0, v.GetAPI)()) || void 0 === d ? void 0 : d.getNetworkType) && (null === (k = (0, v.GetAPI)()) || void 0 === k || k.getNetworkType({ "success": function (c) { E = c.networkType } })) })); u.GetNetworkType = function () { return E } }, "9907": function (c, u, d) { "use strict"; var v = this && this.__assign || function () { return v = Object.assign || function (c) { for (var u, d = 1, v = arguments.length; d < v; d++)for (var E in u = arguments[d]) Object.prototype.hasOwnProperty.call(u, E) && (c[E] = u[E]); return c }, v.apply(this, arguments) }; Object.defineProperty(u, "__esModule", { "value": !0 }), u.SendAction = u.SendEV = u.SendPV = void 0; var E = d(9942), k = "https://track.sohu.com/", R = k + "sv", U = k + "se", H = k + "sa", SendRequest = function (c, u, d) { return void 0 === d && (d = {}), new Promise((function (k, R) { var U; null === (U = (0, E.GetAPI)()) || void 0 === U || U.request(v({ "url": c, "data": u, "method": "POST", "success": function (c) { k(c) }, "fail": function (c) { R(c) } }, d)) })) }; u.SendPV = function (c, u) { return SendRequest(R, c, u) }; u.SendEV = function (c, u) { return SendRequest(U, c, u) }; u.SendAction = function (c, u) { return SendRequest(H, c, u) } }, "794": function (c, u, d) { "use strict"; var v = this && this.__assign || function () { return v = Object.assign || function (c) { for (var u, d = 1, v = arguments.length; d < v; d++)for (var E in u = arguments[d]) Object.prototype.hasOwnProperty.call(u, E) && (c[E] = u[E]); return c }, v.apply(this, arguments) }; Object.defineProperty(u, "__esModule", { "value": !0 }), u.CreateActionModel = u.CreateEVModel = u.CreatePVModel = u.CreateTrackModel = void 0; var E = d(4287), k = d(7911); u.CreateTrackModel = function (c) { return { "report_time": +new Date, "app_name": (null == c ? void 0 : c.appName) || "", "app_id": (null == c ? void 0 : c.appId) || "", "app_version": (null == c ? void 0 : c.appVersion) || "", "device_info": (0, E.GetDeviceInfo)(), "vst_user_id": (null == c ? void 0 : c.vst_user_id) || (0, E.GetVstUserId)(), "ext": v({ "userId": (0, E.GetUserId)() }, null == c ? void 0 : c.ext) } }; var CreateEventModel = function (c, u, d) { return { "timestamp": u.startTimestamp, "log_time": +new Date, "session_id": c, "net": (0, k.GetNetworkType)(), "spm_cnt": u.spmCode, "spm_pre": null == d ? void 0 : d.spmCode, "page_info": u.pageInfo, "ev_page_info": u.evPageInfo, "refer_page_info": null == d ? void 0 : d.pageInfo, "pv_id": u.pvId, "pvid_pre": null == d ? void 0 : d.pvId } }; u.CreatePVModel = function (c, u, d) { return Object.assign(CreateEventModel(c, u, d), { "scm_pre": null == d ? void 0 : d.scm }) }; u.CreateEVModel = function (c, u, d) { return Object.assign(CreateEventModel(c, u, d), { "scm_cnt": u.scm, "ext": u.ext }) }; u.CreateActionModel = function (c, u, d) { return Object.assign(CreateEventModel(c, u, d), { "acode": u.acode, "aext": u.aext }) } }, "3566": function (c, u, d) { "use strict"; var v, E = this && this.__extends || (v = function (c, u) { return v = Object.setPrototypeOf || { "__proto__": [] } instanceof Array && function (c, u) { c.__proto__ = u } || function (c, u) { for (var d in u) Object.prototype.hasOwnProperty.call(u, d) && (c[d] = u[d]) }, v(c, u) }, function (c, u) { if ("function" != typeof u && null !== u) throw new TypeError("Class extends value " + String(u) + " is not a constructor or null"); function __() { this.constructor = c } v(c, u), c.prototype = null === u ? Object.create(u) : (__.prototype = u.prototype, new __) }); Object.defineProperty(u, "__esModule", { "value": !0 }), u.ActionTracker = u.ExposeTracker = u.PageTracker = void 0; var k = d(2665), R = function (c) { function PageTracker(u, d, v, E, R) { var U = c.call(this) || this; return U._pvId = (0, k.CreatePvId)(), U.spmA = u, U.spmB = d, U.pageInfo = v, E && (U._pvId = E), R && U.updateECode(R), U._startTimestamp = +new Date, U } return E(PageTracker, c), Object.defineProperty(PageTracker.prototype, "pvId", { "get": function () { return this._pvId }, "enumerable": !1, "configurable": !0 }), Object.defineProperty(PageTracker.prototype, "startTimestamp", { "get": function () { return this._startTimestamp }, "enumerable": !1, "configurable": !0 }), Object.defineProperty(PageTracker.prototype, "previousStatus", { "get": function () { return this._previousStatus || this.copy() }, "enumerable": !1, "configurable": !0 }), PageTracker.prototype.becomePrevious = function (c, u, d) { void 0 === c && (c = "0"), void 0 === u && (u = "0"); var v = this.copy(); v.spmC = c, v.spmD = u, v.scm = d, this._previousStatus = v }, PageTracker.prototype.becomeCurrent = function (c) { !c && this.updateECode(), this._previousStatus = void 0, this._startTimestamp = +new Date }, PageTracker.prototype.createActionTracker = function (c, u) { var d = new H(this.spmA, this.spmB, c, this.pageInfo, u, this.pvId); return d.updateECode(this.spmE), d }, PageTracker.prototype.createExposeTracker = function (c, u, d, v, E) { void 0 === c && (c = "0"), void 0 === u && (u = "0"), void 0 === d && (d = ""), E || (E = {}); var k = this.pageInfo, R = new U(this.spmA, this.spmB, k, this.pvId); return R.spmC = c, R.spmD = u, R.scm = d, R.evPageInfo = E, v && (R.ext = v), R.updateECode(this.spmE), R }, PageTracker.prototype.copy = function () { var c = new PageTracker(this.spmA, this.spmB, this.pageInfo); return c._startTimestamp = this.startTimestamp, c._pvId = this.pvId, c.updateECode(this.spmE), c }, PageTracker.prototype.getTrackerData = function () { return { "spmA": this.spmA, "spmB": this.spmB, "spmC": this.spmC, "spmD": this.spmD, "spmE": this.spmE, "pvId": this.pvId } }, PageTracker }(function () { function SPMCode() { this.spmC = "0", this.spmD = "0", this._spmE = (0, k.CreateSpmECode)() } return Object.defineProperty(SPMCode.prototype, "spmE", { "get": function () { return this._spmE }, "enumerable": !1, "configurable": !0 }), Object.defineProperty(SPMCode.prototype, "spmCode", { "get": function () { return "".concat(this.spmA, ".").concat(this.spmB, ".").concat(this.spmC, ".").concat(this.spmD, ".").concat(this.spmE) }, "enumerable": !1, "configurable": !0 }), SPMCode.prototype.updateECode = function (c) { this._spmE = c || (0, k.CreateSpmECode)() }, SPMCode }()); u.PageTracker = R; var U = function (c) { function ExposeTracker() { return null !== c && c.apply(this, arguments) || this } return E(ExposeTracker, c), ExposeTracker }(R); u.ExposeTracker = U; var H = function (c) { function ActionTracker(u, d, v, E, k, R) { var U = c.call(this, u, d, E, R) || this; return U.acode = v, U.aext = k, U } return E(ActionTracker, c), ActionTracker }(R); u.ActionTracker = H }, "2665": function (c, u) { "use strict"; Object.defineProperty(u, "__esModule", { "value": !0 }), u.throttle = u.CreateUUID = u.CreateSpmECode = u.CreatePvId = u.CreateSessionId = u.RandomString = void 0; u.RandomString = function (c) { var u = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"; return Array.from(Array(c)).map((function (c) { return u[parseInt((62 * Math.random()).toString())] })).join("") }; u.CreateSessionId = function () { return (new Date).getTime() + (0, u.RandomString)(7) }; u.CreatePvId = function () { return (new Date).getTime() + (0, u.RandomString)(7) }; u.CreateSpmECode = function () { return (new Date).getTime() + (0, u.RandomString)(7) }; u.CreateUUID = function () { return (new Date).getTime() + (0, u.RandomString)(7) }, u.throttle = function throttle(c, u) { var d = -1; return function () { for (var v = this, E = [], k = 0; k < arguments.length; k++)E[k] = arguments[k]; clearTimeout(d), d = setTimeout((function () { c.apply(v, E) }), u) } } }, "1748": function (c, u, d) { c.exports = d(7121) }, "4074": function (c, u, d) { "use strict"; var v = d(3198), E = d(3679), k = d(9764), R = d(7617), U = d(9307), H = d(2351), G = d(1669); c.exports = function xhrAdapter(c) { return new Promise((function dispatchXhrRequest(u, W) { var Z = c.data, Y = c.headers; v.isFormData(Z) && delete Y["Content-Type"]; var J = new XMLHttpRequest; if (c.auth) { var K = c.auth.username || "", X = c.auth.password || ""; Y.Authorization = "Basic " + btoa(K + ":" + X) } var Q = R(c.baseURL, c.url); if (J.open(c.method.toUpperCase(), k(Q, c.params, c.paramsSerializer), !0), J.timeout = c.timeout, J.onreadystatechange = function handleLoad() { if (J && 4 === J.readyState && (0 !== J.status || J.responseURL && 0 === J.responseURL.indexOf("file:"))) { var d = "getAllResponseHeaders" in J ? U(J.getAllResponseHeaders()) : null, v = { "data": c.responseType && "text" !== c.responseType ? J.response : J.responseText, "status": J.status, "statusText": J.statusText, "headers": d, "config": c, "request": J }; E(u, W, v), J = null } }, J.onabort = function handleAbort() { J && (W(G("Request aborted", c, "ECONNABORTED", J)), J = null) }, J.onerror = function handleError() { W(G("Network Error", c, null, J)), J = null }, J.ontimeout = function handleTimeout() { var u = "timeout of " + c.timeout + "ms exceeded"; c.timeoutErrorMessage && (u = c.timeoutErrorMessage), W(G(u, c, "ECONNABORTED", J)), J = null }, v.isStandardBrowserEnv()) { var ee = d(2630), te = (c.withCredentials || H(Q)) && c.xsrfCookieName ? ee.read(c.xsrfCookieName) : void 0; te && (Y[c.xsrfHeaderName] = te) } if ("setRequestHeader" in J && v.forEach(Y, (function setRequestHeader(c, u) { void 0 === Z && "content-type" === u.toLowerCase() ? delete Y[u] : J.setRequestHeader(u, c) })), v.isUndefined(c.withCredentials) || (J.withCredentials = !!c.withCredentials), c.responseType) try { J.responseType = c.responseType } catch (u) { if ("json" !== c.responseType) throw u } "function" == typeof c.onDownloadProgress && J.addEventListener("progress", c.onDownloadProgress), "function" == typeof c.onUploadProgress && J.upload && J.upload.addEventListener("progress", c.onUploadProgress), c.cancelToken && c.cancelToken.promise.then((function onCanceled(c) { J && (J.abort(), W(c), J = null) })), void 0 === Z && (Z = null), J.send(Z) })) } }, "7121": function (c, u, d) { "use strict"; var v = d(3198), E = d(8250), k = d(6916), R = d(4367); function createInstance(c) { var u = new k(c), d = E(k.prototype.request, u); return v.extend(d, k.prototype, u), v.extend(d, u), d } var U = createInstance(d(7668)); U.Axios = k, U.create = function create(c) { return createInstance(R(U.defaults, c)) }, U.Cancel = d(675), U.CancelToken = d(9272), U.isCancel = d(2965), U.all = function all(c) { return Promise.all(c) }, U.spread = d(5537), c.exports = U, c.exports.default = U }, "675": function (c) { "use strict"; function Cancel(c) { this.message = c } Cancel.prototype.toString = function toString() { return "Cancel" + (this.message ? ": " + this.message : "") }, Cancel.prototype.__CANCEL__ = !0, c.exports = Cancel }, "9272": function (c, u, d) { "use strict"; var v = d(675); function CancelToken(c) { if ("function" != typeof c) throw new TypeError("executor must be a function."); var u; this.promise = new Promise((function promiseExecutor(c) { u = c })); var d = this; c((function cancel(c) { d.reason || (d.reason = new v(c), u(d.reason)) })) } CancelToken.prototype.throwIfRequested = function throwIfRequested() { if (this.reason) throw this.reason }, CancelToken.source = function source() { var c; return { "token": new CancelToken((function executor(u) { c = u })), "cancel": c } }, c.exports = CancelToken }, "2965": function (c) { "use strict"; c.exports = function isCancel(c) { return !(!c || !c.__CANCEL__) } }, "6916": function (c, u, d) { "use strict"; var v = d(3198), E = d(9764), k = d(5445), R = d(642), U = d(4367); function Axios(c) { this.defaults = c, this.interceptors = { "request": new k, "response": new k } } Axios.prototype.request = function request(c) { "string" == typeof c ? (c = arguments[1] || {}).url = arguments[0] : c = c || {}, (c = U(this.defaults, c)).method ? c.method = c.method.toLowerCase() : this.defaults.method ? c.method = this.defaults.method.toLowerCase() : c.method = "get"; var u = [R, void 0], d = Promise.resolve(c); for (this.interceptors.request.forEach((function unshiftRequestInterceptors(c) { u.unshift(c.fulfilled, c.rejected) })), this.interceptors.response.forEach((function pushResponseInterceptors(c) { u.push(c.fulfilled, c.rejected) })); u.length;)d = d.then(u.shift(), u.shift()); return d }, Axios.prototype.getUri = function getUri(c) { return c = U(this.defaults, c), E(c.url, c.params, c.paramsSerializer).replace(/^\?/, "") }, v.forEach(["delete", "get", "head", "options"], (function forEachMethodNoData(c) { Axios.prototype[c] = function (u, d) { return this.request(v.merge(d || {}, { "method": c, "url": u })) } })), v.forEach(["post", "put", "patch"], (function forEachMethodWithData(c) { Axios.prototype[c] = function (u, d, E) { return this.request(v.merge(E || {}, { "method": c, "url": u, "data": d })) } })), c.exports = Axios }, "5445": function (c, u, d) { "use strict"; var v = d(3198); function InterceptorManager() { this.handlers = [] } InterceptorManager.prototype.use = function use(c, u) { return this.handlers.push({ "fulfilled": c, "rejected": u }), this.handlers.length - 1 }, InterceptorManager.prototype.eject = function eject(c) { this.handlers[c] && (this.handlers[c] = null) }, InterceptorManager.prototype.forEach = function forEach(c) { v.forEach(this.handlers, (function forEachHandler(u) { null !== u && c(u) })) }, c.exports = InterceptorManager }, "7617": function (c, u, d) { "use strict"; var v = d(3874), E = d(9750); c.exports = function buildFullPath(c, u) { return c && !v(u) ? E(c, u) : u } }, "1669": function (c, u, d) { "use strict"; var v = d(7619); c.exports = function createError(c, u, d, E, k) { var R = new Error(c); return v(R, u, d, E, k) } }, "642": function (c, u, d) { "use strict"; var v = d(3198), E = d(3343), k = d(2965), R = d(7668); function throwIfCancellationRequested(c) { c.cancelToken && c.cancelToken.throwIfRequested() } c.exports = function dispatchRequest(c) { return throwIfCancellationRequested(c), c.headers = c.headers || {}, c.data = E(c.data, c.headers, c.transformRequest), c.headers = v.merge(c.headers.common || {}, c.headers[c.method] || {}, c.headers), v.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (function cleanHeaderConfig(u) { delete c.headers[u] })), (c.adapter || R.adapter)(c).then((function onAdapterResolution(u) { return throwIfCancellationRequested(c), u.data = E(u.data, u.headers, c.transformResponse), u }), (function onAdapterRejection(u) { return k(u) || (throwIfCancellationRequested(c), u && u.response && (u.response.data = E(u.response.data, u.response.headers, c.transformResponse))), Promise.reject(u) })) } }, "7619": function (c) { "use strict"; c.exports = function enhanceError(c, u, d, v, E) { return c.config = u, d && (c.code = d), c.request = v, c.response = E, c.isAxiosError = !0, c.toJSON = function () { return { "message": this.message, "name": this.name, "description": this.description, "number": this.number, "fileName": this.fileName, "lineNumber": this.lineNumber, "columnNumber": this.columnNumber, "stack": this.stack, "config": this.config, "code": this.code } }, c } }, "4367": function (c, u, d) { "use strict"; var v = d(3198); c.exports = function mergeConfig(c, u) { u = u || {}; var d = {}, E = ["url", "method", "params", "data"], k = ["headers", "auth", "proxy"], R = ["baseURL", "url", "transformRequest", "transformResponse", "paramsSerializer", "timeout", "withCredentials", "adapter", "responseType", "xsrfCookieName", "xsrfHeaderName", "onUploadProgress", "onDownloadProgress", "maxContentLength", "validateStatus", "maxRedirects", "httpAgent", "httpsAgent", "cancelToken", "socketPath"]; v.forEach(E, (function valueFromConfig2(c) { void 0 !== u[c] && (d[c] = u[c]) })), v.forEach(k, (function mergeDeepProperties(E) { v.isObject(u[E]) ? d[E] = v.deepMerge(c[E], u[E]) : void 0 !== u[E] ? d[E] = u[E] : v.isObject(c[E]) ? d[E] = v.deepMerge(c[E]) : void 0 !== c[E] && (d[E] = c[E]) })), v.forEach(R, (function defaultToConfig2(v) { void 0 !== u[v] ? d[v] = u[v] : void 0 !== c[v] && (d[v] = c[v]) })); var U = E.concat(k).concat(R), H = Object.keys(u).filter((function filterAxiosKeys(c) { return -1 === U.indexOf(c) })); return v.forEach(H, (function otherKeysDefaultToConfig2(v) { void 0 !== u[v] ? d[v] = u[v] : void 0 !== c[v] && (d[v] = c[v]) })), d } }, "3679": function (c, u, d) { "use strict"; var v = d(1669); c.exports = function settle(c, u, d) { var E = d.config.validateStatus; !E || E(d.status) ? c(d) : u(v("Request failed with status code " + d.status, d.config, null, d.request, d)) } }, "3343": function (c, u, d) { "use strict"; var v = d(3198); c.exports = function transformData(c, u, d) { return v.forEach(d, (function transform(d) { c = d(c, u) })), c } }, "7668": function (c, u, d) { "use strict"; var v = d(3198), E = d(2020), k = { "Content-Type": "application/x-www-form-urlencoded" }; function setContentTypeIfUnset(c, u) { !v.isUndefined(c) && v.isUndefined(c["Content-Type"]) && (c["Content-Type"] = u) } var R = { "adapter": function getDefaultAdapter() { var c; return ("undefined" != typeof XMLHttpRequest || "undefined" != typeof process && "[object process]" === Object.prototype.toString.call(process)) && (c = d(4074)), c }(), "transformRequest": [function transformRequest(c, u) { return E(u, "Accept"), E(u, "Content-Type"), v.isFormData(c) || v.isArrayBuffer(c) || v.isBuffer(c) || v.isStream(c) || v.isFile(c) || v.isBlob(c) ? c : v.isArrayBufferView(c) ? c.buffer : v.isURLSearchParams(c) ? (setContentTypeIfUnset(u, "application/x-www-form-urlencoded;charset=utf-8"), c.toString()) : v.isObject(c) ? (setContentTypeIfUnset(u, "application/json;charset=utf-8"), JSON.stringify(c)) : c }], "transformResponse": [function transformResponse(c) { if ("string" == typeof c) try { c = JSON.parse(c) } catch (c) { } return c }], "timeout": 0, "xsrfCookieName": "XSRF-TOKEN", "xsrfHeaderName": "X-XSRF-TOKEN", "maxContentLength": -1, "validateStatus": function validateStatus(c) { return c >= 200 && c < 300 }, "headers": { "common": { "Accept": "application/json, text/plain, */*" } } }; v.forEach(["delete", "get", "head"], (function forEachMethodNoData(c) { R.headers[c] = {} })), v.forEach(["post", "put", "patch"], (function forEachMethodWithData(c) { R.headers[c] = v.merge(k) })), c.exports = R }, "8250": function (c) { "use strict"; c.exports = function bind(c, u) { return function wrap() { for (var d = new Array(arguments.length), v = 0; v < d.length; v++)d[v] = arguments[v]; return c.apply(u, d) } } }, "9764": function (c, u, d) { "use strict"; var v = d(3198); function encode(c) { return encodeURIComponent(c).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]") } c.exports = function buildURL(c, u, d) { if (!u) return c; var E; if (d) E = d(u); else if (v.isURLSearchParams(u)) E = u.toString(); else { var k = []; v.forEach(u, (function serialize(c, u) { null != c && (v.isArray(c) ? u += "[]" : c = [c], v.forEach(c, (function parseValue(c) { v.isDate(c) ? c = c.toISOString() : v.isObject(c) && (c = JSON.stringify(c)), k.push(encode(u) + "=" + encode(c)) }))) })), E = k.join("&") } if (E) { var R = c.indexOf("#"); -1 !== R && (c = c.slice(0, R)), c += (-1 === c.indexOf("?") ? "?" : "&") + E } return c } }, "9750": function (c) { "use strict"; c.exports = function combineURLs(c, u) { return u ? c.replace(/\/+$/, "") + "/" + u.replace(/^\/+/, "") : c } }, "2630": function (c, u, d) { "use strict"; var v = d(3198); c.exports = v.isStandardBrowserEnv() ? function standardBrowserEnv() { return { "write": function write(c, u, d, E, k, R) { var U = []; U.push(c + "=" + encodeURIComponent(u)), v.isNumber(d) && U.push("expires=" + new Date(d).toGMTString()), v.isString(E) && U.push("path=" + E), v.isString(k) && U.push("domain=" + k), !0 === R && U.push("secure"), document.cookie = U.join("; ") }, "read": function read(c) { var u = document.cookie.match(new RegExp("(^|;\\s*)(" + c + ")=([^;]*)")); return u ? decodeURIComponent(u[3]) : null }, "remove": function remove(c) { this.write(c, "", Date.now() - 864e5) } } }() : { "write": function write() { }, "read": function read() { return null }, "remove": function remove() { } } }, "3874": function (c) { "use strict"; c.exports = function isAbsoluteURL(c) { return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(c) } }, "2351": function (c, u, d) { "use strict"; var v = d(3198); c.exports = v.isStandardBrowserEnv() ? function standardBrowserEnv() { var c, u = /(msie|trident)/i.test(navigator.userAgent), d = document.createElement("a"); function resolveURL(c) { var v = c; return u && (d.setAttribute("href", v), v = d.href), d.setAttribute("href", v), { "href": d.href, "protocol": d.protocol ? d.protocol.replace(/:$/, "") : "", "host": d.host, "search": d.search ? d.search.replace(/^\?/, "") : "", "hash": d.hash ? d.hash.replace(/^#/, "") : "", "hostname": d.hostname, "port": d.port, "pathname": "/" === d.pathname.charAt(0) ? d.pathname : "/" + d.pathname } } return c = resolveURL(window.location.href), function isURLSameOrigin(u) { var d = v.isString(u) ? resolveURL(u) : u; return d.protocol === c.protocol && d.host === c.host } }() : function isURLSameOrigin() { return !0 } }, "2020": function (c, u, d) { "use strict"; var v = d(3198); c.exports = function normalizeHeaderName(c, u) { v.forEach(c, (function processHeader(d, v) { v !== u && v.toUpperCase() === u.toUpperCase() && (c[u] = d, delete c[v]) })) } }, "9307": function (c, u, d) { "use strict"; var v = d(3198), E = ["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]; c.exports = function parseHeaders(c) { var u, d, k, R = {}; return c ? (v.forEach(c.split("\n"), (function parser(c) { if (k = c.indexOf(":"), u = v.trim(c.substr(0, k)).toLowerCase(), d = v.trim(c.substr(k + 1)), u) { if (R[u] && E.indexOf(u) >= 0) return; R[u] = "set-cookie" === u ? (R[u] ? R[u] : []).concat([d]) : R[u] ? R[u] + ", " + d : d } })), R) : R } }, "5537": function (c) { "use strict"; c.exports = function spread(c) { return function wrap(u) { return c.apply(null, u) } } }, "3198": function (c, u, d) { "use strict"; var v = d(8250), E = Object.prototype.toString; function isArray(c) { return "[object Array]" === E.call(c) } function isUndefined(c) { return void 0 === c } function isObject(c) { return null !== c && "object" == typeof c } function isFunction(c) { return "[object Function]" === E.call(c) } function forEach(c, u) { if (null != c) if ("object" != typeof c && (c = [c]), isArray(c)) for (var d = 0, v = c.length; d < v; d++)u.call(null, c[d], d, c); else for (var E in c) Object.prototype.hasOwnProperty.call(c, E) && u.call(null, c[E], E, c) } c.exports = { "isArray": isArray, "isArrayBuffer": function isArrayBuffer(c) { return "[object ArrayBuffer]" === E.call(c) }, "isBuffer": function isBuffer(c) { return null !== c && !isUndefined(c) && null !== c.constructor && !isUndefined(c.constructor) && "function" == typeof c.constructor.isBuffer && c.constructor.isBuffer(c) }, "isFormData": function isFormData(c) { return "undefined" != typeof FormData && c instanceof FormData }, "isArrayBufferView": function isArrayBufferView(c) { return "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(c) : c && c.buffer && c.buffer instanceof ArrayBuffer }, "isString": function isString(c) { return "string" == typeof c }, "isNumber": function isNumber(c) { return "number" == typeof c }, "isObject": isObject, "isUndefined": isUndefined, "isDate": function isDate(c) { return "[object Date]" === E.call(c) }, "isFile": function isFile(c) { return "[object File]" === E.call(c) }, "isBlob": function isBlob(c) { return "[object Blob]" === E.call(c) }, "isFunction": isFunction, "isStream": function isStream(c) { return isObject(c) && isFunction(c.pipe) }, "isURLSearchParams": function isURLSearchParams(c) { return "undefined" != typeof URLSearchParams && c instanceof URLSearchParams }, "isStandardBrowserEnv": function isStandardBrowserEnv() { return ("undefined" == typeof navigator || "ReactNative" !== navigator.product && "NativeScript" !== navigator.product && "NS" !== navigator.product) && ("undefined" != typeof window && "undefined" != typeof document) }, "forEach": forEach, "merge": function merge() { var c = {}; function assignValue(u, d) { "object" == typeof c[d] && "object" == typeof u ? c[d] = merge(c[d], u) : c[d] = u } for (var u = 0, d = arguments.length; u < d; u++)forEach(arguments[u], assignValue); return c }, "deepMerge": function deepMerge() { var c = {}; function assignValue(u, d) { "object" == typeof c[d] && "object" == typeof u ? c[d] = deepMerge(c[d], u) : c[d] = "object" == typeof u ? deepMerge({}, u) : u } for (var u = 0, d = arguments.length; u < d; u++)forEach(arguments[u], assignValue); return c }, "extend": function extend(c, u, d) { return forEach(u, (function assignValue(u, E) { c[E] = d && "function" == typeof u ? v(u, d) : u })), c }, "trim": function trim(c) { return c.replace(/^\s*/, "").replace(/\s*$/, "") } } }, "1795": function (c, u, d) { var v; c = d.nmd(c), function () { "use strict"; var E = { "function": !0, "object": !0 }, k = E[typeof window] && window || this, R = E[typeof u] && u, U = E.object && c && !c.nodeType && c, H = R && U && "object" == typeof d.g && d.g; !H || H.global !== H && H.window !== H && H.self !== H || (k = H); var G = Math.pow(2, 53) - 1, W = /\bOpera/, Z = Object.prototype, Y = Z.hasOwnProperty, J = Z.toString; function capitalize(c) { return (c = String(c)).charAt(0).toUpperCase() + c.slice(1) } function format(c) { return c = trim(c), /^(?:webOS|i(?:OS|P))/.test(c) ? c : capitalize(c) } function forOwn(c, u) { for (var d in c) Y.call(c, d) && u(c[d], d, c) } function getClassOf(c) { return null == c ? capitalize(c) : J.call(c).slice(8, -1) } function qualify(c) { return String(c).replace(/([ -])(?!$)/g, "$1?") } function reduce(c, u) { var d = null; return function each(c, u) { var d = -1, v = c ? c.length : 0; if ("number" == typeof v && v > -1 && v <= G) for (; ++d < v;)u(c[d], d, c); else forOwn(c, u) }(c, (function (v, E) { d = u(d, v, E, c) })), d } function trim(c) { return String(c).replace(/^ +| +$/g, "") } var K = function parse(c) { var u = k, d = c && "object" == typeof c && "String" != getClassOf(c); d && (u = c, c = null); var v = u.navigator || {}, E = v.userAgent || ""; c || (c = E); var R, U, H = d ? !!v.likeChrome : /\bChrome\b/.test(c) && !/internal|\n/i.test(J.toString()), G = "Object", Z = d ? G : "ScriptBridgingProxyObject", Y = d ? G : "Environment", K = d && u.java ? "JavaPackage" : getClassOf(u.java), X = d ? G : "RuntimeObject", Q = /\bJava/.test(K) && u.java, ee = Q && getClassOf(u.environment) == Y, te = Q ? "a" : "α", ne = Q ? "b" : "β", re = u.document || {}, oe = u.operamini || u.opera, ie = W.test(ie = d && oe ? oe["[[Class]]"] : getClassOf(oe)) ? ie : oe = null, ae = c, se = [], ce = null, le = c == E, ue = le && oe && "function" == typeof oe.version && oe.version(), de = function getLayout(u) { return reduce(u, (function (u, d) { return u || RegExp("\\b" + (d.pattern || qualify(d)) + "\\b", "i").exec(c) && (d.label || d) })) }([{ "label": "EdgeHTML", "pattern": "Edge" }, "Trident", { "label": "WebKit", "pattern": "AppleWebKit" }, "iCab", "Presto", "NetFront", "Tasman", "KHTML", "Gecko"]), pe = function getName(u) { return reduce(u, (function (u, d) { return u || RegExp("\\b" + (d.pattern || qualify(d)) + "\\b", "i").exec(c) && (d.label || d) })) }(["Adobe AIR", "Arora", "Avant Browser", "Breach", "Camino", "Electron", "Epiphany", "Fennec", "Flock", "Galeon", "GreenBrowser", "iCab", "Iceweasel", "K-Meleon", "Konqueror", "Lunascape", "Maxthon", { "label": "Microsoft Edge", "pattern": "(?:Edge|Edg|EdgA|EdgiOS)" }, "Midori", "Nook Browser", "PaleMoon", "PhantomJS", "Raven", "Rekonq", "RockMelt", { "label": "Samsung Internet", "pattern": "SamsungBrowser" }, "SeaMonkey", { "label": "Silk", "pattern": "(?:Cloud9|Silk-Accelerated)" }, "Sleipnir", "SlimBrowser", { "label": "SRWare Iron", "pattern": "Iron" }, "Sunrise", "Swiftfox", "Vivaldi", "Waterfox", "WebPositive", { "label": "Yandex Browser", "pattern": "YaBrowser" }, { "label": "UC Browser", "pattern": "UCBrowser" }, "Opera Mini", { "label": "Opera Mini", "pattern": "OPiOS" }, "Opera", { "label": "Opera", "pattern": "OPR" }, "Chromium", "Chrome", { "label": "Chrome", "pattern": "(?:HeadlessChrome)" }, { "label": "Chrome Mobile", "pattern": "(?:CriOS|CrMo)" }, { "label": "Firefox", "pattern": "(?:Firefox|Minefield)" }, { "label": "Firefox for iOS", "pattern": "FxiOS" }, { "label": "IE", "pattern": "IEMobile" }, { "label": "IE", "pattern": "MSIE" }, "Safari"]), fe = getProduct([{ "label": "BlackBerry", "pattern": "BB10" }, "BlackBerry", { "label": "Galaxy S", "pattern": "GT-I9000" }, { "label": "Galaxy S2", "pattern": "GT-I9100" }, { "label": "Galaxy S3", "pattern": "GT-I9300" }, { "label": "Galaxy S4", "pattern": "GT-I9500" }, { "label": "Galaxy S5", "pattern": "SM-G900" }, { "label": "Galaxy S6", "pattern": "SM-G920" }, { "label": "Galaxy S6 Edge", "pattern": "SM-G925" }, { "label": "Galaxy S7", "pattern": "SM-G930" }, { "label": "Galaxy S7 Edge", "pattern": "SM-G935" }, "Google TV", "Lumia", "iPad", "iPod", "iPhone", "Kindle", { "label": "Kindle Fire", "pattern": "(?:Cloud9|Silk-Accelerated)" }, "Nexus", "Nook", "PlayBook", "PlayStation Vita", "PlayStation", "TouchPad", "Transformer", { "label": "Wii U", "pattern": "WiiU" }, "Wii", "Xbox One", { "label": "Xbox 360", "pattern": "Xbox" }, "Xoom"]), he = function getManufacturer(u) { return reduce(u, (function (u, d, v) { return u || (d[fe] || d[/^[a-z]+(?: +[a-z]+\b)*/i.exec(fe)] || RegExp("\\b" + qualify(v) + "(?:\\b|\\w*\\d)", "i").exec(c)) && v })) }({ "Apple": { "iPad": 1, "iPhone": 1, "iPod": 1 }, "Alcatel": {}, "Archos": {}, "Amazon": { "Kindle": 1, "Kindle Fire": 1 }, "Asus": { "Transformer": 1 }, "Barnes & Noble": { "Nook": 1 }, "BlackBerry": { "PlayBook": 1 }, "Google": { "Google TV": 1, "Nexus": 1 }, "HP": { "TouchPad": 1 }, "HTC": {}, "Huawei": {}, "Lenovo": {}, "LG": {}, "Microsoft": { "Xbox": 1, "Xbox One": 1 }, "Motorola": { "Xoom": 1 }, "Nintendo": { "Wii U": 1, "Wii": 1 }, "Nokia": { "Lumia": 1 }, "Oppo": {}, "Samsung": { "Galaxy S": 1, "Galaxy S2": 1, "Galaxy S3": 1, "Galaxy S4": 1 }, "Sony": { "PlayStation": 1, "PlayStation Vita": 1 }, "Xiaomi": { "Mi": 1, "Redmi": 1 } }), me = function getOS(u) { return reduce(u, (function (u, d) { var v = d.pattern || qualify(d); return !u && (u = RegExp("\\b" + v + "(?:/[\\d.]+|[ \\w.]*)", "i").exec(c)) && (u = function cleanupOS(c, u, d) { var v = { "10.0": "10", "6.4": "10 Technical Preview", "6.3": "8.1", "6.2": "8", "6.1": "Server 2008 R2 / 7", "6.0": "Server 2008 / Vista", "5.2": "Server 2003 / XP 64-bit", "5.1": "XP", "5.01": "2000 SP1", "5.0": "2000", "4.0": "NT", "4.90": "ME" }; return u && d && /^Win/i.test(c) && !/^Windows Phone /i.test(c) && (v = v[/[\d.]+$/.exec(c)]) && (c = "Windows " + v), c = String(c), u && d && (c = c.replace(RegExp(u, "i"), d)), format(c.replace(/ ce$/i, " CE").replace(/\bhpw/i, "web").replace(/\bMacintosh\b/, "Mac OS").replace(/_PowerPC\b/i, " OS").replace(/\b(OS X) [^ \d]+/i, "$1").replace(/\bMac (OS X)\b/, "$1").replace(/\/(\d)/, " $1").replace(/_/g, ".").replace(/(?: BePC|[ .]*fc[ \d.]+)$/i, "").replace(/\bx86\.64\b/gi, "x86_64").replace(/\b(Windows Phone) OS\b/, "$1").replace(/\b(Chrome OS \w+) [\d.]+\b/, "$1").split(" on ")[0]) }(u, v, d.label || d)), u })) }(["Windows Phone", "KaiOS", "Android", "CentOS", { "label": "Chrome OS", "pattern": "CrOS" }, "Debian", { "label": "DragonFly BSD", "pattern": "DragonFly" }, "Fedora", "FreeBSD", "Gentoo", "Haiku", "Kubuntu", "Linux Mint", "OpenBSD", "Red Hat", "SuSE", "Ubuntu", "Xubuntu", "Cygwin", "Symbian OS", "hpwOS", "webOS ", "webOS", "Tablet OS", "Tizen", "Linux", "Mac OS X", "Macintosh", "Mac", "Windows 98;", "Windows "]); function getProduct(u) { return reduce(u, (function (u, d) { var v = d.pattern || qualify(d); return !u && (u = RegExp("\\b" + v + " *\\d+[.\\w_]*", "i").exec(c) || RegExp("\\b" + v + " *\\w+-[\\w]*", "i").exec(c) || RegExp("\\b" + v + "(?:; *(?:[a-z]+[_-])?[a-z]+\\d+|[^ ();-]*)", "i").exec(c)) && ((u = String(d.label && !RegExp(v, "i").test(d.label) ? d.label : u).split("/"))[1] && !/[\d.]+/.test(u[0]) && (u[0] += " " + u[1]), d = d.label || d, u = format(u[0].replace(RegExp(v, "i"), d).replace(RegExp("; *(?:" + d + "[_-])?", "i"), " ").replace(RegExp("(" + d + ")[-_.]?(\\w)", "i"), "$1 $2"))), u })) } function getVersion(u) { return reduce(u, (function (u, d) { return u || (RegExp(d + "(?:-[\\d.]+/|(?: for [\\w-]+)?[ /-])([\\d.]+[^ ();/_-]*)", "i").exec(c) || 0)[1] || null })) } if (de && (de = [de]), /\bAndroid\b/.test(me) && !fe && (R = /\bAndroid[^;]*;(.*?)(?:Build|\) AppleWebKit)\b/i.exec(c)) && (fe = trim(R[1]).replace(/^[a-z]{2}-[a-z]{2};\s*/i, "") || null), he && !fe ? fe = getProduct([he]) : he && fe && (fe = fe.replace(RegExp("^(" + qualify(he) + ")[-_.\\s]", "i"), he + " ").replace(RegExp("^(" + qualify(he) + ")[-_.]?(\\w)", "i"), he + " $2")), (R = /\bGoogle TV\b/.exec(fe)) && (fe = R[0]), /\bSimulator\b/i.test(c) && (fe = (fe ? fe + " " : "") + "Simulator"), "Opera Mini" == pe && /\bOPiOS\b/.test(c) && se.push("running in Turbo/Uncompressed mode"), "IE" == pe && /\blike iPhone OS\b/.test(c) ? (he = (R = parse(c.replace(/like iPhone OS/, ""))).manufacturer, fe = R.product) : /^iP/.test(fe) ? (pe || (pe = "Safari"), me = "iOS" + ((R = / OS ([\d_]+)/i.exec(c)) ? " " + R[1].replace(/_/g, ".") : "")) : "Konqueror" == pe && /^Linux\b/i.test(me) ? me = "Kubuntu" : he && "Google" != he && (/Chrome/.test(pe) && !/\bMobile Safari\b/i.test(c) || /\bVita\b/.test(fe)) || /\bAndroid\b/.test(me) && /^Chrome/.test(pe) && /\bVersion\//i.test(c) ? (pe = "Android Browser", me = /\bAndroid\b/.test(me) ? me : "Android") : "Silk" == pe ? (/\bMobi/i.test(c) || (me = "Android", se.unshift("desktop mode")), /Accelerated *= *true/i.test(c) && se.unshift("accelerated")) : "UC Browser" == pe && /\bUCWEB\b/.test(c) ? se.push("speed mode") : "PaleMoon" == pe && (R = /\bFirefox\/([\d.]+)\b/.exec(c)) ? se.push("identifying as Firefox " + R[1]) : "Firefox" == pe && (R = /\b(Mobile|Tablet|TV)\b/i.exec(c)) ? (me || (me = "Firefox OS"), fe || (fe = R[1])) : !pe || (R = !/\bMinefield\b/i.test(c) && /\b(?:Firefox|Safari)\b/.exec(pe)) ? (pe && !fe && /[\/,]|^[^(]+?\)/.test(c.slice(c.indexOf(R + "/") + 8)) && (pe = null), (R = fe || he || me) && (fe || he || /\b(?:Android|Symbian OS|Tablet OS|webOS)\b/.test(me)) && (pe = /[a-z]+(?: Hat)?/i.exec(/\bAndroid\b/.test(me) ? me : R) + " Browser")) : "Electron" == pe && (R = (/\bChrome\/([\d.]+)\b/.exec(c) || 0)[1]) && se.push("Chromium " + R), ue || (ue = getVersion(["(?:Cloud9|CriOS|CrMo|Edge|Edg|EdgA|EdgiOS|FxiOS|HeadlessChrome|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|SamsungBrowser|Silk(?!/[\\d.]+$)|UCBrowser|YaBrowser)", "Version", qualify(pe), "(?:Firefox|Minefield|NetFront)"])), (R = ("iCab" == de && parseFloat(ue) > 3 ? "WebKit" : /\bOpera\b/.test(pe) && (/\bOPR\b/.test(c) ? "Blink" : "Presto")) || /\b(?:Midori|Nook|Safari)\b/i.test(c) && !/^(?:Trident|EdgeHTML)$/.test(de) && "WebKit" || !de && /\bMSIE\b/i.test(c) && ("Mac OS" == me ? "Tasman" : "Trident") || "WebKit" == de && /\bPlayStation\b(?! Vita\b)/i.test(pe) && "NetFront") && (de = [R]), "IE" == pe && (R = (/; *(?:XBLWP|ZuneWP)(\d+)/i.exec(c) || 0)[1]) ? (pe += " Mobile", me = "Windows Phone " + (/\+$/.test(R) ? R : R + ".x"), se.unshift("desktop mode")) : /\bWPDesktop\b/i.test(c) ? (pe = "IE Mobile", me = "Windows Phone 8.x", se.unshift("desktop mode"), ue || (ue = (/\brv:([\d.]+)/.exec(c) || 0)[1])) : "IE" != pe && "Trident" == de && (R = /\brv:([\d.]+)/.exec(c)) && (pe && se.push("identifying as " + pe + (ue ? " " + ue : "")), pe = "IE", ue = R[1]), le) { if (function isHostType(c, u) { var d = null != c ? typeof c[u] : "number"; return !(/^(?:boolean|number|string|undefined)$/.test(d) || "object" == d && !c[u]) }(u, "global")) if (Q && (ae = (R = Q.lang.System).getProperty("os.arch"), me = me || R.getProperty("os.name") + " " + R.getProperty("os.version")), ee) { try { ue = u.require("ringo/engine").version.join("."), pe = "RingoJS" } catch (c) { (R = u.system) && R.global.system == u.system && (pe = "Narwhal", me || (me = R[0].os || null)) } pe || (pe = "Rhino") } else "object" == typeof u.process && !u.process.browser && (R = u.process) && ("object" == typeof R.versions && ("string" == typeof R.versions.electron ? (se.push("Node " + R.versions.node), pe = "Electron", ue = R.versions.electron) : "string" == typeof R.versions.nw && (se.push("Chromium " + ue, "Node " + R.versions.node), pe = "NW.js", ue = R.versions.nw)), pe || (pe = "Node.js", ae = R.arch, me = R.platform, ue = (ue = /[\d.]+/.exec(R.version)) ? ue[0] : null)); else getClassOf(R = u.runtime) == Z ? (pe = "Adobe AIR", me = R.flash.system.Capabilities.os) : getClassOf(R = u.phantom) == X ? (pe = "PhantomJS", ue = (R = R.version || null) && R.major + "." + R.minor + "." + R.patch) : "number" == typeof re.documentMode && (R = /\bTrident\/(\d+)/i.exec(c)) ? (ue = [ue, re.documentMode], (R = +R[1] + 4) != ue[1] && (se.push("IE " + ue[1] + " mode"), de && (de[1] = ""), ue[1] = R), ue = "IE" == pe ? String(ue[1].toFixed(1)) : ue[0]) : "number" == typeof re.documentMode && /^(?:Chrome|Firefox)\b/.test(pe) && (se.push("masking as " + pe + " " + ue), pe = "IE", ue = "11.0", de = ["Trident"], me = "Windows"); me = me && format(me) } if (ue && (R = /(?:[ab]|dp|pre|[ab]\d+pre)(?:\d+\+?)?$/i.exec(ue) || /(?:alpha|beta)(?: ?\d)?/i.exec(c + ";" + (le && v.appMinorVersion)) || /\bMinefield\b/i.test(c) && "a") && (ce = /b/i.test(R) ? "beta" : "alpha", ue = ue.replace(RegExp(R + "\\+?$"), "") + ("beta" == ce ? ne : te) + (/\d+\+?/.exec(R) || "")), "Fennec" == pe || "Firefox" == pe && /\b(?:Android|Firefox OS|KaiOS)\b/.test(me)) pe = "Firefox Mobile"; else if ("Maxthon" == pe && ue) ue = ue.replace(/\.[\d.]+/, ".x"); else if (/\bXbox\b/i.test(fe)) "Xbox 360" == fe && (me = null), "Xbox 360" == fe && /\bIEMobile\b/.test(c) && se.unshift("mobile mode"); else if (!/^(?:Chrome|IE|Opera)$/.test(pe) && (!pe || fe || /Browser|Mobi/.test(pe)) || "Windows CE" != me && !/Mobi/i.test(c)) if ("IE" == pe && le) try { null === u.external && se.unshift("platform preview") } catch (c) { se.unshift("embedded") } else (/\bBlackBerry\b/.test(fe) || /\bBB10\b/.test(c)) && (R = (RegExp(fe.replace(/ +/g, " *") + "/([.\\d]+)", "i").exec(c) || 0)[1] || ue) ? (me = ((R = [R, /BB10/.test(c)])[1] ? (fe = null, he = "BlackBerry") : "Device Software") + " " + R[0], ue = null) : this != forOwn && "Wii" != fe && (le && oe || /Opera/.test(pe) && /\b(?:MSIE|Firefox)\b/i.test(c) || "Firefox" == pe && /\bOS X (?:\d+\.){2,}/.test(me) || "IE" == pe && (me && !/^Win/.test(me) && ue > 5.5 || /\bWindows XP\b/.test(me) && ue > 8 || 8 == ue && !/\bTrident\b/.test(c))) && !W.test(R = parse.call(forOwn, c.replace(W, "") + ";")) && R.name && (R = "ing as " + R.name + ((R = R.version) ? " " + R : ""), W.test(pe) ? (/\bIE\b/.test(R) && "Mac OS" == me && (me = null), R = "identify" + R) : (R = "mask" + R, pe = ie ? format(ie.replace(/([a-z])([A-Z])/g, "$1 $2")) : "Opera", /\bIE\b/.test(R) && (me = null), le || (ue = null)), de = ["Presto"], se.push(R)); else pe += " Mobile"; (R = (/\bAppleWebKit\/([\d.]+\+?)/i.exec(c) || 0)[1]) && (R = [parseFloat(R.replace(/\.(\d)$/, ".0$1")), R], "Safari" == pe && "+" == R[1].slice(-1) ? (pe = "WebKit Nightly", ce = "alpha", ue = R[1].slice(0, -1)) : ue != R[1] && ue != (R[2] = (/\bSafari\/([\d.]+\+?)/i.exec(c) || 0)[1]) || (ue = null), R[1] = (/\b(?:Headless)?Chrome\/([\d.]+)/i.exec(c) || 0)[1], 537.36 == R[0] && 537.36 == R[2] && parseFloat(R[1]) >= 28 && "WebKit" == de && (de = ["Blink"]), le && (H || R[1]) ? (de && (de[1] = "like Chrome"), R = R[1] || ((R = R[0]) < 530 ? 1 : R < 532 ? 2 : R < 532.05 ? 3 : R < 533 ? 4 : R < 534.03 ? 5 : R < 534.07 ? 6 : R < 534.1 ? 7 : R < 534.13 ? 8 : R < 534.16 ? 9 : R < 534.24 ? 10 : R < 534.3 ? 11 : R < 535.01 ? 12 : R < 535.02 ? "13+" : R < 535.07 ? 15 : R < 535.11 ? 16 : R < 535.19 ? 17 : R < 536.05 ? 18 : R < 536.1 ? 19 : R < 537.01 ? 20 : R < 537.11 ? "21+" : R < 537.13 ? 23 : R < 537.18 ? 24 : R < 537.24 ? 25 : R < 537.36 ? 26 : "Blink" != de ? "27" : "28")) : (de && (de[1] = "like Safari"), R = (R = R[0]) < 400 ? 1 : R < 500 ? 2 : R < 526 ? 3 : R < 533 ? 4 : R < 534 ? "4+" : R < 535 ? 5 : R < 537 ? 6 : R < 538 ? 7 : R < 601 ? 8 : R < 602 ? 9 : R < 604 ? 10 : R < 606 ? 11 : R < 608 ? 12 : "12"), de && (de[1] += " " + (R += "number" == typeof R ? ".x" : /[.+]/.test(R) ? "" : "+")), "Safari" == pe && (!ue || parseInt(ue) > 45) ? ue = R : "Chrome" == pe && /\bHeadlessChrome/i.test(c) && se.unshift("headless")), "Opera" == pe && (R = /\bzbov|zvav$/.exec(me)) ? (pe += " ", se.unshift("desktop mode"), "zvav" == R ? (pe += "Mini", ue = null) : pe += "Mobile", me = me.replace(RegExp(" *" + R + "$"), "")) : "Safari" == pe && /\bChrome\b/.exec(de && de[1]) ? (se.unshift("desktop mode"), pe = "Chrome Mobile", ue = null, /\bOS X\b/.test(me) ? (he = "Apple", me = "iOS 4.3+") : me = null) : /\bSRWare Iron\b/.test(pe) && !ue && (ue = getVersion("Chrome")), ue && 0 == ue.indexOf(R = /[\d.]+$/.exec(me)) && c.indexOf("/" + R + "-") > -1 && (me = trim(me.replace(R, ""))), me && -1 != me.indexOf(pe) && !RegExp(pe + " OS").test(me) && (me = me.replace(RegExp(" *" + qualify(pe) + " *"), "")), de && !/\b(?:Avant|Nook)\b/.test(pe) && (/Browser|Lunascape|Maxthon/.test(pe) || "Safari" != pe && /^iOS/.test(me) && /\bSafari\b/.test(de[1]) || /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Samsung Internet|Sleipnir|SRWare Iron|Vivaldi|Web)/.test(pe) && de[1]) && (R = de[de.length - 1]) && se.push(R), se.length && (se = ["(" + se.join("; ") + ")"]), he && fe && fe.indexOf(he) < 0 && se.push("on " + he), fe && se.push((/^on /.test(se[se.length - 1]) ? "" : "on ") + fe), me && (R = / ([\d.+]+)$/.exec(me), U = R && "/" == me.charAt(me.length - R[0].length - 1), me = { "architecture": 32, "family": R && !U ? me.replace(R[0], "") : me, "version": R ? R[1] : null, "toString": function () { var c = this.version; return this.family + (c && !U ? " " + c : "") + (64 == this.architecture ? " 64-bit" : "") } }), (R = /\b(?:AMD|IA|Win|WOW|x86_|x)64\b/i.exec(ae)) && !/\bi686\b/i.test(ae) ? (me && (me.architecture = 64, me.family = me.family.replace(RegExp(" *" + R), "")), pe && (/\bWOW64\b/i.test(c) || le && /\w(?:86|32)$/.test(v.cpuClass || v.platform) && !/\bWin64; x64\b/i.test(c)) && se.unshift("32-bit")) : me && /^OS X/.test(me.family) && "Chrome" == pe && parseFloat(ue) >= 39 && (me.architecture = 64), c || (c = null); var ge = {}; return ge.description = c, ge.layout = de && de[0], ge.manufacturer = he, ge.name = pe, ge.prerelease = ce, ge.product = fe, ge.ua = c, ge.version = pe && ue, ge.os = me || { "architecture": null, "family": null, "version": null, "toString": function () { return "null" } }, ge.parse = parse, ge.toString = function toStringPlatform() { return this.description || "" }, ge.version && se.unshift(ue), ge.name && se.unshift(pe), me && pe && (me != String(me).split(" ")[0] || me != pe.split(" ")[0] && !fe) && se.push(fe ? "(" + me + ")" : "on " + me), se.length && (ge.description = se.join(" ")), ge }(); k.platform = K, void 0 === (v = function () { return K }.call(u, d, u, c)) || (c.exports = v) }.call(this) }, "5760": function (c) { "use strict"; function Cache(c) { this._maxSize = c, this.clear() } Cache.prototype.clear = function () { this._size = 0, this._values = Object.create(null) }, Cache.prototype.get = function (c) { return this._values[c] }, Cache.prototype.set = function (c, u) { return this._size >= this._maxSize && this.clear(), c in this._values || this._size++, this._values[c] = u }; var u = /[^.^\]^[]+|(?=\[\]|\.\.)/g, d = /^\d+$/, v = /^\d/, E = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g, k = /^\s*(['"]?)(.*?)(\1)\s*$/, R = new Cache(512), U = new Cache(512), H = new Cache(512); function normalizePath(c) { return R.get(c) || R.set(c, split(c).map((function (c) { return c.replace(k, "$2") }))) } function split(c) { return c.match(u) || [""] } function isQuoted(c) { return "string" == typeof c && c && -1 !== ["'", '"'].indexOf(c.charAt(0)) } function shouldBeQuoted(c) { return !isQuoted(c) && (function hasLeadingNumber(c) { return c.match(v) && !c.match(d) }(c) || function hasSpecialChars(c) { return E.test(c) }(c)) } c.exports = { "Cache": Cache, "split": split, "normalizePath": normalizePath, "setter": function (c) { var u = normalizePath(c); return U.get(c) || U.set(c, (function setter(c, d) { for (var v = 0, E = u.length, k = c; v < E - 1;) { var R = u[v]; if ("__proto__" === R || "constructor" === R || "prototype" === R) return c; k = k[u[v++]] } k[u[v]] = d })) }, "getter": function (c, u) { var d = normalizePath(c); return H.get(c) || H.set(c, (function getter(c) { for (var v = 0, E = d.length; v < E;) { if (null == c && u) return; c = c[d[v++]] } return c })) }, "join": function (c) { return c.reduce((function (c, u) { return c + (isQuoted(u) || d.test(u) ? "[" + u + "]" : (c ? "." : "") + u) }), "") }, "forEach": function (c, u, d) { !function forEach(c, u, d) { var v, E, k, R, U = c.length; for (E = 0; E < U; E++)(v = c[E]) && (shouldBeQuoted(v) && (v = '"' + v + '"'), k = !(R = isQuoted(v)) && /^\d+$/.test(v), u.call(d, v, R, k, E, c)) }(Array.isArray(c) ? c : split(c), u, d) } } }, "7563": function (c, u, d) { "use strict"; const v = d(610), E = d(4020), k = d(500), R = d(2806), U = Symbol("encodeFragmentIdentifier"); function validateArrayFormatSeparator(c) { if ("string" != typeof c || 1 !== c.length) throw new TypeError("arrayFormatSeparator must be single character string") } function encode(c, u) { return u.encode ? u.strict ? v(c) : encodeURIComponent(c) : c } function decode(c, u) { return u.decode ? E(c) : c } function keysSorter(c) { return Array.isArray(c) ? c.sort() : "object" == typeof c ? keysSorter(Object.keys(c)).sort(((c, u) => Number(c) - Number(u))).map((u => c[u])) : c } function removeHash(c) { const u = c.indexOf("#"); return -1 !== u && (c = c.slice(0, u)), c } function extract(c) { const u = (c = removeHash(c)).indexOf("?"); return -1 === u ? "" : c.slice(u + 1) } function parseValue(c, u) { return u.parseNumbers && !Number.isNaN(Number(c)) && "string" == typeof c && "" !== c.trim() ? c = Number(c) : !u.parseBooleans || null === c || "true" !== c.toLowerCase() && "false" !== c.toLowerCase() || (c = "true" === c.toLowerCase()), c } function parse(c, u) { validateArrayFormatSeparator((u = Object.assign({ "decode": !0, "sort": !0, "arrayFormat": "none", "arrayFormatSeparator": ",", "parseNumbers": !1, "parseBooleans": !1 }, u)).arrayFormatSeparator); const d = function parserForArrayFormat(c) { let u; switch (c.arrayFormat) { case "index": return (c, d, v) => { u = /\[(\d*)\]$/.exec(c), c = c.replace(/\[\d*\]$/, ""), u ? (void 0 === v[c] && (v[c] = {}), v[c][u[1]] = d) : v[c] = d }; case "bracket": return (c, d, v) => { u = /(\[\])$/.exec(c), c = c.replace(/\[\]$/, ""), u ? void 0 !== v[c] ? v[c] = [].concat(v[c], d) : v[c] = [d] : v[c] = d }; case "colon-list-separator": return (c, d, v) => { u = /(:list)$/.exec(c), c = c.replace(/:list$/, ""), u ? void 0 !== v[c] ? v[c] = [].concat(v[c], d) : v[c] = [d] : v[c] = d }; case "comma": case "separator": return (u, d, v) => { const E = "string" == typeof d && d.includes(c.arrayFormatSeparator), k = "string" == typeof d && !E && decode(d, c).includes(c.arrayFormatSeparator); d = k ? decode(d, c) : d; const R = E || k ? d.split(c.arrayFormatSeparator).map((u => decode(u, c))) : null === d ? d : decode(d, c); v[u] = R }; case "bracket-separator": return (u, d, v) => { const E = /(\[\])$/.test(u); if (u = u.replace(/\[\]$/, ""), !E) return void (v[u] = d ? decode(d, c) : d); const k = null === d ? [] : d.split(c.arrayFormatSeparator).map((u => decode(u, c))); void 0 !== v[u] ? v[u] = [].concat(v[u], k) : v[u] = k }; default: return (c, u, d) => { void 0 !== d[c] ? d[c] = [].concat(d[c], u) : d[c] = u } } }(u), v = Object.create(null); if ("string" != typeof c) return v; if (!(c = c.trim().replace(/^[?#&]/, ""))) return v; for (const E of c.split("&")) { if ("" === E) continue; let [c, R] = k(u.decode ? E.replace(/\+/g, " ") : E, "="); R = void 0 === R ? null : ["comma", "separator", "bracket-separator"].includes(u.arrayFormat) ? R : decode(R, u), d(decode(c, u), R, v) } for (const c of Object.keys(v)) { const d = v[c]; if ("object" == typeof d && null !== d) for (const c of Object.keys(d)) d[c] = parseValue(d[c], u); else v[c] = parseValue(d, u) } return !1 === u.sort ? v : (!0 === u.sort ? Object.keys(v).sort() : Object.keys(v).sort(u.sort)).reduce(((c, u) => { const d = v[u]; return Boolean(d) && "object" == typeof d && !Array.isArray(d) ? c[u] = keysSorter(d) : c[u] = d, c }), Object.create(null)) } u.extract = extract, u.parse = parse, u.stringify = (c, u) => { if (!c) return ""; validateArrayFormatSeparator((u = Object.assign({ "encode": !0, "strict": !0, "arrayFormat": "none", "arrayFormatSeparator": "," }, u)).arrayFormatSeparator); const shouldFilter = d => u.skipNull && null == c[d] || u.skipEmptyString && "" === c[d], d = function encoderForArrayFormat(c) { switch (c.arrayFormat) { case "index": return u => (d, v) => { const E = d.length; return void 0 === v || c.skipNull && null === v || c.skipEmptyString && "" === v ? d : null === v ? [...d, [encode(u, c), "[", E, "]"].join("")] : [...d, [encode(u, c), "[", encode(E, c), "]=", encode(v, c)].join("")] }; case "bracket": return u => (d, v) => void 0 === v || c.skipNull && null === v || c.skipEmptyString && "" === v ? d : null === v ? [...d, [encode(u, c), "[]"].join("")] : [...d, [encode(u, c), "[]=", encode(v, c)].join("")]; case "colon-list-separator": return u => (d, v) => void 0 === v || c.skipNull && null === v || c.skipEmptyString && "" === v ? d : null === v ? [...d, [encode(u, c), ":list="].join("")] : [...d, [encode(u, c), ":list=", encode(v, c)].join("")]; case "comma": case "separator": case "bracket-separator": { const u = "bracket-separator" === c.arrayFormat ? "[]=" : "="; return d => (v, E) => void 0 === E || c.skipNull && null === E || c.skipEmptyString && "" === E ? v : (E = null === E ? "" : E, 0 === v.length ? [[encode(d, c), u, encode(E, c)].join("")] : [[v, encode(E, c)].join(c.arrayFormatSeparator)]) } default: return u => (d, v) => void 0 === v || c.skipNull && null === v || c.skipEmptyString && "" === v ? d : null === v ? [...d, encode(u, c)] : [...d, [encode(u, c), "=", encode(v, c)].join("")] } }(u), v = {}; for (const u of Object.keys(c)) shouldFilter(u) || (v[u] = c[u]); const E = Object.keys(v); return !1 !== u.sort && E.sort(u.sort), E.map((v => { const E = c[v]; return void 0 === E ? "" : null === E ? encode(v, u) : Array.isArray(E) ? 0 === E.length && "bracket-separator" === u.arrayFormat ? encode(v, u) + "[]" : E.reduce(d(v), []).join("&") : encode(v, u) + "=" + encode(E, u) })).filter((c => c.length > 0)).join("&") }, u.parseUrl = (c, u) => { u = Object.assign({ "decode": !0 }, u); const [d, v] = k(c, "#"); return Object.assign({ "url": d.split("?")[0] || "", "query": parse(extract(c), u) }, u && u.parseFragmentIdentifier && v ? { "fragmentIdentifier": decode(v, u) } : {}) }, u.stringifyUrl = (c, d) => { d = Object.assign({ "encode": !0, "strict": !0, [U]: !0 }, d); const v = removeHash(c.url).split("?")[0] || "", E = u.extract(c.url), k = u.parse(E, { "sort": !1 }), R = Object.assign(k, c.query); let H = u.stringify(R, d); H && (H = `?${H}`); let G = function getHash(c) { let u = ""; const d = c.indexOf("#"); return -1 !== d && (u = c.slice(d)), u }(c.url); return c.fragmentIdentifier && (G = `#${d[U] ? encode(c.fragmentIdentifier, d) : c.fragmentIdentifier}`), `${v}${H}${G}` }, u.pick = (c, d, v) => { v = Object.assign({ "parseFragmentIdentifier": !0, [U]: !1 }, v); const { "url": E, "query": k, "fragmentIdentifier": H } = u.parseUrl(c, v); return u.stringifyUrl({ "url": E, "query": R(k, d), "fragmentIdentifier": H }, v) }, u.exclude = (c, d, v) => { const E = Array.isArray(d) ? c => !d.includes(c) : (c, u) => !d(c, u); return u.pick(c, E, v) } }, "8273": function (c, u) { "use strict"; function isAbsolute(c) { return "/" === c.charAt(0) } function spliceOne(c, u) { for (var d = u, v = d + 1, E = c.length; v < E; d += 1, v += 1)c[d] = c[v]; c.pop() } u.Z = function resolvePathname(c, u) { void 0 === u && (u = ""); var d, v = c && c.split("/") || [], E = u && u.split("/") || [], k = c && isAbsolute(c), R = u && isAbsolute(u), U = k || R; if (c && isAbsolute(c) ? E = v : v.length && (E.pop(), E = E.concat(v)), !E.length) return "/"; if (E.length) { var H = E[E.length - 1]; d = "." === H || ".." === H || "" === H } else d = !1; for (var G = 0, W = E.length; W >= 0; W--) { var Z = E[W]; "." === Z ? spliceOne(E, W) : ".." === Z ? (spliceOne(E, W), G++) : G && (spliceOne(E, W), G--) } if (!U) for (; G--; G)E.unshift(".."); !U || "" === E[0] || E[0] && isAbsolute(E[0]) || E.unshift(""); var Y = E.join("/"); return d && "/" !== Y.substr(-1) && (Y += "/"), Y } }, "500": function (c) { "use strict"; c.exports = (c, u) => { if ("string" != typeof c || "string" != typeof u) throw new TypeError("Expected the arguments to be of type `string`"); if ("" === u) return [c]; const d = c.indexOf(u); return -1 === d ? [c] : [c.slice(0, d), c.slice(d + u.length)] } }, "610": function (c) { "use strict"; c.exports = c => encodeURIComponent(c).replace(/[!'()*]/g, (c => `%${c.charCodeAt(0).toString(16).toUpperCase()}`)) }, "9421": function (c, u, d) { "use strict"; function isObject(c) { return null !== c && "object" == typeof c && "constructor" in c && c.constructor === Object } function extend(c, u) { void 0 === c && (c = {}), void 0 === u && (u = {}), Object.keys(u).forEach((function (d) { void 0 === c[d] ? c[d] = u[d] : isObject(u[d]) && isObject(c[d]) && Object.keys(u[d]).length > 0 && extend(c[d], u[d]) })) } d.d(u, { "Z": function () { return pe } }); var v = { "body": {}, "addEventListener": function () { }, "removeEventListener": function () { }, "activeElement": { "blur": function () { }, "nodeName": "" }, "querySelector": function () { return null }, "querySelectorAll": function () { return [] }, "getElementById": function () { return null }, "createEvent": function () { return { "initEvent": function () { } } }, "createElement": function () { return { "children": [], "childNodes": [], "style": {}, "setAttribute": function () { }, "getElementsByTagName": function () { return [] } } }, "createElementNS": function () { return {} }, "importNode": function () { return null }, "location": { "hash": "", "host": "", "hostname": "", "href": "", "origin": "", "pathname": "", "protocol": "", "search": "" } }; function getDocument() { var c = "undefined" != typeof document ? document : {}; return extend(c, v), c } var E = { "document": v, "navigator": { "userAgent": "" }, "location": { "hash": "", "host": "", "hostname": "", "href": "", "origin": "", "pathname": "", "protocol": "", "search": "" }, "history": { "replaceState": function () { }, "pushState": function () { }, "go": function () { }, "back": function () { } }, "CustomEvent": function CustomEvent() { return this }, "addEventListener": function () { }, "removeEventListener": function () { }, "getComputedStyle": function () { return { "getPropertyValue": function () { return "" } } }, "Image": function () { }, "Date": function () { }, "screen": {}, "setTimeout": function () { }, "clearTimeout": function () { }, "matchMedia": function () { return {} }, "requestAnimationFrame": function (c) { return "undefined" == typeof setTimeout ? (c(), null) : setTimeout(c, 0) }, "cancelAnimationFrame": function (c) { "undefined" != typeof setTimeout && clearTimeout(c) } }; function ssr_window_esm_getWindow() { var c = "undefined" != typeof window ? window : {}; return extend(c, E), c } function _getPrototypeOf(c) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(c) { return c.__proto__ || Object.getPrototypeOf(c) }, _getPrototypeOf(c) } function _setPrototypeOf(c, u) { return _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(c, u) { return c.__proto__ = u, c }, _setPrototypeOf(c, u) } function _construct(c, u, d) { return _construct = function _isNativeReflectConstruct() { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], (function () { }))), !0 } catch (c) { return !1 } }() ? Reflect.construct : function _construct(c, u, d) { var v = [null]; v.push.apply(v, u); var E = new (Function.bind.apply(c, v)); return d && _setPrototypeOf(E, d.prototype), E }, _construct.apply(null, arguments) } function _wrapNativeSuper(c) { var u = "function" == typeof Map ? new Map : void 0; return _wrapNativeSuper = function _wrapNativeSuper(c) { if (null === c || !function _isNativeFunction(c) { return -1 !== Function.toString.call(c).indexOf("[native code]") }(c)) return c; if ("function" != typeof c) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== u) { if (u.has(c)) return u.get(c); u.set(c, Wrapper) } function Wrapper() { return _construct(c, arguments, _getPrototypeOf(this).constructor) } return Wrapper.prototype = Object.create(c.prototype, { "constructor": { "value": Wrapper, "enumerable": !1, "writable": !0, "configurable": !0 } }), _setPrototypeOf(Wrapper, c) }, _wrapNativeSuper(c) } var k = function (c) { function Dom7(u) { var d; return function makeReactive(c) { var u = c.__proto__; Object.defineProperty(c, "__proto__", { "get": function get() { return u }, "set": function set(c) { u.__proto__ = c } }) }(function _assertThisInitialized(c) { if (void 0 === c) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return c }(d = c.call.apply(c, [this].concat(u)) || this)), d } return function _inheritsLoose(c, u) { c.prototype = Object.create(u.prototype), c.prototype.constructor = c, c.__proto__ = u }(Dom7, c), Dom7 }(_wrapNativeSuper(Array)); function arrayFlat(c) { void 0 === c && (c = []); var u = []; return c.forEach((function (c) { Array.isArray(c) ? u.push.apply(u, arrayFlat(c)) : u.push(c) })), u } function arrayFilter(c, u) { return Array.prototype.filter.call(c, u) } function $(c, u) { var d = ssr_window_esm_getWindow(), v = getDocument(), E = []; if (!u && c instanceof k) return c; if (!c) return new k(E); if ("string" == typeof c) { var R = c.trim(); if (R.indexOf("<") >= 0 && R.indexOf(">") >= 0) { var U = "div"; 0 === R.indexOf("<li") && (U = "ul"), 0 === R.indexOf("<tr") && (U = "tbody"), 0 !== R.indexOf("<td") && 0 !== R.indexOf("<th") || (U = "tr"), 0 === R.indexOf("<tbody") && (U = "table"), 0 === R.indexOf("<option") && (U = "select"); var H = v.createElement(U); H.innerHTML = R; for (var G = 0; G < H.childNodes.length; G += 1)E.push(H.childNodes[G]) } else E = function qsa(c, u) { if ("string" != typeof c) return [c]; for (var d = [], v = u.querySelectorAll(c), E = 0; E < v.length; E += 1)d.push(v[E]); return d }(c.trim(), u || v) } else if (c.nodeType || c === d || c === v) E.push(c); else if (Array.isArray(c)) { if (c instanceof k) return c; E = c } return new k(function arrayUnique(c) { for (var u = [], d = 0; d < c.length; d += 1)-1 === u.indexOf(c[d]) && u.push(c[d]); return u }(E)) } $.fn = k.prototype; var R = "resize scroll".split(" "); function shortcut(c) { return function eventHandler() { for (var u = arguments.length, d = new Array(u), v = 0; v < u; v++)d[v] = arguments[v]; if (void 0 === d[0]) { for (var E = 0; E < this.length; E += 1)R.indexOf(c) < 0 && (c in this[E] ? this[E][c]() : $(this[E]).trigger(c)); return this } return this.on.apply(this, [c].concat(d)) } } shortcut("click"), shortcut("blur"), shortcut("focus"), shortcut("focusin"), shortcut("focusout"), shortcut("keyup"), shortcut("keydown"), shortcut("keypress"), shortcut("submit"), shortcut("change"), shortcut("mousedown"), shortcut("mousemove"), shortcut("mouseup"), shortcut("mouseenter"), shortcut("mouseleave"), shortcut("mouseout"), shortcut("mouseover"), shortcut("touchstart"), shortcut("touchend"), shortcut("touchmove"), shortcut("resize"), shortcut("scroll"); var U = { "addClass": function addClass() { for (var c = arguments.length, u = new Array(c), d = 0; d < c; d++)u[d] = arguments[d]; var v = arrayFlat(u.map((function (c) { return c.split(" ") }))); return this.forEach((function (c) { var u; (u = c.classList).add.apply(u, v) })), this }, "removeClass": function removeClass() { for (var c = arguments.length, u = new Array(c), d = 0; d < c; d++)u[d] = arguments[d]; var v = arrayFlat(u.map((function (c) { return c.split(" ") }))); return this.forEach((function (c) { var u; (u = c.classList).remove.apply(u, v) })), this }, "hasClass": function hasClass() { for (var c = arguments.length, u = new Array(c), d = 0; d < c; d++)u[d] = arguments[d]; var v = arrayFlat(u.map((function (c) { return c.split(" ") }))); return arrayFilter(this, (function (c) { return v.filter((function (u) { return c.classList.contains(u) })).length > 0 })).length > 0 }, "toggleClass": function toggleClass() { for (var c = arguments.length, u = new Array(c), d = 0; d < c; d++)u[d] = arguments[d]; var v = arrayFlat(u.map((function (c) { return c.split(" ") }))); this.forEach((function (c) { v.forEach((function (u) { c.classList.toggle(u) })) })) }, "attr": function attr(c, u) { if (1 === arguments.length && "string" == typeof c) return this[0] ? this[0].getAttribute(c) : void 0; for (var d = 0; d < this.length; d += 1)if (2 === arguments.length) this[d].setAttribute(c, u); else for (var v in c) this[d][v] = c[v], this[d].setAttribute(v, c[v]); return this }, "removeAttr": function removeAttr(c) { for (var u = 0; u < this.length; u += 1)this[u].removeAttribute(c); return this }, "transform": function transform(c) { for (var u = 0; u < this.length; u += 1)this[u].style.transform = c; return this }, "transition": function transition(c) { for (var u = 0; u < this.length; u += 1)this[u].style.transitionDuration = "string" != typeof c ? c + "ms" : c; return this }, "on": function on() { for (var c = arguments.length, u = new Array(c), d = 0; d < c; d++)u[d] = arguments[d]; var v = u[0], E = u[1], k = u[2], R = u[3]; function handleLiveEvent(c) { var u = c.target; if (u) { var d = c.target.dom7EventData || []; if (d.indexOf(c) < 0 && d.unshift(c), $(u).is(E)) k.apply(u, d); else for (var v = $(u).parents(), R = 0; R < v.length; R += 1)$(v[R]).is(E) && k.apply(v[R], d) } } function handleEvent(c) { var u = c && c.target && c.target.dom7EventData || []; u.indexOf(c) < 0 && u.unshift(c), k.apply(this, u) } "function" == typeof u[1] && (v = u[0], k = u[1], R = u[2], E = void 0), R || (R = !1); for (var U, H = v.split(" "), G = 0; G < this.length; G += 1) { var W = this[G]; if (E) for (U = 0; U < H.length; U += 1) { var Z = H[U]; W.dom7LiveListeners || (W.dom7LiveListeners = {}), W.dom7LiveListeners[Z] || (W.dom7LiveListeners[Z] = []), W.dom7LiveListeners[Z].push({ "listener": k, "proxyListener": handleLiveEvent }), W.addEventListener(Z, handleLiveEvent, R) } else for (U = 0; U < H.length; U += 1) { var Y = H[U]; W.dom7Listeners || (W.dom7Listeners = {}), W.dom7Listeners[Y] || (W.dom7Listeners[Y] = []), W.dom7Listeners[Y].push({ "listener": k, "proxyListener": handleEvent }), W.addEventListener(Y, handleEvent, R) } } return this }, "off": function off() { for (var c = arguments.length, u = new Array(c), d = 0; d < c; d++)u[d] = arguments[d]; var v = u[0], E = u[1], k = u[2], R = u[3]; "function" == typeof u[1] && (v = u[0], k = u[1], R = u[2], E = void 0), R || (R = !1); for (var U = v.split(" "), H = 0; H < U.length; H += 1)for (var G = U[H], W = 0; W < this.length; W += 1) { var Z = this[W], Y = void 0; if (!E && Z.dom7Listeners ? Y = Z.dom7Listeners[G] : E && Z.dom7LiveListeners && (Y = Z.dom7LiveListeners[G]), Y && Y.length) for (var J = Y.length - 1; J >= 0; J -= 1) { var K = Y[J]; k && K.listener === k || k && K.listener && K.listener.dom7proxy && K.listener.dom7proxy === k ? (Z.removeEventListener(G, K.proxyListener, R), Y.splice(J, 1)) : k || (Z.removeEventListener(G, K.proxyListener, R), Y.splice(J, 1)) } } return this }, "trigger": function trigger() { for (var c = ssr_window_esm_getWindow(), u = arguments.length, d = new Array(u), v = 0; v < u; v++)d[v] = arguments[v]; for (var E = d[0].split(" "), k = d[1], R = 0; R < E.length; R += 1)for (var U = E[R], H = 0; H < this.length; H += 1) { var G = this[H]; if (c.CustomEvent) { var W = new c.CustomEvent(U, { "detail": k, "bubbles": !0, "cancelable": !0 }); G.dom7EventData = d.filter((function (c, u) { return u > 0 })), G.dispatchEvent(W), G.dom7EventData = [], delete G.dom7EventData } } return this }, "transitionEnd": function transitionEnd(c) { var u = this; return c && u.on("transitionend", (function fireCallBack(d) { d.target === this && (c.call(this, d), u.off("transitionend", fireCallBack)) })), this }, "outerWidth": function dom7_esm_outerWidth(c) { if (this.length > 0) { if (c) { var u = this.styles(); return this[0].offsetWidth + parseFloat(u.getPropertyValue("margin-right")) + parseFloat(u.getPropertyValue("margin-left")) } return this[0].offsetWidth } return null }, "outerHeight": function dom7_esm_outerHeight(c) { if (this.length > 0) { if (c) { var u = this.styles(); return this[0].offsetHeight + parseFloat(u.getPropertyValue("margin-top")) + parseFloat(u.getPropertyValue("margin-bottom")) } return this[0].offsetHeight } return null }, "styles": function styles() { var c = ssr_window_esm_getWindow(); return this[0] ? c.getComputedStyle(this[0], null) : {} }, "offset": function offset() { if (this.length > 0) { var c = ssr_window_esm_getWindow(), u = getDocument(), d = this[0], v = d.getBoundingClientRect(), E = u.body, k = d.clientTop || E.clientTop || 0, R = d.clientLeft || E.clientLeft || 0, U = d === c ? c.scrollY : d.scrollTop, H = d === c ? c.scrollX : d.scrollLeft; return { "top": v.top + U - k, "left": v.left + H - R } } return null }, "css": function css(c, u) { var d, v = ssr_window_esm_getWindow(); if (1 === arguments.length) { if ("string" != typeof c) { for (d = 0; d < this.length; d += 1)for (var E in c) this[d].style[E] = c[E]; return this } if (this[0]) return v.getComputedStyle(this[0], null).getPropertyValue(c) } if (2 === arguments.length && "string" == typeof c) { for (d = 0; d < this.length; d += 1)this[d].style[c] = u; return this } return this }, "each": function each(c) { return c ? (this.forEach((function (u, d) { c.apply(u, [u, d]) })), this) : this }, "html": function html(c) { if (void 0 === c) return this[0] ? this[0].innerHTML : null; for (var u = 0; u < this.length; u += 1)this[u].innerHTML = c; return this }, "text": function dom7_esm_text(c) { if (void 0 === c) return this[0] ? this[0].textContent.trim() : null; for (var u = 0; u < this.length; u += 1)this[u].textContent = c; return this }, "is": function is(c) { var u, d, v = ssr_window_esm_getWindow(), E = getDocument(), R = this[0]; if (!R || void 0 === c) return !1; if ("string" == typeof c) { if (R.matches) return R.matches(c); if (R.webkitMatchesSelector) return R.webkitMatchesSelector(c); if (R.msMatchesSelector) return R.msMatchesSelector(c); for (u = $(c), d = 0; d < u.length; d += 1)if (u[d] === R) return !0; return !1 } if (c === E) return R === E; if (c === v) return R === v; if (c.nodeType || c instanceof k) { for (u = c.nodeType ? [c] : c, d = 0; d < u.length; d += 1)if (u[d] === R) return !0; return !1 } return !1 }, "index": function index() { var c, u = this[0]; if (u) { for (c = 0; null !== (u = u.previousSibling);)1 === u.nodeType && (c += 1); return c } }, "eq": function eq(c) { if (void 0 === c) return this; var u = this.length; if (c > u - 1) return $([]); if (c < 0) { var d = u + c; return $(d < 0 ? [] : [this[d]]) } return $([this[c]]) }, "append": function append() { for (var c, u = getDocument(), d = 0; d < arguments.length; d += 1) { c = d < 0 || arguments.length <= d ? void 0 : arguments[d]; for (var v = 0; v < this.length; v += 1)if ("string" == typeof c) { var E = u.createElement("div"); for (E.innerHTML = c; E.firstChild;)this[v].appendChild(E.firstChild) } else if (c instanceof k) for (var R = 0; R < c.length; R += 1)this[v].appendChild(c[R]); else this[v].appendChild(c) } return this }, "prepend": function prepend(c) { var u, d, v = getDocument(); for (u = 0; u < this.length; u += 1)if ("string" == typeof c) { var E = v.createElement("div"); for (E.innerHTML = c, d = E.childNodes.length - 1; d >= 0; d -= 1)this[u].insertBefore(E.childNodes[d], this[u].childNodes[0]) } else if (c instanceof k) for (d = 0; d < c.length; d += 1)this[u].insertBefore(c[d], this[u].childNodes[0]); else this[u].insertBefore(c, this[u].childNodes[0]); return this }, "next": function next(c) { return this.length > 0 ? c ? this[0].nextElementSibling && $(this[0].nextElementSibling).is(c) ? $([this[0].nextElementSibling]) : $([]) : this[0].nextElementSibling ? $([this[0].nextElementSibling]) : $([]) : $([]) }, "nextAll": function nextAll(c) { var u = [], d = this[0]; if (!d) return $([]); for (; d.nextElementSibling;) { var v = d.nextElementSibling; c ? $(v).is(c) && u.push(v) : u.push(v), d = v } return $(u) }, "prev": function prev(c) { if (this.length > 0) { var u = this[0]; return c ? u.previousElementSibling && $(u.previousElementSibling).is(c) ? $([u.previousElementSibling]) : $([]) : u.previousElementSibling ? $([u.previousElementSibling]) : $([]) } return $([]) }, "prevAll": function prevAll(c) { var u = [], d = this[0]; if (!d) return $([]); for (; d.previousElementSibling;) { var v = d.previousElementSibling; c ? $(v).is(c) && u.push(v) : u.push(v), d = v } return $(u) }, "parent": function dom7_esm_parent(c) { for (var u = [], d = 0; d < this.length; d += 1)null !== this[d].parentNode && (c ? $(this[d].parentNode).is(c) && u.push(this[d].parentNode) : u.push(this[d].parentNode)); return $(u) }, "parents": function parents(c) { for (var u = [], d = 0; d < this.length; d += 1)for (var v = this[d].parentNode; v;)c ? $(v).is(c) && u.push(v) : u.push(v), v = v.parentNode; return $(u) }, "closest": function closest(c) { var u = this; return void 0 === c ? $([]) : (u.is(c) || (u = u.parents(c).eq(0)), u) }, "find": function find(c) { for (var u = [], d = 0; d < this.length; d += 1)for (var v = this[d].querySelectorAll(c), E = 0; E < v.length; E += 1)u.push(v[E]); return $(u) }, "children": function children(c) { for (var u = [], d = 0; d < this.length; d += 1)for (var v = this[d].children, E = 0; E < v.length; E += 1)c && !$(v[E]).is(c) || u.push(v[E]); return $(u) }, "filter": function filter(c) { return $(arrayFilter(this, c)) }, "remove": function remove() { for (var c = 0; c < this.length; c += 1)this[c].parentNode && this[c].parentNode.removeChild(this[c]); return this } }; Object.keys(U).forEach((function (c) { Object.defineProperty($.fn, c, { "value": U[c], "writable": !0 }) })); var H, G, W, Z = $; function nextTick(c, u) { return void 0 === u && (u = 0), setTimeout(c, u) } function now() { return Date.now() } function getTranslate(c, u) { void 0 === u && (u = "x"); var d, v, E, k = ssr_window_esm_getWindow(), R = function utils_getComputedStyle(c) { var u, d = ssr_window_esm_getWindow(); return d.getComputedStyle && (u = d.getComputedStyle(c, null)), !u && c.currentStyle && (u = c.currentStyle), u || (u = c.style), u }(c); return k.WebKitCSSMatrix ? ((v = R.transform || R.webkitTransform).split(",").length > 6 && (v = v.split(", ").map((function (c) { return c.replace(",", ".") })).join(", ")), E = new k.WebKitCSSMatrix("none" === v ? "" : v)) : d = (E = R.MozTransform || R.OTransform || R.MsTransform || R.msTransform || R.transform || R.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,")).toString().split(","), "x" === u && (v = k.WebKitCSSMatrix ? E.m41 : 16 === d.length ? parseFloat(d[12]) : parseFloat(d[4])), "y" === u && (v = k.WebKitCSSMatrix ? E.m42 : 16 === d.length ? parseFloat(d[13]) : parseFloat(d[5])), v || 0 } function utils_isObject(c) { return "object" == typeof c && null !== c && c.constructor && "Object" === Object.prototype.toString.call(c).slice(8, -1) } function utils_extend() { for (var c, u = Object(arguments.length <= 0 ? void 0 : arguments[0]), d = ["__proto__", "constructor", "prototype"], v = 1; v < arguments.length; v += 1) { var E = v < 0 || arguments.length <= v ? void 0 : arguments[v]; if (null != E && (c = E, !("undefined" != typeof window ? c instanceof HTMLElement : c && (1 === c.nodeType || 11 === c.nodeType)))) for (var k = Object.keys(Object(E)).filter((function (c) { return d.indexOf(c) < 0 })), R = 0, U = k.length; R < U; R += 1) { var H = k[R], G = Object.getOwnPropertyDescriptor(E, H); void 0 !== G && G.enumerable && (utils_isObject(u[H]) && utils_isObject(E[H]) ? E[H].__swiper__ ? u[H] = E[H] : utils_extend(u[H], E[H]) : !utils_isObject(u[H]) && utils_isObject(E[H]) ? (u[H] = {}, E[H].__swiper__ ? u[H] = E[H] : utils_extend(u[H], E[H])) : u[H] = E[H]) } } return u } function bindModuleMethods(c, u) { Object.keys(u).forEach((function (d) { utils_isObject(u[d]) && Object.keys(u[d]).forEach((function (v) { "function" == typeof u[d][v] && (u[d][v] = u[d][v].bind(c)) })), c[d] = u[d] })) } function classesToSelector(c) { return void 0 === c && (c = ""), "." + c.trim().replace(/([\.:\/])/g, "\\$1").replace(/ /g, ".") } function createElementIfNotDefined(c, u, d, v) { var E = getDocument(); return d && Object.keys(v).forEach((function (d) { if (!u[d] && !0 === u.auto) { var k = E.createElement("div"); k.className = v[d], c.append(k), u[d] = k } })), u } function getSupport() { return H || (H = function calcSupport() { var c = ssr_window_esm_getWindow(), u = getDocument(); return { "touch": !!("ontouchstart" in c || c.DocumentTouch && u instanceof c.DocumentTouch), "pointerEvents": !!c.PointerEvent && "maxTouchPoints" in c.navigator && c.navigator.maxTouchPoints >= 0, "observer": function checkObserver() { return "MutationObserver" in c || "WebkitMutationObserver" in c }(), "passiveListener": function checkPassiveListener() { var u = !1; try { var d = Object.defineProperty({}, "passive", { "get": function get() { u = !0 } }); c.addEventListener("testPassiveListener", null, d) } catch (c) { } return u }(), "gestures": function checkGestures() { return "ongesturestart" in c }() } }()), H } function getDevice(c) { return void 0 === c && (c = {}), G || (G = function calcDevice(c) { var u = (void 0 === c ? {} : c).userAgent, d = getSupport(), v = ssr_window_esm_getWindow(), E = v.navigator.platform, k = u || v.navigator.userAgent, R = { "ios": !1, "android": !1 }, U = v.screen.width, H = v.screen.height, G = k.match(/(Android);?[\s\/]+([\d.]+)?/), W = k.match(/(iPad).*OS\s([\d_]+)/), Z = k.match(/(iPod)(.*OS\s([\d_]+))?/), Y = !W && k.match(/(iPhone\sOS|iOS)\s([\d_]+)/), J = "Win32" === E, K = "MacIntel" === E; return !W && K && d.touch && ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf(U + "x" + H) >= 0 && ((W = k.match(/(Version)\/([\d.]+)/)) || (W = [0, 1, "13_0_0"]), K = !1), G && !J && (R.os = "android", R.android = !0), (W || Y || Z) && (R.os = "ios", R.ios = !0), R }(c)), G } function getBrowser() { return W || (W = function calcBrowser() { var c = ssr_window_esm_getWindow(); return { "isEdge": !!c.navigator.userAgent.match(/Edge/g), "isSafari": function isSafari() { var u = c.navigator.userAgent.toLowerCase(); return u.indexOf("safari") >= 0 && u.indexOf("chrome") < 0 && u.indexOf("android") < 0 }(), "isWebView": /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(c.navigator.userAgent) } }()), W } var Y = { "name": "resize", "create": function create() { var c = this; utils_extend(c, { "resize": { "observer": null, "createObserver": function createObserver() { c && !c.destroyed && c.initialized && (c.resize.observer = new ResizeObserver((function (u) { var d = c.width, v = c.height, E = d, k = v; u.forEach((function (u) { var d = u.contentBoxSize, v = u.contentRect, R = u.target; R && R !== c.el || (E = v ? v.width : (d[0] || d).inlineSize, k = v ? v.height : (d[0] || d).blockSize) })), E === d && k === v || c.resize.resizeHandler() })), c.resize.observer.observe(c.el)) }, "removeObserver": function removeObserver() { c.resize.observer && c.resize.observer.unobserve && c.el && (c.resize.observer.unobserve(c.el), c.resize.observer = null) }, "resizeHandler": function resizeHandler() { c && !c.destroyed && c.initialized && (c.emit("beforeResize"), c.emit("resize")) }, "orientationChangeHandler": function orientationChangeHandler() { c && !c.destroyed && c.initialized && c.emit("orientationchange") } } }) }, "on": { "init": function init(c) { var u = ssr_window_esm_getWindow(); c.params.resizeObserver && function supportsResizeObserver() { return void 0 !== ssr_window_esm_getWindow().ResizeObserver }() ? c.resize.createObserver() : (u.addEventListener("resize", c.resize.resizeHandler), u.addEventListener("orientationchange", c.resize.orientationChangeHandler)) }, "destroy": function destroy(c) { var u = ssr_window_esm_getWindow(); c.resize.removeObserver(), u.removeEventListener("resize", c.resize.resizeHandler), u.removeEventListener("orientationchange", c.resize.orientationChangeHandler) } } }; function _extends() { return _extends = Object.assign || function (c) { for (var u = 1; u < arguments.length; u++) { var d = arguments[u]; for (var v in d) Object.prototype.hasOwnProperty.call(d, v) && (c[v] = d[v]) } return c }, _extends.apply(this, arguments) } var J = { "attach": function attach(c, u) { void 0 === u && (u = {}); var d = ssr_window_esm_getWindow(), v = this, E = new (d.MutationObserver || d.WebkitMutationObserver)((function (c) { if (1 !== c.length) { var u = function observerUpdate() { v.emit("observerUpdate", c[0]) }; d.requestAnimationFrame ? d.requestAnimationFrame(u) : d.setTimeout(u, 0) } else v.emit("observerUpdate", c[0]) })); E.observe(c, { "attributes": void 0 === u.attributes || u.attributes, "childList": void 0 === u.childList || u.childList, "characterData": void 0 === u.characterData || u.characterData }), v.observer.observers.push(E) }, "init": function init() { var c = this; if (c.support.observer && c.params.observer) { if (c.params.observeParents) for (var u = c.$el.parents(), d = 0; d < u.length; d += 1)c.observer.attach(u[d]); c.observer.attach(c.$el[0], { "childList": c.params.observeSlideChildren }), c.observer.attach(c.$wrapperEl[0], { "attributes": !1 }) } }, "destroy": function destroy() { this.observer.observers.forEach((function (c) { c.disconnect() })), this.observer.observers = [] } }, K = { "name": "observer", "params": { "observer": !1, "observeParents": !1, "observeSlideChildren": !1 }, "create": function create() { bindModuleMethods(this, { "observer": _extends({}, J, { "observers": [] }) }) }, "on": { "init": function init(c) { c.observer.init() }, "destroy": function destroy(c) { c.observer.destroy() } } }, X = { "on": function on(c, u, d) { var v = this; if ("function" != typeof u) return v; var E = d ? "unshift" : "push"; return c.split(" ").forEach((function (c) { v.eventsListeners[c] || (v.eventsListeners[c] = []), v.eventsListeners[c][E](u) })), v }, "once": function once(c, u, d) { var v = this; if ("function" != typeof u) return v; function onceHandler() { v.off(c, onceHandler), onceHandler.__emitterProxy && delete onceHandler.__emitterProxy; for (var d = arguments.length, E = new Array(d), k = 0; k < d; k++)E[k] = arguments[k]; u.apply(v, E) } return onceHandler.__emitterProxy = u, v.on(c, onceHandler, d) }, "onAny": function onAny(c, u) { var d = this; if ("function" != typeof c) return d; var v = u ? "unshift" : "push"; return d.eventsAnyListeners.indexOf(c) < 0 && d.eventsAnyListeners[v](c), d }, "offAny": function offAny(c) { var u = this; if (!u.eventsAnyListeners) return u; var d = u.eventsAnyListeners.indexOf(c); return d >= 0 && u.eventsAnyListeners.splice(d, 1), u }, "off": function off(c, u) { var d = this; return d.eventsListeners ? (c.split(" ").forEach((function (c) { void 0 === u ? d.eventsListeners[c] = [] : d.eventsListeners[c] && d.eventsListeners[c].forEach((function (v, E) { (v === u || v.__emitterProxy && v.__emitterProxy === u) && d.eventsListeners[c].splice(E, 1) })) })), d) : d }, "emit": function emit() { var c, u, d, v = this; if (!v.eventsListeners) return v; for (var E = arguments.length, k = new Array(E), R = 0; R < E; R++)k[R] = arguments[R]; return "string" == typeof k[0] || Array.isArray(k[0]) ? (c = k[0], u = k.slice(1, k.length), d = v) : (c = k[0].events, u = k[0].data, d = k[0].context || v), u.unshift(d), (Array.isArray(c) ? c : c.split(" ")).forEach((function (c) { v.eventsAnyListeners && v.eventsAnyListeners.length && v.eventsAnyListeners.forEach((function (v) { v.apply(d, [c].concat(u)) })), v.eventsListeners && v.eventsListeners[c] && v.eventsListeners[c].forEach((function (c) { c.apply(d, u) })) })), v } }; var Q = { "updateSize": function updateSize() { var c, u, d = this, v = d.$el; c = void 0 !== d.params.width && null !== d.params.width ? d.params.width : v[0].clientWidth, u = void 0 !== d.params.height && null !== d.params.height ? d.params.height : v[0].clientHeight, 0 === c && d.isHorizontal() || 0 === u && d.isVertical() || (c = c - parseInt(v.css("padding-left") || 0, 10) - parseInt(v.css("padding-right") || 0, 10), u = u - parseInt(v.css("padding-top") || 0, 10) - parseInt(v.css("padding-bottom") || 0, 10), Number.isNaN(c) && (c = 0), Number.isNaN(u) && (u = 0), utils_extend(d, { "width": c, "height": u, "size": d.isHorizontal() ? c : u })) }, "updateSlides": function updateSlides() { var c = this; function getDirectionLabel(u) { return c.isHorizontal() ? u : { "width": "height", "margin-top": "margin-left", "margin-bottom ": "margin-right", "margin-left": "margin-top", "margin-right": "margin-bottom", "padding-left": "padding-top", "padding-right": "padding-bottom", "marginRight": "marginBottom" }[u] } function getDirectionPropertyValue(c, u) { return parseFloat(c.getPropertyValue(getDirectionLabel(u)) || 0) } var u = c.params, d = c.$wrapperEl, v = c.size, E = c.rtlTranslate, k = c.wrongRTL, R = c.virtual && u.virtual.enabled, U = R ? c.virtual.slides.length : c.slides.length, H = d.children("." + c.params.slideClass), G = R ? c.virtual.slides.length : H.length, W = [], Z = [], Y = [], J = u.slidesOffsetBefore; "function" == typeof J && (J = u.slidesOffsetBefore.call(c)); var K = u.slidesOffsetAfter; "function" == typeof K && (K = u.slidesOffsetAfter.call(c)); var X = c.snapGrid.length, Q = c.slidesGrid.length, ee = u.spaceBetween, te = -J, ne = 0, re = 0; if (void 0 !== v) { var oe, ie; "string" == typeof ee && ee.indexOf("%") >= 0 && (ee = parseFloat(ee.replace("%", "")) / 100 * v), c.virtualSize = -ee, E ? H.css({ "marginLeft": "", "marginTop": "" }) : H.css({ "marginRight": "", "marginBottom": "" }), u.slidesPerColumn > 1 && (oe = Math.floor(G / u.slidesPerColumn) === G / c.params.slidesPerColumn ? G : Math.ceil(G / u.slidesPerColumn) * u.slidesPerColumn, "auto" !== u.slidesPerView && "row" === u.slidesPerColumnFill && (oe = Math.max(oe, u.slidesPerView * u.slidesPerColumn))); for (var ae, se, ce, le = u.slidesPerColumn, ue = oe / le, de = Math.floor(G / u.slidesPerColumn), pe = 0; pe < G; pe += 1) { ie = 0; var fe = H.eq(pe); if (u.slidesPerColumn > 1) { var he = void 0, me = void 0, ge = void 0; if ("row" === u.slidesPerColumnFill && u.slidesPerGroup > 1) { var _e = Math.floor(pe / (u.slidesPerGroup * u.slidesPerColumn)), ve = pe - u.slidesPerColumn * u.slidesPerGroup * _e, ye = 0 === _e ? u.slidesPerGroup : Math.min(Math.ceil((G - _e * le * u.slidesPerGroup) / le), u.slidesPerGroup); he = (me = ve - (ge = Math.floor(ve / ye)) * ye + _e * u.slidesPerGroup) + ge * oe / le, fe.css({ "-webkit-box-ordinal-group": he, "-moz-box-ordinal-group": he, "-ms-flex-order": he, "-webkit-order": he, "order": he }) } else "column" === u.slidesPerColumnFill ? (ge = pe - (me = Math.floor(pe / le)) * le, (me > de || me === de && ge === le - 1) && (ge += 1) >= le && (ge = 0, me += 1)) : me = pe - (ge = Math.floor(pe / ue)) * ue; fe.css(getDirectionLabel("margin-top"), 0 !== ge ? u.spaceBetween && u.spaceBetween + "px" : "") } if ("none" !== fe.css("display")) { if ("auto" === u.slidesPerView) { var be = getComputedStyle(fe[0]), Se = fe[0].style.transform, we = fe[0].style.webkitTransform; if (Se && (fe[0].style.transform = "none"), we && (fe[0].style.webkitTransform = "none"), u.roundLengths) ie = c.isHorizontal() ? fe.outerWidth(!0) : fe.outerHeight(!0); else { var Ee = getDirectionPropertyValue(be, "width"), Ce = getDirectionPropertyValue(be, "padding-left"), Te = getDirectionPropertyValue(be, "padding-right"), xe = getDirectionPropertyValue(be, "margin-left"), Ae = getDirectionPropertyValue(be, "margin-right"), Ie = be.getPropertyValue("box-sizing"); if (Ie && "border-box" === Ie) ie = Ee + xe + Ae; else { var ke = fe[0], Oe = ke.clientWidth; ie = Ee + Ce + Te + xe + Ae + (ke.offsetWidth - Oe) } } Se && (fe[0].style.transform = Se), we && (fe[0].style.webkitTransform = we), u.roundLengths && (ie = Math.floor(ie)) } else ie = (v - (u.slidesPerView - 1) * ee) / u.slidesPerView, u.roundLengths && (ie = Math.floor(ie)), H[pe] && (H[pe].style[getDirectionLabel("width")] = ie + "px"); H[pe] && (H[pe].swiperSlideSize = ie), Y.push(ie), u.centeredSlides ? (te = te + ie / 2 + ne / 2 + ee, 0 === ne && 0 !== pe && (te = te - v / 2 - ee), 0 === pe && (te = te - v / 2 - ee), Math.abs(te) < .001 && (te = 0), u.roundLengths && (te = Math.floor(te)), re % u.slidesPerGroup == 0 && W.push(te), Z.push(te)) : (u.roundLengths && (te = Math.floor(te)), (re - Math.min(c.params.slidesPerGroupSkip, re)) % c.params.slidesPerGroup == 0 && W.push(te), Z.push(te), te = te + ie + ee), c.virtualSize += ie + ee, ne = ie, re += 1 } } if (c.virtualSize = Math.max(c.virtualSize, v) + K, E && k && ("slide" === u.effect || "coverflow" === u.effect) && d.css({ "width": c.virtualSize + u.spaceBetween + "px" }), u.setWrapperSize) d.css(((se = {})[getDirectionLabel("width")] = c.virtualSize + u.spaceBetween + "px", se)); if (u.slidesPerColumn > 1) if (c.virtualSize = (ie + u.spaceBetween) * oe, c.virtualSize = Math.ceil(c.virtualSize / u.slidesPerColumn) - u.spaceBetween, d.css(((ce = {})[getDirectionLabel("width")] = c.virtualSize + u.spaceBetween + "px", ce)), u.centeredSlides) { ae = []; for (var Pe = 0; Pe < W.length; Pe += 1) { var Re = W[Pe]; u.roundLengths && (Re = Math.floor(Re)), W[Pe] < c.virtualSize + W[0] && ae.push(Re) } W = ae } if (!u.centeredSlides) { ae = []; for (var Me = 0; Me < W.length; Me += 1) { var Ne = W[Me]; u.roundLengths && (Ne = Math.floor(Ne)), W[Me] <= c.virtualSize - v && ae.push(Ne) } W = ae, Math.floor(c.virtualSize - v) - Math.floor(W[W.length - 1]) > 1 && W.push(c.virtualSize - v) } if (0 === W.length && (W = [0]), 0 !== u.spaceBetween) { var De, $e = c.isHorizontal() && E ? "marginLeft" : getDirectionLabel("marginRight"); H.filter((function (c, d) { return !u.cssMode || d !== H.length - 1 })).css(((De = {})[$e] = ee + "px", De)) } if (u.centeredSlides && u.centeredSlidesBounds) { var Le = 0; Y.forEach((function (c) { Le += c + (u.spaceBetween ? u.spaceBetween : 0) })); var Fe = (Le -= u.spaceBetween) - v; W = W.map((function (c) { return c < 0 ? -J : c > Fe ? Fe + K : c })) } if (u.centerInsufficientSlides) { var je = 0; if (Y.forEach((function (c) { je += c + (u.spaceBetween ? u.spaceBetween : 0) })), (je -= u.spaceBetween) < v) { var Be = (v - je) / 2; W.forEach((function (c, u) { W[u] = c - Be })), Z.forEach((function (c, u) { Z[u] = c + Be })) } } utils_extend(c, { "slides": H, "snapGrid": W, "slidesGrid": Z, "slidesSizesGrid": Y }), G !== U && c.emit("slidesLengthChange"), W.length !== X && (c.params.watchOverflow && c.checkOverflow(), c.emit("snapGridLengthChange")), Z.length !== Q && c.emit("slidesGridLengthChange"), (u.watchSlidesProgress || u.watchSlidesVisibility) && c.updateSlidesOffset() } }, "updateAutoHeight": function updateAutoHeight(c) { var u, d = this, v = [], E = d.virtual && d.params.virtual.enabled, k = 0; "number" == typeof c ? d.setTransition(c) : !0 === c && d.setTransition(d.params.speed); var R = function getSlideByIndex(c) { return E ? d.slides.filter((function (u) { return parseInt(u.getAttribute("data-swiper-slide-index"), 10) === c }))[0] : d.slides.eq(c)[0] }; if ("auto" !== d.params.slidesPerView && d.params.slidesPerView > 1) if (d.params.centeredSlides) d.visibleSlides.each((function (c) { v.push(c) })); else for (u = 0; u < Math.ceil(d.params.slidesPerView); u += 1) { var U = d.activeIndex + u; if (U > d.slides.length && !E) break; v.push(R(U)) } else v.push(R(d.activeIndex)); for (u = 0; u < v.length; u += 1)if (void 0 !== v[u]) { var H = v[u].offsetHeight; k = H > k ? H : k } k && d.$wrapperEl.css("height", k + "px") }, "updateSlidesOffset": function updateSlidesOffset() { for (var c = this.slides, u = 0; u < c.length; u += 1)c[u].swiperSlideOffset = this.isHorizontal() ? c[u].offsetLeft : c[u].offsetTop }, "updateSlidesProgress": function updateSlidesProgress(c) { void 0 === c && (c = this && this.translate || 0); var u = this, d = u.params, v = u.slides, E = u.rtlTranslate; if (0 !== v.length) { void 0 === v[0].swiperSlideOffset && u.updateSlidesOffset(); var k = -c; E && (k = c), v.removeClass(d.slideVisibleClass), u.visibleSlidesIndexes = [], u.visibleSlides = []; for (var R = 0; R < v.length; R += 1) { var U = v[R], H = (k + (d.centeredSlides ? u.minTranslate() : 0) - U.swiperSlideOffset) / (U.swiperSlideSize + d.spaceBetween); if (d.watchSlidesVisibility || d.centeredSlides && d.autoHeight) { var G = -(k - U.swiperSlideOffset), W = G + u.slidesSizesGrid[R]; (G >= 0 && G < u.size - 1 || W > 1 && W <= u.size || G <= 0 && W >= u.size) && (u.visibleSlides.push(U), u.visibleSlidesIndexes.push(R), v.eq(R).addClass(d.slideVisibleClass)) } U.progress = E ? -H : H } u.visibleSlides = Z(u.visibleSlides) } }, "updateProgress": function updateProgress(c) { var u = this; if (void 0 === c) { var d = u.rtlTranslate ? -1 : 1; c = u && u.translate && u.translate * d || 0 } var v = u.params, E = u.maxTranslate() - u.minTranslate(), k = u.progress, R = u.isBeginning, U = u.isEnd, H = R, G = U; 0 === E ? (k = 0, R = !0, U = !0) : (R = (k = (c - u.minTranslate()) / E) <= 0, U = k >= 1), utils_extend(u, { "progress": k, "isBeginning": R, "isEnd": U }), (v.watchSlidesProgress || v.watchSlidesVisibility || v.centeredSlides && v.autoHeight) && u.updateSlidesProgress(c), R && !H && u.emit("reachBeginning toEdge"), U && !G && u.emit("reachEnd toEdge"), (H && !R || G && !U) && u.emit("fromEdge"), u.emit("progress", k) }, "updateSlidesClasses": function updateSlidesClasses() { var c, u = this, d = u.slides, v = u.params, E = u.$wrapperEl, k = u.activeIndex, R = u.realIndex, U = u.virtual && v.virtual.enabled; d.removeClass(v.slideActiveClass + " " + v.slideNextClass + " " + v.slidePrevClass + " " + v.slideDuplicateActiveClass + " " + v.slideDuplicateNextClass + " " + v.slideDuplicatePrevClass), (c = U ? u.$wrapperEl.find("." + v.slideClass + '[data-swiper-slide-index="' + k + '"]') : d.eq(k)).addClass(v.slideActiveClass), v.loop && (c.hasClass(v.slideDuplicateClass) ? E.children("." + v.slideClass + ":not(." + v.slideDuplicateClass + ')[data-swiper-slide-index="' + R + '"]').addClass(v.slideDuplicateActiveClass) : E.children("." + v.slideClass + "." + v.slideDuplicateClass + '[data-swiper-slide-index="' + R + '"]').addClass(v.slideDuplicateActiveClass)); var H = c.nextAll("." + v.slideClass).eq(0).addClass(v.slideNextClass); v.loop && 0 === H.length && (H = d.eq(0)).addClass(v.slideNextClass); var G = c.prevAll("." + v.slideClass).eq(0).addClass(v.slidePrevClass); v.loop && 0 === G.length && (G = d.eq(-1)).addClass(v.slidePrevClass), v.loop && (H.hasClass(v.slideDuplicateClass) ? E.children("." + v.slideClass + ":not(." + v.slideDuplicateClass + ')[data-swiper-slide-index="' + H.attr("data-swiper-slide-index") + '"]').addClass(v.slideDuplicateNextClass) : E.children("." + v.slideClass + "." + v.slideDuplicateClass + '[data-swiper-slide-index="' + H.attr("data-swiper-slide-index") + '"]').addClass(v.slideDuplicateNextClass), G.hasClass(v.slideDuplicateClass) ? E.children("." + v.slideClass + ":not(." + v.slideDuplicateClass + ')[data-swiper-slide-index="' + G.attr("data-swiper-slide-index") + '"]').addClass(v.slideDuplicatePrevClass) : E.children("." + v.slideClass + "." + v.slideDuplicateClass + '[data-swiper-slide-index="' + G.attr("data-swiper-slide-index") + '"]').addClass(v.slideDuplicatePrevClass)), u.emitSlidesClasses() }, "updateActiveIndex": function updateActiveIndex(c) { var u, d = this, v = d.rtlTranslate ? d.translate : -d.translate, E = d.slidesGrid, k = d.snapGrid, R = d.params, U = d.activeIndex, H = d.realIndex, G = d.snapIndex, W = c; if (void 0 === W) { for (var Z = 0; Z < E.length; Z += 1)void 0 !== E[Z + 1] ? v >= E[Z] && v < E[Z + 1] - (E[Z + 1] - E[Z]) / 2 ? W = Z : v >= E[Z] && v < E[Z + 1] && (W = Z + 1) : v >= E[Z] && (W = Z); R.normalizeSlideIndex && (W < 0 || void 0 === W) && (W = 0) } if (k.indexOf(v) >= 0) u = k.indexOf(v); else { var Y = Math.min(R.slidesPerGroupSkip, W); u = Y + Math.floor((W - Y) / R.slidesPerGroup) } if (u >= k.length && (u = k.length - 1), W !== U) { var J = parseInt(d.slides.eq(W).attr("data-swiper-slide-index") || W, 10); utils_extend(d, { "snapIndex": u, "realIndex": J, "previousIndex": U, "activeIndex": W }), d.emit("activeIndexChange"), d.emit("snapIndexChange"), H !== J && d.emit("realIndexChange"), (d.initialized || d.params.runCallbacksOnInit) && d.emit("slideChange") } else u !== G && (d.snapIndex = u, d.emit("snapIndexChange")) }, "updateClickedSlide": function updateClickedSlide(c) { var u, d = this, v = d.params, E = Z(c.target).closest("." + v.slideClass)[0], k = !1; if (E) for (var R = 0; R < d.slides.length; R += 1)if (d.slides[R] === E) { k = !0, u = R; break } if (!E || !k) return d.clickedSlide = void 0, void (d.clickedIndex = void 0); d.clickedSlide = E, d.virtual && d.params.virtual.enabled ? d.clickedIndex = parseInt(Z(E).attr("data-swiper-slide-index"), 10) : d.clickedIndex = u, v.slideToClickedSlide && void 0 !== d.clickedIndex && d.clickedIndex !== d.activeIndex && d.slideToClickedSlide() } }; var ee = { "getTranslate": function getSwiperTranslate(c) { void 0 === c && (c = this.isHorizontal() ? "x" : "y"); var u = this, d = u.params, v = u.rtlTranslate, E = u.translate, k = u.$wrapperEl; if (d.virtualTranslate) return v ? -E : E; if (d.cssMode) return E; var R = getTranslate(k[0], c); return v && (R = -R), R || 0 }, "setTranslate": function setTranslate(c, u) { var d = this, v = d.rtlTranslate, E = d.params, k = d.$wrapperEl, R = d.wrapperEl, U = d.progress, H = 0, G = 0; d.isHorizontal() ? H = v ? -c : c : G = c, E.roundLengths && (H = Math.floor(H), G = Math.floor(G)), E.cssMode ? R[d.isHorizontal() ? "scrollLeft" : "scrollTop"] = d.isHorizontal() ? -H : -G : E.virtualTranslate || k.transform("translate3d(" + H + "px, " + G + "px, 0px)"), d.previousTranslate = d.translate, d.translate = d.isHorizontal() ? H : G; var W = d.maxTranslate() - d.minTranslate(); (0 === W ? 0 : (c - d.minTranslate()) / W) !== U && d.updateProgress(c), d.emit("setTranslate", d.translate, u) }, "minTranslate": function minTranslate() { return -this.snapGrid[0] }, "maxTranslate": function maxTranslate() { return -this.snapGrid[this.snapGrid.length - 1] }, "translateTo": function translateTo(c, u, d, v, E) { void 0 === c && (c = 0), void 0 === u && (u = this.params.speed), void 0 === d && (d = !0), void 0 === v && (v = !0); var k = this, R = k.params, U = k.wrapperEl; if (k.animating && R.preventInteractionOnTransition) return !1; var H, G = k.minTranslate(), W = k.maxTranslate(); if (H = v && c > G ? G : v && c < W ? W : c, k.updateProgress(H), R.cssMode) { var Z, Y = k.isHorizontal(); if (0 === u) U[Y ? "scrollLeft" : "scrollTop"] = -H; else if (U.scrollTo) U.scrollTo(((Z = {})[Y ? "left" : "top"] = -H, Z.behavior = "smooth", Z)); else U[Y ? "scrollLeft" : "scrollTop"] = -H; return !0 } return 0 === u ? (k.setTransition(0), k.setTranslate(H), d && (k.emit("beforeTransitionStart", u, E), k.emit("transitionEnd"))) : (k.setTransition(u), k.setTranslate(H), d && (k.emit("beforeTransitionStart", u, E), k.emit("transitionStart")), k.animating || (k.animating = !0, k.onTranslateToWrapperTransitionEnd || (k.onTranslateToWrapperTransitionEnd = function transitionEnd(c) { k && !k.destroyed && c.target === this && (k.$wrapperEl[0].removeEventListener("transitionend", k.onTranslateToWrapperTransitionEnd), k.$wrapperEl[0].removeEventListener("webkitTransitionEnd", k.onTranslateToWrapperTransitionEnd), k.onTranslateToWrapperTransitionEnd = null, delete k.onTranslateToWrapperTransitionEnd, d && k.emit("transitionEnd")) }), k.$wrapperEl[0].addEventListener("transitionend", k.onTranslateToWrapperTransitionEnd), k.$wrapperEl[0].addEventListener("webkitTransitionEnd", k.onTranslateToWrapperTransitionEnd))), !0 } }; var te = { "slideTo": function slideTo(c, u, d, v, E) { if (void 0 === c && (c = 0), void 0 === u && (u = this.params.speed), void 0 === d && (d = !0), "number" != typeof c && "string" != typeof c) throw new Error("The 'index' argument cannot have type other than 'number' or 'string'. [" + typeof c + "] given."); if ("string" == typeof c) { var k = parseInt(c, 10); if (!isFinite(k)) throw new Error("The passed-in 'index' (string) couldn't be converted to 'number'. [" + c + "] given."); c = k } var R = this, U = c; U < 0 && (U = 0); var H = R.params, G = R.snapGrid, W = R.slidesGrid, Z = R.previousIndex, Y = R.activeIndex, J = R.rtlTranslate, K = R.wrapperEl, X = R.enabled; if (R.animating && H.preventInteractionOnTransition || !X && !v && !E) return !1; var Q = Math.min(R.params.slidesPerGroupSkip, U), ee = Q + Math.floor((U - Q) / R.params.slidesPerGroup); ee >= G.length && (ee = G.length - 1), (Y || H.initialSlide || 0) === (Z || 0) && d && R.emit("beforeSlideChangeStart"); var te, ne = -G[ee]; if (R.updateProgress(ne), H.normalizeSlideIndex) for (var re = 0; re < W.length; re += 1) { var oe = -Math.floor(100 * ne), ie = Math.floor(100 * W[re]), ae = Math.floor(100 * W[re + 1]); void 0 !== W[re + 1] ? oe >= ie && oe < ae - (ae - ie) / 2 ? U = re : oe >= ie && oe < ae && (U = re + 1) : oe >= ie && (U = re) } if (R.initialized && U !== Y) { if (!R.allowSlideNext && ne < R.translate && ne < R.minTranslate()) return !1; if (!R.allowSlidePrev && ne > R.translate && ne > R.maxTranslate() && (Y || 0) !== U) return !1 } if (te = U > Y ? "next" : U < Y ? "prev" : "reset", J && -ne === R.translate || !J && ne === R.translate) return R.updateActiveIndex(U), H.autoHeight && R.updateAutoHeight(), R.updateSlidesClasses(), "slide" !== H.effect && R.setTranslate(ne), "reset" !== te && (R.transitionStart(d, te), R.transitionEnd(d, te)), !1; if (H.cssMode) { var se, ce = R.isHorizontal(), le = -ne; if (J && (le = K.scrollWidth - K.offsetWidth - le), 0 === u) K[ce ? "scrollLeft" : "scrollTop"] = le; else if (K.scrollTo) K.scrollTo(((se = {})[ce ? "left" : "top"] = le, se.behavior = "smooth", se)); else K[ce ? "scrollLeft" : "scrollTop"] = le; return !0 } return 0 === u ? (R.setTransition(0), R.setTranslate(ne), R.updateActiveIndex(U), R.updateSlidesClasses(), R.emit("beforeTransitionStart", u, v), R.transitionStart(d, te), R.transitionEnd(d, te)) : (R.setTransition(u), R.setTranslate(ne), R.updateActiveIndex(U), R.updateSlidesClasses(), R.emit("beforeTransitionStart", u, v), R.transitionStart(d, te), R.animating || (R.animating = !0, R.onSlideToWrapperTransitionEnd || (R.onSlideToWrapperTransitionEnd = function transitionEnd(c) { R && !R.destroyed && c.target === this && (R.$wrapperEl[0].removeEventListener("transitionend", R.onSlideToWrapperTransitionEnd), R.$wrapperEl[0].removeEventListener("webkitTransitionEnd", R.onSlideToWrapperTransitionEnd), R.onSlideToWrapperTransitionEnd = null, delete R.onSlideToWrapperTransitionEnd, R.transitionEnd(d, te)) }), R.$wrapperEl[0].addEventListener("transitionend", R.onSlideToWrapperTransitionEnd), R.$wrapperEl[0].addEventListener("webkitTransitionEnd", R.onSlideToWrapperTransitionEnd))), !0 }, "slideToLoop": function slideToLoop(c, u, d, v) { void 0 === c && (c = 0), void 0 === u && (u = this.params.speed), void 0 === d && (d = !0); var E = this, k = c; return E.params.loop && (k += E.loopedSlides), E.slideTo(k, u, d, v) }, "slideNext": function slideNext(c, u, d) { void 0 === c && (c = this.params.speed), void 0 === u && (u = !0); var v = this, E = v.params, k = v.animating; if (!v.enabled) return v; var R = v.activeIndex < E.slidesPerGroupSkip ? 1 : E.slidesPerGroup; if (E.loop) { if (k && E.loopPreventsSlide) return !1; v.loopFix(), v._clientLeft = v.$wrapperEl[0].clientLeft } return v.slideTo(v.activeIndex + R, c, u, d) }, "slidePrev": function slidePrev(c, u, d) { void 0 === c && (c = this.params.speed), void 0 === u && (u = !0); var v = this, E = v.params, k = v.animating, R = v.snapGrid, U = v.slidesGrid, H = v.rtlTranslate; if (!v.enabled) return v; if (E.loop) { if (k && E.loopPreventsSlide) return !1; v.loopFix(), v._clientLeft = v.$wrapperEl[0].clientLeft } function normalize(c) { return c < 0 ? -Math.floor(Math.abs(c)) : Math.floor(c) } var G, W = normalize(H ? v.translate : -v.translate), Z = R.map((function (c) { return normalize(c) })), Y = R[Z.indexOf(W) - 1]; return void 0 === Y && E.cssMode && R.forEach((function (c) { !Y && W >= c && (Y = c) })), void 0 !== Y && (G = U.indexOf(Y)) < 0 && (G = v.activeIndex - 1), v.slideTo(G, c, u, d) }, "slideReset": function slideReset(c, u, d) { return void 0 === c && (c = this.params.speed), void 0 === u && (u = !0), this.slideTo(this.activeIndex, c, u, d) }, "slideToClosest": function slideToClosest(c, u, d, v) { void 0 === c && (c = this.params.speed), void 0 === u && (u = !0), void 0 === v && (v = .5); var E = this, k = E.activeIndex, R = Math.min(E.params.slidesPerGroupSkip, k), U = R + Math.floor((k - R) / E.params.slidesPerGroup), H = E.rtlTranslate ? E.translate : -E.translate; if (H >= E.snapGrid[U]) { var G = E.snapGrid[U]; H - G > (E.snapGrid[U + 1] - G) * v && (k += E.params.slidesPerGroup) } else { var W = E.snapGrid[U - 1]; H - W <= (E.snapGrid[U] - W) * v && (k -= E.params.slidesPerGroup) } return k = Math.max(k, 0), k = Math.min(k, E.slidesGrid.length - 1), E.slideTo(k, c, u, d) }, "slideToClickedSlide": function slideToClickedSlide() { var c, u = this, d = u.params, v = u.$wrapperEl, E = "auto" === d.slidesPerView ? u.slidesPerViewDynamic() : d.slidesPerView, k = u.clickedIndex; if (d.loop) { if (u.animating) return; c = parseInt(Z(u.clickedSlide).attr("data-swiper-slide-index"), 10), d.centeredSlides ? k < u.loopedSlides - E / 2 || k > u.slides.length - u.loopedSlides + E / 2 ? (u.loopFix(), k = v.children("." + d.slideClass + '[data-swiper-slide-index="' + c + '"]:not(.' + d.slideDuplicateClass + ")").eq(0).index(), nextTick((function () { u.slideTo(k) }))) : u.slideTo(k) : k > u.slides.length - E ? (u.loopFix(), k = v.children("." + d.slideClass + '[data-swiper-slide-index="' + c + '"]:not(.' + d.slideDuplicateClass + ")").eq(0).index(), nextTick((function () { u.slideTo(k) }))) : u.slideTo(k) } else u.slideTo(k) } }; var ne = { "loopCreate": function loopCreate() { var c = this, u = getDocument(), d = c.params, v = c.$wrapperEl; v.children("." + d.slideClass + "." + d.slideDuplicateClass).remove(); var E = v.children("." + d.slideClass); if (d.loopFillGroupWithBlank) { var k = d.slidesPerGroup - E.length % d.slidesPerGroup; if (k !== d.slidesPerGroup) { for (var R = 0; R < k; R += 1) { var U = Z(u.createElement("div")).addClass(d.slideClass + " " + d.slideBlankClass); v.append(U) } E = v.children("." + d.slideClass) } } "auto" !== d.slidesPerView || d.loopedSlides || (d.loopedSlides = E.length), c.loopedSlides = Math.ceil(parseFloat(d.loopedSlides || d.slidesPerView, 10)), c.loopedSlides += d.loopAdditionalSlides, c.loopedSlides > E.length && (c.loopedSlides = E.length); var H = [], G = []; E.each((function (u, d) { var v = Z(u); d < c.loopedSlides && G.push(u), d < E.length && d >= E.length - c.loopedSlides && H.push(u), v.attr("data-swiper-slide-index", d) })); for (var W = 0; W < G.length; W += 1)v.append(Z(G[W].cloneNode(!0)).addClass(d.slideDuplicateClass)); for (var Y = H.length - 1; Y >= 0; Y -= 1)v.prepend(Z(H[Y].cloneNode(!0)).addClass(d.slideDuplicateClass)) }, "loopFix": function loopFix() { var c = this; c.emit("beforeLoopFix"); var u, d = c.activeIndex, v = c.slides, E = c.loopedSlides, k = c.allowSlidePrev, R = c.allowSlideNext, U = c.snapGrid, H = c.rtlTranslate; c.allowSlidePrev = !0, c.allowSlideNext = !0; var G = -U[d] - c.getTranslate(); if (d < E) u = v.length - 3 * E + d, u += E, c.slideTo(u, 0, !1, !0) && 0 !== G && c.setTranslate((H ? -c.translate : c.translate) - G); else if (d >= v.length - E) { u = -v.length + d + E, u += E, c.slideTo(u, 0, !1, !0) && 0 !== G && c.setTranslate((H ? -c.translate : c.translate) - G) } c.allowSlidePrev = k, c.allowSlideNext = R, c.emit("loopFix") }, "loopDestroy": function loopDestroy() { var c = this, u = c.$wrapperEl, d = c.params, v = c.slides; u.children("." + d.slideClass + "." + d.slideDuplicateClass + ",." + d.slideClass + "." + d.slideBlankClass).remove(), v.removeAttr("data-swiper-slide-index") } }; var re = { "appendSlide": function appendSlide(c) { var u = this, d = u.$wrapperEl, v = u.params; if (v.loop && u.loopDestroy(), "object" == typeof c && "length" in c) for (var E = 0; E < c.length; E += 1)c[E] && d.append(c[E]); else d.append(c); v.loop && u.loopCreate(), v.observer && u.support.observer || u.update() }, "prependSlide": function prependSlide(c) { var u = this, d = u.params, v = u.$wrapperEl, E = u.activeIndex; d.loop && u.loopDestroy(); var k = E + 1; if ("object" == typeof c && "length" in c) { for (var R = 0; R < c.length; R += 1)c[R] && v.prepend(c[R]); k = E + c.length } else v.prepend(c); d.loop && u.loopCreate(), d.observer && u.support.observer || u.update(), u.slideTo(k, 0, !1) }, "addSlide": function addSlide(c, u) { var d = this, v = d.$wrapperEl, E = d.params, k = d.activeIndex; E.loop && (k -= d.loopedSlides, d.loopDestroy(), d.slides = v.children("." + E.slideClass)); var R = d.slides.length; if (c <= 0) d.prependSlide(u); else if (c >= R) d.appendSlide(u); else { for (var U = k > c ? k + 1 : k, H = [], G = R - 1; G >= c; G -= 1) { var W = d.slides.eq(G); W.remove(), H.unshift(W) } if ("object" == typeof u && "length" in u) { for (var Z = 0; Z < u.length; Z += 1)u[Z] && v.append(u[Z]); U = k > c ? k + u.length : k } else v.append(u); for (var Y = 0; Y < H.length; Y += 1)v.append(H[Y]); E.loop && d.loopCreate(), E.observer && d.support.observer || d.update(), E.loop ? d.slideTo(U + d.loopedSlides, 0, !1) : d.slideTo(U, 0, !1) } }, "removeSlide": function removeSlide(c) { var u = this, d = u.params, v = u.$wrapperEl, E = u.activeIndex; d.loop && (E -= u.loopedSlides, u.loopDestroy(), u.slides = v.children("." + d.slideClass)); var k, R = E; if ("object" == typeof c && "length" in c) { for (var U = 0; U < c.length; U += 1)k = c[U], u.slides[k] && u.slides.eq(k).remove(), k < R && (R -= 1); R = Math.max(R, 0) } else k = c, u.slides[k] && u.slides.eq(k).remove(), k < R && (R -= 1), R = Math.max(R, 0); d.loop && u.loopCreate(), d.observer && u.support.observer || u.update(), d.loop ? u.slideTo(R + u.loopedSlides, 0, !1) : u.slideTo(R, 0, !1) }, "removeAllSlides": function removeAllSlides() { for (var c = [], u = 0; u < this.slides.length; u += 1)c.push(u); this.removeSlide(c) } }; function onTouchStart(c) { var u = this, d = getDocument(), v = ssr_window_esm_getWindow(), E = u.touchEventsData, k = u.params, R = u.touches; if (u.enabled && (!u.animating || !k.preventInteractionOnTransition)) { var U = c; U.originalEvent && (U = U.originalEvent); var H = Z(U.target); if ("wrapper" !== k.touchEventsTarget || H.closest(u.wrapperEl).length) if (E.isTouchEvent = "touchstart" === U.type, E.isTouchEvent || !("which" in U) || 3 !== U.which) if (!(!E.isTouchEvent && "button" in U && U.button > 0)) if (!E.isTouched || !E.isMoved) if (!!k.noSwipingClass && "" !== k.noSwipingClass && U.target && U.target.shadowRoot && c.path && c.path[0] && (H = Z(c.path[0])), k.noSwiping && H.closest(k.noSwipingSelector ? k.noSwipingSelector : "." + k.noSwipingClass)[0]) u.allowClick = !0; else if (!k.swipeHandler || H.closest(k.swipeHandler)[0]) { R.currentX = "touchstart" === U.type ? U.targetTouches[0].pageX : U.pageX, R.currentY = "touchstart" === U.type ? U.targetTouches[0].pageY : U.pageY; var G = R.currentX, W = R.currentY, Y = k.edgeSwipeDetection || k.iOSEdgeSwipeDetection, J = k.edgeSwipeThreshold || k.iOSEdgeSwipeThreshold; if (Y && (G <= J || G >= v.innerWidth - J)) { if ("prevent" !== Y) return; c.preventDefault() } if (utils_extend(E, { "isTouched": !0, "isMoved": !1, "allowTouchCallbacks": !0, "isScrolling": void 0, "startMoving": void 0 }), R.startX = G, R.startY = W, E.touchStartTime = now(), u.allowClick = !0, u.updateSize(), u.swipeDirection = void 0, k.threshold > 0 && (E.allowThresholdMove = !1), "touchstart" !== U.type) { var K = !0; H.is(E.focusableElements) && (K = !1), d.activeElement && Z(d.activeElement).is(E.focusableElements) && d.activeElement !== H[0] && d.activeElement.blur(); var X = K && u.allowTouchMove && k.touchStartPreventDefault; !k.touchStartForcePreventDefault && !X || H[0].isContentEditable || U.preventDefault() } u.emit("touchStart", U) } } } function onTouchMove(c) { var u = getDocument(), d = this, v = d.touchEventsData, E = d.params, k = d.touches, R = d.rtlTranslate; if (d.enabled) { var U = c; if (U.originalEvent && (U = U.originalEvent), v.isTouched) { if (!v.isTouchEvent || "touchmove" === U.type) { var H = "touchmove" === U.type && U.targetTouches && (U.targetTouches[0] || U.changedTouches[0]), G = "touchmove" === U.type ? H.pageX : U.pageX, W = "touchmove" === U.type ? H.pageY : U.pageY; if (U.preventedByNestedSwiper) return k.startX = G, void (k.startY = W); if (!d.allowTouchMove) return d.allowClick = !1, void (v.isTouched && (utils_extend(k, { "startX": G, "startY": W, "currentX": G, "currentY": W }), v.touchStartTime = now())); if (v.isTouchEvent && E.touchReleaseOnEdges && !E.loop) if (d.isVertical()) { if (W < k.startY && d.translate <= d.maxTranslate() || W > k.startY && d.translate >= d.minTranslate()) return v.isTouched = !1, void (v.isMoved = !1) } else if (G < k.startX && d.translate <= d.maxTranslate() || G > k.startX && d.translate >= d.minTranslate()) return; if (v.isTouchEvent && u.activeElement && U.target === u.activeElement && Z(U.target).is(v.focusableElements)) return v.isMoved = !0, void (d.allowClick = !1); if (v.allowTouchCallbacks && d.emit("touchMove", U), !(U.targetTouches && U.targetTouches.length > 1)) { k.currentX = G, k.currentY = W; var Y = k.currentX - k.startX, J = k.currentY - k.startY; if (!(d.params.threshold && Math.sqrt(Math.pow(Y, 2) + Math.pow(J, 2)) < d.params.threshold)) { var K; if (void 0 === v.isScrolling) d.isHorizontal() && k.currentY === k.startY || d.isVertical() && k.currentX === k.startX ? v.isScrolling = !1 : Y * Y + J * J >= 25 && (K = 180 * Math.atan2(Math.abs(J), Math.abs(Y)) / Math.PI, v.isScrolling = d.isHorizontal() ? K > E.touchAngle : 90 - K > E.touchAngle); if (v.isScrolling && d.emit("touchMoveOpposite", U), void 0 === v.startMoving && (k.currentX === k.startX && k.currentY === k.startY || (v.startMoving = !0)), v.isScrolling) v.isTouched = !1; else if (v.startMoving) { d.allowClick = !1, !E.cssMode && U.cancelable && U.preventDefault(), E.touchMoveStopPropagation && !E.nested && U.stopPropagation(), v.isMoved || (E.loop && d.loopFix(), v.startTranslate = d.getTranslate(), d.setTransition(0), d.animating && d.$wrapperEl.trigger("webkitTransitionEnd transitionend"), v.allowMomentumBounce = !1, !E.grabCursor || !0 !== d.allowSlideNext && !0 !== d.allowSlidePrev || d.setGrabCursor(!0), d.emit("sliderFirstMove", U)), d.emit("sliderMove", U), v.isMoved = !0; var X = d.isHorizontal() ? Y : J; k.diff = X, X *= E.touchRatio, R && (X = -X), d.swipeDirection = X > 0 ? "prev" : "next", v.currentTranslate = X + v.startTranslate; var Q = !0, ee = E.resistanceRatio; if (E.touchReleaseOnEdges && (ee = 0), X > 0 && v.currentTranslate > d.minTranslate() ? (Q = !1, E.resistance && (v.currentTranslate = d.minTranslate() - 1 + Math.pow(-d.minTranslate() + v.startTranslate + X, ee))) : X < 0 && v.currentTranslate < d.maxTranslate() && (Q = !1, E.resistance && (v.currentTranslate = d.maxTranslate() + 1 - Math.pow(d.maxTranslate() - v.startTranslate - X, ee))), Q && (U.preventedByNestedSwiper = !0), !d.allowSlideNext && "next" === d.swipeDirection && v.currentTranslate < v.startTranslate && (v.currentTranslate = v.startTranslate), !d.allowSlidePrev && "prev" === d.swipeDirection && v.currentTranslate > v.startTranslate && (v.currentTranslate = v.startTranslate), d.allowSlidePrev || d.allowSlideNext || (v.currentTranslate = v.startTranslate), E.threshold > 0) { if (!(Math.abs(X) > E.threshold || v.allowThresholdMove)) return void (v.currentTranslate = v.startTranslate); if (!v.allowThresholdMove) return v.allowThresholdMove = !0, k.startX = k.currentX, k.startY = k.currentY, v.currentTranslate = v.startTranslate, void (k.diff = d.isHorizontal() ? k.currentX - k.startX : k.currentY - k.startY) } E.followFinger && !E.cssMode && ((E.freeMode || E.watchSlidesProgress || E.watchSlidesVisibility) && (d.updateActiveIndex(), d.updateSlidesClasses()), E.freeMode && (0 === v.velocities.length && v.velocities.push({ "position": k[d.isHorizontal() ? "startX" : "startY"], "time": v.touchStartTime }), v.velocities.push({ "position": k[d.isHorizontal() ? "currentX" : "currentY"], "time": now() })), d.updateProgress(v.currentTranslate), d.setTranslate(v.currentTranslate)) } } } } } else v.startMoving && v.isScrolling && d.emit("touchMoveOpposite", U) } } function onTouchEnd(c) { var u = this, d = u.touchEventsData, v = u.params, E = u.touches, k = u.rtlTranslate, R = u.$wrapperEl, U = u.slidesGrid, H = u.snapGrid; if (u.enabled) { var G = c; if (G.originalEvent && (G = G.originalEvent), d.allowTouchCallbacks && u.emit("touchEnd", G), d.allowTouchCallbacks = !1, !d.isTouched) return d.isMoved && v.grabCursor && u.setGrabCursor(!1), d.isMoved = !1, void (d.startMoving = !1); v.grabCursor && d.isMoved && d.isTouched && (!0 === u.allowSlideNext || !0 === u.allowSlidePrev) && u.setGrabCursor(!1); var W, Z = now(), Y = Z - d.touchStartTime; if (u.allowClick && (u.updateClickedSlide(G), u.emit("tap click", G), Y < 300 && Z - d.lastClickTime < 300 && u.emit("doubleTap doubleClick", G)), d.lastClickTime = now(), nextTick((function () { u.destroyed || (u.allowClick = !0) })), !d.isTouched || !d.isMoved || !u.swipeDirection || 0 === E.diff || d.currentTranslate === d.startTranslate) return d.isTouched = !1, d.isMoved = !1, void (d.startMoving = !1); if (d.isTouched = !1, d.isMoved = !1, d.startMoving = !1, W = v.followFinger ? k ? u.translate : -u.translate : -d.currentTranslate, !v.cssMode) if (v.freeMode) { if (W < -u.minTranslate()) return void u.slideTo(u.activeIndex); if (W > -u.maxTranslate()) return void (u.slides.length < H.length ? u.slideTo(H.length - 1) : u.slideTo(u.slides.length - 1)); if (v.freeModeMomentum) { if (d.velocities.length > 1) { var J = d.velocities.pop(), K = d.velocities.pop(), X = J.position - K.position, Q = J.time - K.time; u.velocity = X / Q, u.velocity /= 2, Math.abs(u.velocity) < v.freeModeMinimumVelocity && (u.velocity = 0), (Q > 150 || now() - J.time > 300) && (u.velocity = 0) } else u.velocity = 0; u.velocity *= v.freeModeMomentumVelocityRatio, d.velocities.length = 0; var ee = 1e3 * v.freeModeMomentumRatio, te = u.velocity * ee, ne = u.translate + te; k && (ne = -ne); var re, oe, ie = !1, ae = 20 * Math.abs(u.velocity) * v.freeModeMomentumBounceRatio; if (ne < u.maxTranslate()) v.freeModeMomentumBounce ? (ne + u.maxTranslate() < -ae && (ne = u.maxTranslate() - ae), re = u.maxTranslate(), ie = !0, d.allowMomentumBounce = !0) : ne = u.maxTranslate(), v.loop && v.centeredSlides && (oe = !0); else if (ne > u.minTranslate()) v.freeModeMomentumBounce ? (ne - u.minTranslate() > ae && (ne = u.minTranslate() + ae), re = u.minTranslate(), ie = !0, d.allowMomentumBounce = !0) : ne = u.minTranslate(), v.loop && v.centeredSlides && (oe = !0); else if (v.freeModeSticky) { for (var se, ce = 0; ce < H.length; ce += 1)if (H[ce] > -ne) { se = ce; break } ne = -(ne = Math.abs(H[se] - ne) < Math.abs(H[se - 1] - ne) || "next" === u.swipeDirection ? H[se] : H[se - 1]) } if (oe && u.once("transitionEnd", (function () { u.loopFix() })), 0 !== u.velocity) { if (ee = k ? Math.abs((-ne - u.translate) / u.velocity) : Math.abs((ne - u.translate) / u.velocity), v.freeModeSticky) { var le = Math.abs((k ? -ne : ne) - u.translate), ue = u.slidesSizesGrid[u.activeIndex]; ee = le < ue ? v.speed : le < 2 * ue ? 1.5 * v.speed : 2.5 * v.speed } } else if (v.freeModeSticky) return void u.slideToClosest(); v.freeModeMomentumBounce && ie ? (u.updateProgress(re), u.setTransition(ee), u.setTranslate(ne), u.transitionStart(!0, u.swipeDirection), u.animating = !0, R.transitionEnd((function () { u && !u.destroyed && d.allowMomentumBounce && (u.emit("momentumBounce"), u.setTransition(v.speed), setTimeout((function () { u.setTranslate(re), R.transitionEnd((function () { u && !u.destroyed && u.transitionEnd() })) }), 0)) }))) : u.velocity ? (u.updateProgress(ne), u.setTransition(ee), u.setTranslate(ne), u.transitionStart(!0, u.swipeDirection), u.animating || (u.animating = !0, R.transitionEnd((function () { u && !u.destroyed && u.transitionEnd() })))) : (u.emit("_freeModeNoMomentumRelease"), u.updateProgress(ne)), u.updateActiveIndex(), u.updateSlidesClasses() } else { if (v.freeModeSticky) return void u.slideToClosest(); v.freeMode && u.emit("_freeModeNoMomentumRelease") } (!v.freeModeMomentum || Y >= v.longSwipesMs) && (u.updateProgress(), u.updateActiveIndex(), u.updateSlidesClasses()) } else { for (var de = 0, pe = u.slidesSizesGrid[0], fe = 0; fe < U.length; fe += fe < v.slidesPerGroupSkip ? 1 : v.slidesPerGroup) { var he = fe < v.slidesPerGroupSkip - 1 ? 1 : v.slidesPerGroup; void 0 !== U[fe + he] ? W >= U[fe] && W < U[fe + he] && (de = fe, pe = U[fe + he] - U[fe]) : W >= U[fe] && (de = fe, pe = U[U.length - 1] - U[U.length - 2]) } var me = (W - U[de]) / pe, ge = de < v.slidesPerGroupSkip - 1 ? 1 : v.slidesPerGroup; if (Y > v.longSwipesMs) { if (!v.longSwipes) return void u.slideTo(u.activeIndex); "next" === u.swipeDirection && (me >= v.longSwipesRatio ? u.slideTo(de + ge) : u.slideTo(de)), "prev" === u.swipeDirection && (me > 1 - v.longSwipesRatio ? u.slideTo(de + ge) : u.slideTo(de)) } else { if (!v.shortSwipes) return void u.slideTo(u.activeIndex); u.navigation && (G.target === u.navigation.nextEl || G.target === u.navigation.prevEl) ? G.target === u.navigation.nextEl ? u.slideTo(de + ge) : u.slideTo(de) : ("next" === u.swipeDirection && u.slideTo(de + ge), "prev" === u.swipeDirection && u.slideTo(de)) } } } } function onResize() { var c = this, u = c.params, d = c.el; if (!d || 0 !== d.offsetWidth) { u.breakpoints && c.setBreakpoint(); var v = c.allowSlideNext, E = c.allowSlidePrev, k = c.snapGrid; c.allowSlideNext = !0, c.allowSlidePrev = !0, c.updateSize(), c.updateSlides(), c.updateSlidesClasses(), ("auto" === u.slidesPerView || u.slidesPerView > 1) && c.isEnd && !c.isBeginning && !c.params.centeredSlides ? c.slideTo(c.slides.length - 1, 0, !1, !0) : c.slideTo(c.activeIndex, 0, !1, !0), c.autoplay && c.autoplay.running && c.autoplay.paused && c.autoplay.run(), c.allowSlidePrev = E, c.allowSlideNext = v, c.params.watchOverflow && k !== c.snapGrid && c.checkOverflow() } } function onClick(c) { var u = this; u.enabled && (u.allowClick || (u.params.preventClicks && c.preventDefault(), u.params.preventClicksPropagation && u.animating && (c.stopPropagation(), c.stopImmediatePropagation()))) } function onScroll() { var c = this, u = c.wrapperEl, d = c.rtlTranslate; if (c.enabled) { c.previousTranslate = c.translate, c.isHorizontal() ? c.translate = d ? u.scrollWidth - u.offsetWidth - u.scrollLeft : -u.scrollLeft : c.translate = -u.scrollTop, -0 === c.translate && (c.translate = 0), c.updateActiveIndex(), c.updateSlidesClasses(); var v = c.maxTranslate() - c.minTranslate(); (0 === v ? 0 : (c.translate - c.minTranslate()) / v) !== c.progress && c.updateProgress(d ? -c.translate : c.translate), c.emit("setTranslate", c.translate, !1) } } var oe = !1; function dummyEventListener() { } var ie = { "attachEvents": function attachEvents() { var c = this, u = getDocument(), d = c.params, v = c.touchEvents, E = c.el, k = c.wrapperEl, R = c.device, U = c.support; c.onTouchStart = onTouchStart.bind(c), c.onTouchMove = onTouchMove.bind(c), c.onTouchEnd = onTouchEnd.bind(c), d.cssMode && (c.onScroll = onScroll.bind(c)), c.onClick = onClick.bind(c); var H = !!d.nested; if (!U.touch && U.pointerEvents) E.addEventListener(v.start, c.onTouchStart, !1), u.addEventListener(v.move, c.onTouchMove, H), u.addEventListener(v.end, c.onTouchEnd, !1); else { if (U.touch) { var G = !("touchstart" !== v.start || !U.passiveListener || !d.passiveListeners) && { "passive": !0, "capture": !1 }; E.addEventListener(v.start, c.onTouchStart, G), E.addEventListener(v.move, c.onTouchMove, U.passiveListener ? { "passive": !1, "capture": H } : H), E.addEventListener(v.end, c.onTouchEnd, G), v.cancel && E.addEventListener(v.cancel, c.onTouchEnd, G), oe || (u.addEventListener("touchstart", dummyEventListener), oe = !0) } (d.simulateTouch && !R.ios && !R.android || d.simulateTouch && !U.touch && R.ios) && (E.addEventListener("mousedown", c.onTouchStart, !1), u.addEventListener("mousemove", c.onTouchMove, H), u.addEventListener("mouseup", c.onTouchEnd, !1)) } (d.preventClicks || d.preventClicksPropagation) && E.addEventListener("click", c.onClick, !0), d.cssMode && k.addEventListener("scroll", c.onScroll), d.updateOnWindowResize ? c.on(R.ios || R.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, !0) : c.on("observerUpdate", onResize, !0) }, "detachEvents": function detachEvents() { var c = this, u = getDocument(), d = c.params, v = c.touchEvents, E = c.el, k = c.wrapperEl, R = c.device, U = c.support, H = !!d.nested; if (!U.touch && U.pointerEvents) E.removeEventListener(v.start, c.onTouchStart, !1), u.removeEventListener(v.move, c.onTouchMove, H), u.removeEventListener(v.end, c.onTouchEnd, !1); else { if (U.touch) { var G = !("onTouchStart" !== v.start || !U.passiveListener || !d.passiveListeners) && { "passive": !0, "capture": !1 }; E.removeEventListener(v.start, c.onTouchStart, G), E.removeEventListener(v.move, c.onTouchMove, H), E.removeEventListener(v.end, c.onTouchEnd, G), v.cancel && E.removeEventListener(v.cancel, c.onTouchEnd, G) } (d.simulateTouch && !R.ios && !R.android || d.simulateTouch && !U.touch && R.ios) && (E.removeEventListener("mousedown", c.onTouchStart, !1), u.removeEventListener("mousemove", c.onTouchMove, H), u.removeEventListener("mouseup", c.onTouchEnd, !1)) } (d.preventClicks || d.preventClicksPropagation) && E.removeEventListener("click", c.onClick, !0), d.cssMode && k.removeEventListener("scroll", c.onScroll), c.off(R.ios || R.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize) } }; var ae = { "setBreakpoint": function setBreakpoint() { var c = this, u = c.activeIndex, d = c.initialized, v = c.loopedSlides, E = void 0 === v ? 0 : v, k = c.params, R = c.$el, U = k.breakpoints; if (U && (!U || 0 !== Object.keys(U).length)) { var H = c.getBreakpoint(U, c.params.breakpointsBase, c.el); if (H && c.currentBreakpoint !== H) { var G = H in U ? U[H] : void 0; G && ["slidesPerView", "spaceBetween", "slidesPerGroup", "slidesPerGroupSkip", "slidesPerColumn"].forEach((function (c) { var u = G[c]; void 0 !== u && (G[c] = "slidesPerView" !== c || "AUTO" !== u && "auto" !== u ? "slidesPerView" === c ? parseFloat(u) : parseInt(u, 10) : "auto") })); var W = G || c.originalParams, Z = k.slidesPerColumn > 1, Y = W.slidesPerColumn > 1, J = k.enabled; Z && !Y ? (R.removeClass(k.containerModifierClass + "multirow " + k.containerModifierClass + "multirow-column"), c.emitContainerClasses()) : !Z && Y && (R.addClass(k.containerModifierClass + "multirow"), "column" === W.slidesPerColumnFill && R.addClass(k.containerModifierClass + "multirow-column"), c.emitContainerClasses()); var K = W.direction && W.direction !== k.direction, X = k.loop && (W.slidesPerView !== k.slidesPerView || K); K && d && c.changeDirection(), utils_extend(c.params, W); var Q = c.params.enabled; utils_extend(c, { "allowTouchMove": c.params.allowTouchMove, "allowSlideNext": c.params.allowSlideNext, "allowSlidePrev": c.params.allowSlidePrev }), J && !Q ? c.disable() : !J && Q && c.enable(), c.currentBreakpoint = H, c.emit("_beforeBreakpoint", W), X && d && (c.loopDestroy(), c.loopCreate(), c.updateSlides(), c.slideTo(u - E + c.loopedSlides, 0, !1)), c.emit("breakpoint", W) } } }, "getBreakpoint": function getBreakpoint(c, u, d) { if (void 0 === u && (u = "window"), c && ("container" !== u || d)) { var v = !1, E = ssr_window_esm_getWindow(), k = "window" === u ? E.innerHeight : d.clientHeight, R = Object.keys(c).map((function (c) { if ("string" == typeof c && 0 === c.indexOf("@")) { var u = parseFloat(c.substr(1)); return { "value": k * u, "point": c } } return { "value": c, "point": c } })); R.sort((function (c, u) { return parseInt(c.value, 10) - parseInt(u.value, 10) })); for (var U = 0; U < R.length; U += 1) { var H = R[U], G = H.point, W = H.value; "window" === u ? E.matchMedia("(min-width: " + W + "px)").matches && (v = G) : W <= d.clientWidth && (v = G) } return v || "max" } } }; var se = { "addClasses": function addClasses() { var c = this, u = c.classNames, d = c.params, v = c.rtl, E = c.$el, k = c.device, R = c.support, U = function prepareClasses(c, u) { var d = []; return c.forEach((function (c) { "object" == typeof c ? Object.keys(c).forEach((function (v) { c[v] && d.push(u + v) })) : "string" == typeof c && d.push(u + c) })), d }(["initialized", d.direction, { "pointer-events": R.pointerEvents && !R.touch }, { "free-mode": d.freeMode }, { "autoheight": d.autoHeight }, { "rtl": v }, { "multirow": d.slidesPerColumn > 1 }, { "multirow-column": d.slidesPerColumn > 1 && "column" === d.slidesPerColumnFill }, { "android": k.android }, { "ios": k.ios }, { "css-mode": d.cssMode }], d.containerModifierClass); u.push.apply(u, U), E.addClass([].concat(u).join(" ")), c.emitContainerClasses() }, "removeClasses": function removeClasses() { var c = this, u = c.$el, d = c.classNames; u.removeClass(d.join(" ")), c.emitContainerClasses() } }; var ce = { "init": !0, "direction": "horizontal", "touchEventsTarget": "container", "initialSlide": 0, "speed": 300, "cssMode": !1, "updateOnWindowResize": !0, "resizeObserver": !1, "nested": !1, "createElements": !1, "enabled": !0, "focusableElements": "input, select, option, textarea, button, video, label", "width": null, "height": null, "preventInteractionOnTransition": !1, "userAgent": null, "url": null, "edgeSwipeDetection": !1, "edgeSwipeThreshold": 20, "freeMode": !1, "freeModeMomentum": !0, "freeModeMomentumRatio": 1, "freeModeMomentumBounce": !0, "freeModeMomentumBounceRatio": 1, "freeModeMomentumVelocityRatio": 1, "freeModeSticky": !1, "freeModeMinimumVelocity": .02, "autoHeight": !1, "setWrapperSize": !1, "virtualTranslate": !1, "effect": "slide", "breakpoints": void 0, "breakpointsBase": "window", "spaceBetween": 0, "slidesPerView": 1, "slidesPerColumn": 1, "slidesPerColumnFill": "column", "slidesPerGroup": 1, "slidesPerGroupSkip": 0, "centeredSlides": !1, "centeredSlidesBounds": !1, "slidesOffsetBefore": 0, "slidesOffsetAfter": 0, "normalizeSlideIndex": !0, "centerInsufficientSlides": !1, "watchOverflow": !1, "roundLengths": !1, "touchRatio": 1, "touchAngle": 45, "simulateTouch": !0, "shortSwipes": !0, "longSwipes": !0, "longSwipesRatio": .5, "longSwipesMs": 300, "followFinger": !0, "allowTouchMove": !0, "threshold": 0, "touchMoveStopPropagation": !1, "touchStartPreventDefault": !0, "touchStartForcePreventDefault": !1, "touchReleaseOnEdges": !1, "uniqueNavElements": !0, "resistance": !0, "resistanceRatio": .85, "watchSlidesProgress": !1, "watchSlidesVisibility": !1, "grabCursor": !1, "preventClicks": !0, "preventClicksPropagation": !0, "slideToClickedSlide": !1, "preloadImages": !0, "updateOnImagesReady": !0, "loop": !1, "loopAdditionalSlides": 0, "loopedSlides": null, "loopFillGroupWithBlank": !1, "loopPreventsSlide": !0, "allowSlidePrev": !0, "allowSlideNext": !0, "swipeHandler": null, "noSwiping": !0, "noSwipingClass": "swiper-no-swiping", "noSwipingSelector": null, "passiveListeners": !0, "containerModifierClass": "swiper-container-", "slideClass": "swiper-slide", "slideBlankClass": "swiper-slide-invisible-blank", "slideActiveClass": "swiper-slide-active", "slideDuplicateActiveClass": "swiper-slide-duplicate-active", "slideVisibleClass": "swiper-slide-visible", "slideDuplicateClass": "swiper-slide-duplicate", "slideNextClass": "swiper-slide-next", "slideDuplicateNextClass": "swiper-slide-duplicate-next", "slidePrevClass": "swiper-slide-prev", "slideDuplicatePrevClass": "swiper-slide-duplicate-prev", "wrapperClass": "swiper-wrapper", "runCallbacksOnInit": !0, "_emitClasses": !1 }; function _defineProperties(c, u) { for (var d = 0; d < u.length; d++) { var v = u[d]; v.enumerable = v.enumerable || !1, v.configurable = !0, "value" in v && (v.writable = !0), Object.defineProperty(c, v.key, v) } } var le = { "modular": { "useParams": function useParams(c) { var u = this; u.modules && Object.keys(u.modules).forEach((function (d) { var v = u.modules[d]; v.params && utils_extend(c, v.params) })) }, "useModules": function useModules(c) { void 0 === c && (c = {}); var u = this; u.modules && Object.keys(u.modules).forEach((function (d) { var v = u.modules[d], E = c[d] || {}; v.on && u.on && Object.keys(v.on).forEach((function (c) { u.on(c, v.on[c]) })), v.create && v.create.bind(u)(E) })) } }, "eventsEmitter": X, "update": Q, "translate": ee, "transition": { "setTransition": function setTransition(c, u) { var d = this; d.params.cssMode || d.$wrapperEl.transition(c), d.emit("setTransition", c, u) }, "transitionStart": function transitionStart(c, u) { void 0 === c && (c = !0); var d = this, v = d.activeIndex, E = d.params, k = d.previousIndex; if (!E.cssMode) { E.autoHeight && d.updateAutoHeight(); var R = u; if (R || (R = v > k ? "next" : v < k ? "prev" : "reset"), d.emit("transitionStart"), c && v !== k) { if ("reset" === R) return void d.emit("slideResetTransitionStart"); d.emit("slideChangeTransitionStart"), "next" === R ? d.emit("slideNextTransitionStart") : d.emit("slidePrevTransitionStart") } } }, "transitionEnd": function transitionEnd_transitionEnd(c, u) { void 0 === c && (c = !0); var d = this, v = d.activeIndex, E = d.previousIndex, k = d.params; if (d.animating = !1, !k.cssMode) { d.setTransition(0); var R = u; if (R || (R = v > E ? "next" : v < E ? "prev" : "reset"), d.emit("transitionEnd"), c && v !== E) { if ("reset" === R) return void d.emit("slideResetTransitionEnd"); d.emit("slideChangeTransitionEnd"), "next" === R ? d.emit("slideNextTransitionEnd") : d.emit("slidePrevTransitionEnd") } } } }, "slide": te, "loop": ne, "grabCursor": { "setGrabCursor": function setGrabCursor(c) { var u = this; if (!(u.support.touch || !u.params.simulateTouch || u.params.watchOverflow && u.isLocked || u.params.cssMode)) { var d = u.el; d.style.cursor = "move", d.style.cursor = c ? "-webkit-grabbing" : "-webkit-grab", d.style.cursor = c ? "-moz-grabbin" : "-moz-grab", d.style.cursor = c ? "grabbing" : "grab" } }, "unsetGrabCursor": function unsetGrabCursor() { var c = this; c.support.touch || c.params.watchOverflow && c.isLocked || c.params.cssMode || (c.el.style.cursor = "") } }, "manipulation": re, "events": ie, "breakpoints": ae, "checkOverflow": { "checkOverflow": function checkOverflow() { var c = this, u = c.params, d = c.isLocked, v = c.slides.length > 0 && u.slidesOffsetBefore + u.spaceBetween * (c.slides.length - 1) + c.slides[0].offsetWidth * c.slides.length; u.slidesOffsetBefore && u.slidesOffsetAfter && v ? c.isLocked = v <= c.size : c.isLocked = 1 === c.snapGrid.length, c.allowSlideNext = !c.isLocked, c.allowSlidePrev = !c.isLocked, d !== c.isLocked && c.emit(c.isLocked ? "lock" : "unlock"), d && d !== c.isLocked && (c.isEnd = !1, c.navigation && c.navigation.update()) } }, "classes": se, "images": { "loadImage": function loadImage(c, u, d, v, E, k) { var R, U = ssr_window_esm_getWindow(); function onReady() { k && k() } Z(c).parent("picture")[0] || c.complete && E ? onReady() : u ? ((R = new U.Image).onload = onReady, R.onerror = onReady, v && (R.sizes = v), d && (R.srcset = d), u && (R.src = u)) : onReady() }, "preloadImages": function preloadImages() { var c = this; function onReady() { null != c && c && !c.destroyed && (void 0 !== c.imagesLoaded && (c.imagesLoaded += 1), c.imagesLoaded === c.imagesToLoad.length && (c.params.updateOnImagesReady && c.update(), c.emit("imagesReady"))) } c.imagesToLoad = c.$el.find("img"); for (var u = 0; u < c.imagesToLoad.length; u += 1) { var d = c.imagesToLoad[u]; c.loadImage(d, d.currentSrc || d.getAttribute("src"), d.srcset || d.getAttribute("srcset"), d.sizes || d.getAttribute("sizes"), !0, onReady) } } } }, ue = {}, de = function () { function Swiper() { for (var c, u, d = arguments.length, v = new Array(d), E = 0; E < d; E++)v[E] = arguments[E]; if (1 === v.length && v[0].constructor && "Object" === Object.prototype.toString.call(v[0]).slice(8, -1) ? u = v[0] : (c = v[0], u = v[1]), u || (u = {}), u = utils_extend({}, u), c && !u.el && (u.el = c), u.el && Z(u.el).length > 1) { var k = []; return Z(u.el).each((function (c) { var d = utils_extend({}, u, { "el": c }); k.push(new Swiper(d)) })), k } var R = this; R.__swiper__ = !0, R.support = getSupport(), R.device = getDevice({ "userAgent": u.userAgent }), R.browser = getBrowser(), R.eventsListeners = {}, R.eventsAnyListeners = [], void 0 === R.modules && (R.modules = {}), Object.keys(R.modules).forEach((function (c) { var d = R.modules[c]; if (d.params) { var v = Object.keys(d.params)[0], E = d.params[v]; if ("object" != typeof E || null === E) return; if (["navigation", "pagination", "scrollbar"].indexOf(v) >= 0 && !0 === u[v] && (u[v] = { "auto": !0 }), !(v in u) || !("enabled" in E)) return; !0 === u[v] && (u[v] = { "enabled": !0 }), "object" != typeof u[v] || "enabled" in u[v] || (u[v].enabled = !0), u[v] || (u[v] = { "enabled": !1 }) } })); var U = utils_extend({}, ce); return R.useParams(U), R.params = utils_extend({}, U, ue, u), R.originalParams = utils_extend({}, R.params), R.passedParams = utils_extend({}, u), R.params && R.params.on && Object.keys(R.params.on).forEach((function (c) { R.on(c, R.params.on[c]) })), R.params && R.params.onAny && R.onAny(R.params.onAny), R.$ = Z, utils_extend(R, { "enabled": R.params.enabled, "el": c, "classNames": [], "slides": Z(), "slidesGrid": [], "snapGrid": [], "slidesSizesGrid": [], "isHorizontal": function isHorizontal() { return "horizontal" === R.params.direction }, "isVertical": function isVertical() { return "vertical" === R.params.direction }, "activeIndex": 0, "realIndex": 0, "isBeginning": !0, "isEnd": !1, "translate": 0, "previousTranslate": 0, "progress": 0, "velocity": 0, "animating": !1, "allowSlideNext": R.params.allowSlideNext, "allowSlidePrev": R.params.allowSlidePrev, "touchEvents": function touchEvents() { var c = ["touchstart", "touchmove", "touchend", "touchcancel"], u = ["mousedown", "mousemove", "mouseup"]; return R.support.pointerEvents && (u = ["pointerdown", "pointermove", "pointerup"]), R.touchEventsTouch = { "start": c[0], "move": c[1], "end": c[2], "cancel": c[3] }, R.touchEventsDesktop = { "start": u[0], "move": u[1], "end": u[2] }, R.support.touch || !R.params.simulateTouch ? R.touchEventsTouch : R.touchEventsDesktop }(), "touchEventsData": { "isTouched": void 0, "isMoved": void 0, "allowTouchCallbacks": void 0, "touchStartTime": void 0, "isScrolling": void 0, "currentTranslate": void 0, "startTranslate": void 0, "allowThresholdMove": void 0, "focusableElements": R.params.focusableElements, "lastClickTime": now(), "clickTimeout": void 0, "velocities": [], "allowMomentumBounce": void 0, "isTouchEvent": void 0, "startMoving": void 0 }, "allowClick": !0, "allowTouchMove": R.params.allowTouchMove, "touches": { "startX": 0, "startY": 0, "currentX": 0, "currentY": 0, "diff": 0 }, "imagesToLoad": [], "imagesLoaded": 0 }), R.useModules(), R.emit("_swiper"), R.params.init && R.init(), R } var c = Swiper.prototype; return c.enable = function enable() { var c = this; c.enabled || (c.enabled = !0, c.params.grabCursor && c.setGrabCursor(), c.emit("enable")) }, c.disable = function disable() { var c = this; c.enabled && (c.enabled = !1, c.params.grabCursor && c.unsetGrabCursor(), c.emit("disable")) }, c.setProgress = function setProgress(c, u) { var d = this; c = Math.min(Math.max(c, 0), 1); var v = d.minTranslate(), E = (d.maxTranslate() - v) * c + v; d.translateTo(E, void 0 === u ? 0 : u), d.updateActiveIndex(), d.updateSlidesClasses() }, c.emitContainerClasses = function emitContainerClasses() { var c = this; if (c.params._emitClasses && c.el) { var u = c.el.className.split(" ").filter((function (u) { return 0 === u.indexOf("swiper-container") || 0 === u.indexOf(c.params.containerModifierClass) })); c.emit("_containerClasses", u.join(" ")) } }, c.getSlideClasses = function getSlideClasses(c) { var u = this; return c.className.split(" ").filter((function (c) { return 0 === c.indexOf("swiper-slide") || 0 === c.indexOf(u.params.slideClass) })).join(" ") }, c.emitSlidesClasses = function emitSlidesClasses() { var c = this; if (c.params._emitClasses && c.el) { var u = []; c.slides.each((function (d) { var v = c.getSlideClasses(d); u.push({ "slideEl": d, "classNames": v }), c.emit("_slideClass", d, v) })), c.emit("_slideClasses", u) } }, c.slidesPerViewDynamic = function slidesPerViewDynamic() { var c = this, u = c.params, d = c.slides, v = c.slidesGrid, E = c.size, k = c.activeIndex, R = 1; if (u.centeredSlides) { for (var U, H = d[k].swiperSlideSize, G = k + 1; G < d.length; G += 1)d[G] && !U && (R += 1, (H += d[G].swiperSlideSize) > E && (U = !0)); for (var W = k - 1; W >= 0; W -= 1)d[W] && !U && (R += 1, (H += d[W].swiperSlideSize) > E && (U = !0)) } else for (var Z = k + 1; Z < d.length; Z += 1)v[Z] - v[k] < E && (R += 1); return R }, c.update = function update() { var c = this; if (c && !c.destroyed) { var u = c.snapGrid, d = c.params; d.breakpoints && c.setBreakpoint(), c.updateSize(), c.updateSlides(), c.updateProgress(), c.updateSlidesClasses(), c.params.freeMode ? (setTranslate(), c.params.autoHeight && c.updateAutoHeight()) : (("auto" === c.params.slidesPerView || c.params.slidesPerView > 1) && c.isEnd && !c.params.centeredSlides ? c.slideTo(c.slides.length - 1, 0, !1, !0) : c.slideTo(c.activeIndex, 0, !1, !0)) || setTranslate(), d.watchOverflow && u !== c.snapGrid && c.checkOverflow(), c.emit("update") } function setTranslate() { var u = c.rtlTranslate ? -1 * c.translate : c.translate, d = Math.min(Math.max(u, c.maxTranslate()), c.minTranslate()); c.setTranslate(d), c.updateActiveIndex(), c.updateSlidesClasses() } }, c.changeDirection = function changeDirection(c, u) { void 0 === u && (u = !0); var d = this, v = d.params.direction; return c || (c = "horizontal" === v ? "vertical" : "horizontal"), c === v || "horizontal" !== c && "vertical" !== c || (d.$el.removeClass("" + d.params.containerModifierClass + v).addClass("" + d.params.containerModifierClass + c), d.emitContainerClasses(), d.params.direction = c, d.slides.each((function (u) { "vertical" === c ? u.style.width = "" : u.style.height = "" })), d.emit("changeDirection"), u && d.update()), d }, c.mount = function mount(c) { var u = this; if (u.mounted) return !0; var d = Z(c || u.params.el); if (!(c = d[0])) return !1; c.swiper = u; var v = function getWrapperSelector() { return "." + (u.params.wrapperClass || "").trim().split(" ").join(".") }, E = function getWrapper() { if (c && c.shadowRoot && c.shadowRoot.querySelector) { var u = Z(c.shadowRoot.querySelector(v())); return u.children = function (c) { return d.children(c) }, u } return d.children(v()) }(); if (0 === E.length && u.params.createElements) { var k = getDocument().createElement("div"); E = Z(k), k.className = u.params.wrapperClass, d.append(k), d.children("." + u.params.slideClass).each((function (c) { E.append(c) })) } return utils_extend(u, { "$el": d, "el": c, "$wrapperEl": E, "wrapperEl": E[0], "mounted": !0, "rtl": "rtl" === c.dir.toLowerCase() || "rtl" === d.css("direction"), "rtlTranslate": "horizontal" === u.params.direction && ("rtl" === c.dir.toLowerCase() || "rtl" === d.css("direction")), "wrongRTL": "-webkit-box" === E.css("display") }), !0 }, c.init = function init(c) { var u = this; return u.initialized || !1 === u.mount(c) || (u.emit("beforeInit"), u.params.breakpoints && u.setBreakpoint(), u.addClasses(), u.params.loop && u.loopCreate(), u.updateSize(), u.updateSlides(), u.params.watchOverflow && u.checkOverflow(), u.params.grabCursor && u.enabled && u.setGrabCursor(), u.params.preloadImages && u.preloadImages(), u.params.loop ? u.slideTo(u.params.initialSlide + u.loopedSlides, 0, u.params.runCallbacksOnInit, !1, !0) : u.slideTo(u.params.initialSlide, 0, u.params.runCallbacksOnInit, !1, !0), u.attachEvents(), u.initialized = !0, u.emit("init"), u.emit("afterInit")), u }, c.destroy = function destroy(c, u) { void 0 === c && (c = !0), void 0 === u && (u = !0); var d = this, v = d.params, E = d.$el, k = d.$wrapperEl, R = d.slides; return void 0 === d.params || d.destroyed || (d.emit("beforeDestroy"), d.initialized = !1, d.detachEvents(), v.loop && d.loopDestroy(), u && (d.removeClasses(), E.removeAttr("style"), k.removeAttr("style"), R && R.length && R.removeClass([v.slideVisibleClass, v.slideActiveClass, v.slideNextClass, v.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index")), d.emit("destroy"), Object.keys(d.eventsListeners).forEach((function (c) { d.off(c) })), !1 !== c && (d.$el[0].swiper = null, function deleteProps(c) { var u = c; Object.keys(u).forEach((function (c) { try { u[c] = null } catch (c) { } try { delete u[c] } catch (c) { } })) }(d)), d.destroyed = !0), null }, Swiper.extendDefaults = function extendDefaults(c) { utils_extend(ue, c) }, Swiper.installModule = function installModule(c) { Swiper.prototype.modules || (Swiper.prototype.modules = {}); var u = c.name || Object.keys(Swiper.prototype.modules).length + "_" + now(); Swiper.prototype.modules[u] = c }, Swiper.use = function use(c) { return Array.isArray(c) ? (c.forEach((function (c) { return Swiper.installModule(c) })), Swiper) : (Swiper.installModule(c), Swiper) }, function _createClass(c, u, d) { return u && _defineProperties(c.prototype, u), d && _defineProperties(c, d), c }(Swiper, null, [{ "key": "extendedDefaults", "get": function get() { return ue } }, { "key": "defaults", "get": function get() { return ce } }]), Swiper }(); Object.keys(le).forEach((function (c) { Object.keys(le[c]).forEach((function (u) { de.prototype[u] = le[c][u] })) })), de.use([Y, K]); var pe = de; function virtual_extends() { return virtual_extends = Object.assign || function (c) { for (var u = 1; u < arguments.length; u++) { var d = arguments[u]; for (var v in d) Object.prototype.hasOwnProperty.call(d, v) && (c[v] = d[v]) } return c }, virtual_extends.apply(this, arguments) } var fe = { "update": function update(c) { var u = this, d = u.params, v = d.slidesPerView, E = d.slidesPerGroup, k = d.centeredSlides, R = u.params.virtual, U = R.addSlidesBefore, H = R.addSlidesAfter, G = u.virtual, W = G.from, Z = G.to, Y = G.slides, J = G.slidesGrid, K = G.renderSlide, X = G.offset; u.updateActiveIndex(); var Q, ee, te, ne = u.activeIndex || 0; Q = u.rtlTranslate ? "right" : u.isHorizontal() ? "left" : "top", k ? (ee = Math.floor(v / 2) + E + H, te = Math.floor(v / 2) + E + U) : (ee = v + (E - 1) + H, te = E + U); var re = Math.max((ne || 0) - te, 0), oe = Math.min((ne || 0) + ee, Y.length - 1), ie = (u.slidesGrid[re] || 0) - (u.slidesGrid[0] || 0); function onRendered() { u.updateSlides(), u.updateProgress(), u.updateSlidesClasses(), u.lazy && u.params.lazy.enabled && u.lazy.load() } if (utils_extend(u.virtual, { "from": re, "to": oe, "offset": ie, "slidesGrid": u.slidesGrid }), W === re && Z === oe && !c) return u.slidesGrid !== J && ie !== X && u.slides.css(Q, ie + "px"), void u.updateProgress(); if (u.params.virtual.renderExternal) return u.params.virtual.renderExternal.call(u, { "offset": ie, "from": re, "to": oe, "slides": function getSlides() { for (var c = [], u = re; u <= oe; u += 1)c.push(Y[u]); return c }() }), void (u.params.virtual.renderExternalUpdate && onRendered()); var ae = [], se = []; if (c) u.$wrapperEl.find("." + u.params.slideClass).remove(); else for (var ce = W; ce <= Z; ce += 1)(ce < re || ce > oe) && u.$wrapperEl.find("." + u.params.slideClass + '[data-swiper-slide-index="' + ce + '"]').remove(); for (var le = 0; le < Y.length; le += 1)le >= re && le <= oe && (void 0 === Z || c ? se.push(le) : (le > Z && se.push(le), le < W && ae.push(le))); se.forEach((function (c) { u.$wrapperEl.append(K(Y[c], c)) })), ae.sort((function (c, u) { return u - c })).forEach((function (c) { u.$wrapperEl.prepend(K(Y[c], c)) })), u.$wrapperEl.children(".swiper-slide").css(Q, ie + "px"), onRendered() }, "renderSlide": function renderSlide(c, u) { var d = this, v = d.params.virtual; if (v.cache && d.virtual.cache[u]) return d.virtual.cache[u]; var E = v.renderSlide ? Z(v.renderSlide.call(d, c, u)) : Z('<div class="' + d.params.slideClass + '" data-swiper-slide-index="' + u + '">' + c + "</div>"); return E.attr("data-swiper-slide-index") || E.attr("data-swiper-slide-index", u), v.cache && (d.virtual.cache[u] = E), E }, "appendSlide": function appendSlide(c) { var u = this; if ("object" == typeof c && "length" in c) for (var d = 0; d < c.length; d += 1)c[d] && u.virtual.slides.push(c[d]); else u.virtual.slides.push(c); u.virtual.update(!0) }, "prependSlide": function prependSlide(c) { var u = this, d = u.activeIndex, v = d + 1, E = 1; if (Array.isArray(c)) { for (var k = 0; k < c.length; k += 1)c[k] && u.virtual.slides.unshift(c[k]); v = d + c.length, E = c.length } else u.virtual.slides.unshift(c); if (u.params.virtual.cache) { var R = u.virtual.cache, U = {}; Object.keys(R).forEach((function (c) { var u = R[c], d = u.attr("data-swiper-slide-index"); d && u.attr("data-swiper-slide-index", parseInt(d, 10) + 1), U[parseInt(c, 10) + E] = u })), u.virtual.cache = U } u.virtual.update(!0), u.slideTo(v, 0) }, "removeSlide": function removeSlide(c) { var u = this; if (null != c) { var d = u.activeIndex; if (Array.isArray(c)) for (var v = c.length - 1; v >= 0; v -= 1)u.virtual.slides.splice(c[v], 1), u.params.virtual.cache && delete u.virtual.cache[c[v]], c[v] < d && (d -= 1), d = Math.max(d, 0); else u.virtual.slides.splice(c, 1), u.params.virtual.cache && delete u.virtual.cache[c], c < d && (d -= 1), d = Math.max(d, 0); u.virtual.update(!0), u.slideTo(d, 0) } }, "removeAllSlides": function removeAllSlides() { var c = this; c.virtual.slides = [], c.params.virtual.cache && (c.virtual.cache = {}), c.virtual.update(!0), c.slideTo(0, 0) } }, he = { "name": "virtual", "params": { "virtual": { "enabled": !1, "slides": [], "cache": !0, "renderSlide": null, "renderExternal": null, "renderExternalUpdate": !0, "addSlidesBefore": 0, "addSlidesAfter": 0 } }, "create": function create() { bindModuleMethods(this, { "virtual": virtual_extends({}, fe, { "slides": this.params.virtual.slides, "cache": {} }) }) }, "on": { "beforeInit": function beforeInit(c) { if (c.params.virtual.enabled) { c.classNames.push(c.params.containerModifierClass + "virtual"); var u = { "watchSlidesProgress": !0 }; utils_extend(c.params, u), utils_extend(c.originalParams, u), c.params.initialSlide || c.virtual.update() } }, "setTranslate": function setTranslate(c) { c.params.virtual.enabled && c.virtual.update() } } }; function keyboard_extends() { return keyboard_extends = Object.assign || function (c) { for (var u = 1; u < arguments.length; u++) { var d = arguments[u]; for (var v in d) Object.prototype.hasOwnProperty.call(d, v) && (c[v] = d[v]) } return c }, keyboard_extends.apply(this, arguments) } var me = { "handle": function handle(c) { var u = this; if (u.enabled) { var d = ssr_window_esm_getWindow(), v = getDocument(), E = u.rtlTranslate, k = c; k.originalEvent && (k = k.originalEvent); var R = k.keyCode || k.charCode, U = u.params.keyboard.pageUpDown, H = U && 33 === R, G = U && 34 === R, W = 37 === R, Z = 39 === R, Y = 38 === R, J = 40 === R; if (!u.allowSlideNext && (u.isHorizontal() && Z || u.isVertical() && J || G)) return !1; if (!u.allowSlidePrev && (u.isHorizontal() && W || u.isVertical() && Y || H)) return !1; if (!(k.shiftKey || k.altKey || k.ctrlKey || k.metaKey || v.activeElement && v.activeElement.nodeName && ("input" === v.activeElement.nodeName.toLowerCase() || "textarea" === v.activeElement.nodeName.toLowerCase()))) { if (u.params.keyboard.onlyInViewport && (H || G || W || Z || Y || J)) { var K = !1; if (u.$el.parents("." + u.params.slideClass).length > 0 && 0 === u.$el.parents("." + u.params.slideActiveClass).length) return; var X = u.$el, Q = X[0].clientWidth, ee = X[0].clientHeight, te = d.innerWidth, ne = d.innerHeight, re = u.$el.offset(); E && (re.left -= u.$el[0].scrollLeft); for (var oe = [[re.left, re.top], [re.left + Q, re.top], [re.left, re.top + ee], [re.left + Q, re.top + ee]], ie = 0; ie < oe.length; ie += 1) { var ae = oe[ie]; if (ae[0] >= 0 && ae[0] <= te && ae[1] >= 0 && ae[1] <= ne) { if (0 === ae[0] && 0 === ae[1]) continue; K = !0 } } if (!K) return } u.isHorizontal() ? ((H || G || W || Z) && (k.preventDefault ? k.preventDefault() : k.returnValue = !1), ((G || Z) && !E || (H || W) && E) && u.slideNext(), ((H || W) && !E || (G || Z) && E) && u.slidePrev()) : ((H || G || Y || J) && (k.preventDefault ? k.preventDefault() : k.returnValue = !1), (G || J) && u.slideNext(), (H || Y) && u.slidePrev()), u.emit("keyPress", R) } } }, "enable": function enable() { var c = this, u = getDocument(); c.keyboard.enabled || (Z(u).on("keydown", c.keyboard.handle), c.keyboard.enabled = !0) }, "disable": function disable() { var c = this, u = getDocument(); c.keyboard.enabled && (Z(u).off("keydown", c.keyboard.handle), c.keyboard.enabled = !1) } }, ge = { "name": "keyboard", "params": { "keyboard": { "enabled": !1, "onlyInViewport": !0, "pageUpDown": !0 } }, "create": function create() { bindModuleMethods(this, { "keyboard": keyboard_extends({ "enabled": !1 }, me) }) }, "on": { "init": function init(c) { c.params.keyboard.enabled && c.keyboard.enable() }, "destroy": function destroy(c) { c.keyboard.enabled && c.keyboard.disable() } } }; var _e = { "lastScrollTime": now(), "lastEventBeforeSnap": void 0, "recentWheelEvents": [], "event": function event() { return ssr_window_esm_getWindow().navigator.userAgent.indexOf("firefox") > -1 ? "DOMMouseScroll" : function isEventSupported() { var c = getDocument(), u = "onwheel", d = u in c; if (!d) { var v = c.createElement("div"); v.setAttribute(u, "return;"), d = "function" == typeof v[u] } return !d && c.implementation && c.implementation.hasFeature && !0 !== c.implementation.hasFeature("", "") && (d = c.implementation.hasFeature("Events.wheel", "3.0")), d }() ? "wheel" : "mousewheel" }, "normalize": function normalize(c) { var u = 0, d = 0, v = 0, E = 0; return "detail" in c && (d = c.detail), "wheelDelta" in c && (d = -c.wheelDelta / 120), "wheelDeltaY" in c && (d = -c.wheelDeltaY / 120), "wheelDeltaX" in c && (u = -c.wheelDeltaX / 120), "axis" in c && c.axis === c.HORIZONTAL_AXIS && (u = d, d = 0), v = 10 * u, E = 10 * d, "deltaY" in c && (E = c.deltaY), "deltaX" in c && (v = c.deltaX), c.shiftKey && !v && (v = E, E = 0), (v || E) && c.deltaMode && (1 === c.deltaMode ? (v *= 40, E *= 40) : (v *= 800, E *= 800)), v && !u && (u = v < 1 ? -1 : 1), E && !d && (d = E < 1 ? -1 : 1), { "spinX": u, "spinY": d, "pixelX": v, "pixelY": E } }, "handleMouseEnter": function handleMouseEnter() { this.enabled && (this.mouseEntered = !0) }, "handleMouseLeave": function handleMouseLeave() { this.enabled && (this.mouseEntered = !1) }, "handle": function handle(c) { var u = c, d = this; if (d.enabled) { var v = d.params.mousewheel; d.params.cssMode && u.preventDefault(); var E = d.$el; if ("container" !== d.params.mousewheel.eventsTarget && (E = Z(d.params.mousewheel.eventsTarget)), !d.mouseEntered && !E[0].contains(u.target) && !v.releaseOnEdges) return !0; u.originalEvent && (u = u.originalEvent); var k = 0, R = d.rtlTranslate ? -1 : 1, U = _e.normalize(u); if (v.forceToAxis) if (d.isHorizontal()) { if (!(Math.abs(U.pixelX) > Math.abs(U.pixelY))) return !0; k = -U.pixelX * R } else { if (!(Math.abs(U.pixelY) > Math.abs(U.pixelX))) return !0; k = -U.pixelY } else k = Math.abs(U.pixelX) > Math.abs(U.pixelY) ? -U.pixelX * R : -U.pixelY; if (0 === k) return !0; v.invert && (k = -k); var H = d.getTranslate() + k * v.sensitivity; if (H >= d.minTranslate() && (H = d.minTranslate()), H <= d.maxTranslate() && (H = d.maxTranslate()), (!!d.params.loop || !(H === d.minTranslate() || H === d.maxTranslate())) && d.params.nested && u.stopPropagation(), d.params.freeMode) { var G = { "time": now(), "delta": Math.abs(k), "direction": Math.sign(k) }, W = d.mousewheel.lastEventBeforeSnap, Y = W && G.time < W.time + 500 && G.delta <= W.delta && G.direction === W.direction; if (!Y) { d.mousewheel.lastEventBeforeSnap = void 0, d.params.loop && d.loopFix(); var J = d.getTranslate() + k * v.sensitivity, K = d.isBeginning, X = d.isEnd; if (J >= d.minTranslate() && (J = d.minTranslate()), J <= d.maxTranslate() && (J = d.maxTranslate()), d.setTransition(0), d.setTranslate(J), d.updateProgress(), d.updateActiveIndex(), d.updateSlidesClasses(), (!K && d.isBeginning || !X && d.isEnd) && d.updateSlidesClasses(), d.params.freeModeSticky) { clearTimeout(d.mousewheel.timeout), d.mousewheel.timeout = void 0; var Q = d.mousewheel.recentWheelEvents; Q.length >= 15 && Q.shift(); var ee = Q.length ? Q[Q.length - 1] : void 0, te = Q[0]; if (Q.push(G), ee && (G.delta > ee.delta || G.direction !== ee.direction)) Q.splice(0); else if (Q.length >= 15 && G.time - te.time < 500 && te.delta - G.delta >= 1 && G.delta <= 6) { var ne = k > 0 ? .8 : .2; d.mousewheel.lastEventBeforeSnap = G, Q.splice(0), d.mousewheel.timeout = nextTick((function () { d.slideToClosest(d.params.speed, !0, void 0, ne) }), 0) } d.mousewheel.timeout || (d.mousewheel.timeout = nextTick((function () { d.mousewheel.lastEventBeforeSnap = G, Q.splice(0), d.slideToClosest(d.params.speed, !0, void 0, .5) }), 500)) } if (Y || d.emit("scroll", u), d.params.autoplay && d.params.autoplayDisableOnInteraction && d.autoplay.stop(), J === d.minTranslate() || J === d.maxTranslate()) return !0 } } else { var re = { "time": now(), "delta": Math.abs(k), "direction": Math.sign(k), "raw": c }, oe = d.mousewheel.recentWheelEvents; oe.length >= 2 && oe.shift(); var ie = oe.length ? oe[oe.length - 1] : void 0; if (oe.push(re), ie ? (re.direction !== ie.direction || re.delta > ie.delta || re.time > ie.time + 150) && d.mousewheel.animateSlider(re) : d.mousewheel.animateSlider(re), d.mousewheel.releaseScroll(re)) return !0 } return u.preventDefault ? u.preventDefault() : u.returnValue = !1, !1 } }, "animateSlider": function animateSlider(c) { var u = this, d = ssr_window_esm_getWindow(); return !(this.params.mousewheel.thresholdDelta && c.delta < this.params.mousewheel.thresholdDelta) && (!(this.params.mousewheel.thresholdTime && now() - u.mousewheel.lastScrollTime < this.params.mousewheel.thresholdTime) && (c.delta >= 6 && now() - u.mousewheel.lastScrollTime < 60 || (c.direction < 0 ? u.isEnd && !u.params.loop || u.animating || (u.slideNext(), u.emit("scroll", c.raw)) : u.isBeginning && !u.params.loop || u.animating || (u.slidePrev(), u.emit("scroll", c.raw)), u.mousewheel.lastScrollTime = (new d.Date).getTime(), !1))) }, "releaseScroll": function releaseScroll(c) { var u = this, d = u.params.mousewheel; if (c.direction < 0) { if (u.isEnd && !u.params.loop && d.releaseOnEdges) return !0 } else if (u.isBeginning && !u.params.loop && d.releaseOnEdges) return !0; return !1 }, "enable": function enable() { var c = this, u = _e.event(); if (c.params.cssMode) return c.wrapperEl.removeEventListener(u, c.mousewheel.handle), !0; if (!u) return !1; if (c.mousewheel.enabled) return !1; var d = c.$el; return "container" !== c.params.mousewheel.eventsTarget && (d = Z(c.params.mousewheel.eventsTarget)), d.on("mouseenter", c.mousewheel.handleMouseEnter), d.on("mouseleave", c.mousewheel.handleMouseLeave), d.on(u, c.mousewheel.handle), c.mousewheel.enabled = !0, !0 }, "disable": function disable() { var c = this, u = _e.event(); if (c.params.cssMode) return c.wrapperEl.addEventListener(u, c.mousewheel.handle), !0; if (!u) return !1; if (!c.mousewheel.enabled) return !1; var d = c.$el; return "container" !== c.params.mousewheel.eventsTarget && (d = Z(c.params.mousewheel.eventsTarget)), d.off(u, c.mousewheel.handle), c.mousewheel.enabled = !1, !0 } }; function navigation_extends() { return navigation_extends = Object.assign || function (c) { for (var u = 1; u < arguments.length; u++) { var d = arguments[u]; for (var v in d) Object.prototype.hasOwnProperty.call(d, v) && (c[v] = d[v]) } return c }, navigation_extends.apply(this, arguments) } var ve = { "toggleEl": function toggleEl(c, u) { c[u ? "addClass" : "removeClass"](this.params.navigation.disabledClass), c[0] && "BUTTON" === c[0].tagName && (c[0].disabled = u) }, "update": function update() { var c = this, u = c.params.navigation, d = c.navigation.toggleEl; if (!c.params.loop) { var v = c.navigation, E = v.$nextEl, k = v.$prevEl; k && k.length > 0 && (c.isBeginning ? d(k, !0) : d(k, !1), c.params.watchOverflow && c.enabled && k[c.isLocked ? "addClass" : "removeClass"](u.lockClass)), E && E.length > 0 && (c.isEnd ? d(E, !0) : d(E, !1), c.params.watchOverflow && c.enabled && E[c.isLocked ? "addClass" : "removeClass"](u.lockClass)) } }, "onPrevClick": function onPrevClick(c) { var u = this; c.preventDefault(), u.isBeginning && !u.params.loop || u.slidePrev() }, "onNextClick": function onNextClick(c) { var u = this; c.preventDefault(), u.isEnd && !u.params.loop || u.slideNext() }, "init": function init() { var c, u, d = this, v = d.params.navigation; (d.params.navigation = createElementIfNotDefined(d.$el, d.params.navigation, d.params.createElements, { "nextEl": "swiper-button-next", "prevEl": "swiper-button-prev" }), v.nextEl || v.prevEl) && (v.nextEl && (c = Z(v.nextEl), d.params.uniqueNavElements && "string" == typeof v.nextEl && c.length > 1 && 1 === d.$el.find(v.nextEl).length && (c = d.$el.find(v.nextEl))), v.prevEl && (u = Z(v.prevEl), d.params.uniqueNavElements && "string" == typeof v.prevEl && u.length > 1 && 1 === d.$el.find(v.prevEl).length && (u = d.$el.find(v.prevEl))), c && c.length > 0 && c.on("click", d.navigation.onNextClick), u && u.length > 0 && u.on("click", d.navigation.onPrevClick), utils_extend(d.navigation, { "$nextEl": c, "nextEl": c && c[0], "$prevEl": u, "prevEl": u && u[0] }), d.enabled || (c && c.addClass(v.lockClass), u && u.addClass(v.lockClass))) }, "destroy": function destroy() { var c = this, u = c.navigation, d = u.$nextEl, v = u.$prevEl; d && d.length && (d.off("click", c.navigation.onNextClick), d.removeClass(c.params.navigation.disabledClass)), v && v.length && (v.off("click", c.navigation.onPrevClick), v.removeClass(c.params.navigation.disabledClass)) } }; function pagination_extends() { return pagination_extends = Object.assign || function (c) { for (var u = 1; u < arguments.length; u++) { var d = arguments[u]; for (var v in d) Object.prototype.hasOwnProperty.call(d, v) && (c[v] = d[v]) } return c }, pagination_extends.apply(this, arguments) } var ye = { "update": function update() { var c = this, u = c.rtl, d = c.params.pagination; if (d.el && c.pagination.el && c.pagination.$el && 0 !== c.pagination.$el.length) { var v, E = c.virtual && c.params.virtual.enabled ? c.virtual.slides.length : c.slides.length, k = c.pagination.$el, R = c.params.loop ? Math.ceil((E - 2 * c.loopedSlides) / c.params.slidesPerGroup) : c.snapGrid.length; if (c.params.loop ? ((v = Math.ceil((c.activeIndex - c.loopedSlides) / c.params.slidesPerGroup)) > E - 1 - 2 * c.loopedSlides && (v -= E - 2 * c.loopedSlides), v > R - 1 && (v -= R), v < 0 && "bullets" !== c.params.paginationType && (v = R + v)) : v = void 0 !== c.snapIndex ? c.snapIndex : c.activeIndex || 0, "bullets" === d.type && c.pagination.bullets && c.pagination.bullets.length > 0) { var U, H, G, W = c.pagination.bullets; if (d.dynamicBullets && (c.pagination.bulletSize = W.eq(0)[c.isHorizontal() ? "outerWidth" : "outerHeight"](!0), k.css(c.isHorizontal() ? "width" : "height", c.pagination.bulletSize * (d.dynamicMainBullets + 4) + "px"), d.dynamicMainBullets > 1 && void 0 !== c.previousIndex && (c.pagination.dynamicBulletIndex += v - c.previousIndex, c.pagination.dynamicBulletIndex > d.dynamicMainBullets - 1 ? c.pagination.dynamicBulletIndex = d.dynamicMainBullets - 1 : c.pagination.dynamicBulletIndex < 0 && (c.pagination.dynamicBulletIndex = 0)), U = v - c.pagination.dynamicBulletIndex, G = ((H = U + (Math.min(W.length, d.dynamicMainBullets) - 1)) + U) / 2), W.removeClass(d.bulletActiveClass + " " + d.bulletActiveClass + "-next " + d.bulletActiveClass + "-next-next " + d.bulletActiveClass + "-prev " + d.bulletActiveClass + "-prev-prev " + d.bulletActiveClass + "-main"), k.length > 1) W.each((function (c) { var u = Z(c), E = u.index(); E === v && u.addClass(d.bulletActiveClass), d.dynamicBullets && (E >= U && E <= H && u.addClass(d.bulletActiveClass + "-main"), E === U && u.prev().addClass(d.bulletActiveClass + "-prev").prev().addClass(d.bulletActiveClass + "-prev-prev"), E === H && u.next().addClass(d.bulletActiveClass + "-next").next().addClass(d.bulletActiveClass + "-next-next")) })); else { var Y = W.eq(v), J = Y.index(); if (Y.addClass(d.bulletActiveClass), d.dynamicBullets) { for (var K = W.eq(U), X = W.eq(H), Q = U; Q <= H; Q += 1)W.eq(Q).addClass(d.bulletActiveClass + "-main"); if (c.params.loop) if (J >= W.length - d.dynamicMainBullets) { for (var ee = d.dynamicMainBullets; ee >= 0; ee -= 1)W.eq(W.length - ee).addClass(d.bulletActiveClass + "-main"); W.eq(W.length - d.dynamicMainBullets - 1).addClass(d.bulletActiveClass + "-prev") } else K.prev().addClass(d.bulletActiveClass + "-prev").prev().addClass(d.bulletActiveClass + "-prev-prev"), X.next().addClass(d.bulletActiveClass + "-next").next().addClass(d.bulletActiveClass + "-next-next"); else K.prev().addClass(d.bulletActiveClass + "-prev").prev().addClass(d.bulletActiveClass + "-prev-prev"), X.next().addClass(d.bulletActiveClass + "-next").next().addClass(d.bulletActiveClass + "-next-next") } } if (d.dynamicBullets) { var te = Math.min(W.length, d.dynamicMainBullets + 4), ne = (c.pagination.bulletSize * te - c.pagination.bulletSize) / 2 - G * c.pagination.bulletSize, re = u ? "right" : "left"; W.css(c.isHorizontal() ? re : "top", ne + "px") } } if ("fraction" === d.type && (k.find(classesToSelector(d.currentClass)).text(d.formatFractionCurrent(v + 1)), k.find(classesToSelector(d.totalClass)).text(d.formatFractionTotal(R))), "progressbar" === d.type) { var oe; oe = d.progressbarOpposite ? c.isHorizontal() ? "vertical" : "horizontal" : c.isHorizontal() ? "horizontal" : "vertical"; var ie = (v + 1) / R, ae = 1, se = 1; "horizontal" === oe ? ae = ie : se = ie, k.find(classesToSelector(d.progressbarFillClass)).transform("translate3d(0,0,0) scaleX(" + ae + ") scaleY(" + se + ")").transition(c.params.speed) } "custom" === d.type && d.renderCustom ? (k.html(d.renderCustom(c, v + 1, R)), c.emit("paginationRender", k[0])) : c.emit("paginationUpdate", k[0]), c.params.watchOverflow && c.enabled && k[c.isLocked ? "addClass" : "removeClass"](d.lockClass) } }, "render": function render() { var c = this, u = c.params.pagination; if (u.el && c.pagination.el && c.pagination.$el && 0 !== c.pagination.$el.length) { var d = c.virtual && c.params.virtual.enabled ? c.virtual.slides.length : c.slides.length, v = c.pagination.$el, E = ""; if ("bullets" === u.type) { var k = c.params.loop ? Math.ceil((d - 2 * c.loopedSlides) / c.params.slidesPerGroup) : c.snapGrid.length; c.params.freeMode && !c.params.loop && k > d && (k = d); for (var R = 0; R < k; R += 1)u.renderBullet ? E += u.renderBullet.call(c, R, u.bulletClass) : E += "<" + u.bulletElement + ' class="' + u.bulletClass + '"></' + u.bulletElement + ">"; v.html(E), c.pagination.bullets = v.find(classesToSelector(u.bulletClass)) } "fraction" === u.type && (E = u.renderFraction ? u.renderFraction.call(c, u.currentClass, u.totalClass) : '<span class="' + u.currentClass + '"></span> / <span class="' + u.totalClass + '"></span>', v.html(E)), "progressbar" === u.type && (E = u.renderProgressbar ? u.renderProgressbar.call(c, u.progressbarFillClass) : '<span class="' + u.progressbarFillClass + '"></span>', v.html(E)), "custom" !== u.type && c.emit("paginationRender", c.pagination.$el[0]) } }, "init": function init() { var c = this; c.params.pagination = createElementIfNotDefined(c.$el, c.params.pagination, c.params.createElements, { "el": "swiper-pagination" }); var u = c.params.pagination; if (u.el) { var d = Z(u.el); 0 !== d.length && (c.params.uniqueNavElements && "string" == typeof u.el && d.length > 1 && (d = c.$el.find(u.el)), "bullets" === u.type && u.clickable && d.addClass(u.clickableClass), d.addClass(u.modifierClass + u.type), "bullets" === u.type && u.dynamicBullets && (d.addClass("" + u.modifierClass + u.type + "-dynamic"), c.pagination.dynamicBulletIndex = 0, u.dynamicMainBullets < 1 && (u.dynamicMainBullets = 1)), "progressbar" === u.type && u.progressbarOpposite && d.addClass(u.progressbarOppositeClass), u.clickable && d.on("click", classesToSelector(u.bulletClass), (function onClick(u) { u.preventDefault(); var d = Z(this).index() * c.params.slidesPerGroup; c.params.loop && (d += c.loopedSlides), c.slideTo(d) })), utils_extend(c.pagination, { "$el": d, "el": d[0] }), c.enabled || d.addClass(u.lockClass)) } }, "destroy": function destroy() { var c = this, u = c.params.pagination; if (u.el && c.pagination.el && c.pagination.$el && 0 !== c.pagination.$el.length) { var d = c.pagination.$el; d.removeClass(u.hiddenClass), d.removeClass(u.modifierClass + u.type), c.pagination.bullets && c.pagination.bullets.removeClass(u.bulletActiveClass), u.clickable && d.off("click", classesToSelector(u.bulletClass)) } } }; function scrollbar_extends() { return scrollbar_extends = Object.assign || function (c) { for (var u = 1; u < arguments.length; u++) { var d = arguments[u]; for (var v in d) Object.prototype.hasOwnProperty.call(d, v) && (c[v] = d[v]) } return c }, scrollbar_extends.apply(this, arguments) } var be = { "setTranslate": function setTranslate() { var c = this; if (c.params.scrollbar.el && c.scrollbar.el) { var u = c.scrollbar, d = c.rtlTranslate, v = c.progress, E = u.dragSize, k = u.trackSize, R = u.$dragEl, U = u.$el, H = c.params.scrollbar, G = E, W = (k - E) * v; d ? (W = -W) > 0 ? (G = E - W, W = 0) : -W + E > k && (G = k + W) : W < 0 ? (G = E + W, W = 0) : W + E > k && (G = k - W), c.isHorizontal() ? (R.transform("translate3d(" + W + "px, 0, 0)"), R[0].style.width = G + "px") : (R.transform("translate3d(0px, " + W + "px, 0)"), R[0].style.height = G + "px"), H.hide && (clearTimeout(c.scrollbar.timeout), U[0].style.opacity = 1, c.scrollbar.timeout = setTimeout((function () { U[0].style.opacity = 0, U.transition(400) }), 1e3)) } }, "setTransition": function setTransition(c) { var u = this; u.params.scrollbar.el && u.scrollbar.el && u.scrollbar.$dragEl.transition(c) }, "updateSize": function updateSize() { var c = this; if (c.params.scrollbar.el && c.scrollbar.el) { var u = c.scrollbar, d = u.$dragEl, v = u.$el; d[0].style.width = "", d[0].style.height = ""; var E, k = c.isHorizontal() ? v[0].offsetWidth : v[0].offsetHeight, R = c.size / c.virtualSize, U = R * (k / c.size); E = "auto" === c.params.scrollbar.dragSize ? k * R : parseInt(c.params.scrollbar.dragSize, 10), c.isHorizontal() ? d[0].style.width = E + "px" : d[0].style.height = E + "px", v[0].style.display = R >= 1 ? "none" : "", c.params.scrollbar.hide && (v[0].style.opacity = 0), utils_extend(u, { "trackSize": k, "divider": R, "moveDivider": U, "dragSize": E }), c.params.watchOverflow && c.enabled && u.$el[c.isLocked ? "addClass" : "removeClass"](c.params.scrollbar.lockClass) } }, "getPointerPosition": function getPointerPosition(c) { return this.isHorizontal() ? "touchstart" === c.type || "touchmove" === c.type ? c.targetTouches[0].clientX : c.clientX : "touchstart" === c.type || "touchmove" === c.type ? c.targetTouches[0].clientY : c.clientY }, "setDragPosition": function setDragPosition(c) { var u, d = this, v = d.scrollbar, E = d.rtlTranslate, k = v.$el, R = v.dragSize, U = v.trackSize, H = v.dragStartPos; u = (v.getPointerPosition(c) - k.offset()[d.isHorizontal() ? "left" : "top"] - (null !== H ? H : R / 2)) / (U - R), u = Math.max(Math.min(u, 1), 0), E && (u = 1 - u); var G = d.minTranslate() + (d.maxTranslate() - d.minTranslate()) * u; d.updateProgress(G), d.setTranslate(G), d.updateActiveIndex(), d.updateSlidesClasses() }, "onDragStart": function onDragStart(c) { var u = this, d = u.params.scrollbar, v = u.scrollbar, E = u.$wrapperEl, k = v.$el, R = v.$dragEl; u.scrollbar.isTouched = !0, u.scrollbar.dragStartPos = c.target === R[0] || c.target === R ? v.getPointerPosition(c) - c.target.getBoundingClientRect()[u.isHorizontal() ? "left" : "top"] : null, c.preventDefault(), c.stopPropagation(), E.transition(100), R.transition(100), v.setDragPosition(c), clearTimeout(u.scrollbar.dragTimeout), k.transition(0), d.hide && k.css("opacity", 1), u.params.cssMode && u.$wrapperEl.css("scroll-snap-type", "none"), u.emit("scrollbarDragStart", c) }, "onDragMove": function onDragMove(c) { var u = this, d = u.scrollbar, v = u.$wrapperEl, E = d.$el, k = d.$dragEl; u.scrollbar.isTouched && (c.preventDefault ? c.preventDefault() : c.returnValue = !1, d.setDragPosition(c), v.transition(0), E.transition(0), k.transition(0), u.emit("scrollbarDragMove", c)) }, "onDragEnd": function onDragEnd(c) { var u = this, d = u.params.scrollbar, v = u.scrollbar, E = u.$wrapperEl, k = v.$el; u.scrollbar.isTouched && (u.scrollbar.isTouched = !1, u.params.cssMode && (u.$wrapperEl.css("scroll-snap-type", ""), E.transition("")), d.hide && (clearTimeout(u.scrollbar.dragTimeout), u.scrollbar.dragTimeout = nextTick((function () { k.css("opacity", 0), k.transition(400) }), 1e3)), u.emit("scrollbarDragEnd", c), d.snapOnRelease && u.slideToClosest()) }, "enableDraggable": function enableDraggable() { var c = this; if (c.params.scrollbar.el) { var u = getDocument(), d = c.scrollbar, v = c.touchEventsTouch, E = c.touchEventsDesktop, k = c.params, R = c.support, U = d.$el[0], H = !(!R.passiveListener || !k.passiveListeners) && { "passive": !1, "capture": !1 }, G = !(!R.passiveListener || !k.passiveListeners) && { "passive": !0, "capture": !1 }; U && (R.touch ? (U.addEventListener(v.start, c.scrollbar.onDragStart, H), U.addEventListener(v.move, c.scrollbar.onDragMove, H), U.addEventListener(v.end, c.scrollbar.onDragEnd, G)) : (U.addEventListener(E.start, c.scrollbar.onDragStart, H), u.addEventListener(E.move, c.scrollbar.onDragMove, H), u.addEventListener(E.end, c.scrollbar.onDragEnd, G))) } }, "disableDraggable": function disableDraggable() { var c = this; if (c.params.scrollbar.el) { var u = getDocument(), d = c.scrollbar, v = c.touchEventsTouch, E = c.touchEventsDesktop, k = c.params, R = c.support, U = d.$el[0], H = !(!R.passiveListener || !k.passiveListeners) && { "passive": !1, "capture": !1 }, G = !(!R.passiveListener || !k.passiveListeners) && { "passive": !0, "capture": !1 }; U && (R.touch ? (U.removeEventListener(v.start, c.scrollbar.onDragStart, H), U.removeEventListener(v.move, c.scrollbar.onDragMove, H), U.removeEventListener(v.end, c.scrollbar.onDragEnd, G)) : (U.removeEventListener(E.start, c.scrollbar.onDragStart, H), u.removeEventListener(E.move, c.scrollbar.onDragMove, H), u.removeEventListener(E.end, c.scrollbar.onDragEnd, G))) } }, "init": function init() { var c = this, u = c.scrollbar, d = c.$el; c.params.scrollbar = createElementIfNotDefined(d, c.params.scrollbar, c.params.createElements, { "el": "swiper-scrollbar" }); var v = c.params.scrollbar; if (v.el) { var E = Z(v.el); c.params.uniqueNavElements && "string" == typeof v.el && E.length > 1 && 1 === d.find(v.el).length && (E = d.find(v.el)); var k = E.find("." + c.params.scrollbar.dragClass); 0 === k.length && (k = Z('<div class="' + c.params.scrollbar.dragClass + '"></div>'), E.append(k)), utils_extend(u, { "$el": E, "el": E[0], "$dragEl": k, "dragEl": k[0] }), v.draggable && u.enableDraggable(), E && E[c.enabled ? "removeClass" : "addClass"](c.params.scrollbar.lockClass) } }, "destroy": function destroy() { this.scrollbar.disableDraggable() } }; function parallax_extends() { return parallax_extends = Object.assign || function (c) { for (var u = 1; u < arguments.length; u++) { var d = arguments[u]; for (var v in d) Object.prototype.hasOwnProperty.call(d, v) && (c[v] = d[v]) } return c }, parallax_extends.apply(this, arguments) } var Se = { "setTransform": function setTransform(c, u) { var d = this.rtl, v = Z(c), E = d ? -1 : 1, k = v.attr("data-swiper-parallax") || "0", R = v.attr("data-swiper-parallax-x"), U = v.attr("data-swiper-parallax-y"), H = v.attr("data-swiper-parallax-scale"), G = v.attr("data-swiper-parallax-opacity"); if (R || U ? (R = R || "0", U = U || "0") : this.isHorizontal() ? (R = k, U = "0") : (U = k, R = "0"), R = R.indexOf("%") >= 0 ? parseInt(R, 10) * u * E + "%" : R * u * E + "px", U = U.indexOf("%") >= 0 ? parseInt(U, 10) * u + "%" : U * u + "px", null != G) { var W = G - (G - 1) * (1 - Math.abs(u)); v[0].style.opacity = W } if (null == H) v.transform("translate3d(" + R + ", " + U + ", 0px)"); else { var Y = H - (H - 1) * (1 - Math.abs(u)); v.transform("translate3d(" + R + ", " + U + ", 0px) scale(" + Y + ")") } }, "setTranslate": function setTranslate() { var c = this, u = c.$el, d = c.slides, v = c.progress, E = c.snapGrid; u.children("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((function (u) { c.parallax.setTransform(u, v) })), d.each((function (u, d) { var k = u.progress; c.params.slidesPerGroup > 1 && "auto" !== c.params.slidesPerView && (k += Math.ceil(d / 2) - v * (E.length - 1)), k = Math.min(Math.max(k, -1), 1), Z(u).find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((function (u) { c.parallax.setTransform(u, k) })) })) }, "setTransition": function setTransition(c) { void 0 === c && (c = this.params.speed); this.$el.find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((function (u) { var d = Z(u), v = parseInt(d.attr("data-swiper-parallax-duration"), 10) || c; 0 === c && (v = 0), d.transition(v) })) } }; function zoom_extends() { return zoom_extends = Object.assign || function (c) { for (var u = 1; u < arguments.length; u++) { var d = arguments[u]; for (var v in d) Object.prototype.hasOwnProperty.call(d, v) && (c[v] = d[v]) } return c }, zoom_extends.apply(this, arguments) } var we = { "getDistanceBetweenTouches": function getDistanceBetweenTouches(c) { if (c.targetTouches.length < 2) return 1; var u = c.targetTouches[0].pageX, d = c.targetTouches[0].pageY, v = c.targetTouches[1].pageX, E = c.targetTouches[1].pageY; return Math.sqrt(Math.pow(v - u, 2) + Math.pow(E - d, 2)) }, "onGestureStart": function onGestureStart(c) { var u = this, d = u.support, v = u.params.zoom, E = u.zoom, k = E.gesture; if (E.fakeGestureTouched = !1, E.fakeGestureMoved = !1, !d.gestures) { if ("touchstart" !== c.type || "touchstart" === c.type && c.targetTouches.length < 2) return; E.fakeGestureTouched = !0, k.scaleStart = we.getDistanceBetweenTouches(c) } k.$slideEl && k.$slideEl.length || (k.$slideEl = Z(c.target).closest("." + u.params.slideClass), 0 === k.$slideEl.length && (k.$slideEl = u.slides.eq(u.activeIndex)), k.$imageEl = k.$slideEl.find("img, svg, canvas, picture, .swiper-zoom-target"), k.$imageWrapEl = k.$imageEl.parent("." + v.containerClass), k.maxRatio = k.$imageWrapEl.attr("data-swiper-zoom") || v.maxRatio, 0 !== k.$imageWrapEl.length) ? (k.$imageEl && k.$imageEl.transition(0), u.zoom.isScaling = !0) : k.$imageEl = void 0 }, "onGestureChange": function onGestureChange(c) { var u = this, d = u.support, v = u.params.zoom, E = u.zoom, k = E.gesture; if (!d.gestures) { if ("touchmove" !== c.type || "touchmove" === c.type && c.targetTouches.length < 2) return; E.fakeGestureMoved = !0, k.scaleMove = we.getDistanceBetweenTouches(c) } k.$imageEl && 0 !== k.$imageEl.length ? (d.gestures ? E.scale = c.scale * E.currentScale : E.scale = k.scaleMove / k.scaleStart * E.currentScale, E.scale > k.maxRatio && (E.scale = k.maxRatio - 1 + Math.pow(E.scale - k.maxRatio + 1, .5)), E.scale < v.minRatio && (E.scale = v.minRatio + 1 - Math.pow(v.minRatio - E.scale + 1, .5)), k.$imageEl.transform("translate3d(0,0,0) scale(" + E.scale + ")")) : "gesturechange" === c.type && E.onGestureStart(c) }, "onGestureEnd": function onGestureEnd(c) { var u = this, d = u.device, v = u.support, E = u.params.zoom, k = u.zoom, R = k.gesture; if (!v.gestures) { if (!k.fakeGestureTouched || !k.fakeGestureMoved) return; if ("touchend" !== c.type || "touchend" === c.type && c.changedTouches.length < 2 && !d.android) return; k.fakeGestureTouched = !1, k.fakeGestureMoved = !1 } R.$imageEl && 0 !== R.$imageEl.length && (k.scale = Math.max(Math.min(k.scale, R.maxRatio), E.minRatio), R.$imageEl.transition(u.params.speed).transform("translate3d(0,0,0) scale(" + k.scale + ")"), k.currentScale = k.scale, k.isScaling = !1, 1 === k.scale && (R.$slideEl = void 0)) }, "onTouchStart": function onTouchStart(c) { var u = this.device, d = this.zoom, v = d.gesture, E = d.image; v.$imageEl && 0 !== v.$imageEl.length && (E.isTouched || (u.android && c.cancelable && c.preventDefault(), E.isTouched = !0, E.touchesStart.x = "touchstart" === c.type ? c.targetTouches[0].pageX : c.pageX, E.touchesStart.y = "touchstart" === c.type ? c.targetTouches[0].pageY : c.pageY)) }, "onTouchMove": function onTouchMove(c) { var u = this, d = u.zoom, v = d.gesture, E = d.image, k = d.velocity; if (v.$imageEl && 0 !== v.$imageEl.length && (u.allowClick = !1, E.isTouched && v.$slideEl)) { E.isMoved || (E.width = v.$imageEl[0].offsetWidth, E.height = v.$imageEl[0].offsetHeight, E.startX = getTranslate(v.$imageWrapEl[0], "x") || 0, E.startY = getTranslate(v.$imageWrapEl[0], "y") || 0, v.slideWidth = v.$slideEl[0].offsetWidth, v.slideHeight = v.$slideEl[0].offsetHeight, v.$imageWrapEl.transition(0)); var R = E.width * d.scale, U = E.height * d.scale; if (!(R < v.slideWidth && U < v.slideHeight)) { if (E.minX = Math.min(v.slideWidth / 2 - R / 2, 0), E.maxX = -E.minX, E.minY = Math.min(v.slideHeight / 2 - U / 2, 0), E.maxY = -E.minY, E.touchesCurrent.x = "touchmove" === c.type ? c.targetTouches[0].pageX : c.pageX, E.touchesCurrent.y = "touchmove" === c.type ? c.targetTouches[0].pageY : c.pageY, !E.isMoved && !d.isScaling) { if (u.isHorizontal() && (Math.floor(E.minX) === Math.floor(E.startX) && E.touchesCurrent.x < E.touchesStart.x || Math.floor(E.maxX) === Math.floor(E.startX) && E.touchesCurrent.x > E.touchesStart.x)) return void (E.isTouched = !1); if (!u.isHorizontal() && (Math.floor(E.minY) === Math.floor(E.startY) && E.touchesCurrent.y < E.touchesStart.y || Math.floor(E.maxY) === Math.floor(E.startY) && E.touchesCurrent.y > E.touchesStart.y)) return void (E.isTouched = !1) } c.cancelable && c.preventDefault(), c.stopPropagation(), E.isMoved = !0, E.currentX = E.touchesCurrent.x - E.touchesStart.x + E.startX, E.currentY = E.touchesCurrent.y - E.touchesStart.y + E.startY, E.currentX < E.minX && (E.currentX = E.minX + 1 - Math.pow(E.minX - E.currentX + 1, .8)), E.currentX > E.maxX && (E.currentX = E.maxX - 1 + Math.pow(E.currentX - E.maxX + 1, .8)), E.currentY < E.minY && (E.currentY = E.minY + 1 - Math.pow(E.minY - E.currentY + 1, .8)), E.currentY > E.maxY && (E.currentY = E.maxY - 1 + Math.pow(E.currentY - E.maxY + 1, .8)), k.prevPositionX || (k.prevPositionX = E.touchesCurrent.x), k.prevPositionY || (k.prevPositionY = E.touchesCurrent.y), k.prevTime || (k.prevTime = Date.now()), k.x = (E.touchesCurrent.x - k.prevPositionX) / (Date.now() - k.prevTime) / 2, k.y = (E.touchesCurrent.y - k.prevPositionY) / (Date.now() - k.prevTime) / 2, Math.abs(E.touchesCurrent.x - k.prevPositionX) < 2 && (k.x = 0), Math.abs(E.touchesCurrent.y - k.prevPositionY) < 2 && (k.y = 0), k.prevPositionX = E.touchesCurrent.x, k.prevPositionY = E.touchesCurrent.y, k.prevTime = Date.now(), v.$imageWrapEl.transform("translate3d(" + E.currentX + "px, " + E.currentY + "px,0)") } } }, "onTouchEnd": function onTouchEnd() { var c = this.zoom, u = c.gesture, d = c.image, v = c.velocity; if (u.$imageEl && 0 !== u.$imageEl.length) { if (!d.isTouched || !d.isMoved) return d.isTouched = !1, void (d.isMoved = !1); d.isTouched = !1, d.isMoved = !1; var E = 300, k = 300, R = v.x * E, U = d.currentX + R, H = v.y * k, G = d.currentY + H; 0 !== v.x && (E = Math.abs((U - d.currentX) / v.x)), 0 !== v.y && (k = Math.abs((G - d.currentY) / v.y)); var W = Math.max(E, k); d.currentX = U, d.currentY = G; var Z = d.width * c.scale, Y = d.height * c.scale; d.minX = Math.min(u.slideWidth / 2 - Z / 2, 0), d.maxX = -d.minX, d.minY = Math.min(u.slideHeight / 2 - Y / 2, 0), d.maxY = -d.minY, d.currentX = Math.max(Math.min(d.currentX, d.maxX), d.minX), d.currentY = Math.max(Math.min(d.currentY, d.maxY), d.minY), u.$imageWrapEl.transition(W).transform("translate3d(" + d.currentX + "px, " + d.currentY + "px,0)") } }, "onTransitionEnd": function onTransitionEnd() { var c = this, u = c.zoom, d = u.gesture; d.$slideEl && c.previousIndex !== c.activeIndex && (d.$imageEl && d.$imageEl.transform("translate3d(0,0,0) scale(1)"), d.$imageWrapEl && d.$imageWrapEl.transform("translate3d(0,0,0)"), u.scale = 1, u.currentScale = 1, d.$slideEl = void 0, d.$imageEl = void 0, d.$imageWrapEl = void 0) }, "toggle": function toggle(c) { var u = this.zoom; u.scale && 1 !== u.scale ? u.out() : u.in(c) }, "in": function _in(c) { var u, d, v, E, k, R, U, H, G, W, Y, J, K, X, Q, ee, te = this, ne = ssr_window_esm_getWindow(), re = te.zoom, oe = te.params.zoom, ie = re.gesture, ae = re.image; (ie.$slideEl || (c && c.target && (ie.$slideEl = Z(c.target).closest("." + te.params.slideClass)), ie.$slideEl || (te.params.virtual && te.params.virtual.enabled && te.virtual ? ie.$slideEl = te.$wrapperEl.children("." + te.params.slideActiveClass) : ie.$slideEl = te.slides.eq(te.activeIndex)), ie.$imageEl = ie.$slideEl.find("img, svg, canvas, picture, .swiper-zoom-target"), ie.$imageWrapEl = ie.$imageEl.parent("." + oe.containerClass)), ie.$imageEl && 0 !== ie.$imageEl.length && ie.$imageWrapEl && 0 !== ie.$imageWrapEl.length) && (ie.$slideEl.addClass("" + oe.zoomedSlideClass), void 0 === ae.touchesStart.x && c ? (u = "touchend" === c.type ? c.changedTouches[0].pageX : c.pageX, d = "touchend" === c.type ? c.changedTouches[0].pageY : c.pageY) : (u = ae.touchesStart.x, d = ae.touchesStart.y), re.scale = ie.$imageWrapEl.attr("data-swiper-zoom") || oe.maxRatio, re.currentScale = ie.$imageWrapEl.attr("data-swiper-zoom") || oe.maxRatio, c ? (Q = ie.$slideEl[0].offsetWidth, ee = ie.$slideEl[0].offsetHeight, v = ie.$slideEl.offset().left + ne.scrollX + Q / 2 - u, E = ie.$slideEl.offset().top + ne.scrollY + ee / 2 - d, U = ie.$imageEl[0].offsetWidth, H = ie.$imageEl[0].offsetHeight, G = U * re.scale, W = H * re.scale, K = -(Y = Math.min(Q / 2 - G / 2, 0)), X = -(J = Math.min(ee / 2 - W / 2, 0)), (k = v * re.scale) < Y && (k = Y), k > K && (k = K), (R = E * re.scale) < J && (R = J), R > X && (R = X)) : (k = 0, R = 0), ie.$imageWrapEl.transition(300).transform("translate3d(" + k + "px, " + R + "px,0)"), ie.$imageEl.transition(300).transform("translate3d(0,0,0) scale(" + re.scale + ")")) }, "out": function out() { var c = this, u = c.zoom, d = c.params.zoom, v = u.gesture; v.$slideEl || (c.params.virtual && c.params.virtual.enabled && c.virtual ? v.$slideEl = c.$wrapperEl.children("." + c.params.slideActiveClass) : v.$slideEl = c.slides.eq(c.activeIndex), v.$imageEl = v.$slideEl.find("img, svg, canvas, picture, .swiper-zoom-target"), v.$imageWrapEl = v.$imageEl.parent("." + d.containerClass)), v.$imageEl && 0 !== v.$imageEl.length && v.$imageWrapEl && 0 !== v.$imageWrapEl.length && (u.scale = 1, u.currentScale = 1, v.$imageWrapEl.transition(300).transform("translate3d(0,0,0)"), v.$imageEl.transition(300).transform("translate3d(0,0,0) scale(1)"), v.$slideEl.removeClass("" + d.zoomedSlideClass), v.$slideEl = void 0) }, "toggleGestures": function toggleGestures(c) { var u = this, d = u.zoom, v = d.slideSelector, E = d.passiveListener; u.$wrapperEl[c]("gesturestart", v, d.onGestureStart, E), u.$wrapperEl[c]("gesturechange", v, d.onGestureChange, E), u.$wrapperEl[c]("gestureend", v, d.onGestureEnd, E) }, "enableGestures": function enableGestures() { this.zoom.gesturesEnabled || (this.zoom.gesturesEnabled = !0, this.zoom.toggleGestures("on")) }, "disableGestures": function disableGestures() { this.zoom.gesturesEnabled && (this.zoom.gesturesEnabled = !1, this.zoom.toggleGestures("off")) }, "enable": function enable() { var c = this, u = c.support, d = c.zoom; if (!d.enabled) { d.enabled = !0; var v = !("touchstart" !== c.touchEvents.start || !u.passiveListener || !c.params.passiveListeners) && { "passive": !0, "capture": !1 }, E = !u.passiveListener || { "passive": !1, "capture": !0 }, k = "." + c.params.slideClass; c.zoom.passiveListener = v, c.zoom.slideSelector = k, u.gestures ? (c.$wrapperEl.on(c.touchEvents.start, c.zoom.enableGestures, v), c.$wrapperEl.on(c.touchEvents.end, c.zoom.disableGestures, v)) : "touchstart" === c.touchEvents.start && (c.$wrapperEl.on(c.touchEvents.start, k, d.onGestureStart, v), c.$wrapperEl.on(c.touchEvents.move, k, d.onGestureChange, E), c.$wrapperEl.on(c.touchEvents.end, k, d.onGestureEnd, v), c.touchEvents.cancel && c.$wrapperEl.on(c.touchEvents.cancel, k, d.onGestureEnd, v)), c.$wrapperEl.on(c.touchEvents.move, "." + c.params.zoom.containerClass, d.onTouchMove, E) } }, "disable": function disable() { var c = this, u = c.zoom; if (u.enabled) { var d = c.support; c.zoom.enabled = !1; var v = !("touchstart" !== c.touchEvents.start || !d.passiveListener || !c.params.passiveListeners) && { "passive": !0, "capture": !1 }, E = !d.passiveListener || { "passive": !1, "capture": !0 }, k = "." + c.params.slideClass; d.gestures ? (c.$wrapperEl.off(c.touchEvents.start, c.zoom.enableGestures, v), c.$wrapperEl.off(c.touchEvents.end, c.zoom.disableGestures, v)) : "touchstart" === c.touchEvents.start && (c.$wrapperEl.off(c.touchEvents.start, k, u.onGestureStart, v), c.$wrapperEl.off(c.touchEvents.move, k, u.onGestureChange, E), c.$wrapperEl.off(c.touchEvents.end, k, u.onGestureEnd, v), c.touchEvents.cancel && c.$wrapperEl.off(c.touchEvents.cancel, k, u.onGestureEnd, v)), c.$wrapperEl.off(c.touchEvents.move, "." + c.params.zoom.containerClass, u.onTouchMove, E) } } }, Ee = { "name": "zoom", "params": { "zoom": { "enabled": !1, "maxRatio": 3, "minRatio": 1, "toggle": !0, "containerClass": "swiper-zoom-container", "zoomedSlideClass": "swiper-slide-zoomed" } }, "create": function create() { var c = this; bindModuleMethods(c, { "zoom": zoom_extends({ "enabled": !1, "scale": 1, "currentScale": 1, "isScaling": !1, "gesture": { "$slideEl": void 0, "slideWidth": void 0, "slideHeight": void 0, "$imageEl": void 0, "$imageWrapEl": void 0, "maxRatio": 3 }, "image": { "isTouched": void 0, "isMoved": void 0, "currentX": void 0, "currentY": void 0, "minX": void 0, "minY": void 0, "maxX": void 0, "maxY": void 0, "width": void 0, "height": void 0, "startX": void 0, "startY": void 0, "touchesStart": {}, "touchesCurrent": {} }, "velocity": { "x": void 0, "y": void 0, "prevPositionX": void 0, "prevPositionY": void 0, "prevTime": void 0 } }, we) }); var u = 1; Object.defineProperty(c.zoom, "scale", { "get": function get() { return u }, "set": function set(d) { if (u !== d) { var v = c.zoom.gesture.$imageEl ? c.zoom.gesture.$imageEl[0] : void 0, E = c.zoom.gesture.$slideEl ? c.zoom.gesture.$slideEl[0] : void 0; c.emit("zoomChange", d, v, E) } u = d } }) }, "on": { "init": function init(c) { c.params.zoom.enabled && c.zoom.enable() }, "destroy": function destroy(c) { c.zoom.disable() }, "touchStart": function touchStart(c, u) { c.zoom.enabled && c.zoom.onTouchStart(u) }, "touchEnd": function touchEnd(c, u) { c.zoom.enabled && c.zoom.onTouchEnd(u) }, "doubleTap": function doubleTap(c, u) { !c.animating && c.params.zoom.enabled && c.zoom.enabled && c.params.zoom.toggle && c.zoom.toggle(u) }, "transitionEnd": function transitionEnd(c) { c.zoom.enabled && c.params.zoom.enabled && c.zoom.onTransitionEnd() }, "slideChange": function slideChange(c) { c.zoom.enabled && c.params.zoom.enabled && c.params.cssMode && c.zoom.onTransitionEnd() } } }; function lazy_extends() { return lazy_extends = Object.assign || function (c) { for (var u = 1; u < arguments.length; u++) { var d = arguments[u]; for (var v in d) Object.prototype.hasOwnProperty.call(d, v) && (c[v] = d[v]) } return c }, lazy_extends.apply(this, arguments) } var Ce = { "loadInSlide": function loadInSlide(c, u) { void 0 === u && (u = !0); var d = this, v = d.params.lazy; if (void 0 !== c && 0 !== d.slides.length) { var E = d.virtual && d.params.virtual.enabled ? d.$wrapperEl.children("." + d.params.slideClass + '[data-swiper-slide-index="' + c + '"]') : d.slides.eq(c), k = E.find("." + v.elementClass + ":not(." + v.loadedClass + "):not(." + v.loadingClass + ")"); !E.hasClass(v.elementClass) || E.hasClass(v.loadedClass) || E.hasClass(v.loadingClass) || k.push(E[0]), 0 !== k.length && k.each((function (c) { var k = Z(c); k.addClass(v.loadingClass); var R = k.attr("data-background"), U = k.attr("data-src"), H = k.attr("data-srcset"), G = k.attr("data-sizes"), W = k.parent("picture"); d.loadImage(k[0], U || R, H, G, !1, (function () { if (null != d && d && (!d || d.params) && !d.destroyed) { if (R ? (k.css("background-image", 'url("' + R + '")'), k.removeAttr("data-background")) : (H && (k.attr("srcset", H), k.removeAttr("data-srcset")), G && (k.attr("sizes", G), k.removeAttr("data-sizes")), W.length && W.children("source").each((function (c) { var u = Z(c); u.attr("data-srcset") && (u.attr("srcset", u.attr("data-srcset")), u.removeAttr("data-srcset")) })), U && (k.attr("src", U), k.removeAttr("data-src"))), k.addClass(v.loadedClass).removeClass(v.loadingClass), E.find("." + v.preloaderClass).remove(), d.params.loop && u) { var c = E.attr("data-swiper-slide-index"); if (E.hasClass(d.params.slideDuplicateClass)) { var Y = d.$wrapperEl.children('[data-swiper-slide-index="' + c + '"]:not(.' + d.params.slideDuplicateClass + ")"); d.lazy.loadInSlide(Y.index(), !1) } else { var J = d.$wrapperEl.children("." + d.params.slideDuplicateClass + '[data-swiper-slide-index="' + c + '"]'); d.lazy.loadInSlide(J.index(), !1) } } d.emit("lazyImageReady", E[0], k[0]), d.params.autoHeight && d.updateAutoHeight() } })), d.emit("lazyImageLoad", E[0], k[0]) })) } }, "load": function load() { var c = this, u = c.$wrapperEl, d = c.params, v = c.slides, E = c.activeIndex, k = c.virtual && d.virtual.enabled, R = d.lazy, U = d.slidesPerView; function slideExist(c) { if (k) { if (u.children("." + d.slideClass + '[data-swiper-slide-index="' + c + '"]').length) return !0 } else if (v[c]) return !0; return !1 } function slideIndex(c) { return k ? Z(c).attr("data-swiper-slide-index") : Z(c).index() } if ("auto" === U && (U = 0), c.lazy.initialImageLoaded || (c.lazy.initialImageLoaded = !0), c.params.watchSlidesVisibility) u.children("." + d.slideVisibleClass).each((function (u) { var d = k ? Z(u).attr("data-swiper-slide-index") : Z(u).index(); c.lazy.loadInSlide(d) })); else if (U > 1) for (var H = E; H < E + U; H += 1)slideExist(H) && c.lazy.loadInSlide(H); else c.lazy.loadInSlide(E); if (R.loadPrevNext) if (U > 1 || R.loadPrevNextAmount && R.loadPrevNextAmount > 1) { for (var G = R.loadPrevNextAmount, W = U, Y = Math.min(E + W + Math.max(G, W), v.length), J = Math.max(E - Math.max(W, G), 0), K = E + U; K < Y; K += 1)slideExist(K) && c.lazy.loadInSlide(K); for (var X = J; X < E; X += 1)slideExist(X) && c.lazy.loadInSlide(X) } else { var Q = u.children("." + d.slideNextClass); Q.length > 0 && c.lazy.loadInSlide(slideIndex(Q)); var ee = u.children("." + d.slidePrevClass); ee.length > 0 && c.lazy.loadInSlide(slideIndex(ee)) } }, "checkInViewOnLoad": function checkInViewOnLoad() { var c = ssr_window_esm_getWindow(), u = this; if (u && !u.destroyed) { var d = u.params.lazy.scrollingElement ? Z(u.params.lazy.scrollingElement) : Z(c), v = d[0] === c, E = v ? c.innerWidth : d[0].offsetWidth, k = v ? c.innerHeight : d[0].offsetHeight, R = u.$el.offset(), U = !1; u.rtlTranslate && (R.left -= u.$el[0].scrollLeft); for (var H = [[R.left, R.top], [R.left + u.width, R.top], [R.left, R.top + u.height], [R.left + u.width, R.top + u.height]], G = 0; G < H.length; G += 1) { var W = H[G]; if (W[0] >= 0 && W[0] <= E && W[1] >= 0 && W[1] <= k) { if (0 === W[0] && 0 === W[1]) continue; U = !0 } } var Y = !("touchstart" !== u.touchEvents.start || !u.support.passiveListener || !u.params.passiveListeners) && { "passive": !0, "capture": !1 }; U ? (u.lazy.load(), d.off("scroll", u.lazy.checkInViewOnLoad, Y)) : u.lazy.scrollHandlerAttached || (u.lazy.scrollHandlerAttached = !0, d.on("scroll", u.lazy.checkInViewOnLoad, Y)) } } }; function controller_extends() { return controller_extends = Object.assign || function (c) { for (var u = 1; u < arguments.length; u++) { var d = arguments[u]; for (var v in d) Object.prototype.hasOwnProperty.call(d, v) && (c[v] = d[v]) } return c }, controller_extends.apply(this, arguments) } var Te = { "LinearSpline": function LinearSpline(c, u) { var d, v, E = function search() { var c, u, d; return function (v, E) { for (u = -1, c = v.length; c - u > 1;)v[d = c + u >> 1] <= E ? u = d : c = d; return c } }(); return this.x = c, this.y = u, this.lastIndex = c.length - 1, this.interpolate = function interpolate(c) { return c ? (v = E(this.x, c), d = v - 1, (c - this.x[d]) * (this.y[v] - this.y[d]) / (this.x[v] - this.x[d]) + this.y[d]) : 0 }, this }, "getInterpolateFunction": function getInterpolateFunction(c) { var u = this; u.controller.spline || (u.controller.spline = u.params.loop ? new Te.LinearSpline(u.slidesGrid, c.slidesGrid) : new Te.LinearSpline(u.snapGrid, c.snapGrid)) }, "setTranslate": function setTranslate(c, u) { var d, v, E = this, k = E.controller.control, R = E.constructor; function setControlledTranslate(c) { var u = E.rtlTranslate ? -E.translate : E.translate; "slide" === E.params.controller.by && (E.controller.getInterpolateFunction(c), v = -E.controller.spline.interpolate(-u)), v && "container" !== E.params.controller.by || (d = (c.maxTranslate() - c.minTranslate()) / (E.maxTranslate() - E.minTranslate()), v = (u - E.minTranslate()) * d + c.minTranslate()), E.params.controller.inverse && (v = c.maxTranslate() - v), c.updateProgress(v), c.setTranslate(v, E), c.updateActiveIndex(), c.updateSlidesClasses() } if (Array.isArray(k)) for (var U = 0; U < k.length; U += 1)k[U] !== u && k[U] instanceof R && setControlledTranslate(k[U]); else k instanceof R && u !== k && setControlledTranslate(k) }, "setTransition": function setTransition(c, u) { var d, v = this, E = v.constructor, k = v.controller.control; function setControlledTransition(u) { u.setTransition(c, v), 0 !== c && (u.transitionStart(), u.params.autoHeight && nextTick((function () { u.updateAutoHeight() })), u.$wrapperEl.transitionEnd((function () { k && (u.params.loop && "slide" === v.params.controller.by && u.loopFix(), u.transitionEnd()) }))) } if (Array.isArray(k)) for (d = 0; d < k.length; d += 1)k[d] !== u && k[d] instanceof E && setControlledTransition(k[d]); else k instanceof E && u !== k && setControlledTransition(k) } }, xe = { "name": "controller", "params": { "controller": { "control": void 0, "inverse": !1, "by": "slide" } }, "create": function create() { bindModuleMethods(this, { "controller": controller_extends({ "control": this.params.controller.control }, Te) }) }, "on": { "update": function update(c) { c.controller.control && c.controller.spline && (c.controller.spline = void 0, delete c.controller.spline) }, "resize": function resize(c) { c.controller.control && c.controller.spline && (c.controller.spline = void 0, delete c.controller.spline) }, "observerUpdate": function observerUpdate(c) { c.controller.control && c.controller.spline && (c.controller.spline = void 0, delete c.controller.spline) }, "setTranslate": function setTranslate(c, u, d) { c.controller.control && c.controller.setTranslate(u, d) }, "setTransition": function setTransition(c, u, d) { c.controller.control && c.controller.setTransition(u, d) } } }; function a11y_extends() { return a11y_extends = Object.assign || function (c) { for (var u = 1; u < arguments.length; u++) { var d = arguments[u]; for (var v in d) Object.prototype.hasOwnProperty.call(d, v) && (c[v] = d[v]) } return c }, a11y_extends.apply(this, arguments) } var Ae = { "getRandomNumber": function getRandomNumber(c) { void 0 === c && (c = 16); return "x".repeat(c).replace(/x/g, (function randomChar() { return Math.round(16 * Math.random()).toString(16) })) }, "makeElFocusable": function makeElFocusable(c) { return c.attr("tabIndex", "0"), c }, "makeElNotFocusable": function makeElNotFocusable(c) { return c.attr("tabIndex", "-1"), c }, "addElRole": function addElRole(c, u) { return c.attr("role", u), c }, "addElRoleDescription": function addElRoleDescription(c, u) { return c.attr("aria-roledescription", u), c }, "addElControls": function addElControls(c, u) { return c.attr("aria-controls", u), c }, "addElLabel": function addElLabel(c, u) { return c.attr("aria-label", u), c }, "addElId": function addElId(c, u) { return c.attr("id", u), c }, "addElLive": function addElLive(c, u) { return c.attr("aria-live", u), c }, "disableEl": function disableEl(c) { return c.attr("aria-disabled", !0), c }, "enableEl": function enableEl(c) { return c.attr("aria-disabled", !1), c }, "onEnterOrSpaceKey": function onEnterOrSpaceKey(c) { if (13 === c.keyCode || 32 === c.keyCode) { var u = this, d = u.params.a11y, v = Z(c.target); u.navigation && u.navigation.$nextEl && v.is(u.navigation.$nextEl) && (u.isEnd && !u.params.loop || u.slideNext(), u.isEnd ? u.a11y.notify(d.lastSlideMessage) : u.a11y.notify(d.nextSlideMessage)), u.navigation && u.navigation.$prevEl && v.is(u.navigation.$prevEl) && (u.isBeginning && !u.params.loop || u.slidePrev(), u.isBeginning ? u.a11y.notify(d.firstSlideMessage) : u.a11y.notify(d.prevSlideMessage)), u.pagination && v.is(classesToSelector(u.params.pagination.bulletClass)) && v[0].click() } }, "notify": function notify(c) { var u = this.a11y.liveRegion; 0 !== u.length && (u.html(""), u.html(c)) }, "updateNavigation": function updateNavigation() { var c = this; if (!c.params.loop && c.navigation) { var u = c.navigation, d = u.$nextEl, v = u.$prevEl; v && v.length > 0 && (c.isBeginning ? (c.a11y.disableEl(v), c.a11y.makeElNotFocusable(v)) : (c.a11y.enableEl(v), c.a11y.makeElFocusable(v))), d && d.length > 0 && (c.isEnd ? (c.a11y.disableEl(d), c.a11y.makeElNotFocusable(d)) : (c.a11y.enableEl(d), c.a11y.makeElFocusable(d))) } }, "updatePagination": function updatePagination() { var c = this, u = c.params.a11y; c.pagination && c.params.pagination.clickable && c.pagination.bullets && c.pagination.bullets.length && c.pagination.bullets.each((function (d) { var v = Z(d); c.a11y.makeElFocusable(v), c.params.pagination.renderBullet || (c.a11y.addElRole(v, "button"), c.a11y.addElLabel(v, u.paginationBulletMessage.replace(/\{\{index\}\}/, v.index() + 1))) })) }, "init": function init() { var c = this, u = c.params.a11y; c.$el.append(c.a11y.liveRegion); var d = c.$el; u.containerRoleDescriptionMessage && c.a11y.addElRoleDescription(d, u.containerRoleDescriptionMessage), u.containerMessage && c.a11y.addElLabel(d, u.containerMessage); var v = c.$wrapperEl, E = v.attr("id") || "swiper-wrapper-" + c.a11y.getRandomNumber(16), k = c.params.autoplay && c.params.autoplay.enabled ? "off" : "polite"; c.a11y.addElId(v, E), c.a11y.addElLive(v, k), u.itemRoleDescriptionMessage && c.a11y.addElRoleDescription(Z(c.slides), u.itemRoleDescriptionMessage), c.a11y.addElRole(Z(c.slides), u.slideRole); var R, U, H = c.params.loop ? c.slides.filter((function (u) { return !u.classList.contains(c.params.slideDuplicateClass) })).length : c.slides.length; c.slides.each((function (d, v) { var E = Z(d), k = c.params.loop ? parseInt(E.attr("data-swiper-slide-index"), 10) : v, R = u.slideLabelMessage.replace(/\{\{index\}\}/, k + 1).replace(/\{\{slidesLength\}\}/, H); c.a11y.addElLabel(E, R) })), c.navigation && c.navigation.$nextEl && (R = c.navigation.$nextEl), c.navigation && c.navigation.$prevEl && (U = c.navigation.$prevEl), R && R.length && (c.a11y.makeElFocusable(R), "BUTTON" !== R[0].tagName && (c.a11y.addElRole(R, "button"), R.on("keydown", c.a11y.onEnterOrSpaceKey)), c.a11y.addElLabel(R, u.nextSlideMessage), c.a11y.addElControls(R, E)), U && U.length && (c.a11y.makeElFocusable(U), "BUTTON" !== U[0].tagName && (c.a11y.addElRole(U, "button"), U.on("keydown", c.a11y.onEnterOrSpaceKey)), c.a11y.addElLabel(U, u.prevSlideMessage), c.a11y.addElControls(U, E)), c.pagination && c.params.pagination.clickable && c.pagination.bullets && c.pagination.bullets.length && c.pagination.$el.on("keydown", classesToSelector(c.params.pagination.bulletClass), c.a11y.onEnterOrSpaceKey) }, "destroy": function destroy() { var c, u, d = this; d.a11y.liveRegion && d.a11y.liveRegion.length > 0 && d.a11y.liveRegion.remove(), d.navigation && d.navigation.$nextEl && (c = d.navigation.$nextEl), d.navigation && d.navigation.$prevEl && (u = d.navigation.$prevEl), c && c.off("keydown", d.a11y.onEnterOrSpaceKey), u && u.off("keydown", d.a11y.onEnterOrSpaceKey), d.pagination && d.params.pagination.clickable && d.pagination.bullets && d.pagination.bullets.length && d.pagination.$el.off("keydown", classesToSelector(d.params.pagination.bulletClass), d.a11y.onEnterOrSpaceKey) } }; function history_extends() { return history_extends = Object.assign || function (c) { for (var u = 1; u < arguments.length; u++) { var d = arguments[u]; for (var v in d) Object.prototype.hasOwnProperty.call(d, v) && (c[v] = d[v]) } return c }, history_extends.apply(this, arguments) } var Ie = { "init": function init() { var c = this, u = ssr_window_esm_getWindow(); if (c.params.history) { if (!u.history || !u.history.pushState) return c.params.history.enabled = !1, void (c.params.hashNavigation.enabled = !0); var d = c.history; d.initialized = !0, d.paths = Ie.getPathValues(c.params.url), (d.paths.key || d.paths.value) && (d.scrollToSlide(0, d.paths.value, c.params.runCallbacksOnInit), c.params.history.replaceState || u.addEventListener("popstate", c.history.setHistoryPopState)) } }, "destroy": function destroy() { var c = ssr_window_esm_getWindow(); this.params.history.replaceState || c.removeEventListener("popstate", this.history.setHistoryPopState) }, "setHistoryPopState": function setHistoryPopState() { var c = this; c.history.paths = Ie.getPathValues(c.params.url), c.history.scrollToSlide(c.params.speed, c.history.paths.value, !1) }, "getPathValues": function getPathValues(c) { var u = ssr_window_esm_getWindow(), d = (c ? new URL(c) : u.location).pathname.slice(1).split("/").filter((function (c) { return "" !== c })), v = d.length; return { "key": d[v - 2], "value": d[v - 1] } }, "setHistory": function setHistory(c, u) { var d = this, v = ssr_window_esm_getWindow(); if (d.history.initialized && d.params.history.enabled) { var E; E = d.params.url ? new URL(d.params.url) : v.location; var k = d.slides.eq(u), R = Ie.slugify(k.attr("data-history")); if (d.params.history.root.length > 0) { var U = d.params.history.root; "/" === U[U.length - 1] && (U = U.slice(0, U.length - 1)), R = U + "/" + c + "/" + R } else E.pathname.includes(c) || (R = c + "/" + R); var H = v.history.state; H && H.value === R || (d.params.history.replaceState ? v.history.replaceState({ "value": R }, null, R) : v.history.pushState({ "value": R }, null, R)) } }, "slugify": function slugify(c) { return c.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, "") }, "scrollToSlide": function scrollToSlide(c, u, d) { var v = this; if (u) for (var E = 0, k = v.slides.length; E < k; E += 1) { var R = v.slides.eq(E); if (Ie.slugify(R.attr("data-history")) === u && !R.hasClass(v.params.slideDuplicateClass)) { var U = R.index(); v.slideTo(U, c, d) } } else v.slideTo(0, c, d) } }; function hash_navigation_extends() { return hash_navigation_extends = Object.assign || function (c) { for (var u = 1; u < arguments.length; u++) { var d = arguments[u]; for (var v in d) Object.prototype.hasOwnProperty.call(d, v) && (c[v] = d[v]) } return c }, hash_navigation_extends.apply(this, arguments) } var ke = { "onHashChange": function onHashChange() { var c = this, u = getDocument(); c.emit("hashChange"); var d = u.location.hash.replace("#", ""); if (d !== c.slides.eq(c.activeIndex).attr("data-hash")) { var v = c.$wrapperEl.children("." + c.params.slideClass + '[data-hash="' + d + '"]').index(); if (void 0 === v) return; c.slideTo(v) } }, "setHash": function setHash() { var c = this, u = ssr_window_esm_getWindow(), d = getDocument(); if (c.hashNavigation.initialized && c.params.hashNavigation.enabled) if (c.params.hashNavigation.replaceState && u.history && u.history.replaceState) u.history.replaceState(null, null, "#" + c.slides.eq(c.activeIndex).attr("data-hash") || 0), c.emit("hashSet"); else { var v = c.slides.eq(c.activeIndex), E = v.attr("data-hash") || v.attr("data-history"); d.location.hash = E || "", c.emit("hashSet") } }, "init": function init() { var c = this, u = getDocument(), d = ssr_window_esm_getWindow(); if (!(!c.params.hashNavigation.enabled || c.params.history && c.params.history.enabled)) { c.hashNavigation.initialized = !0; var v = u.location.hash.replace("#", ""); if (v) for (var E = 0, k = c.slides.length; E < k; E += 1) { var R = c.slides.eq(E); if ((R.attr("data-hash") || R.attr("data-history")) === v && !R.hasClass(c.params.slideDuplicateClass)) { var U = R.index(); c.slideTo(U, 0, c.params.runCallbacksOnInit, !0) } } c.params.hashNavigation.watchState && Z(d).on("hashchange", c.hashNavigation.onHashChange) } }, "destroy": function destroy() { var c = ssr_window_esm_getWindow(); this.params.hashNavigation.watchState && Z(c).off("hashchange", this.hashNavigation.onHashChange) } }; function autoplay_extends() { return autoplay_extends = Object.assign || function (c) { for (var u = 1; u < arguments.length; u++) { var d = arguments[u]; for (var v in d) Object.prototype.hasOwnProperty.call(d, v) && (c[v] = d[v]) } return c }, autoplay_extends.apply(this, arguments) } var Oe = { "run": function run() { var c = this, u = c.slides.eq(c.activeIndex), d = c.params.autoplay.delay; u.attr("data-swiper-autoplay") && (d = u.attr("data-swiper-autoplay") || c.params.autoplay.delay), clearTimeout(c.autoplay.timeout), c.autoplay.timeout = nextTick((function () { var u; c.params.autoplay.reverseDirection ? c.params.loop ? (c.loopFix(), u = c.slidePrev(c.params.speed, !0, !0), c.emit("autoplay")) : c.isBeginning ? c.params.autoplay.stopOnLastSlide ? c.autoplay.stop() : (u = c.slideTo(c.slides.length - 1, c.params.speed, !0, !0), c.emit("autoplay")) : (u = c.slidePrev(c.params.speed, !0, !0), c.emit("autoplay")) : c.params.loop ? (c.loopFix(), u = c.slideNext(c.params.speed, !0, !0), c.emit("autoplay")) : c.isEnd ? c.params.autoplay.stopOnLastSlide ? c.autoplay.stop() : (u = c.slideTo(0, c.params.speed, !0, !0), c.emit("autoplay")) : (u = c.slideNext(c.params.speed, !0, !0), c.emit("autoplay")), (c.params.cssMode && c.autoplay.running || !1 === u) && c.autoplay.run() }), d) }, "start": function start() { var c = this; return void 0 === c.autoplay.timeout && (!c.autoplay.running && (c.autoplay.running = !0, c.emit("autoplayStart"), c.autoplay.run(), !0)) }, "stop": function stop() { var c = this; return !!c.autoplay.running && (void 0 !== c.autoplay.timeout && (c.autoplay.timeout && (clearTimeout(c.autoplay.timeout), c.autoplay.timeout = void 0), c.autoplay.running = !1, c.emit("autoplayStop"), !0)) }, "pause": function pause(c) { var u = this; u.autoplay.running && (u.autoplay.paused || (u.autoplay.timeout && clearTimeout(u.autoplay.timeout), u.autoplay.paused = !0, 0 !== c && u.params.autoplay.waitForTransition ? ["transitionend", "webkitTransitionEnd"].forEach((function (c) { u.$wrapperEl[0].addEventListener(c, u.autoplay.onTransitionEnd) })) : (u.autoplay.paused = !1, u.autoplay.run()))) }, "onVisibilityChange": function onVisibilityChange() { var c = this, u = getDocument(); "hidden" === u.visibilityState && c.autoplay.running && c.autoplay.pause(), "visible" === u.visibilityState && c.autoplay.paused && (c.autoplay.run(), c.autoplay.paused = !1) }, "onTransitionEnd": function onTransitionEnd(c) { var u = this; u && !u.destroyed && u.$wrapperEl && c.target === u.$wrapperEl[0] && (["transitionend", "webkitTransitionEnd"].forEach((function (c) { u.$wrapperEl[0].removeEventListener(c, u.autoplay.onTransitionEnd) })), u.autoplay.paused = !1, u.autoplay.running ? u.autoplay.run() : u.autoplay.stop()) }, "onMouseEnter": function onMouseEnter() { var c = this; c.params.autoplay.disableOnInteraction ? c.autoplay.stop() : c.autoplay.pause(), ["transitionend", "webkitTransitionEnd"].forEach((function (u) { c.$wrapperEl[0].removeEventListener(u, c.autoplay.onTransitionEnd) })) }, "onMouseLeave": function onMouseLeave() { var c = this; c.params.autoplay.disableOnInteraction || (c.autoplay.paused = !1, c.autoplay.run()) }, "attachMouseEvents": function attachMouseEvents() { var c = this; c.params.autoplay.pauseOnMouseEnter && (c.$el.on("mouseenter", c.autoplay.onMouseEnter), c.$el.on("mouseleave", c.autoplay.onMouseLeave)) }, "detachMouseEvents": function detachMouseEvents() { var c = this; c.$el.off("mouseenter", c.autoplay.onMouseEnter), c.$el.off("mouseleave", c.autoplay.onMouseLeave) } }; function effect_fade_extends() { return effect_fade_extends = Object.assign || function (c) { for (var u = 1; u < arguments.length; u++) { var d = arguments[u]; for (var v in d) Object.prototype.hasOwnProperty.call(d, v) && (c[v] = d[v]) } return c }, effect_fade_extends.apply(this, arguments) } var Pe = { "setTranslate": function setTranslate() { for (var c = this, u = c.slides, d = 0; d < u.length; d += 1) { var v = c.slides.eq(d), E = -v[0].swiperSlideOffset; c.params.virtualTranslate || (E -= c.translate); var k = 0; c.isHorizontal() || (k = E, E = 0); var R = c.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(v[0].progress), 0) : 1 + Math.min(Math.max(v[0].progress, -1), 0); v.css({ "opacity": R }).transform("translate3d(" + E + "px, " + k + "px, 0px)") } }, "setTransition": function setTransition(c) { var u = this, d = u.slides, v = u.$wrapperEl; if (d.transition(c), u.params.virtualTranslate && 0 !== c) { var E = !1; d.transitionEnd((function () { if (!E && u && !u.destroyed) { E = !0, u.animating = !1; for (var c = ["webkitTransitionEnd", "transitionend"], d = 0; d < c.length; d += 1)v.trigger(c[d]) } })) } } }; function effect_cube_extends() { return effect_cube_extends = Object.assign || function (c) { for (var u = 1; u < arguments.length; u++) { var d = arguments[u]; for (var v in d) Object.prototype.hasOwnProperty.call(d, v) && (c[v] = d[v]) } return c }, effect_cube_extends.apply(this, arguments) } var Re = { "setTranslate": function setTranslate() { var c, u = this, d = u.$el, v = u.$wrapperEl, E = u.slides, k = u.width, R = u.height, U = u.rtlTranslate, H = u.size, G = u.browser, W = u.params.cubeEffect, Y = u.isHorizontal(), J = u.virtual && u.params.virtual.enabled, K = 0; W.shadow && (Y ? (0 === (c = v.find(".swiper-cube-shadow")).length && (c = Z('<div class="swiper-cube-shadow"></div>'), v.append(c)), c.css({ "height": k + "px" })) : 0 === (c = d.find(".swiper-cube-shadow")).length && (c = Z('<div class="swiper-cube-shadow"></div>'), d.append(c))); for (var X = 0; X < E.length; X += 1) { var Q = E.eq(X), ee = X; J && (ee = parseInt(Q.attr("data-swiper-slide-index"), 10)); var te = 90 * ee, ne = Math.floor(te / 360); U && (te = -te, ne = Math.floor(-te / 360)); var re = Math.max(Math.min(Q[0].progress, 1), -1), oe = 0, ie = 0, ae = 0; ee % 4 == 0 ? (oe = 4 * -ne * H, ae = 0) : (ee - 1) % 4 == 0 ? (oe = 0, ae = 4 * -ne * H) : (ee - 2) % 4 == 0 ? (oe = H + 4 * ne * H, ae = H) : (ee - 3) % 4 == 0 && (oe = -H, ae = 3 * H + 4 * H * ne), U && (oe = -oe), Y || (ie = oe, oe = 0); var se = "rotateX(" + (Y ? 0 : -te) + "deg) rotateY(" + (Y ? te : 0) + "deg) translate3d(" + oe + "px, " + ie + "px, " + ae + "px)"; if (re <= 1 && re > -1 && (K = 90 * ee + 90 * re, U && (K = 90 * -ee - 90 * re)), Q.transform(se), W.slideShadows) { var ce = Y ? Q.find(".swiper-slide-shadow-left") : Q.find(".swiper-slide-shadow-top"), le = Y ? Q.find(".swiper-slide-shadow-right") : Q.find(".swiper-slide-shadow-bottom"); 0 === ce.length && (ce = Z('<div class="swiper-slide-shadow-' + (Y ? "left" : "top") + '"></div>'), Q.append(ce)), 0 === le.length && (le = Z('<div class="swiper-slide-shadow-' + (Y ? "right" : "bottom") + '"></div>'), Q.append(le)), ce.length && (ce[0].style.opacity = Math.max(-re, 0)), le.length && (le[0].style.opacity = Math.max(re, 0)) } } if (v.css({ "-webkit-transform-origin": "50% 50% -" + H / 2 + "px", "-moz-transform-origin": "50% 50% -" + H / 2 + "px", "-ms-transform-origin": "50% 50% -" + H / 2 + "px", "transform-origin": "50% 50% -" + H / 2 + "px" }), W.shadow) if (Y) c.transform("translate3d(0px, " + (k / 2 + W.shadowOffset) + "px, " + -k / 2 + "px) rotateX(90deg) rotateZ(0deg) scale(" + W.shadowScale + ")"); else { var ue = Math.abs(K) - 90 * Math.floor(Math.abs(K) / 90), de = 1.5 - (Math.sin(2 * ue * Math.PI / 360) / 2 + Math.cos(2 * ue * Math.PI / 360) / 2), pe = W.shadowScale, fe = W.shadowScale / de, he = W.shadowOffset; c.transform("scale3d(" + pe + ", 1, " + fe + ") translate3d(0px, " + (R / 2 + he) + "px, " + -R / 2 / fe + "px) rotateX(-90deg)") } var me = G.isSafari || G.isWebView ? -H / 2 : 0; v.transform("translate3d(0px,0," + me + "px) rotateX(" + (u.isHorizontal() ? 0 : K) + "deg) rotateY(" + (u.isHorizontal() ? -K : 0) + "deg)") }, "setTransition": function setTransition(c) { var u = this, d = u.$el; u.slides.transition(c).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(c), u.params.cubeEffect.shadow && !u.isHorizontal() && d.find(".swiper-cube-shadow").transition(c) } }; function effect_flip_extends() { return effect_flip_extends = Object.assign || function (c) { for (var u = 1; u < arguments.length; u++) { var d = arguments[u]; for (var v in d) Object.prototype.hasOwnProperty.call(d, v) && (c[v] = d[v]) } return c }, effect_flip_extends.apply(this, arguments) } var Me = { "setTranslate": function setTranslate() { for (var c = this, u = c.slides, d = c.rtlTranslate, v = 0; v < u.length; v += 1) { var E = u.eq(v), k = E[0].progress; c.params.flipEffect.limitRotation && (k = Math.max(Math.min(E[0].progress, 1), -1)); var R = -180 * k, U = 0, H = -E[0].swiperSlideOffset, G = 0; if (c.isHorizontal() ? d && (R = -R) : (G = H, H = 0, U = -R, R = 0), E[0].style.zIndex = -Math.abs(Math.round(k)) + u.length, c.params.flipEffect.slideShadows) { var W = c.isHorizontal() ? E.find(".swiper-slide-shadow-left") : E.find(".swiper-slide-shadow-top"), Y = c.isHorizontal() ? E.find(".swiper-slide-shadow-right") : E.find(".swiper-slide-shadow-bottom"); 0 === W.length && (W = Z('<div class="swiper-slide-shadow-' + (c.isHorizontal() ? "left" : "top") + '"></div>'), E.append(W)), 0 === Y.length && (Y = Z('<div class="swiper-slide-shadow-' + (c.isHorizontal() ? "right" : "bottom") + '"></div>'), E.append(Y)), W.length && (W[0].style.opacity = Math.max(-k, 0)), Y.length && (Y[0].style.opacity = Math.max(k, 0)) } E.transform("translate3d(" + H + "px, " + G + "px, 0px) rotateX(" + U + "deg) rotateY(" + R + "deg)") } }, "setTransition": function setTransition(c) { var u = this, d = u.slides, v = u.activeIndex, E = u.$wrapperEl; if (d.transition(c).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(c), u.params.virtualTranslate && 0 !== c) { var k = !1; d.eq(v).transitionEnd((function onTransitionEnd() { if (!k && u && !u.destroyed) { k = !0, u.animating = !1; for (var c = ["webkitTransitionEnd", "transitionend"], d = 0; d < c.length; d += 1)E.trigger(c[d]) } })) } } }; function effect_coverflow_extends() { return effect_coverflow_extends = Object.assign || function (c) { for (var u = 1; u < arguments.length; u++) { var d = arguments[u]; for (var v in d) Object.prototype.hasOwnProperty.call(d, v) && (c[v] = d[v]) } return c }, effect_coverflow_extends.apply(this, arguments) } var Ne = { "setTranslate": function setTranslate() { for (var c = this, u = c.width, d = c.height, v = c.slides, E = c.slidesSizesGrid, k = c.params.coverflowEffect, R = c.isHorizontal(), U = c.translate, H = R ? u / 2 - U : d / 2 - U, G = R ? k.rotate : -k.rotate, W = k.depth, Y = 0, J = v.length; Y < J; Y += 1) { var K = v.eq(Y), X = E[Y], Q = (H - K[0].swiperSlideOffset - X / 2) / X * k.modifier, ee = R ? G * Q : 0, te = R ? 0 : G * Q, ne = -W * Math.abs(Q), re = k.stretch; "string" == typeof re && -1 !== re.indexOf("%") && (re = parseFloat(k.stretch) / 100 * X); var oe = R ? 0 : re * Q, ie = R ? re * Q : 0, ae = 1 - (1 - k.scale) * Math.abs(Q); Math.abs(ie) < .001 && (ie = 0), Math.abs(oe) < .001 && (oe = 0), Math.abs(ne) < .001 && (ne = 0), Math.abs(ee) < .001 && (ee = 0), Math.abs(te) < .001 && (te = 0), Math.abs(ae) < .001 && (ae = 0); var se = "translate3d(" + ie + "px," + oe + "px," + ne + "px)  rotateX(" + te + "deg) rotateY(" + ee + "deg) scale(" + ae + ")"; if (K.transform(se), K[0].style.zIndex = 1 - Math.abs(Math.round(Q)), k.slideShadows) { var ce = R ? K.find(".swiper-slide-shadow-left") : K.find(".swiper-slide-shadow-top"), le = R ? K.find(".swiper-slide-shadow-right") : K.find(".swiper-slide-shadow-bottom"); 0 === ce.length && (ce = Z('<div class="swiper-slide-shadow-' + (R ? "left" : "top") + '"></div>'), K.append(ce)), 0 === le.length && (le = Z('<div class="swiper-slide-shadow-' + (R ? "right" : "bottom") + '"></div>'), K.append(le)), ce.length && (ce[0].style.opacity = Q > 0 ? Q : 0), le.length && (le[0].style.opacity = -Q > 0 ? -Q : 0) } } }, "setTransition": function setTransition(c) { this.slides.transition(c).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(c) } }; function thumbs_extends() { return thumbs_extends = Object.assign || function (c) { for (var u = 1; u < arguments.length; u++) { var d = arguments[u]; for (var v in d) Object.prototype.hasOwnProperty.call(d, v) && (c[v] = d[v]) } return c }, thumbs_extends.apply(this, arguments) } var De = { "init": function init() { var c = this, u = c.params.thumbs; if (c.thumbs.initialized) return !1; c.thumbs.initialized = !0; var d = c.constructor; return u.swiper instanceof d ? (c.thumbs.swiper = u.swiper, utils_extend(c.thumbs.swiper.originalParams, { "watchSlidesProgress": !0, "slideToClickedSlide": !1 }), utils_extend(c.thumbs.swiper.params, { "watchSlidesProgress": !0, "slideToClickedSlide": !1 })) : utils_isObject(u.swiper) && (c.thumbs.swiper = new d(utils_extend({}, u.swiper, { "watchSlidesVisibility": !0, "watchSlidesProgress": !0, "slideToClickedSlide": !1 })), c.thumbs.swiperCreated = !0), c.thumbs.swiper.$el.addClass(c.params.thumbs.thumbsContainerClass), c.thumbs.swiper.on("tap", c.thumbs.onThumbClick), !0 }, "onThumbClick": function onThumbClick() { var c = this, u = c.thumbs.swiper; if (u) { var d = u.clickedIndex, v = u.clickedSlide; if (!(v && Z(v).hasClass(c.params.thumbs.slideThumbActiveClass) || null == d)) { var E; if (E = u.params.loop ? parseInt(Z(u.clickedSlide).attr("data-swiper-slide-index"), 10) : d, c.params.loop) { var k = c.activeIndex; c.slides.eq(k).hasClass(c.params.slideDuplicateClass) && (c.loopFix(), c._clientLeft = c.$wrapperEl[0].clientLeft, k = c.activeIndex); var R = c.slides.eq(k).prevAll('[data-swiper-slide-index="' + E + '"]').eq(0).index(), U = c.slides.eq(k).nextAll('[data-swiper-slide-index="' + E + '"]').eq(0).index(); E = void 0 === R ? U : void 0 === U ? R : U - k < k - R ? U : R } c.slideTo(E) } } }, "update": function update(c) { var u = this, d = u.thumbs.swiper; if (d) { var v = "auto" === d.params.slidesPerView ? d.slidesPerViewDynamic() : d.params.slidesPerView, E = u.params.thumbs.autoScrollOffset, k = E && !d.params.loop; if (u.realIndex !== d.realIndex || k) { var R, U, H = d.activeIndex; if (d.params.loop) { d.slides.eq(H).hasClass(d.params.slideDuplicateClass) && (d.loopFix(), d._clientLeft = d.$wrapperEl[0].clientLeft, H = d.activeIndex); var G = d.slides.eq(H).prevAll('[data-swiper-slide-index="' + u.realIndex + '"]').eq(0).index(), W = d.slides.eq(H).nextAll('[data-swiper-slide-index="' + u.realIndex + '"]').eq(0).index(); R = void 0 === G ? W : void 0 === W ? G : W - H == H - G ? d.params.slidesPerGroup > 1 ? W : H : W - H < H - G ? W : G, U = u.activeIndex > u.previousIndex ? "next" : "prev" } else U = (R = u.realIndex) > u.previousIndex ? "next" : "prev"; k && (R += "next" === U ? E : -1 * E), d.visibleSlidesIndexes && d.visibleSlidesIndexes.indexOf(R) < 0 && (d.params.centeredSlides ? R = R > H ? R - Math.floor(v / 2) + 1 : R + Math.floor(v / 2) - 1 : R > H && d.params.slidesPerGroup, d.slideTo(R, c ? 0 : void 0)) } var Z = 1, Y = u.params.thumbs.slideThumbActiveClass; if (u.params.slidesPerView > 1 && !u.params.centeredSlides && (Z = u.params.slidesPerView), u.params.thumbs.multipleActiveThumbs || (Z = 1), Z = Math.floor(Z), d.slides.removeClass(Y), d.params.loop || d.params.virtual && d.params.virtual.enabled) for (var J = 0; J < Z; J += 1)d.$wrapperEl.children('[data-swiper-slide-index="' + (u.realIndex + J) + '"]').addClass(Y); else for (var K = 0; K < Z; K += 1)d.slides.eq(u.realIndex + K).addClass(Y) } } }, $e = [he, ge, { "name": "mousewheel", "params": { "mousewheel": { "enabled": !1, "releaseOnEdges": !1, "invert": !1, "forceToAxis": !1, "sensitivity": 1, "eventsTarget": "container", "thresholdDelta": null, "thresholdTime": null } }, "create": function create() { bindModuleMethods(this, { "mousewheel": { "enabled": !1, "lastScrollTime": now(), "lastEventBeforeSnap": void 0, "recentWheelEvents": [], "enable": _e.enable, "disable": _e.disable, "handle": _e.handle, "handleMouseEnter": _e.handleMouseEnter, "handleMouseLeave": _e.handleMouseLeave, "animateSlider": _e.animateSlider, "releaseScroll": _e.releaseScroll } }) }, "on": { "init": function init(c) { !c.params.mousewheel.enabled && c.params.cssMode && c.mousewheel.disable(), c.params.mousewheel.enabled && c.mousewheel.enable() }, "destroy": function destroy(c) { c.params.cssMode && c.mousewheel.enable(), c.mousewheel.enabled && c.mousewheel.disable() } } }, { "name": "navigation", "params": { "navigation": { "nextEl": null, "prevEl": null, "hideOnClick": !1, "disabledClass": "swiper-button-disabled", "hiddenClass": "swiper-button-hidden", "lockClass": "swiper-button-lock" } }, "create": function create() { bindModuleMethods(this, { "navigation": navigation_extends({}, ve) }) }, "on": { "init": function init(c) { c.navigation.init(), c.navigation.update() }, "toEdge": function toEdge(c) { c.navigation.update() }, "fromEdge": function fromEdge(c) { c.navigation.update() }, "destroy": function destroy(c) { c.navigation.destroy() }, "enable disable": function enableDisable(c) { var u = c.navigation, d = u.$nextEl, v = u.$prevEl; d && d[c.enabled ? "removeClass" : "addClass"](c.params.navigation.lockClass), v && v[c.enabled ? "removeClass" : "addClass"](c.params.navigation.lockClass) }, "click": function click(c, u) { var d = c.navigation, v = d.$nextEl, E = d.$prevEl, k = u.target; if (c.params.navigation.hideOnClick && !Z(k).is(E) && !Z(k).is(v)) { if (c.pagination && c.params.pagination && c.params.pagination.clickable && (c.pagination.el === k || c.pagination.el.contains(k))) return; var R; v ? R = v.hasClass(c.params.navigation.hiddenClass) : E && (R = E.hasClass(c.params.navigation.hiddenClass)), !0 === R ? c.emit("navigationShow") : c.emit("navigationHide"), v && v.toggleClass(c.params.navigation.hiddenClass), E && E.toggleClass(c.params.navigation.hiddenClass) } } } }, { "name": "pagination", "params": { "pagination": { "el": null, "bulletElement": "span", "clickable": !1, "hideOnClick": !1, "renderBullet": null, "renderProgressbar": null, "renderFraction": null, "renderCustom": null, "progressbarOpposite": !1, "type": "bullets", "dynamicBullets": !1, "dynamicMainBullets": 1, "formatFractionCurrent": function formatFractionCurrent(c) { return c }, "formatFractionTotal": function formatFractionTotal(c) { return c }, "bulletClass": "swiper-pagination-bullet", "bulletActiveClass": "swiper-pagination-bullet-active", "modifierClass": "swiper-pagination-", "currentClass": "swiper-pagination-current", "totalClass": "swiper-pagination-total", "hiddenClass": "swiper-pagination-hidden", "progressbarFillClass": "swiper-pagination-progressbar-fill", "progressbarOppositeClass": "swiper-pagination-progressbar-opposite", "clickableClass": "swiper-pagination-clickable", "lockClass": "swiper-pagination-lock" } }, "create": function create() { bindModuleMethods(this, { "pagination": pagination_extends({ "dynamicBulletIndex": 0 }, ye) }) }, "on": { "init": function init(c) { c.pagination.init(), c.pagination.render(), c.pagination.update() }, "activeIndexChange": function activeIndexChange(c) { (c.params.loop || void 0 === c.snapIndex) && c.pagination.update() }, "snapIndexChange": function snapIndexChange(c) { c.params.loop || c.pagination.update() }, "slidesLengthChange": function slidesLengthChange(c) { c.params.loop && (c.pagination.render(), c.pagination.update()) }, "snapGridLengthChange": function snapGridLengthChange(c) { c.params.loop || (c.pagination.render(), c.pagination.update()) }, "destroy": function destroy(c) { c.pagination.destroy() }, "enable disable": function enableDisable(c) { var u = c.pagination.$el; u && u[c.enabled ? "removeClass" : "addClass"](c.params.pagination.lockClass) }, "click": function click(c, u) { var d = u.target; if (c.params.pagination.el && c.params.pagination.hideOnClick && c.pagination.$el.length > 0 && !Z(d).hasClass(c.params.pagination.bulletClass)) { if (c.navigation && (c.navigation.nextEl && d === c.navigation.nextEl || c.navigation.prevEl && d === c.navigation.prevEl)) return; !0 === c.pagination.$el.hasClass(c.params.pagination.hiddenClass) ? c.emit("paginationShow") : c.emit("paginationHide"), c.pagination.$el.toggleClass(c.params.pagination.hiddenClass) } } } }, { "name": "scrollbar", "params": { "scrollbar": { "el": null, "dragSize": "auto", "hide": !1, "draggable": !1, "snapOnRelease": !0, "lockClass": "swiper-scrollbar-lock", "dragClass": "swiper-scrollbar-drag" } }, "create": function create() { bindModuleMethods(this, { "scrollbar": scrollbar_extends({ "isTouched": !1, "timeout": null, "dragTimeout": null }, be) }) }, "on": { "init": function init(c) { c.scrollbar.init(), c.scrollbar.updateSize(), c.scrollbar.setTranslate() }, "update": function update(c) { c.scrollbar.updateSize() }, "resize": function resize(c) { c.scrollbar.updateSize() }, "observerUpdate": function observerUpdate(c) { c.scrollbar.updateSize() }, "setTranslate": function setTranslate(c) { c.scrollbar.setTranslate() }, "setTransition": function setTransition(c, u) { c.scrollbar.setTransition(u) }, "enable disable": function enableDisable(c) { var u = c.scrollbar.$el; u && u[c.enabled ? "removeClass" : "addClass"](c.params.scrollbar.lockClass) }, "destroy": function destroy(c) { c.scrollbar.destroy() } } }, { "name": "parallax", "params": { "parallax": { "enabled": !1 } }, "create": function create() { bindModuleMethods(this, { "parallax": parallax_extends({}, Se) }) }, "on": { "beforeInit": function beforeInit(c) { c.params.parallax.enabled && (c.params.watchSlidesProgress = !0, c.originalParams.watchSlidesProgress = !0) }, "init": function init(c) { c.params.parallax.enabled && c.parallax.setTranslate() }, "setTranslate": function setTranslate(c) { c.params.parallax.enabled && c.parallax.setTranslate() }, "setTransition": function setTransition(c, u) { c.params.parallax.enabled && c.parallax.setTransition(u) } } }, Ee, { "name": "lazy", "params": { "lazy": { "checkInView": !1, "enabled": !1, "loadPrevNext": !1, "loadPrevNextAmount": 1, "loadOnTransitionStart": !1, "scrollingElement": "", "elementClass": "swiper-lazy", "loadingClass": "swiper-lazy-loading", "loadedClass": "swiper-lazy-loaded", "preloaderClass": "swiper-lazy-preloader" } }, "create": function create() { bindModuleMethods(this, { "lazy": lazy_extends({ "initialImageLoaded": !1 }, Ce) }) }, "on": { "beforeInit": function beforeInit(c) { c.params.lazy.enabled && c.params.preloadImages && (c.params.preloadImages = !1) }, "init": function init(c) { c.params.lazy.enabled && !c.params.loop && 0 === c.params.initialSlide && (c.params.lazy.checkInView ? c.lazy.checkInViewOnLoad() : c.lazy.load()) }, "scroll": function scroll(c) { c.params.freeMode && !c.params.freeModeSticky && c.lazy.load() }, "scrollbarDragMove resize _freeModeNoMomentumRelease": function lazyLoad(c) { c.params.lazy.enabled && c.lazy.load() }, "transitionStart": function transitionStart(c) { c.params.lazy.enabled && (c.params.lazy.loadOnTransitionStart || !c.params.lazy.loadOnTransitionStart && !c.lazy.initialImageLoaded) && c.lazy.load() }, "transitionEnd": function transitionEnd(c) { c.params.lazy.enabled && !c.params.lazy.loadOnTransitionStart && c.lazy.load() }, "slideChange": function slideChange(c) { var u = c.params, d = u.lazy, v = u.cssMode, E = u.watchSlidesVisibility, k = u.watchSlidesProgress, R = u.touchReleaseOnEdges, U = u.resistanceRatio; d.enabled && (v || (E || k) && (R || 0 === U)) && c.lazy.load() } } }, xe, { "name": "a11y", "params": { "a11y": { "enabled": !0, "notificationClass": "swiper-notification", "prevSlideMessage": "Previous slide", "nextSlideMessage": "Next slide", "firstSlideMessage": "This is the first slide", "lastSlideMessage": "This is the last slide", "paginationBulletMessage": "Go to slide {{index}}", "slideLabelMessage": "{{index}} / {{slidesLength}}", "containerMessage": null, "containerRoleDescriptionMessage": null, "itemRoleDescriptionMessage": null, "slideRole": "group" } }, "create": function create() { bindModuleMethods(this, { "a11y": a11y_extends({}, Ae, { "liveRegion": Z('<span class="' + this.params.a11y.notificationClass + '" aria-live="assertive" aria-atomic="true"></span>') }) }) }, "on": { "afterInit": function afterInit(c) { c.params.a11y.enabled && (c.a11y.init(), c.a11y.updateNavigation()) }, "toEdge": function toEdge(c) { c.params.a11y.enabled && c.a11y.updateNavigation() }, "fromEdge": function fromEdge(c) { c.params.a11y.enabled && c.a11y.updateNavigation() }, "paginationUpdate": function paginationUpdate(c) { c.params.a11y.enabled && c.a11y.updatePagination() }, "destroy": function destroy(c) { c.params.a11y.enabled && c.a11y.destroy() } } }, { "name": "history", "params": { "history": { "enabled": !1, "root": "", "replaceState": !1, "key": "slides" } }, "create": function create() { bindModuleMethods(this, { "history": history_extends({}, Ie) }) }, "on": { "init": function init(c) { c.params.history.enabled && c.history.init() }, "destroy": function destroy(c) { c.params.history.enabled && c.history.destroy() }, "transitionEnd _freeModeNoMomentumRelease": function transitionEnd_freeModeNoMomentumRelease(c) { c.history.initialized && c.history.setHistory(c.params.history.key, c.activeIndex) }, "slideChange": function slideChange(c) { c.history.initialized && c.params.cssMode && c.history.setHistory(c.params.history.key, c.activeIndex) } } }, { "name": "hash-navigation", "params": { "hashNavigation": { "enabled": !1, "replaceState": !1, "watchState": !1 } }, "create": function create() { bindModuleMethods(this, { "hashNavigation": hash_navigation_extends({ "initialized": !1 }, ke) }) }, "on": { "init": function init(c) { c.params.hashNavigation.enabled && c.hashNavigation.init() }, "destroy": function destroy(c) { c.params.hashNavigation.enabled && c.hashNavigation.destroy() }, "transitionEnd _freeModeNoMomentumRelease": function transitionEnd_freeModeNoMomentumRelease(c) { c.hashNavigation.initialized && c.hashNavigation.setHash() }, "slideChange": function slideChange(c) { c.hashNavigation.initialized && c.params.cssMode && c.hashNavigation.setHash() } } }, { "name": "autoplay", "params": { "autoplay": { "enabled": !1, "delay": 3e3, "waitForTransition": !0, "disableOnInteraction": !0, "stopOnLastSlide": !1, "reverseDirection": !1, "pauseOnMouseEnter": !1 } }, "create": function create() { bindModuleMethods(this, { "autoplay": autoplay_extends({}, Oe, { "running": !1, "paused": !1 }) }) }, "on": { "init": function init(c) { c.params.autoplay.enabled && (c.autoplay.start(), getDocument().addEventListener("visibilitychange", c.autoplay.onVisibilityChange), c.autoplay.attachMouseEvents()) }, "beforeTransitionStart": function beforeTransitionStart(c, u, d) { c.autoplay.running && (d || !c.params.autoplay.disableOnInteraction ? c.autoplay.pause(u) : c.autoplay.stop()) }, "sliderFirstMove": function sliderFirstMove(c) { c.autoplay.running && (c.params.autoplay.disableOnInteraction ? c.autoplay.stop() : c.autoplay.pause()) }, "touchEnd": function touchEnd(c) { c.params.cssMode && c.autoplay.paused && !c.params.autoplay.disableOnInteraction && c.autoplay.run() }, "destroy": function destroy(c) { c.autoplay.detachMouseEvents(), c.autoplay.running && c.autoplay.stop(), getDocument().removeEventListener("visibilitychange", c.autoplay.onVisibilityChange) } } }, { "name": "effect-fade", "params": { "fadeEffect": { "crossFade": !1 } }, "create": function create() { bindModuleMethods(this, { "fadeEffect": effect_fade_extends({}, Pe) }) }, "on": { "beforeInit": function beforeInit(c) { if ("fade" === c.params.effect) { c.classNames.push(c.params.containerModifierClass + "fade"); var u = { "slidesPerView": 1, "slidesPerColumn": 1, "slidesPerGroup": 1, "watchSlidesProgress": !0, "spaceBetween": 0, "virtualTranslate": !0 }; utils_extend(c.params, u), utils_extend(c.originalParams, u) } }, "setTranslate": function setTranslate(c) { "fade" === c.params.effect && c.fadeEffect.setTranslate() }, "setTransition": function setTransition(c, u) { "fade" === c.params.effect && c.fadeEffect.setTransition(u) } } }, { "name": "effect-cube", "params": { "cubeEffect": { "slideShadows": !0, "shadow": !0, "shadowOffset": 20, "shadowScale": .94 } }, "create": function create() { bindModuleMethods(this, { "cubeEffect": effect_cube_extends({}, Re) }) }, "on": { "beforeInit": function beforeInit(c) { if ("cube" === c.params.effect) { c.classNames.push(c.params.containerModifierClass + "cube"), c.classNames.push(c.params.containerModifierClass + "3d"); var u = { "slidesPerView": 1, "slidesPerColumn": 1, "slidesPerGroup": 1, "watchSlidesProgress": !0, "resistanceRatio": 0, "spaceBetween": 0, "centeredSlides": !1, "virtualTranslate": !0 }; utils_extend(c.params, u), utils_extend(c.originalParams, u) } }, "setTranslate": function setTranslate(c) { "cube" === c.params.effect && c.cubeEffect.setTranslate() }, "setTransition": function setTransition(c, u) { "cube" === c.params.effect && c.cubeEffect.setTransition(u) } } }, { "name": "effect-flip", "params": { "flipEffect": { "slideShadows": !0, "limitRotation": !0 } }, "create": function create() { bindModuleMethods(this, { "flipEffect": effect_flip_extends({}, Me) }) }, "on": { "beforeInit": function beforeInit(c) { if ("flip" === c.params.effect) { c.classNames.push(c.params.containerModifierClass + "flip"), c.classNames.push(c.params.containerModifierClass + "3d"); var u = { "slidesPerView": 1, "slidesPerColumn": 1, "slidesPerGroup": 1, "watchSlidesProgress": !0, "spaceBetween": 0, "virtualTranslate": !0 }; utils_extend(c.params, u), utils_extend(c.originalParams, u) } }, "setTranslate": function setTranslate(c) { "flip" === c.params.effect && c.flipEffect.setTranslate() }, "setTransition": function setTransition(c, u) { "flip" === c.params.effect && c.flipEffect.setTransition(u) } } }, { "name": "effect-coverflow", "params": { "coverflowEffect": { "rotate": 50, "stretch": 0, "depth": 100, "scale": 1, "modifier": 1, "slideShadows": !0 } }, "create": function create() { bindModuleMethods(this, { "coverflowEffect": effect_coverflow_extends({}, Ne) }) }, "on": { "beforeInit": function beforeInit(c) { "coverflow" === c.params.effect && (c.classNames.push(c.params.containerModifierClass + "coverflow"), c.classNames.push(c.params.containerModifierClass + "3d"), c.params.watchSlidesProgress = !0, c.originalParams.watchSlidesProgress = !0) }, "setTranslate": function setTranslate(c) { "coverflow" === c.params.effect && c.coverflowEffect.setTranslate() }, "setTransition": function setTransition(c, u) { "coverflow" === c.params.effect && c.coverflowEffect.setTransition(u) } } }, { "name": "thumbs", "params": { "thumbs": { "swiper": null, "multipleActiveThumbs": !0, "autoScrollOffset": 0, "slideThumbActiveClass": "swiper-slide-thumb-active", "thumbsContainerClass": "swiper-container-thumbs" } }, "create": function create() { bindModuleMethods(this, { "thumbs": thumbs_extends({ "swiper": null, "initialized": !1 }, De) }) }, "on": { "beforeInit": function beforeInit(c) { var u = c.params.thumbs; u && u.swiper && (c.thumbs.init(), c.thumbs.update(!0)) }, "slideChange": function slideChange(c) { c.thumbs.swiper && c.thumbs.update() }, "update": function update(c) { c.thumbs.swiper && c.thumbs.update() }, "resize": function resize(c) { c.thumbs.swiper && c.thumbs.update() }, "observerUpdate": function observerUpdate(c) { c.thumbs.swiper && c.thumbs.update() }, "setTransition": function setTransition(c, u) { var d = c.thumbs.swiper; d && d.setTransition(u) }, "beforeDestroy": function beforeDestroy(c) { var u = c.thumbs.swiper; u && c.thumbs.swiperCreated && u && u.destroy() } } }]; pe.use($e) }, "9885": function (c) { const u = /[A-Z\xc0-\xd6\xd8-\xde]?[a-z\xdf-\xf6\xf8-\xff]+(?:['’](?:d|ll|m|re|s|t|ve))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde]|$)|(?:[A-Z\xc0-\xd6\xd8-\xde]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['’](?:D|LL|M|RE|S|T|VE))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde](?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])|$)|[A-Z\xc0-\xd6\xd8-\xde]?(?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['’](?:d|ll|m|re|s|t|ve))?|[A-Z\xc0-\xd6\xd8-\xde]+(?:['’](?:D|LL|M|RE|S|T|VE))?|\d*(?:1ST|2ND|3RD|(?![123])\dTH)(?=\b|[a-z_])|\d*(?:1st|2nd|3rd|(?![123])\dth)(?=\b|[A-Z_])|\d+|(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?(?:\u200d(?:[^\ud800-\udfff]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?)*/g, words = c => c.match(u) || [], upperFirst = c => c[0].toUpperCase() + c.slice(1), join = (c, u) => words(c).join(u).toLowerCase(), camelCase = c => words(c).reduce(((c, u) => `${c}${c ? u[0].toUpperCase() + u.slice(1).toLowerCase() : u.toLowerCase()}`), ""); c.exports = { "words": words, "upperFirst": upperFirst, "camelCase": camelCase, "pascalCase": c => upperFirst(camelCase(c)), "snakeCase": c => join(c, "_"), "kebabCase": c => join(c, "-"), "sentenceCase": c => upperFirst(join(c, " ")), "titleCase": c => words(c).map(upperFirst).join(" ") } }, "1742": function (c) { c.exports = function () { var c = document.getSelection(); if (!c.rangeCount) return function () { }; for (var u = document.activeElement, d = [], v = 0; v < c.rangeCount; v++)d.push(c.getRangeAt(v)); switch (u.tagName.toUpperCase()) { case "INPUT": case "TEXTAREA": u.blur(); break; default: u = null }return c.removeAllRanges(), function () { "Caret" === c.type && c.removeAllRanges(), c.rangeCount || d.forEach((function (u) { c.addRange(u) })), u && u.focus() } } }, "4633": function (c) { function toposort(c, u) { var d = c.length, v = new Array(d), E = {}, k = d, R = function makeOutgoingEdges(c) { for (var u = new Map, d = 0, v = c.length; d < v; d++) { var E = c[d]; u.has(E[0]) || u.set(E[0], new Set), u.has(E[1]) || u.set(E[1], new Set), u.get(E[0]).add(E[1]) } return u }(u), U = function makeNodesHash(c) { for (var u = new Map, d = 0, v = c.length; d < v; d++)u.set(c[d], d); return u }(c); for (u.forEach((function (c) { if (!U.has(c[0]) || !U.has(c[1])) throw new Error("Unknown node. There is an unknown node in the supplied edges.") })); k--;)E[k] || visit(c[k], k, new Set); return v; function visit(c, u, k) { if (k.has(c)) { var H; try { H = ", node was:" + JSON.stringify(c) } catch (c) { H = "" } throw new Error("Cyclic dependency" + H) } if (!U.has(c)) throw new Error("Found unknown node. Make sure to provided all involved nodes. Unknown node: " + JSON.stringify(c)); if (!E[u]) { E[u] = !0; var G = R.get(c) || new Set; if (u = (G = Array.from(G)).length) { k.add(c); do { var W = G[--u]; visit(W, U.get(W), k) } while (u); k.delete(c) } v[--d] = c } } } c.exports = function (c) { return toposort(function uniqueNodes(c) { for (var u = new Set, d = 0, v = c.length; d < v; d++) { var E = c[d]; u.add(E[0]), u.add(E[1]) } return Array.from(u) }(c), c) }, c.exports.array = toposort }, "9724": function (c, u, d) { "use strict"; var v = d(2095), E = d.n(v), k = Object.prototype.hasOwnProperty, R = new Map; function decodeParam(c) { try { return decodeURIComponent(c) } catch (u) { return c } } function matchRoute(c, u, d, v, U) { var H, G, W = 0; return { "next": function next(Z) { if (c === Z) return { "done": !0 }; if (!H && (H = function matchPath(c, u, d, v) { var U = !c.children, H = (c.path || "") + "|" + U, G = R.get(H); if (!G) { var W = []; G = { "keys": W, "pattern": E()(c.path || "", W, { "end": U }) }, R.set(H, G) } var Z = G.pattern.exec(u); if (!Z) return null; for (var Y = Z[0], J = Object.assign({}, v), K = 1; K < Z.length; K++) { var X = G.keys[K - 1], Q = X.name, ee = Z[K]; void 0 === ee && k.call(J, Q) || (X.repeat ? J[Q] = ee ? ee.split(X.delimiter).map(decodeParam) : [] : J[Q] = ee ? decodeParam(ee) : ee) } return { "path": U || "/" !== Y.charAt(Y.length - 1) ? Y : Y.substr(1), "keys": d.concat(G.keys), "params": J } }(c, d, v, U), H)) return { "done": !1, "value": { "route": c, "baseUrl": u, "path": H.path, "keys": H.keys, "params": H.params } }; if (H && c.children) for (; W < c.children.length;) { if (!G) { var Y = c.children[W]; Y.parent = c, G = matchRoute(Y, u + H.path, d.substr(H.path.length), H.keys, H.params) } var J = G.next(Z); if (!J.done) return { "done": !1, "value": J.value }; G = null, W++ } return { "done": !0 } } } } function resolveRoute(c, u) { if ("function" == typeof c.route.action) return c.route.action(c, u) } var U = function () { function UniversalRouter(c, u) { if (void 0 === u && (u = {}), !c || "object" != typeof c) throw new TypeError("Invalid routes"); this.baseUrl = u.baseUrl || "", this.errorHandler = u.errorHandler, this.resolveRoute = u.resolveRoute || resolveRoute, this.context = Object.assign({ "router": this }, u.context), this.root = Array.isArray(c) ? { "path": "", "children": c, "parent": null } : c, this.root.parent = null } return UniversalRouter.prototype.resolve = function resolve(c) { var u = this, d = Object.assign({}, this.context, {}, "string" == typeof c ? { "pathname": c } : c), v = matchRoute(this.root, this.baseUrl, d.pathname.substr(this.baseUrl.length), [], null), resolve = this.resolveRoute, E = null, k = null, R = d; function next(c, u, U) { void 0 === u && (u = E.value.route); var H = null === U && !E.done && E.value.route; if (E = k || v.next(H), k = null, !c && (E.done || !function isChildRoute(c, u) { for (var d = u; d;)if ((d = d.parent) === c) return !0; return !1 }(u, E.value.route))) return k = E, Promise.resolve(null); if (E.done) { var G = new Error("Route not found"); return G.status = 404, Promise.reject(G) } return R = Object.assign({}, d, {}, E.value), Promise.resolve(resolve(R, E.value.params)).then((function (d) { return null != d ? d : next(c, u, d) })) } return d.next = next, Promise.resolve().then((function () { return next(!0, u.root) })).catch((function (c) { if (u.errorHandler) return u.errorHandler(c, R); throw c })) }, UniversalRouter }(); U.pathToRegexp = E(), u.Z = U }, "2095": function (c) { c.exports = pathToRegexp, c.exports.match = function match(c, u) { var d = []; return regexpToFunction(pathToRegexp(c, d, u), d) }, c.exports.regexpToFunction = regexpToFunction, c.exports.parse = parse, c.exports.compile = function compile(c, u) { return tokensToFunction(parse(c, u), u) }, c.exports.tokensToFunction = tokensToFunction, c.exports.tokensToRegExp = tokensToRegExp; var u = "/", d = new RegExp(["(\\\\.)", "(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?"].join("|"), "g"); function parse(c, v) { for (var E, k = [], R = 0, U = 0, H = "", G = v && v.delimiter || u, W = v && v.whitelist || void 0, Z = !1; null !== (E = d.exec(c));) { var Y = E[0], J = E[1], K = E.index; if (H += c.slice(U, K), U = K + Y.length, J) H += J[1], Z = !0; else { var X = "", Q = E[2], ee = E[3], te = E[4], ne = E[5]; if (!Z && H.length) { var re = H.length - 1, oe = H[re]; (!W || W.indexOf(oe) > -1) && (X = oe, H = H.slice(0, re)) } H && (k.push(H), H = "", Z = !1); var ie = "+" === ne || "*" === ne, ae = "?" === ne || "*" === ne, se = ee || te, ce = X || G; k.push({ "name": Q || R++, "prefix": X, "delimiter": ce, "optional": ae, "repeat": ie, "pattern": se ? escapeGroup(se) : "[^" + escapeString(ce === G ? ce : ce + G) + "]+?" }) } } return (H || U < c.length) && k.push(H + c.substr(U)), k } function regexpToFunction(c, u) { return function (d, v) { var E = c.exec(d); if (!E) return !1; for (var k = E[0], R = E.index, U = {}, H = v && v.decode || decodeURIComponent, G = 1; G < E.length; G++)if (void 0 !== E[G]) { var W = u[G - 1]; W.repeat ? U[W.name] = E[G].split(W.delimiter).map((function (c) { return H(c, W) })) : U[W.name] = H(E[G], W) } return { "path": k, "index": R, "params": U } } } function tokensToFunction(c, u) { for (var d = new Array(c.length), v = 0; v < c.length; v++)"object" == typeof c[v] && (d[v] = new RegExp("^(?:" + c[v].pattern + ")$", flags(u))); return function (u, v) { for (var E = "", k = v && v.encode || encodeURIComponent, R = !v || !1 !== v.validate, U = 0; U < c.length; U++) { var H = c[U]; if ("string" != typeof H) { var G, W = u ? u[H.name] : void 0; if (Array.isArray(W)) { if (!H.repeat) throw new TypeError('Expected "' + H.name + '" to not repeat, but got array'); if (0 === W.length) { if (H.optional) continue; throw new TypeError('Expected "' + H.name + '" to not be empty') } for (var Z = 0; Z < W.length; Z++) { if (G = k(W[Z], H), R && !d[U].test(G)) throw new TypeError('Expected all "' + H.name + '" to match "' + H.pattern + '"'); E += (0 === Z ? H.prefix : H.delimiter) + G } } else if ("string" != typeof W && "number" != typeof W && "boolean" != typeof W) { if (!H.optional) throw new TypeError('Expected "' + H.name + '" to be ' + (H.repeat ? "an array" : "a string")) } else { if (G = k(String(W), H), R && !d[U].test(G)) throw new TypeError('Expected "' + H.name + '" to match "' + H.pattern + '", but got "' + G + '"'); E += H.prefix + G } } else E += H } return E } } function escapeString(c) { return c.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1") } function escapeGroup(c) { return c.replace(/([=!:$/()])/g, "\\$1") } function flags(c) { return c && c.sensitive ? "" : "i" } function tokensToRegExp(c, d, v) { for (var E = (v = v || {}).strict, k = !1 !== v.start, R = !1 !== v.end, U = v.delimiter || u, H = [].concat(v.endsWith || []).map(escapeString).concat("$").join("|"), G = k ? "^" : "", W = 0; W < c.length; W++) { var Z = c[W]; if ("string" == typeof Z) G += escapeString(Z); else { var Y = Z.repeat ? "(?:" + Z.pattern + ")(?:" + escapeString(Z.delimiter) + "(?:" + Z.pattern + "))*" : Z.pattern; d && d.push(Z), Z.optional ? Z.prefix ? G += "(?:" + escapeString(Z.prefix) + "(" + Y + "))?" : G += "(" + Y + ")?" : G += escapeString(Z.prefix) + "(" + Y + ")" } } if (R) E || (G += "(?:" + escapeString(U) + ")?"), G += "$" === H ? "$" : "(?=" + H + ")"; else { var J = c[c.length - 1], K = "string" == typeof J ? J[J.length - 1] === U : void 0 === J; E || (G += "(?:" + escapeString(U) + "(?=" + H + "))?"), K || (G += "(?=" + escapeString(U) + "|" + H + ")") } return new RegExp(G, flags(v)) } function pathToRegexp(c, u, d) { return c instanceof RegExp ? function regexpToRegexp(c, u) { if (!u) return c; var d = c.source.match(/\((?!\?)/g); if (d) for (var v = 0; v < d.length; v++)u.push({ "name": v, "prefix": null, "delimiter": null, "optional": !1, "repeat": !1, "pattern": null }); return c }(c, u) : Array.isArray(c) ? function arrayToRegexp(c, u, d) { for (var v = [], E = 0; E < c.length; E++)v.push(pathToRegexp(c[E], u, d).source); return new RegExp("(?:" + v.join("|") + ")", flags(d)) }(c, u, d) : function stringToRegexp(c, u, d) { return tokensToRegExp(parse(c, d), u, d) }(c, u, d) } }, "989": function (c, u, d) { "use strict"; d.d(u, { "MT": function () { return createStore }, "nv": function () { return se }, "Se": function () { return ae }, "OI": function () { return ie }, "rn": function () { return oe } }); var v = d(6252), E = d(2610); function getTarget() { return "undefined" != typeof navigator && "undefined" != typeof window ? window : "undefined" != typeof globalThis ? globalThis : {} } const k = "function" == typeof Proxy, R = "devtools-plugin:setup"; let U, H; function now() { return function isPerformanceSupported() { var c; return void 0 !== U || ("undefined" != typeof window && window.performance ? (U = !0, H = window.performance) : "undefined" != typeof globalThis && (null === (c = globalThis.perf_hooks) || void 0 === c ? void 0 : c.performance) ? (U = !0, H = globalThis.perf_hooks.performance) : U = !1), U }() ? H.now() : Date.now() } class ApiProxy { "constructor"(c, u) { this.target = null, this.targetQueue = [], this.onQueue = [], this.plugin = c, this.hook = u; const d = {}; if (c.settings) for (const u in c.settings) { const v = c.settings[u]; d[u] = v.defaultValue } const v = `__vue-devtools-plugin-settings__${c.id}`; let E = Object.assign({}, d); try { const c = localStorage.getItem(v), u = JSON.parse(c); Object.assign(E, u) } catch (c) { } this.fallbacks = { "getSettings"() { return E }, "setSettings"(c) { try { localStorage.setItem(v, JSON.stringify(c)) } catch (c) { } E = c }, "now"() { return now() } }, u && u.on("plugin:settings:set", ((c, u) => { c === this.plugin.id && this.fallbacks.setSettings(u) })), this.proxiedOn = new Proxy({}, { "get": (c, u) => this.target ? this.target.on[u] : (...c) => { this.onQueue.push({ "method": u, "args": c }) } }), this.proxiedTarget = new Proxy({}, { "get": (c, u) => this.target ? this.target[u] : "on" === u ? this.proxiedOn : Object.keys(this.fallbacks).includes(u) ? (...c) => (this.targetQueue.push({ "method": u, "args": c, "resolve": () => { } }), this.fallbacks[u](...c)) : (...c) => new Promise((d => { this.targetQueue.push({ "method": u, "args": c, "resolve": d }) })) }) } async"setRealTarget"(c) { this.target = c; for (const c of this.onQueue) this.target.on[c.method](...c.args); for (const c of this.targetQueue) c.resolve(await this.target[c.method](...c.args)) } } function setupDevtoolsPlugin(c, u) { const d = c, v = getTarget(), E = function getDevtoolsGlobalHook() { return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__ }(), U = k && d.enableEarlyProxy; if (!E || !v.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ && U) { const c = U ? new ApiProxy(d, E) : null; (v.__VUE_DEVTOOLS_PLUGINS__ = v.__VUE_DEVTOOLS_PLUGINS__ || []).push({ "pluginDescriptor": d, "setupFn": u, "proxy": c }), c && u(c.proxiedTarget) } else E.emit(R, c, u) } var G = "store"; function forEachValue(c, u) { Object.keys(c).forEach((function (d) { return u(c[d], d) })) } function isObject(c) { return null !== c && "object" == typeof c } function genericSubscribe(c, u, d) { return u.indexOf(c) < 0 && (d && d.prepend ? u.unshift(c) : u.push(c)), function () { var d = u.indexOf(c); d > -1 && u.splice(d, 1) } } function resetStore(c, u) { c._actions = Object.create(null), c._mutations = Object.create(null), c._wrappedGetters = Object.create(null), c._modulesNamespaceMap = Object.create(null); var d = c.state; installModule(c, d, [], c._modules.root, !0), resetStoreState(c, d, u) } function resetStoreState(c, u, d) { var k = c._state, R = c._scope; c.getters = {}, c._makeLocalGettersCache = Object.create(null); var U = c._wrappedGetters, H = {}, G = {}, W = (0, E.B)(!0); W.run((function () { forEachValue(U, (function (u, d) { H[d] = function partial(c, u) { return function () { return c(u) } }(u, c), G[d] = (0, v.Fl)((function () { return H[d]() })), Object.defineProperty(c.getters, d, { "get": function () { return G[d].value }, "enumerable": !0 }) })) })), c._state = (0, E.qj)({ "data": u }), c._scope = W, c.strict && function enableStrictMode(c) { (0, v.YP)((function () { return c._state.data }), (function () { 0 }), { "deep": !0, "flush": "sync" }) }(c), k && d && c._withCommit((function () { k.data = null })), R && R.stop() } function installModule(c, u, d, v, E) { var k = !d.length, R = c._modules.getNamespace(d); if (v.namespaced && (c._modulesNamespaceMap[R], c._modulesNamespaceMap[R] = v), !k && !E) { var U = getNestedState(u, d.slice(0, -1)), H = d[d.length - 1]; c._withCommit((function () { U[H] = v.state })) } var G = v.context = function makeLocalContext(c, u, d) { var v = "" === u, E = { "dispatch": v ? c.dispatch : function (d, v, E) { var k = unifyObjectStyle(d, v, E), R = k.payload, U = k.options, H = k.type; return U && U.root || (H = u + H), c.dispatch(H, R) }, "commit": v ? c.commit : function (d, v, E) { var k = unifyObjectStyle(d, v, E), R = k.payload, U = k.options, H = k.type; U && U.root || (H = u + H), c.commit(H, R, U) } }; return Object.defineProperties(E, { "getters": { "get": v ? function () { return c.getters } : function () { return makeLocalGetters(c, u) } }, "state": { "get": function () { return getNestedState(c.state, d) } } }), E }(c, R, d); v.forEachMutation((function (u, d) { !function registerMutation(c, u, d, v) { var E = c._mutations[u] || (c._mutations[u] = []); E.push((function wrappedMutationHandler(u) { d.call(c, v.state, u) })) }(c, R + d, u, G) })), v.forEachAction((function (u, d) { var v = u.root ? d : R + d, E = u.handler || u; !function registerAction(c, u, d, v) { var E = c._actions[u] || (c._actions[u] = []); E.push((function wrappedActionHandler(u) { var E = d.call(c, { "dispatch": v.dispatch, "commit": v.commit, "getters": v.getters, "state": v.state, "rootGetters": c.getters, "rootState": c.state }, u); return function isPromise(c) { return c && "function" == typeof c.then }(E) || (E = Promise.resolve(E)), c._devtoolHook ? E.catch((function (u) { throw c._devtoolHook.emit("vuex:error", u), u })) : E })) }(c, v, E, G) })), v.forEachGetter((function (u, d) { !function registerGetter(c, u, d, v) { if (c._wrappedGetters[u]) return void 0; c._wrappedGetters[u] = function wrappedGetter(c) { return d(v.state, v.getters, c.state, c.getters) } }(c, R + d, u, G) })), v.forEachChild((function (v, k) { installModule(c, u, d.concat(k), v, E) })) } function makeLocalGetters(c, u) { if (!c._makeLocalGettersCache[u]) { var d = {}, v = u.length; Object.keys(c.getters).forEach((function (E) { if (E.slice(0, v) === u) { var k = E.slice(v); Object.defineProperty(d, k, { "get": function () { return c.getters[E] }, "enumerable": !0 }) } })), c._makeLocalGettersCache[u] = d } return c._makeLocalGettersCache[u] } function getNestedState(c, u) { return u.reduce((function (c, u) { return c[u] }), c) } function unifyObjectStyle(c, u, d) { return isObject(c) && c.type && (d = u, u = c, c = c.type), { "type": c, "payload": u, "options": d } } var W = "vuex:mutations", Z = "vuex:actions", Y = "vuex", J = 0; function addDevtools(c, u) { setupDevtoolsPlugin({ "id": "org.vuejs.vuex", "app": c, "label": "Vuex", "homepage": "https://next.vuex.vuejs.org/", "logo": "https://vuejs.org/images/icons/favicon-96x96.png", "packageName": "vuex", "componentStateTypes": ["vuex bindings"] }, (function (d) { d.addTimelineLayer({ "id": W, "label": "Vuex Mutations", "color": K }), d.addTimelineLayer({ "id": Z, "label": "Vuex Actions", "color": K }), d.addInspector({ "id": Y, "label": "Vuex", "icon": "storage", "treeFilterPlaceholder": "Filter stores..." }), d.on.getInspectorTree((function (d) { if (d.app === c && d.inspectorId === Y) if (d.filter) { var v = []; flattenStoreForInspectorTree(v, u._modules.root, d.filter, ""), d.rootNodes = v } else d.rootNodes = [formatStoreForInspectorTree(u._modules.root, "")] })), d.on.getInspectorState((function (d) { if (d.app === c && d.inspectorId === Y) { var v = d.nodeId; makeLocalGetters(u, v), d.state = function formatStoreForInspectorState(c, u, d) { u = "root" === d ? u : u[d]; var v = Object.keys(u), E = { "state": Object.keys(c.state).map((function (u) { return { "key": u, "editable": !0, "value": c.state[u] } })) }; if (v.length) { var k = function transformPathsToObjectTree(c) { var u = {}; return Object.keys(c).forEach((function (d) { var v = d.split("/"); if (v.length > 1) { var E = u, k = v.pop(); v.forEach((function (c) { E[c] || (E[c] = { "_custom": { "value": {}, "display": c, "tooltip": "Module", "abstract": !0 } }), E = E[c]._custom.value })), E[k] = canThrow((function () { return c[d] })) } else u[d] = canThrow((function () { return c[d] })) })), u }(u); E.getters = Object.keys(k).map((function (c) { return { "key": c.endsWith("/") ? extractNameFromPath(c) : c, "editable": !1, "value": canThrow((function () { return k[c] })) } })) } return E }(function getStoreModule(c, u) { var d = u.split("/").filter((function (c) { return c })); return d.reduce((function (c, v, E) { var k = c[v]; if (!k) throw new Error('Missing module "' + v + '" for path "' + u + '".'); return E === d.length - 1 ? k : k._children }), "root" === u ? c : c.root._children) }(u._modules, v), "root" === v ? u.getters : u._makeLocalGettersCache, v) } })), d.on.editInspectorState((function (d) { if (d.app === c && d.inspectorId === Y) { var v = d.nodeId, E = d.path; "root" !== v && (E = v.split("/").filter(Boolean).concat(E)), u._withCommit((function () { d.set(u._state.data, E, d.state.value) })) } })), u.subscribe((function (c, u) { var v = {}; c.payload && (v.payload = c.payload), v.state = u, d.notifyComponentUpdate(), d.sendInspectorTree(Y), d.sendInspectorState(Y), d.addTimelineEvent({ "layerId": W, "event": { "time": Date.now(), "title": c.type, "data": v } }) })), u.subscribeAction({ "before": function (c, u) { var v = {}; c.payload && (v.payload = c.payload), c._id = J++, c._time = Date.now(), v.state = u, d.addTimelineEvent({ "layerId": Z, "event": { "time": c._time, "title": c.type, "groupId": c._id, "subtitle": "start", "data": v } }) }, "after": function (c, u) { var v = {}, E = Date.now() - c._time; v.duration = { "_custom": { "type": "duration", "display": E + "ms", "tooltip": "Action duration", "value": E } }, c.payload && (v.payload = c.payload), v.state = u, d.addTimelineEvent({ "layerId": Z, "event": { "time": Date.now(), "title": c.type, "groupId": c._id, "subtitle": "end", "data": v } }) } }) })) } var K = 8702998, X = { "label": "namespaced", "textColor": 16777215, "backgroundColor": 6710886 }; function extractNameFromPath(c) { return c && "root" !== c ? c.split("/").slice(-2, -1)[0] : "Root" } function formatStoreForInspectorTree(c, u) { return { "id": u || "root", "label": extractNameFromPath(u), "tags": c.namespaced ? [X] : [], "children": Object.keys(c._children).map((function (d) { return formatStoreForInspectorTree(c._children[d], u + d + "/") })) } } function flattenStoreForInspectorTree(c, u, d, v) { v.includes(d) && c.push({ "id": v || "root", "label": v.endsWith("/") ? v.slice(0, v.length - 1) : v || "Root", "tags": u.namespaced ? [X] : [] }), Object.keys(u._children).forEach((function (E) { flattenStoreForInspectorTree(c, u._children[E], d, v + E + "/") })) } function canThrow(c) { try { return c() } catch (c) { return c } } var Q = function Module(c, u) { this.runtime = u, this._children = Object.create(null), this._rawModule = c; var d = c.state; this.state = ("function" == typeof d ? d() : d) || {} }, ee = { "namespaced": { "configurable": !0 } }; ee.namespaced.get = function () { return !!this._rawModule.namespaced }, Q.prototype.addChild = function addChild(c, u) { this._children[c] = u }, Q.prototype.removeChild = function removeChild(c) { delete this._children[c] }, Q.prototype.getChild = function getChild(c) { return this._children[c] }, Q.prototype.hasChild = function hasChild(c) { return c in this._children }, Q.prototype.update = function update(c) { this._rawModule.namespaced = c.namespaced, c.actions && (this._rawModule.actions = c.actions), c.mutations && (this._rawModule.mutations = c.mutations), c.getters && (this._rawModule.getters = c.getters) }, Q.prototype.forEachChild = function forEachChild(c) { forEachValue(this._children, c) }, Q.prototype.forEachGetter = function forEachGetter(c) { this._rawModule.getters && forEachValue(this._rawModule.getters, c) }, Q.prototype.forEachAction = function forEachAction(c) { this._rawModule.actions && forEachValue(this._rawModule.actions, c) }, Q.prototype.forEachMutation = function forEachMutation(c) { this._rawModule.mutations && forEachValue(this._rawModule.mutations, c) }, Object.defineProperties(Q.prototype, ee); var te = function ModuleCollection(c) { this.register([], c, !1) }; function update(c, u, d) { if (u.update(d), d.modules) for (var v in d.modules) { if (!u.getChild(v)) return void 0; update(c.concat(v), u.getChild(v), d.modules[v]) } } te.prototype.get = function get(c) { return c.reduce((function (c, u) { return c.getChild(u) }), this.root) }, te.prototype.getNamespace = function getNamespace(c) { var u = this.root; return c.reduce((function (c, d) { return c + ((u = u.getChild(d)).namespaced ? d + "/" : "") }), "") }, te.prototype.update = function update$1(c) { update([], this.root, c) }, te.prototype.register = function register(c, u, d) { var v = this; void 0 === d && (d = !0); var E = new Q(u, d); 0 === c.length ? this.root = E : this.get(c.slice(0, -1)).addChild(c[c.length - 1], E); u.modules && forEachValue(u.modules, (function (u, E) { v.register(c.concat(E), u, d) })) }, te.prototype.unregister = function unregister(c) { var u = this.get(c.slice(0, -1)), d = c[c.length - 1], v = u.getChild(d); v && v.runtime && u.removeChild(d) }, te.prototype.isRegistered = function isRegistered(c) { var u = this.get(c.slice(0, -1)), d = c[c.length - 1]; return !!u && u.hasChild(d) }; function createStore(c) { return new ne(c) } var ne = function Store(c) { var u = this; void 0 === c && (c = {}); var d = c.plugins; void 0 === d && (d = []); var v = c.strict; void 0 === v && (v = !1); var E = c.devtools; this._committing = !1, this._actions = Object.create(null), this._actionSubscribers = [], this._mutations = Object.create(null), this._wrappedGetters = Object.create(null), this._modules = new te(c), this._modulesNamespaceMap = Object.create(null), this._subscribers = [], this._makeLocalGettersCache = Object.create(null), this._scope = null, this._devtools = E; var k = this, R = this.dispatch, U = this.commit; this.dispatch = function boundDispatch(c, u) { return R.call(k, c, u) }, this.commit = function boundCommit(c, u, d) { return U.call(k, c, u, d) }, this.strict = v; var H = this._modules.root.state; installModule(this, H, [], this._modules.root), resetStoreState(this, H), d.forEach((function (c) { return c(u) })) }, re = { "state": { "configurable": !0 } }; ne.prototype.install = function install(c, u) { c.provide(u || G, this), c.config.globalProperties.$store = this, void 0 !== this._devtools && this._devtools && addDevtools(c, this) }, re.state.get = function () { return this._state.data }, re.state.set = function (c) { 0 }, ne.prototype.commit = function commit(c, u, d) { var v = this, E = unifyObjectStyle(c, u, d), k = E.type, R = E.payload, U = (E.options, { "type": k, "payload": R }), H = this._mutations[k]; H && (this._withCommit((function () { H.forEach((function commitIterator(c) { c(R) })) })), this._subscribers.slice().forEach((function (c) { return c(U, v.state) }))) }, ne.prototype.dispatch = function dispatch(c, u) { var d = this, v = unifyObjectStyle(c, u), E = v.type, k = v.payload, R = { "type": E, "payload": k }, U = this._actions[E]; if (U) { try { this._actionSubscribers.slice().filter((function (c) { return c.before })).forEach((function (c) { return c.before(R, d.state) })) } catch (c) { 0 } var H = U.length > 1 ? Promise.all(U.map((function (c) { return c(k) }))) : U[0](k); return new Promise((function (c, u) { H.then((function (u) { try { d._actionSubscribers.filter((function (c) { return c.after })).forEach((function (c) { return c.after(R, d.state) })) } catch (c) { 0 } c(u) }), (function (c) { try { d._actionSubscribers.filter((function (c) { return c.error })).forEach((function (u) { return u.error(R, d.state, c) })) } catch (c) { 0 } u(c) })) })) } }, ne.prototype.subscribe = function subscribe(c, u) { return genericSubscribe(c, this._subscribers, u) }, ne.prototype.subscribeAction = function subscribeAction(c, u) { return genericSubscribe("function" == typeof c ? { "before": c } : c, this._actionSubscribers, u) }, ne.prototype.watch = function watch$1(c, u, d) { var E = this; return (0, v.YP)((function () { return c(E.state, E.getters) }), u, Object.assign({}, d)) }, ne.prototype.replaceState = function replaceState(c) { var u = this; this._withCommit((function () { u._state.data = c })) }, ne.prototype.registerModule = function registerModule(c, u, d) { void 0 === d && (d = {}), "string" == typeof c && (c = [c]), this._modules.register(c, u), installModule(this, this.state, c, this._modules.get(c), d.preserveState), resetStoreState(this, this.state) }, ne.prototype.unregisterModule = function unregisterModule(c) { var u = this; "string" == typeof c && (c = [c]), this._modules.unregister(c), this._withCommit((function () { delete getNestedState(u.state, c.slice(0, -1))[c[c.length - 1]] })), resetStore(this) }, ne.prototype.hasModule = function hasModule(c) { return "string" == typeof c && (c = [c]), this._modules.isRegistered(c) }, ne.prototype.hotUpdate = function hotUpdate(c) { this._modules.update(c), resetStore(this, !0) }, ne.prototype._withCommit = function _withCommit(c) { var u = this._committing; this._committing = !0, c(), this._committing = u }, Object.defineProperties(ne.prototype, re); var oe = normalizeNamespace((function (c, u) { var d = {}; return normalizeMap(u).forEach((function (u) { var v = u.key, E = u.val; d[v] = function mappedState() { var u = this.$store.state, d = this.$store.getters; if (c) { var v = getModuleByNamespace(this.$store, "mapState", c); if (!v) return; u = v.context.state, d = v.context.getters } return "function" == typeof E ? E.call(this, u, d) : u[E] }, d[v].vuex = !0 })), d })), ie = normalizeNamespace((function (c, u) { var d = {}; return normalizeMap(u).forEach((function (u) { var v = u.key, E = u.val; d[v] = function mappedMutation() { for (var u = [], d = arguments.length; d--;)u[d] = arguments[d]; var v = this.$store.commit; if (c) { var k = getModuleByNamespace(this.$store, "mapMutations", c); if (!k) return; v = k.context.commit } return "function" == typeof E ? E.apply(this, [v].concat(u)) : v.apply(this.$store, [E].concat(u)) } })), d })), ae = normalizeNamespace((function (c, u) { var d = {}; return normalizeMap(u).forEach((function (u) { var v = u.key, E = u.val; E = c + E, d[v] = function mappedGetter() { if (!c || getModuleByNamespace(this.$store, "mapGetters", c)) return this.$store.getters[E] }, d[v].vuex = !0 })), d })), se = normalizeNamespace((function (c, u) { var d = {}; return normalizeMap(u).forEach((function (u) { var v = u.key, E = u.val; d[v] = function mappedAction() { for (var u = [], d = arguments.length; d--;)u[d] = arguments[d]; var v = this.$store.dispatch; if (c) { var k = getModuleByNamespace(this.$store, "mapActions", c); if (!k) return; v = k.context.dispatch } return "function" == typeof E ? E.apply(this, [v].concat(u)) : v.apply(this.$store, [E].concat(u)) } })), d })); function normalizeMap(c) { return function isValidMap(c) { return Array.isArray(c) || isObject(c) }(c) ? Array.isArray(c) ? c.map((function (c) { return { "key": c, "val": c } })) : Object.keys(c).map((function (u) { return { "key": u, "val": c[u] } })) : [] } function normalizeNamespace(c) { return function (u, d) { return "string" != typeof u ? (d = u, u = "") : "/" !== u.charAt(u.length - 1) && (u += "/"), c(u, d) } } function getModuleByNamespace(c, u, d) { return c._modulesNamespaceMap[d] } }, "7147": function (c, u, d) { "use strict"; var v = "undefined" != typeof globalThis && globalThis || "undefined" != typeof self && self || void 0 !== d.g && d.g || {}, E = "URLSearchParams" in v, k = "Symbol" in v && "iterator" in Symbol, R = "FileReader" in v && "Blob" in v && function () { try { return new Blob, !0 } catch (c) { return !1 } }(), U = "FormData" in v, H = "ArrayBuffer" in v; if (H) var G = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"], W = ArrayBuffer.isView || function (c) { return c && G.indexOf(Object.prototype.toString.call(c)) > -1 }; function normalizeName(c) { if ("string" != typeof c && (c = String(c)), /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(c) || "" === c) throw new TypeError('Invalid character in header field name: "' + c + '"'); return c.toLowerCase() } function normalizeValue(c) { return "string" != typeof c && (c = String(c)), c } function iteratorFor(c) { var u = { "next": function () { var u = c.shift(); return { "done": void 0 === u, "value": u } } }; return k && (u[Symbol.iterator] = function () { return u }), u } function Headers(c) { this.map = {}, c instanceof Headers ? c.forEach((function (c, u) { this.append(u, c) }), this) : Array.isArray(c) ? c.forEach((function (c) { if (2 != c.length) throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + c.length); this.append(c[0], c[1]) }), this) : c && Object.getOwnPropertyNames(c).forEach((function (u) { this.append(u, c[u]) }), this) } function consumed(c) { if (!c._noBody) return c.bodyUsed ? Promise.reject(new TypeError("Already read")) : void (c.bodyUsed = !0) } function fileReaderReady(c) { return new Promise((function (u, d) { c.onload = function () { u(c.result) }, c.onerror = function () { d(c.error) } })) } function readBlobAsArrayBuffer(c) { var u = new FileReader, d = fileReaderReady(u); return u.readAsArrayBuffer(c), d } function bufferClone(c) { if (c.slice) return c.slice(0); var u = new Uint8Array(c.byteLength); return u.set(new Uint8Array(c)), u.buffer } function Body() { return this.bodyUsed = !1, this._initBody = function (c) { this.bodyUsed = this.bodyUsed, this._bodyInit = c, c ? "string" == typeof c ? this._bodyText = c : R && Blob.prototype.isPrototypeOf(c) ? this._bodyBlob = c : U && FormData.prototype.isPrototypeOf(c) ? this._bodyFormData = c : E && URLSearchParams.prototype.isPrototypeOf(c) ? this._bodyText = c.toString() : H && R && function isDataView(c) { return c && DataView.prototype.isPrototypeOf(c) }(c) ? (this._bodyArrayBuffer = bufferClone(c.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : H && (ArrayBuffer.prototype.isPrototypeOf(c) || W(c)) ? this._bodyArrayBuffer = bufferClone(c) : this._bodyText = c = Object.prototype.toString.call(c) : (this._noBody = !0, this._bodyText = ""), this.headers.get("content-type") || ("string" == typeof c ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : E && URLSearchParams.prototype.isPrototypeOf(c) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8")) }, R && (this.blob = function () { var c = consumed(this); if (c) return c; if (this._bodyBlob) return Promise.resolve(this._bodyBlob); if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer])); if (this._bodyFormData) throw new Error("could not read FormData body as blob"); return Promise.resolve(new Blob([this._bodyText])) }), this.arrayBuffer = function () { if (this._bodyArrayBuffer) { var c = consumed(this); return c || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength)) : Promise.resolve(this._bodyArrayBuffer)) } if (R) return this.blob().then(readBlobAsArrayBuffer); throw new Error("could not read as ArrayBuffer") }, this.text = function () { var c = consumed(this); if (c) return c; if (this._bodyBlob) return function readBlobAsText(c) { var u = new FileReader, d = fileReaderReady(u), v = /charset=([A-Za-z0-9_-]+)/.exec(c.type), E = v ? v[1] : "utf-8"; return u.readAsText(c, E), d }(this._bodyBlob); if (this._bodyArrayBuffer) return Promise.resolve(function readArrayBufferAsText(c) { for (var u = new Uint8Array(c), d = new Array(u.length), v = 0; v < u.length; v++)d[v] = String.fromCharCode(u[v]); return d.join("") }(this._bodyArrayBuffer)); if (this._bodyFormData) throw new Error("could not read FormData body as text"); return Promise.resolve(this._bodyText) }, U && (this.formData = function () { return this.text().then(decode) }), this.json = function () { return this.text().then(JSON.parse) }, this } Headers.prototype.append = function (c, u) { c = normalizeName(c), u = normalizeValue(u); var d = this.map[c]; this.map[c] = d ? d + ", " + u : u }, Headers.prototype.delete = function (c) { delete this.map[normalizeName(c)] }, Headers.prototype.get = function (c) { return c = normalizeName(c), this.has(c) ? this.map[c] : null }, Headers.prototype.has = function (c) { return this.map.hasOwnProperty(normalizeName(c)) }, Headers.prototype.set = function (c, u) { this.map[normalizeName(c)] = normalizeValue(u) }, Headers.prototype.forEach = function (c, u) { for (var d in this.map) this.map.hasOwnProperty(d) && c.call(u, this.map[d], d, this) }, Headers.prototype.keys = function () { var c = []; return this.forEach((function (u, d) { c.push(d) })), iteratorFor(c) }, Headers.prototype.values = function () { var c = []; return this.forEach((function (u) { c.push(u) })), iteratorFor(c) }, Headers.prototype.entries = function () { var c = []; return this.forEach((function (u, d) { c.push([d, u]) })), iteratorFor(c) }, k && (Headers.prototype[Symbol.iterator] = Headers.prototype.entries); var Z = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"]; function Request(c, u) { if (!(this instanceof Request)) throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.'); var d = (u = u || {}).body; if (c instanceof Request) { if (c.bodyUsed) throw new TypeError("Already read"); this.url = c.url, this.credentials = c.credentials, u.headers || (this.headers = new Headers(c.headers)), this.method = c.method, this.mode = c.mode, this.signal = c.signal, d || null == c._bodyInit || (d = c._bodyInit, c.bodyUsed = !0) } else this.url = String(c); if (this.credentials = u.credentials || this.credentials || "same-origin", !u.headers && this.headers || (this.headers = new Headers(u.headers)), this.method = function normalizeMethod(c) { var u = c.toUpperCase(); return Z.indexOf(u) > -1 ? u : c }(u.method || this.method || "GET"), this.mode = u.mode || this.mode || null, this.signal = u.signal || this.signal || function () { if ("AbortController" in v) return (new AbortController).signal }(), this.referrer = null, ("GET" === this.method || "HEAD" === this.method) && d) throw new TypeError("Body not allowed for GET or HEAD requests"); if (this._initBody(d), !("GET" !== this.method && "HEAD" !== this.method || "no-store" !== u.cache && "no-cache" !== u.cache)) { var E = /([?&])_=[^&]*/; if (E.test(this.url)) this.url = this.url.replace(E, "$1_=" + (new Date).getTime()); else { this.url += (/\?/.test(this.url) ? "&" : "?") + "_=" + (new Date).getTime() } } } function decode(c) { var u = new FormData; return c.trim().split("&").forEach((function (c) { if (c) { var d = c.split("="), v = d.shift().replace(/\+/g, " "), E = d.join("=").replace(/\+/g, " "); u.append(decodeURIComponent(v), decodeURIComponent(E)) } })), u } function Response(c, u) { if (!(this instanceof Response)) throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.'); if (u || (u = {}), this.type = "default", this.status = void 0 === u.status ? 200 : u.status, this.status < 200 || this.status > 599) throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599]."); this.ok = this.status >= 200 && this.status < 300, this.statusText = void 0 === u.statusText ? "" : "" + u.statusText, this.headers = new Headers(u.headers), this.url = u.url || "", this._initBody(c) } Request.prototype.clone = function () { return new Request(this, { "body": this._bodyInit }) }, Body.call(Request.prototype), Body.call(Response.prototype), Response.prototype.clone = function () { return new Response(this._bodyInit, { "status": this.status, "statusText": this.statusText, "headers": new Headers(this.headers), "url": this.url }) }, Response.error = function () { var c = new Response(null, { "status": 200, "statusText": "" }); return c.ok = !1, c.status = 0, c.type = "error", c }; var Y = [301, 302, 303, 307, 308]; Response.redirect = function (c, u) { if (-1 === Y.indexOf(u)) throw new RangeError("Invalid status code"); return new Response(null, { "status": u, "headers": { "location": c } }) }; var J = v.DOMException; try { new J } catch (c) { (J = function (c, u) { this.message = c, this.name = u; var d = Error(c); this.stack = d.stack }).prototype = Object.create(Error.prototype), J.prototype.constructor = J } function fetch(c, u) { return new Promise((function (d, E) { var k = new Request(c, u); if (k.signal && k.signal.aborted) return E(new J("Aborted", "AbortError")); var U = new XMLHttpRequest; function abortXhr() { U.abort() } if (U.onload = function () { var c, u, v = { "statusText": U.statusText, "headers": (c = U.getAllResponseHeaders() || "", u = new Headers, c.replace(/\r?\n[\t ]+/g, " ").split("\r").map((function (c) { return 0 === c.indexOf("\n") ? c.substr(1, c.length) : c })).forEach((function (c) { var d = c.split(":"), v = d.shift().trim(); if (v) { var E = d.join(":").trim(); try { u.append(v, E) } catch (c) { console.warn("Response " + c.message) } } })), u) }; 0 === k.url.indexOf("file://") && (U.status < 200 || U.status > 599) ? v.status = 200 : v.status = U.status, v.url = "responseURL" in U ? U.responseURL : v.headers.get("X-Request-URL"); var E = "response" in U ? U.response : U.responseText; setTimeout((function () { d(new Response(E, v)) }), 0) }, U.onerror = function () { setTimeout((function () { E(new TypeError("Network request failed")) }), 0) }, U.ontimeout = function () { setTimeout((function () { E(new TypeError("Network request timed out")) }), 0) }, U.onabort = function () { setTimeout((function () { E(new J("Aborted", "AbortError")) }), 0) }, U.open(k.method, function fixUrl(c) { try { return "" === c && v.location.href ? v.location.href : c } catch (u) { return c } }(k.url), !0), "include" === k.credentials ? U.withCredentials = !0 : "omit" === k.credentials && (U.withCredentials = !1), "responseType" in U && (R ? U.responseType = "blob" : H && (U.responseType = "arraybuffer")), u && "object" == typeof u.headers && !(u.headers instanceof Headers || v.Headers && u.headers instanceof v.Headers)) { var G = []; Object.getOwnPropertyNames(u.headers).forEach((function (c) { G.push(normalizeName(c)), U.setRequestHeader(c, normalizeValue(u.headers[c])) })), k.headers.forEach((function (c, u) { -1 === G.indexOf(u) && U.setRequestHeader(u, c) })) } else k.headers.forEach((function (c, u) { U.setRequestHeader(u, c) })); k.signal && (k.signal.addEventListener("abort", abortXhr), U.onreadystatechange = function () { 4 === U.readyState && k.signal.removeEventListener("abort", abortXhr) }), U.send(void 0 === k._bodyInit ? null : k._bodyInit) })) } fetch.polyfill = !0, v.fetch || (v.fetch = fetch, v.Headers = Headers, v.Request = Request, v.Response = Response) }, "6310": function (c, u, d) { "use strict"; d.r(u), d.d(u, { "ArraySchema": function () { return ArraySchema }, "BooleanSchema": function () { return BooleanSchema }, "DateSchema": function () { return DateSchema }, "MixedSchema": function () { return MixedSchema }, "NumberSchema": function () { return NumberSchema }, "ObjectSchema": function () { return ObjectSchema }, "Schema": function () { return Schema }, "StringSchema": function () { return StringSchema }, "TupleSchema": function () { return TupleSchema }, "ValidationError": function () { return ValidationError }, "addMethod": function () { return addMethod }, "array": function () { return create$2 }, "bool": function () { return create$7 }, "boolean": function () { return create$7 }, "date": function () { return create$4 }, "defaultLocale": function () { return se }, "getIn": function () { return getIn }, "isSchema": function () { return isSchema }, "lazy": function () { return create }, "mixed": function () { return create$8 }, "number": function () { return create$5 }, "object": function () { return create$3 }, "printValue": function () { return printValue }, "reach": function () { return reach }, "ref": function () { return create$9 }, "setLocale": function () { return setLocale }, "string": function () { return create$6 }, "tuple": function () { return create$1 } }); var v = d(5760), E = d(9885), k = d(4633), R = d.n(k); const U = Object.prototype.toString, H = Error.prototype.toString, G = RegExp.prototype.toString, W = "undefined" != typeof Symbol ? Symbol.prototype.toString : () => "", Z = /^Symbol\((.*)\)(.*)$/; function printSimpleValue(c, u = !1) { if (null == c || !0 === c || !1 === c) return "" + c; const d = typeof c; if ("number" === d) return function printNumber(c) { return c != +c ? "NaN" : 0 === c && 1 / c < 0 ? "-0" : "" + c }(c); if ("string" === d) return u ? `"${c}"` : c; if ("function" === d) return "[Function " + (c.name || "anonymous") + "]"; if ("symbol" === d) return W.call(c).replace(Z, "Symbol($1)"); const v = U.call(c).slice(8, -1); return "Date" === v ? isNaN(c.getTime()) ? "" + c : c.toISOString(c) : "Error" === v || c instanceof Error ? "[" + H.call(c) + "]" : "RegExp" === v ? G.call(c) : null } function printValue(c, u) { let d = printSimpleValue(c, u); return null !== d ? d : JSON.stringify(c, (function (c, d) { let v = printSimpleValue(this[c], u); return null !== v ? v : d }), 2) } function toArray(c) { return null == c ? [] : [].concat(c) } let Y, J, K, X = /\$\{\s*(\w+)\s*\}/g; Y = Symbol.toStringTag; class ValidationErrorNoStack { "constructor"(c, u, d, v) { this.name = void 0, this.message = void 0, this.value = void 0, this.path = void 0, this.type = void 0, this.params = void 0, this.errors = void 0, this.inner = void 0, this[Y] = "Error", this.name = "ValidationError", this.value = u, this.path = d, this.type = v, this.errors = [], this.inner = [], toArray(c).forEach((c => { if (ValidationError.isError(c)) { this.errors.push(...c.errors); const u = c.inner.length ? c.inner : [c]; this.inner.push(...u) } else this.errors.push(c) })), this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0] } } J = Symbol.hasInstance, K = Symbol.toStringTag; class ValidationError extends Error { static "formatError"(c, u) { const d = u.label || u.path || "this"; return d !== u.path && (u = Object.assign({}, u, { "path": d })), "string" == typeof c ? c.replace(X, ((c, d) => printValue(u[d]))) : "function" == typeof c ? c(u) : c } static "isError"(c) { return c && "ValidationError" === c.name } "constructor"(c, u, d, v, E) { const k = new ValidationErrorNoStack(c, u, d, v); if (E) return k; super(), this.value = void 0, this.path = void 0, this.type = void 0, this.params = void 0, this.errors = [], this.inner = [], this[K] = "Error", this.name = k.name, this.message = k.message, this.type = k.type, this.value = k.value, this.path = k.path, this.errors = k.errors, this.inner = k.inner, Error.captureStackTrace && Error.captureStackTrace(this, ValidationError) } static [J](c) { return ValidationErrorNoStack[Symbol.hasInstance](c) || super[Symbol.hasInstance](c) } } let Q = { "default": "${path} is invalid", "required": "${path} is a required field", "defined": "${path} must be defined", "notNull": "${path} cannot be null", "oneOf": "${path} must be one of the following values: ${values}", "notOneOf": "${path} must not be one of the following values: ${values}", "notType": ({ "path": c, "type": u, "value": d, "originalValue": v }) => { const E = null != v && v !== d ? ` (cast from the value \`${printValue(v, !0)}\`).` : "."; return "mixed" !== u ? `${c} must be a \`${u}\` type, but the final value was: \`${printValue(d, !0)}\`` + E : `${c} must match the configured type. The validated value was: \`${printValue(d, !0)}\`` + E } }, ee = { "length": "${path} must be exactly ${length} characters", "min": "${path} must be at least ${min} characters", "max": "${path} must be at most ${max} characters", "matches": '${path} must match the following: "${regex}"', "email": "${path} must be a valid email", "url": "${path} must be a valid URL", "uuid": "${path} must be a valid UUID", "datetime": "${path} must be a valid ISO date-time", "datetime_precision": "${path} must be a valid ISO date-time with a sub-second precision of exactly ${precision} digits", "datetime_offset": '${path} must be a valid ISO date-time with UTC "Z" timezone', "trim": "${path} must be a trimmed string", "lowercase": "${path} must be a lowercase string", "uppercase": "${path} must be a upper case string" }, te = { "min": "${path} must be greater than or equal to ${min}", "max": "${path} must be less than or equal to ${max}", "lessThan": "${path} must be less than ${less}", "moreThan": "${path} must be greater than ${more}", "positive": "${path} must be a positive number", "negative": "${path} must be a negative number", "integer": "${path} must be an integer" }, ne = { "min": "${path} field must be later than ${min}", "max": "${path} field must be at earlier than ${max}" }, re = { "isValue": "${path} field must be ${value}" }, oe = { "noUnknown": "${path} field has unspecified keys: ${unknown}" }, ie = { "min": "${path} field must have at least ${min} items", "max": "${path} field must have less than or equal to ${max} items", "length": "${path} must have ${length} items" }, ae = { "notType": c => { const { "path": u, "value": d, "spec": v } = c, E = v.types.length; if (Array.isArray(d)) { if (d.length < E) return `${u} tuple value has too few items, expected a length of ${E} but got ${d.length} for value: \`${printValue(d, !0)}\``; if (d.length > E) return `${u} tuple value has too many items, expected a length of ${E} but got ${d.length} for value: \`${printValue(d, !0)}\`` } return ValidationError.formatError(Q.notType, c) } }; var se = Object.assign(Object.create(null), { "mixed": Q, "string": ee, "number": te, "date": ne, "object": oe, "array": ie, "boolean": re, "tuple": ae }); const isSchema = c => c && c.__isYupSchema__; class Condition { static "fromOptions"(c, u) { if (!u.then && !u.otherwise) throw new TypeError("either `then:` or `otherwise:` is required for `when()` conditions"); let { "is": d, "then": v, "otherwise": E } = u, k = "function" == typeof d ? d : (...c) => c.every((c => c === d)); return new Condition(c, ((c, u) => { var d; let R = k(...c) ? v : E; return null != (d = null == R ? void 0 : R(u)) ? d : u })) } "constructor"(c, u) { this.fn = void 0, this.refs = c, this.refs = c, this.fn = u } "resolve"(c, u) { let d = this.refs.map((c => c.getValue(null == u ? void 0 : u.value, null == u ? void 0 : u.parent, null == u ? void 0 : u.context))), v = this.fn(d, c, u); if (void 0 === v || v === c) return c; if (!isSchema(v)) throw new TypeError("conditions must return a schema object"); return v.resolve(u) } } const ce = "$", le = "."; function create$9(c, u) { return new Reference(c, u) } class Reference { "constructor"(c, u = {}) { if (this.key = void 0, this.isContext = void 0, this.isValue = void 0, this.isSibling = void 0, this.path = void 0, this.getter = void 0, this.map = void 0, "string" != typeof c) throw new TypeError("ref must be a string, got: " + c); if (this.key = c.trim(), "" === c) throw new TypeError("ref must be a non-empty string"); this.isContext = this.key[0] === ce, this.isValue = this.key[0] === le, this.isSibling = !this.isContext && !this.isValue; let d = this.isContext ? ce : this.isValue ? le : ""; this.path = this.key.slice(d.length), this.getter = this.path && (0, v.getter)(this.path, !0), this.map = u.map } "getValue"(c, u, d) { let v = this.isContext ? d : this.isValue ? c : u; return this.getter && (v = this.getter(v || {})), this.map && (v = this.map(v)), v } "cast"(c, u) { return this.getValue(c, null == u ? void 0 : u.parent, null == u ? void 0 : u.context) } "resolve"() { return this } "describe"() { return { "type": "ref", "key": this.key } } "toString"() { return `Ref(${this.key})` } static "isRef"(c) { return c && c.__isYupRef } } Reference.prototype.__isYupRef = !0; const isAbsent = c => null == c; function createValidation(c) { function validate({ "value": u, "path": d = "", "options": v, "originalValue": E, "schema": k }, R, U) { const { "name": H, "test": G, "params": W, "message": Z, "skipAbsent": Y } = c; let { "parent": J, "context": K, "abortEarly": X = k.spec.abortEarly, "disableStackTrace": Q = k.spec.disableStackTrace } = v; function resolve(c) { return Reference.isRef(c) ? c.getValue(u, J, K) : c } function createError(c = {}) { const v = Object.assign({ "value": u, "originalValue": E, "label": k.spec.label, "path": c.path || d, "spec": k.spec, "disableStackTrace": c.disableStackTrace || Q }, W, c.params); for (const c of Object.keys(v)) v[c] = resolve(v[c]); const R = new ValidationError(ValidationError.formatError(c.message || Z, v), u, v.path, c.type || H, v.disableStackTrace); return R.params = v, R } const ee = X ? R : U; let te = { "path": d, "parent": J, "type": H, "from": v.from, "createError": createError, "resolve": resolve, "options": v, "originalValue": E, "schema": k }; const handleResult = c => { ValidationError.isError(c) ? ee(c) : c ? U(null) : ee(createError()) }, handleError = c => { ValidationError.isError(c) ? ee(c) : R(c) }; if (Y && isAbsent(u)) return handleResult(!0); let ne; try { var re; if (ne = G.call(te, u, te), "function" == typeof (null == (re = ne) ? void 0 : re.then)) { if (v.sync) throw new Error(`Validation test of type: "${te.type}" returned a Promise during a synchronous validate. This test will finish after the validate call has returned`); return Promise.resolve(ne).then(handleResult, handleError) } } catch (c) { return void handleError(c) } handleResult(ne) } return validate.OPTIONS = c, validate } function getIn(c, u, d, E = d) { let k, R, U; return u ? ((0, v.forEach)(u, ((v, H, G) => { let W = H ? v.slice(1, v.length - 1) : v, Z = "tuple" === (c = c.resolve({ "context": E, "parent": k, "value": d })).type, Y = G ? parseInt(W, 10) : 0; if (c.innerType || Z) { if (Z && !G) throw new Error(`Yup.reach cannot implicitly index into a tuple type. the path part "${U}" must contain an index to the tuple element, e.g. "${U}[0]"`); if (d && Y >= d.length) throw new Error(`Yup.reach cannot resolve an array item at index: ${v}, in the path: ${u}. because there is no value at that index. `); k = d, d = d && d[Y], c = Z ? c.spec.types[Y] : c.innerType } if (!G) { if (!c.fields || !c.fields[W]) throw new Error(`The schema does not contain the path: ${u}. (failed at: ${U} which is a type: "${c.type}")`); k = d, d = d && d[W], c = c.fields[W] } R = W, U = H ? "[" + v + "]" : "." + v })), { "schema": c, "parent": k, "parentPath": R }) : { "parent": k, "parentPath": u, "schema": c } } function reach(c, u, d, v) { return getIn(c, u, d, v).schema } class ReferenceSet extends Set { "describe"() { const c = []; for (const u of this.values()) c.push(Reference.isRef(u) ? u.describe() : u); return c } "resolveAll"(c) { let u = []; for (const d of this.values()) u.push(c(d)); return u } "clone"() { return new ReferenceSet(this.values()) } "merge"(c, u) { const d = this.clone(); return c.forEach((c => d.add(c))), u.forEach((c => d.delete(c))), d } } function clone(c, u = new Map) { if (isSchema(c) || !c || "object" != typeof c) return c; if (u.has(c)) return u.get(c); let d; if (c instanceof Date) d = new Date(c.getTime()), u.set(c, d); else if (c instanceof RegExp) d = new RegExp(c), u.set(c, d); else if (Array.isArray(c)) { d = new Array(c.length), u.set(c, d); for (let v = 0; v < c.length; v++)d[v] = clone(c[v], u) } else if (c instanceof Map) { d = new Map, u.set(c, d); for (const [v, E] of c.entries()) d.set(v, clone(E, u)) } else if (c instanceof Set) { d = new Set, u.set(c, d); for (const v of c) d.add(clone(v, u)) } else { if (!(c instanceof Object)) throw Error(`Unable to clone ${c}`); d = {}, u.set(c, d); for (const [v, E] of Object.entries(c)) d[v] = clone(E, u) } return d } class Schema { "constructor"(c) { this.type = void 0, this.deps = [], this.tests = void 0, this.transforms = void 0, this.conditions = [], this._mutate = void 0, this.internalTests = {}, this._whitelist = new ReferenceSet, this._blacklist = new ReferenceSet, this.exclusiveTests = Object.create(null), this._typeCheck = void 0, this.spec = void 0, this.tests = [], this.transforms = [], this.withMutation((() => { this.typeError(Q.notType) })), this.type = c.type, this._typeCheck = c.check, this.spec = Object.assign({ "strip": !1, "strict": !1, "abortEarly": !0, "recursive": !0, "disableStackTrace": !1, "nullable": !1, "optional": !0, "coerce": !0 }, null == c ? void 0 : c.spec), this.withMutation((c => { c.nonNullable() })) } get "_type"() { return this.type } "clone"(c) { if (this._mutate) return c && Object.assign(this.spec, c), this; const u = Object.create(Object.getPrototypeOf(this)); return u.type = this.type, u._typeCheck = this._typeCheck, u._whitelist = this._whitelist.clone(), u._blacklist = this._blacklist.clone(), u.internalTests = Object.assign({}, this.internalTests), u.exclusiveTests = Object.assign({}, this.exclusiveTests), u.deps = [...this.deps], u.conditions = [...this.conditions], u.tests = [...this.tests], u.transforms = [...this.transforms], u.spec = clone(Object.assign({}, this.spec, c)), u } "label"(c) { let u = this.clone(); return u.spec.label = c, u } "meta"(...c) { if (0 === c.length) return this.spec.meta; let u = this.clone(); return u.spec.meta = Object.assign(u.spec.meta || {}, c[0]), u } "withMutation"(c) { let u = this._mutate; this._mutate = !0; let d = c(this); return this._mutate = u, d } "concat"(c) { if (!c || c === this) return this; if (c.type !== this.type && "mixed" !== this.type) throw new TypeError(`You cannot \`concat()\` schema's of different types: ${this.type} and ${c.type}`); let u = this, d = c.clone(); const v = Object.assign({}, u.spec, d.spec); return d.spec = v, d.internalTests = Object.assign({}, u.internalTests, d.internalTests), d._whitelist = u._whitelist.merge(c._whitelist, c._blacklist), d._blacklist = u._blacklist.merge(c._blacklist, c._whitelist), d.tests = u.tests, d.exclusiveTests = u.exclusiveTests, d.withMutation((u => { c.tests.forEach((c => { u.test(c.OPTIONS) })) })), d.transforms = [...u.transforms, ...d.transforms], d } "isType"(c) { return null == c ? !(!this.spec.nullable || null !== c) || !(!this.spec.optional || void 0 !== c) : this._typeCheck(c) } "resolve"(c) { let u = this; if (u.conditions.length) { let d = u.conditions; u = u.clone(), u.conditions = [], u = d.reduce(((u, d) => d.resolve(u, c)), u), u = u.resolve(c) } return u } "resolveOptions"(c) { var u, d, v, E; return Object.assign({}, c, { "from": c.from || [], "strict": null != (u = c.strict) ? u : this.spec.strict, "abortEarly": null != (d = c.abortEarly) ? d : this.spec.abortEarly, "recursive": null != (v = c.recursive) ? v : this.spec.recursive, "disableStackTrace": null != (E = c.disableStackTrace) ? E : this.spec.disableStackTrace }) } "cast"(c, u = {}) { let d = this.resolve(Object.assign({ "value": c }, u)), v = "ignore-optionality" === u.assert, E = d._cast(c, u); if (!1 !== u.assert && !d.isType(E)) { if (v && isAbsent(E)) return E; let k = printValue(c), R = printValue(E); throw new TypeError(`The value of ${u.path || "field"} could not be cast to a value that satisfies the schema type: "${d.type}". \n\nattempted value: ${k} \n` + (R !== k ? `result of cast: ${R}` : "")) } return E } "_cast"(c, u) { let d = void 0 === c ? c : this.transforms.reduce(((u, d) => d.call(this, u, c, this)), c); return void 0 === d && (d = this.getDefault(u)), d } "_validate"(c, u = {}, d, v) { let { "path": E, "originalValue": k = c, "strict": R = this.spec.strict } = u, U = c; R || (U = this._cast(U, Object.assign({ "assert": !1 }, u))); let H = []; for (let c of Object.values(this.internalTests)) c && H.push(c); this.runTests({ "path": E, "value": U, "originalValue": k, "options": u, "tests": H }, d, (c => { if (c.length) return v(c, U); this.runTests({ "path": E, "value": U, "originalValue": k, "options": u, "tests": this.tests }, d, v) })) } "runTests"(c, u, d) { let v = !1, { "tests": E, "value": k, "originalValue": R, "path": U, "options": H } = c, panicOnce = c => { v || (v = !0, u(c, k)) }, nextOnce = c => { v || (v = !0, d(c, k)) }, G = E.length, W = []; if (!G) return nextOnce([]); let Z = { "value": k, "originalValue": R, "path": U, "options": H, "schema": this }; for (let c = 0; c < E.length; c++) { (0, E[c])(Z, panicOnce, (function finishTestRun(c) { c && (Array.isArray(c) ? W.push(...c) : W.push(c)), --G <= 0 && nextOnce(W) })) } } "asNestedTest"({ "key": c, "index": u, "parent": d, "parentPath": v, "originalParent": E, "options": k }) { const R = null != c ? c : u; if (null == R) throw TypeError("Must include `key` or `index` for nested validations"); const U = "number" == typeof R; let H = d[R]; const G = Object.assign({}, k, { "strict": !0, "parent": d, "value": H, "originalValue": E[R], "key": void 0, [U ? "index" : "key"]: R, "path": U || R.includes(".") ? `${v || ""}[${U ? R : `"${R}"`}]` : (v ? `${v}.` : "") + c }); return (c, u, d) => this.resolve(G)._validate(H, G, u, d) } "validate"(c, u) { var d; let v = this.resolve(Object.assign({}, u, { "value": c })), E = null != (d = null == u ? void 0 : u.disableStackTrace) ? d : v.spec.disableStackTrace; return new Promise(((d, k) => v._validate(c, u, ((c, u) => { ValidationError.isError(c) && (c.value = u), k(c) }), ((c, u) => { c.length ? k(new ValidationError(c, u, void 0, void 0, E)) : d(u) })))) } "validateSync"(c, u) { var d; let v, E = this.resolve(Object.assign({}, u, { "value": c })), k = null != (d = null == u ? void 0 : u.disableStackTrace) ? d : E.spec.disableStackTrace; return E._validate(c, Object.assign({}, u, { "sync": !0 }), ((c, u) => { throw ValidationError.isError(c) && (c.value = u), c }), ((u, d) => { if (u.length) throw new ValidationError(u, c, void 0, void 0, k); v = d })), v } "isValid"(c, u) { return this.validate(c, u).then((() => !0), (c => { if (ValidationError.isError(c)) return !1; throw c })) } "isValidSync"(c, u) { try { return this.validateSync(c, u), !0 } catch (c) { if (ValidationError.isError(c)) return !1; throw c } } "_getDefault"(c) { let u = this.spec.default; return null == u ? u : "function" == typeof u ? u.call(this, c) : clone(u) } "getDefault"(c) { return this.resolve(c || {})._getDefault(c) } "default"(c) { if (0 === arguments.length) return this._getDefault(); return this.clone({ "default": c }) } "strict"(c = !0) { return this.clone({ "strict": c }) } "nullability"(c, u) { const d = this.clone({ "nullable": c }); return d.internalTests.nullable = createValidation({ "message": u, "name": "nullable", "test"(c) { return null !== c || this.schema.spec.nullable } }), d } "optionality"(c, u) { const d = this.clone({ "optional": c }); return d.internalTests.optionality = createValidation({ "message": u, "name": "optionality", "test"(c) { return void 0 !== c || this.schema.spec.optional } }), d } "optional"() { return this.optionality(!0) } "defined"(c = Q.defined) { return this.optionality(!1, c) } "nullable"() { return this.nullability(!0) } "nonNullable"(c = Q.notNull) { return this.nullability(!1, c) } "required"(c = Q.required) { return this.clone().withMutation((u => u.nonNullable(c).defined(c))) } "notRequired"() { return this.clone().withMutation((c => c.nullable().optional())) } "transform"(c) { let u = this.clone(); return u.transforms.push(c), u } "test"(...c) { let u; if (u = 1 === c.length ? "function" == typeof c[0] ? { "test": c[0] } : c[0] : 2 === c.length ? { "name": c[0], "test": c[1] } : { "name": c[0], "message": c[1], "test": c[2] }, void 0 === u.message && (u.message = Q.default), "function" != typeof u.test) throw new TypeError("`test` is a required parameters"); let d = this.clone(), v = createValidation(u), E = u.exclusive || u.name && !0 === d.exclusiveTests[u.name]; if (u.exclusive && !u.name) throw new TypeError("Exclusive tests must provide a unique `name` identifying the test"); return u.name && (d.exclusiveTests[u.name] = !!u.exclusive), d.tests = d.tests.filter((c => { if (c.OPTIONS.name === u.name) { if (E) return !1; if (c.OPTIONS.test === v.OPTIONS.test) return !1 } return !0 })), d.tests.push(v), d } "when"(c, u) { Array.isArray(c) || "string" == typeof c || (u = c, c = "."); let d = this.clone(), v = toArray(c).map((c => new Reference(c))); return v.forEach((c => { c.isSibling && d.deps.push(c.key) })), d.conditions.push("function" == typeof u ? new Condition(v, u) : Condition.fromOptions(v, u)), d } "typeError"(c) { let u = this.clone(); return u.internalTests.typeError = createValidation({ "message": c, "name": "typeError", "skipAbsent": !0, "test"(c) { return !!this.schema._typeCheck(c) || this.createError({ "params": { "type": this.schema.type } }) } }), u } "oneOf"(c, u = Q.oneOf) { let d = this.clone(); return c.forEach((c => { d._whitelist.add(c), d._blacklist.delete(c) })), d.internalTests.whiteList = createValidation({ "message": u, "name": "oneOf", "skipAbsent": !0, "test"(c) { let u = this.schema._whitelist, d = u.resolveAll(this.resolve); return !!d.includes(c) || this.createError({ "params": { "values": Array.from(u).join(", "), "resolved": d } }) } }), d } "notOneOf"(c, u = Q.notOneOf) { let d = this.clone(); return c.forEach((c => { d._blacklist.add(c), d._whitelist.delete(c) })), d.internalTests.blacklist = createValidation({ "message": u, "name": "notOneOf", "test"(c) { let u = this.schema._blacklist, d = u.resolveAll(this.resolve); return !d.includes(c) || this.createError({ "params": { "values": Array.from(u).join(", "), "resolved": d } }) } }), d } "strip"(c = !0) { let u = this.clone(); return u.spec.strip = c, u } "describe"(c) { const u = (c ? this.resolve(c) : this).clone(), { "label": d, "meta": v, "optional": E, "nullable": k } = u.spec; return { "meta": v, "label": d, "optional": E, "nullable": k, "default": u.getDefault(c), "type": u.type, "oneOf": u._whitelist.describe(), "notOneOf": u._blacklist.describe(), "tests": u.tests.map((c => ({ "name": c.OPTIONS.name, "params": c.OPTIONS.params }))).filter(((c, u, d) => d.findIndex((u => u.name === c.name)) === u)) } } } Schema.prototype.__isYupSchema__ = !0; for (const c of ["validate", "validateSync"]) Schema.prototype[`${c}At`] = function (u, d, v = {}) { const { "parent": E, "parentPath": k, "schema": R } = getIn(this, u, d, v.context); return R[c](E && E[k], Object.assign({}, v, { "parent": E, "path": u })) }; for (const c of ["equals", "is"]) Schema.prototype[c] = Schema.prototype.oneOf; for (const c of ["not", "nope"]) Schema.prototype[c] = Schema.prototype.notOneOf; const returnsTrue = () => !0; function create$8(c) { return new MixedSchema(c) } class MixedSchema extends Schema { "constructor"(c) { super("function" == typeof c ? { "type": "mixed", "check": c } : Object.assign({ "type": "mixed", "check": returnsTrue }, c)) } } function create$7() { return new BooleanSchema } create$8.prototype = MixedSchema.prototype; class BooleanSchema extends Schema { "constructor"() { super({ "type": "boolean", "check"(c) { return c instanceof Boolean && (c = c.valueOf()), "boolean" == typeof c } }), this.withMutation((() => { this.transform(((c, u, d) => { if (d.spec.coerce && !d.isType(c)) { if (/^(true|1)$/i.test(String(c))) return !0; if (/^(false|0)$/i.test(String(c))) return !1 } return c })) })) } "isTrue"(c = re.isValue) { return this.test({ "message": c, "name": "is-value", "exclusive": !0, "params": { "value": "true" }, "test"(c) { return isAbsent(c) || !0 === c } }) } "isFalse"(c = re.isValue) { return this.test({ "message": c, "name": "is-value", "exclusive": !0, "params": { "value": "false" }, "test"(c) { return isAbsent(c) || !1 === c } }) } "default"(c) { return super.default(c) } "defined"(c) { return super.defined(c) } "optional"() { return super.optional() } "required"(c) { return super.required(c) } "notRequired"() { return super.notRequired() } "nullable"() { return super.nullable() } "nonNullable"(c) { return super.nonNullable(c) } "strip"(c) { return super.strip(c) } } create$7.prototype = BooleanSchema.prototype; const ue = /^(\d{4}|[+-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,.](\d{1,}))?)?(?:(Z)|([+-])(\d{2})(?::?(\d{2}))?)?)?$/; function parseDateStruct(c) { var u, d; const v = ue.exec(c); return v ? { "year": toNumber(v[1]), "month": toNumber(v[2], 1) - 1, "day": toNumber(v[3], 1), "hour": toNumber(v[4]), "minute": toNumber(v[5]), "second": toNumber(v[6]), "millisecond": v[7] ? toNumber(v[7].substring(0, 3)) : 0, "precision": null != (u = null == (d = v[7]) ? void 0 : d.length) ? u : void 0, "z": v[8] || void 0, "plusMinus": v[9] || void 0, "hourOffset": toNumber(v[10]), "minuteOffset": toNumber(v[11]) } : null } function toNumber(c, u = 0) { return Number(c) || u } let de = /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/, pe = /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i, fe = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i, he = new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$"), isTrimmed = c => isAbsent(c) || c === c.trim(), me = {}.toString(); function create$6() { return new StringSchema } class StringSchema extends Schema { "constructor"() { super({ "type": "string", "check"(c) { return c instanceof String && (c = c.valueOf()), "string" == typeof c } }), this.withMutation((() => { this.transform(((c, u, d) => { if (!d.spec.coerce || d.isType(c)) return c; if (Array.isArray(c)) return c; const v = null != c && c.toString ? c.toString() : c; return v === me ? c : v })) })) } "required"(c) { return super.required(c).withMutation((u => u.test({ "message": c || Q.required, "name": "required", "skipAbsent": !0, "test": c => !!c.length }))) } "notRequired"() { return super.notRequired().withMutation((c => (c.tests = c.tests.filter((c => "required" !== c.OPTIONS.name)), c))) } "length"(c, u = ee.length) { return this.test({ "message": u, "name": "length", "exclusive": !0, "params": { "length": c }, "skipAbsent": !0, "test"(u) { return u.length === this.resolve(c) } }) } "min"(c, u = ee.min) { return this.test({ "message": u, "name": "min", "exclusive": !0, "params": { "min": c }, "skipAbsent": !0, "test"(u) { return u.length >= this.resolve(c) } }) } "max"(c, u = ee.max) { return this.test({ "name": "max", "exclusive": !0, "message": u, "params": { "max": c }, "skipAbsent": !0, "test"(u) { return u.length <= this.resolve(c) } }) } "matches"(c, u) { let d, v, E = !1; return u && ("object" == typeof u ? ({ "excludeEmptyString": E = !1, "message": d, "name": v } = u) : d = u), this.test({ "name": v || "matches", "message": d || ee.matches, "params": { "regex": c }, "skipAbsent": !0, "test": u => "" === u && E || -1 !== u.search(c) }) } "email"(c = ee.email) { return this.matches(de, { "name": "email", "message": c, "excludeEmptyString": !0 }) } "url"(c = ee.url) { return this.matches(pe, { "name": "url", "message": c, "excludeEmptyString": !0 }) } "uuid"(c = ee.uuid) { return this.matches(fe, { "name": "uuid", "message": c, "excludeEmptyString": !1 }) } "datetime"(c) { let u, d, v = ""; return c && ("object" == typeof c ? ({ "message": v = "", "allowOffset": u = !1, "precision": d } = c) : v = c), this.matches(he, { "name": "datetime", "message": v || ee.datetime, "excludeEmptyString": !0 }).test({ "name": "datetime_offset", "message": v || ee.datetime_offset, "params": { "allowOffset": u }, "skipAbsent": !0, "test": c => { if (!c || u) return !0; const d = parseDateStruct(c); return !!d && !!d.z } }).test({ "name": "datetime_precision", "message": v || ee.datetime_precision, "params": { "precision": d }, "skipAbsent": !0, "test": c => { if (!c || null == d) return !0; const u = parseDateStruct(c); return !!u && u.precision === d } }) } "ensure"() { return this.default("").transform((c => null === c ? "" : c)) } "trim"(c = ee.trim) { return this.transform((c => null != c ? c.trim() : c)).test({ "message": c, "name": "trim", "test": isTrimmed }) } "lowercase"(c = ee.lowercase) { return this.transform((c => isAbsent(c) ? c : c.toLowerCase())).test({ "message": c, "name": "string_case", "exclusive": !0, "skipAbsent": !0, "test": c => isAbsent(c) || c === c.toLowerCase() }) } "uppercase"(c = ee.uppercase) { return this.transform((c => isAbsent(c) ? c : c.toUpperCase())).test({ "message": c, "name": "string_case", "exclusive": !0, "skipAbsent": !0, "test": c => isAbsent(c) || c === c.toUpperCase() }) } } create$6.prototype = StringSchema.prototype; function create$5() { return new NumberSchema } class NumberSchema extends Schema { "constructor"() { super({ "type": "number", "check"(c) { return c instanceof Number && (c = c.valueOf()), "number" == typeof c && !(c => c != +c)(c) } }), this.withMutation((() => { this.transform(((c, u, d) => { if (!d.spec.coerce) return c; let v = c; if ("string" == typeof v) { if (v = v.replace(/\s/g, ""), "" === v) return NaN; v = +v } return d.isType(v) || null === v ? v : parseFloat(v) })) })) } "min"(c, u = te.min) { return this.test({ "message": u, "name": "min", "exclusive": !0, "params": { "min": c }, "skipAbsent": !0, "test"(u) { return u >= this.resolve(c) } }) } "max"(c, u = te.max) { return this.test({ "message": u, "name": "max", "exclusive": !0, "params": { "max": c }, "skipAbsent": !0, "test"(u) { return u <= this.resolve(c) } }) } "lessThan"(c, u = te.lessThan) { return this.test({ "message": u, "name": "max", "exclusive": !0, "params": { "less": c }, "skipAbsent": !0, "test"(u) { return u < this.resolve(c) } }) } "moreThan"(c, u = te.moreThan) { return this.test({ "message": u, "name": "min", "exclusive": !0, "params": { "more": c }, "skipAbsent": !0, "test"(u) { return u > this.resolve(c) } }) } "positive"(c = te.positive) { return this.moreThan(0, c) } "negative"(c = te.negative) { return this.lessThan(0, c) } "integer"(c = te.integer) { return this.test({ "name": "integer", "message": c, "skipAbsent": !0, "test": c => Number.isInteger(c) }) } "truncate"() { return this.transform((c => isAbsent(c) ? c : 0 | c)) } "round"(c) { var u; let d = ["ceil", "floor", "round", "trunc"]; if ("trunc" === (c = (null == (u = c) ? void 0 : u.toLowerCase()) || "round")) return this.truncate(); if (-1 === d.indexOf(c.toLowerCase())) throw new TypeError("Only valid options for round() are: " + d.join(", ")); return this.transform((u => isAbsent(u) ? u : Math[c](u))) } } create$5.prototype = NumberSchema.prototype; let ge = new Date(""); function create$4() { return new DateSchema } class DateSchema extends Schema { "constructor"() { super({ "type": "date", "check"(c) { return u = c, "[object Date]" === Object.prototype.toString.call(u) && !isNaN(c.getTime()); var u } }), this.withMutation((() => { this.transform(((c, u, d) => !d.spec.coerce || d.isType(c) || null === c ? c : (c = function parseIsoDate(c) { const u = parseDateStruct(c); if (!u) return Date.parse ? Date.parse(c) : Number.NaN; if (void 0 === u.z && void 0 === u.plusMinus) return new Date(u.year, u.month, u.day, u.hour, u.minute, u.second, u.millisecond).valueOf(); let d = 0; return "Z" !== u.z && void 0 !== u.plusMinus && (d = 60 * u.hourOffset + u.minuteOffset, "+" === u.plusMinus && (d = 0 - d)), Date.UTC(u.year, u.month, u.day, u.hour, u.minute + d, u.second, u.millisecond) }(c), isNaN(c) ? DateSchema.INVALID_DATE : new Date(c)))) })) } "prepareParam"(c, u) { let d; if (Reference.isRef(c)) d = c; else { let v = this.cast(c); if (!this._typeCheck(v)) throw new TypeError(`\`${u}\` must be a Date or a value that can be \`cast()\` to a Date`); d = v } return d } "min"(c, u = ne.min) { let d = this.prepareParam(c, "min"); return this.test({ "message": u, "name": "min", "exclusive": !0, "params": { "min": c }, "skipAbsent": !0, "test"(c) { return c >= this.resolve(d) } }) } "max"(c, u = ne.max) { let d = this.prepareParam(c, "max"); return this.test({ "message": u, "name": "max", "exclusive": !0, "params": { "max": c }, "skipAbsent": !0, "test"(c) { return c <= this.resolve(d) } }) } } function findIndex(c, u) { let d = 1 / 0; return c.some(((c, v) => { var E; if (null != (E = u.path) && E.includes(c)) return d = v, !0 })), d } function sortByKeyOrder(c) { return (u, d) => findIndex(c, u) - findIndex(c, d) } DateSchema.INVALID_DATE = ge, create$4.prototype = DateSchema.prototype, create$4.INVALID_DATE = ge; const parseJson = (c, u, d) => { if ("string" != typeof c) return c; let v = c; try { v = JSON.parse(c) } catch (c) { } return d.isType(v) ? v : c }; function deepPartial(c) { if ("fields" in c) { const u = {}; for (const [d, v] of Object.entries(c.fields)) u[d] = deepPartial(v); return c.setFields(u) } if ("array" === c.type) { const u = c.optional(); return u.innerType && (u.innerType = deepPartial(u.innerType)), u } return "tuple" === c.type ? c.optional().clone({ "types": c.spec.types.map(deepPartial) }) : "optional" in c ? c.optional() : c } let isObject = c => "[object Object]" === Object.prototype.toString.call(c); const _e = sortByKeyOrder([]); function create$3(c) { return new ObjectSchema(c) } class ObjectSchema extends Schema { "constructor"(c) { super({ "type": "object", "check"(c) { return isObject(c) || "function" == typeof c } }), this.fields = Object.create(null), this._sortErrors = _e, this._nodes = [], this._excludedEdges = [], this.withMutation((() => { c && this.shape(c) })) } "_cast"(c, u = {}) { var d; let v = super._cast(c, u); if (void 0 === v) return this.getDefault(u); if (!this._typeCheck(v)) return v; let E = this.fields, k = null != (d = u.stripUnknown) ? d : this.spec.noUnknown, R = [].concat(this._nodes, Object.keys(v).filter((c => !this._nodes.includes(c)))), U = {}, H = Object.assign({}, u, { "parent": U, "__validating": u.__validating || !1 }), G = !1; for (const c of R) { let d = E[c], R = c in v; if (d) { let E, k = v[c]; H.path = (u.path ? `${u.path}.` : "") + c, d = d.resolve({ "value": k, "context": u.context, "parent": U }); let R = d instanceof Schema ? d.spec : void 0, W = null == R ? void 0 : R.strict; if (null != R && R.strip) { G = G || c in v; continue } E = u.__validating && W ? v[c] : d.cast(v[c], H), void 0 !== E && (U[c] = E) } else R && !k && (U[c] = v[c]); R === c in U && U[c] === v[c] || (G = !0) } return G ? U : v } "_validate"(c, u = {}, d, v) { let { "from": E = [], "originalValue": k = c, "recursive": R = this.spec.recursive } = u; u.from = [{ "schema": this, "value": k }, ...E], u.__validating = !0, u.originalValue = k, super._validate(c, u, d, ((c, E) => { if (!R || !isObject(E)) return void v(c, E); k = k || E; let U = []; for (let c of this._nodes) { let d = this.fields[c]; d && !Reference.isRef(d) && U.push(d.asNestedTest({ "options": u, "key": c, "parent": E, "parentPath": u.path, "originalParent": k })) } this.runTests({ "tests": U, "value": E, "originalValue": k, "options": u }, d, (u => { v(u.sort(this._sortErrors).concat(c), E) })) })) } "clone"(c) { const u = super.clone(c); return u.fields = Object.assign({}, this.fields), u._nodes = this._nodes, u._excludedEdges = this._excludedEdges, u._sortErrors = this._sortErrors, u } "concat"(c) { let u = super.concat(c), d = u.fields; for (let [c, u] of Object.entries(this.fields)) { const v = d[c]; d[c] = void 0 === v ? u : v } return u.withMutation((u => u.setFields(d, [...this._excludedEdges, ...c._excludedEdges]))) } "_getDefault"(c) { if ("default" in this.spec) return super._getDefault(c); if (!this._nodes.length) return; let u = {}; return this._nodes.forEach((d => { var v; const E = this.fields[d]; let k = c; null != (v = k) && v.value && (k = Object.assign({}, k, { "parent": k.value, "value": k.value[d] })), u[d] = E && "getDefault" in E ? E.getDefault(k) : void 0 })), u } "setFields"(c, u) { let d = this.clone(); return d.fields = c, d._nodes = function sortFields(c, u = []) { let d = [], E = new Set, k = new Set(u.map((([c, u]) => `${c}-${u}`))); function addNode(c, u) { let R = (0, v.split)(c)[0]; E.add(R), k.has(`${u}-${R}`) || d.push([u, R]) } for (const u of Object.keys(c)) { let d = c[u]; E.add(u), Reference.isRef(d) && d.isSibling ? addNode(d.path, u) : isSchema(d) && "deps" in d && d.deps.forEach((c => addNode(c, u))) } return R().array(Array.from(E), d).reverse() }(c, u), d._sortErrors = sortByKeyOrder(Object.keys(c)), u && (d._excludedEdges = u), d } "shape"(c, u = []) { return this.clone().withMutation((d => { let v = d._excludedEdges; return u.length && (Array.isArray(u[0]) || (u = [u]), v = [...d._excludedEdges, ...u]), d.setFields(Object.assign(d.fields, c), v) })) } "partial"() { const c = {}; for (const [u, d] of Object.entries(this.fields)) c[u] = "optional" in d && d.optional instanceof Function ? d.optional() : d; return this.setFields(c) } "deepPartial"() { return deepPartial(this) } "pick"(c) { const u = {}; for (const d of c) this.fields[d] && (u[d] = this.fields[d]); return this.setFields(u, this._excludedEdges.filter((([u, d]) => c.includes(u) && c.includes(d)))) } "omit"(c) { const u = []; for (const d of Object.keys(this.fields)) c.includes(d) || u.push(d); return this.pick(u) } "from"(c, u, d) { let E = (0, v.getter)(c, !0); return this.transform((k => { if (!k) return k; let R = k; return ((c, u) => { const d = [...(0, v.normalizePath)(u)]; if (1 === d.length) return d[0] in c; let E = d.pop(), k = (0, v.getter)((0, v.join)(d), !0)(c); return !(!k || !(E in k)) })(k, c) && (R = Object.assign({}, k), d || delete R[c], R[u] = E(k)), R })) } "json"() { return this.transform(parseJson) } "noUnknown"(c = !0, u = oe.noUnknown) { "boolean" != typeof c && (u = c, c = !0); let d = this.test({ "name": "noUnknown", "exclusive": !0, "message": u, "test"(u) { if (null == u) return !0; const d = function unknown(c, u) { let d = Object.keys(c.fields); return Object.keys(u).filter((c => -1 === d.indexOf(c))) }(this.schema, u); return !c || 0 === d.length || this.createError({ "params": { "unknown": d.join(", ") } }) } }); return d.spec.noUnknown = c, d } "unknown"(c = !0, u = oe.noUnknown) { return this.noUnknown(!c, u) } "transformKeys"(c) { return this.transform((u => { if (!u) return u; const d = {}; for (const v of Object.keys(u)) d[c(v)] = u[v]; return d })) } "camelCase"() { return this.transformKeys(E.camelCase) } "snakeCase"() { return this.transformKeys(E.snakeCase) } "constantCase"() { return this.transformKeys((c => (0, E.snakeCase)(c).toUpperCase())) } "describe"(c) { const u = (c ? this.resolve(c) : this).clone(), d = super.describe(c); d.fields = {}; for (const [E, k] of Object.entries(u.fields)) { var v; let u = c; null != (v = u) && v.value && (u = Object.assign({}, u, { "parent": u.value, "value": u.value[E] })), d.fields[E] = k.describe(u) } return d } } function create$2(c) { return new ArraySchema(c) } create$3.prototype = ObjectSchema.prototype; class ArraySchema extends Schema { "constructor"(c) { super({ "type": "array", "spec": { "types": c }, "check"(c) { return Array.isArray(c) } }), this.innerType = void 0, this.innerType = c } "_cast"(c, u) { const d = super._cast(c, u); if (!this._typeCheck(d) || !this.innerType) return d; let v = !1; const E = d.map(((c, d) => { const E = this.innerType.cast(c, Object.assign({}, u, { "path": `${u.path || ""}[${d}]` })); return E !== c && (v = !0), E })); return v ? E : d } "_validate"(c, u = {}, d, v) { var E; let k = this.innerType, R = null != (E = u.recursive) ? E : this.spec.recursive; null != u.originalValue && u.originalValue, super._validate(c, u, d, ((E, U) => { var H; if (!R || !k || !this._typeCheck(U)) return void v(E, U); let G = new Array(U.length); for (let d = 0; d < U.length; d++) { var W; G[d] = k.asNestedTest({ "options": u, "index": d, "parent": U, "parentPath": u.path, "originalParent": null != (W = u.originalValue) ? W : c }) } this.runTests({ "value": U, "tests": G, "originalValue": null != (H = u.originalValue) ? H : c, "options": u }, d, (c => v(c.concat(E), U))) })) } "clone"(c) { const u = super.clone(c); return u.innerType = this.innerType, u } "json"() { return this.transform(parseJson) } "concat"(c) { let u = super.concat(c); return u.innerType = this.innerType, c.innerType && (u.innerType = u.innerType ? u.innerType.concat(c.innerType) : c.innerType), u } "of"(c) { let u = this.clone(); if (!isSchema(c)) throw new TypeError("`array.of()` sub-schema must be a valid yup schema not: " + printValue(c)); return u.innerType = c, u.spec = Object.assign({}, u.spec, { "types": c }), u } "length"(c, u = ie.length) { return this.test({ "message": u, "name": "length", "exclusive": !0, "params": { "length": c }, "skipAbsent": !0, "test"(u) { return u.length === this.resolve(c) } }) } "min"(c, u) { return u = u || ie.min, this.test({ "message": u, "name": "min", "exclusive": !0, "params": { "min": c }, "skipAbsent": !0, "test"(u) { return u.length >= this.resolve(c) } }) } "max"(c, u) { return u = u || ie.max, this.test({ "message": u, "name": "max", "exclusive": !0, "params": { "max": c }, "skipAbsent": !0, "test"(u) { return u.length <= this.resolve(c) } }) } "ensure"() { return this.default((() => [])).transform(((c, u) => this._typeCheck(c) ? c : null == u ? [] : [].concat(u))) } "compact"(c) { let u = c ? (u, d, v) => !c(u, d, v) : c => !!c; return this.transform((c => null != c ? c.filter(u) : c)) } "describe"(c) { const u = (c ? this.resolve(c) : this).clone(), d = super.describe(c); if (u.innerType) { var v; let E = c; null != (v = E) && v.value && (E = Object.assign({}, E, { "parent": E.value, "value": E.value[0] })), d.innerType = u.innerType.describe(E) } return d } } function create$1(c) { return new TupleSchema(c) } create$2.prototype = ArraySchema.prototype; class TupleSchema extends Schema { "constructor"(c) { super({ "type": "tuple", "spec": { "types": c }, "check"(c) { const u = this.spec.types; return Array.isArray(c) && c.length === u.length } }), this.withMutation((() => { this.typeError(ae.notType) })) } "_cast"(c, u) { const { "types": d } = this.spec, v = super._cast(c, u); if (!this._typeCheck(v)) return v; let E = !1; const k = d.map(((c, d) => { const k = c.cast(v[d], Object.assign({}, u, { "path": `${u.path || ""}[${d}]` })); return k !== v[d] && (E = !0), k })); return E ? k : v } "_validate"(c, u = {}, d, v) { let E = this.spec.types; super._validate(c, u, d, ((k, R) => { var U; if (!this._typeCheck(R)) return void v(k, R); let H = []; for (let [d, v] of E.entries()) { var G; H[d] = v.asNestedTest({ "options": u, "index": d, "parent": R, "parentPath": u.path, "originalParent": null != (G = u.originalValue) ? G : c }) } this.runTests({ "value": R, "tests": H, "originalValue": null != (U = u.originalValue) ? U : c, "options": u }, d, (c => v(c.concat(k), R))) })) } "describe"(c) { const u = (c ? this.resolve(c) : this).clone(), d = super.describe(c); return d.innerType = u.spec.types.map(((u, d) => { var v; let E = c; return null != (v = E) && v.value && (E = Object.assign({}, E, { "parent": E.value, "value": E.value[d] })), u.describe(E) })), d } } function create(c) { return new Lazy(c) } create$1.prototype = TupleSchema.prototype; class Lazy { "constructor"(c) { this.type = "lazy", this.__isYupSchema__ = !0, this.spec = void 0, this._resolve = (c, u = {}) => { let d = this.builder(c, u); if (!isSchema(d)) throw new TypeError("lazy() functions must return a valid schema"); return this.spec.optional && (d = d.optional()), d.resolve(u) }, this.builder = c, this.spec = { "meta": void 0, "optional": !1 } } "clone"(c) { const u = new Lazy(this.builder); return u.spec = Object.assign({}, this.spec, c), u } "optionality"(c) { return this.clone({ "optional": c }) } "optional"() { return this.optionality(!0) } "resolve"(c) { return this._resolve(c.value, c) } "cast"(c, u) { return this._resolve(c, u).cast(c, u) } "asNestedTest"(c) { let { "key": u, "index": d, "parent": v, "options": E } = c, k = v[null != d ? d : u]; return this._resolve(k, Object.assign({}, E, { "value": k, "parent": v })).asNestedTest(c) } "validate"(c, u) { return this._resolve(c, u).validate(c, u) } "validateSync"(c, u) { return this._resolve(c, u).validateSync(c, u) } "validateAt"(c, u, d) { return this._resolve(u, d).validateAt(c, u, d) } "validateSyncAt"(c, u, d) { return this._resolve(u, d).validateSyncAt(c, u, d) } "isValid"(c, u) { return this._resolve(c, u).isValid(c, u) } "isValidSync"(c, u) { return this._resolve(c, u).isValidSync(c, u) } "describe"(c) { return c ? this.resolve(c).describe(c) : { "type": "lazy", "meta": this.spec.meta, "label": void 0 } } "meta"(...c) { if (0 === c.length) return this.spec.meta; let u = this.clone(); return u.spec.meta = Object.assign(u.spec.meta || {}, c[0]), u } } function setLocale(c) { Object.keys(c).forEach((u => { Object.keys(c[u]).forEach((d => { se[u][d] = c[u][d] })) })) } function addMethod(c, u, d) { if (!c || !isSchema(c.prototype)) throw new TypeError("You must provide a yup schema constructor function"); if ("string" != typeof u) throw new TypeError("A Method name must be provided"); if ("function" != typeof d) throw new TypeError("Method function must be provided"); c.prototype[u] = d } }, "8111": function (c) { "use strict"; c.exports = "data:application/octet-stream;base64,AAEAAAALAIAAAwAwR1NVQrD+s+0AAAE4AAAAQk9TLzJAKEx+AAABfAAAAFZjbWFw65cFHQAAAhwAAAJQZ2x5ZvCRR/EAAASUAAAKtGhlYWQMPROtAAAA4AAAADZoaGVhCCwD+gAAALwAAAAkaG10eEJo//8AAAHUAAAASGxvY2EYqhW4AAAEbAAAACZtYXhwASEAVQAAARgAAAAgbmFtZeNcHtgAAA9IAAAB5nBvc3T6bLhLAAARMAAAAOYAAQAAA+gAAABaA+j/////A+kAAQAAAAAAAAAAAAAAAAAAABIAAQAAAAEAACbZbxtfDzz1AAsD6AAAAADUm2dvAAAAANSbZ2///wAAA+kD6gAAAAgAAgAAAAAAAAABAAAAEgBJAAUAAAAAAAIAAAAKAAoAAAD/AAAAAAAAAAEAAAAKAB4ALAABREZMVAAIAAQAAAAAAAAAAQAAAAFsaWdhAAgAAAABAAAAAQAEAAQAAAABAAgAAQAGAAAAAQAAAAAAAQOwAZAABQAIAnoCvAAAAIwCegK8AAAB4AAxAQIAAAIABQMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUGZFZABA6gHqEQPoAAAAWgPqAAAAAAABAAAAAAAAAAAAAAPoAAAD6AAAA+gAAAPoAAAD6AAAA+gAAAPoAAAD6AAAA+gAAAPoAAAD6AAAA+gAAAPoAAAD6AAAA+j//wPoAAAD6AAAAAAABQAAAAMAAAAsAAAABAAAAXQAAQAAAAAAbgADAAEAAAAsAAMACgAAAXQABABCAAAABAAEAAEAAOoR//8AAOoB//8AAAABAAQAAAABAAIAAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAAAEGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAANwAAAAAAAAAEQAA6gEAAOoBAAAAAQAA6gIAAOoCAAAAAgAA6gMAAOoDAAAAAwAA6gQAAOoEAAAABAAA6gUAAOoFAAAABQAA6gYAAOoGAAAABgAA6gcAAOoHAAAABwAA6ggAAOoIAAAACAAA6gkAAOoJAAAACQAA6goAAOoKAAAACgAA6gsAAOoLAAAACwAA6gwAAOoMAAAADAAA6g0AAOoNAAAADQAA6g4AAOoOAAAADgAA6g8AAOoPAAAADwAA6hAAAOoQAAAAEAAA6hEAAOoRAAAAEQAAAAAARgCMANIBJAF4AcQCMgJgAqgC/ANIA6YD/gROBKAE9AVaAAAAAgAAAAADrwOtABQAKQAAASIHBgcGFBcWFxYyNzY3NjQnJicmAyInJicmNDc2NzYyFxYXFhQHBgcGAfV4Z2Q7PDw7ZGfwZmQ7PDw7ZGZ4bl5bNjc3Nlte215bNjc3NlteA608O2Rn8GdjOzw8O2Nn8GdkOzz8rzc1W17bXlw1Nzc1XF7bXls1NwAAAAACAAAAAAOzA7MAFwAtAAABIgcGBwYVFBcWFxYzMjc2NzY1NCcmJyYTBwYiLwEmNjsBETQ2OwEyFhURMzIWAe52Z2Q7PT07ZGd2fGpmOz4+O2ZpIXYOKA52Dg0XXQsHJgcLXRcNA7M+O2ZqfHZnZDs9PTtkZ3Z9aWY7Pv3wmhISmhIaARcICwsI/ukaAAMAAAAAA+UD5QAXACMALAAAASIHBgcGFRQXFhcWMzI3Njc2NTQnJicmAxQrASI1AzQ7ATIHJyImNDYyFhQGAe6Ecm9BRERBb3KEiXZxQkREQnF1aQIxAwgCQgMBIxIZGSQZGQPkREJxdomEcm9BRERBb3KEinVxQkT9HQICAWICAjEZIxkZIxkAAAAAAgAAAAADsQPkABkALgAAAQYHBgc2BREUFxYXFhc2NzY3NjURJBcmJyYTAQYvASY/ATYyHwEWNjclNjIfARYB9VVVQk+v/tFHPmxebGxdbT1I/tGvT0JVo/7VBASKAwMSAQUBcQEFAgESAgUBEQQD4xMYEhk3YP6sjnVlSD8cHD9IZXWOAVRgNxkSGP62/tkDA48EBBkCAVYCAQHlAQIQBAAAAAADAAAAAAOxA+QAGwAqADMAAAEGBwYHBgcGNxEUFxYXFhc2NzY3NjURJBcmJyYHMzIWFQMUBisBIicDNDYTIiY0NjIWFAYB9UFBODssO38gRz5sXmxsXW09SP7YqFBBVW80BAYMAwImBQELBh4PFhYeFRUD5A8SDhIOEikK/q2PdWRJPh0dPklkdY8BU141GRIY/AYE/sYCAwUBOgQG/kAVHxUVHxUAAAACAAAAAAPkA+QAFwAtAAABIgcGBwYVFBcWFxYzMjc2NzY1NCcmJyYTAQYiLwEmPwE2Mh8BFjI3ATYyHwEWAe6Ecm9BQ0NCbnODiXVxQkREQnF1kf6gAQUBowMDFgEFAYUCBQEBQwIFARUEA+NEQnF1iYNzbkJDQ0FvcoSJdXFCRP6j/qUBAagEBR4CAWYBAQENAgIVBAAAAAQAAAAAA68DrQAUACkAPwBDAAABIgcGBwYUFxYXFjI3Njc2NCcmJyYDIicmJyY0NzY3NjIXFhcWFAcGBwYTBQ4BLwEmBg8BBhYfARYyNwE+ASYiFzAfAQH1eGdkOzw8O2Rn8GZkOzw8O2RmeG5eWzY3NzZbXtteWzY3NzZbXmn+9gYSBmAGDwUDBQEGfQUQBgElBQELEBUBAQOtPDtkZ/BnYzs8PDtjZ/BnZDs8/K83NVte215cNTc3NVxe215bNTcCJt0FAQVJBQIGBAcRBoAGBQEhBQ8LBAEBAAABAAAAAAO7AzoAFwAAEy4BPwE+AR8BFjY3ATYWFycWFAcBBiInPQoGBwUHGgzLDCELAh0LHwsNCgr9uQoeCgGzCyEOCw0HCZMJAQoBvgkCCg0LHQv9sQsKAAAAAAIAAAAAA+UD5gAXACwAAAEiBwYHBhUUFxYXFjMyNzY3NjU0JyYnJhMHBi8BJicmNRM0NjsBMhYVExceAQHvhHJvQUNDQm5zg4l1cUJEREJxdVcQAwT6AwIEEAMCKwIDDsUCAQPlREJxdYmDc25CQ0NBb3KEiXVxQkT9VhwEAncCAgMGAXoCAwMC/q2FAgQAAAQAAAAAA68DrQADABgALQAzAAABMB8BAyIHBgcGFBcWFxYyNzY3NjQnJicmAyInJicmNDc2NzYyFxYXFhQHBgcGAyMVMzUjAuUBAfJ4Z2Q7PDw7ZGfwZmQ7PDw7ZGZ4bl5bNjc3Nlte215bNjc3NltemyT92QKDAQEBLDw7ZGfwZ2M7PDw7Y2fwZ2Q7PPyvNzVbXtteXDU3NzVcXtteWzU3AjH9JAAAAAMAAAAAA+QD5AAXACcAMAAAASIHBgcGFRQXFhcWMzI3Njc2NTQnJicmAzMyFhUDFAYrASImNQM0NhMiJjQ2MhYUBgHuhHJvQUNDQm5zg4l1cUJEREJxdZ42BAYMAwInAwMMBh8PFhYeFhYD40RCcXWJg3NuQkNDQW9yhIl1cUJE/vYGBf7AAgMDAgFABQb+NhYfFhYfFgAABAAAAAADwAPAAAgAEgAoAD0AAAEyNjQmIgYUFhcjFTMRIxUzNSMDIgcGBwYVFBYXFjMyNzY3NjU0Jy4BAyInJicmNDc2NzYyFxYXFhQHBgcGAfQYISEwISFRjzk5yTorhG5rPT99am+DdmhlPD4+PMyFbV5bNTc3NVte2l5bNTc3NVteAqAiLyIiLyI5Hf7EHBwCsT89a26Ed8w8Pj48ZWh2g29qffyjNzVbXtpeWzU3NzVbXtpeWzU3AAADAAAAAAOoA6gACwAgADUAAAEHJwcXBxc3FzcnNwMiBwYHBhQXFhcWMjc2NzY0JyYnJgMiJyYnJjQ3Njc2MhcWFxYUBwYHBgKOmpocmpocmpocmpq2dmZiOjs7OmJm7GZiOjs7OmJmdmtdWTQ2NjRZXdZdWTQ2NjRZXQKqmpocmpocmpocmpoBGTs6YmbsZmI6Ozs6YmbsZmI6O/zCNjRZXdZdWTQ2NjRZXdZdWTQ2AAMAAAAAA+kD6gAaAC8AMAAAAQYHBiMiJyYnJjQ3Njc2MhcWFxYVFAcGBwEHATI3Njc2NCcmJyYiBwYHBhQXFhcWMwKONUBCR21dWjU3NzVaXdpdWzU2GBcrASM5/eBXS0grKysrSEuuSkkqLCwqSUpXASMrFxg2NVtd2l1aNTc3NVpdbUdCQDX+3jkBGSsrSEuuSkkqLCwqSUquS0grKwAC//8AAAPoA+gAFAAwAAABIgcGBwYQFxYXFiA3Njc2ECcmJyYTFg4BIi8BBwYuATQ/AScmPgEWHwE3Nh4BBg8BAfSIdHFDRERDcXQBEHRxQ0REQ3F0SQoBFBsKoqgKGxMKqKIKARQbCqKoChsUAQqoA+hEQ3F0/vB0cUNERENxdAEQdHFDRP1jChsTCqiiCgEUGwqiqAobFAEKqKIKARQbCqIAAAIAAAAAA+QD5AAXADQAAAEiBwYHBhUUFxYXFjMyNzY3NjU0JyYnJhMUBiMFFxYUDwEGLwEuAT8BNh8BFhQPAQUyFh0BAe6Ecm9BQ0NCbnODiXVxQkREQnF1fwQC/pGDAQEVAwTsAgEC7AQEFAIBhAFwAgMD40RCcXWJg3NuQkNDQW9yhIl1cUJE/fYCAwuVAgQCFAQE0AIFAtEEBBQCBQGVCwMDJwAAAAUAAAAAA9QD0wAjACcANwBHAEgAAAERFAYjISImNREjIiY9ATQ2MyE1NDYzITIWHQEhMhYdARQGIyERIREHIgYVERQWOwEyNjURNCYjISIGFREUFjsBMjY1ETQmKwEDeyYb/XYbJkMJDQ0JAQYZEgEvExkBBgkNDQn9CQJc0QkNDQktCQ0NCf7sCQ0NCS0JDQ0JLQMi/TQbJiYbAswMCiwJDS4SGRkSLg0JLAoM/UwCtGsNCf5NCQ0NCQGzCQ0NCf5NCQ0NCQGzCQ0AAAAAEADGAAEAAAAAAAEABAAAAAEAAAAAAAIABwAEAAEAAAAAAAMABAALAAEAAAAAAAQABAAPAAEAAAAAAAUACwATAAEAAAAAAAYABAAeAAEAAAAAAAoAKwAiAAEAAAAAAAsAEwBNAAMAAQQJAAEACABgAAMAAQQJAAIADgBoAAMAAQQJAAMACAB2AAMAAQQJAAQACAB+AAMAAQQJAAUAFgCGAAMAAQQJAAYACACcAAMAAQQJAAoAVgCkAAMAAQQJAAsAJgD6d2V1aVJlZ3VsYXJ3ZXVpd2V1aVZlcnNpb24gMS4wd2V1aUdlbmVyYXRlZCBieSBzdmcydHRmIGZyb20gRm9udGVsbG8gcHJvamVjdC5odHRwOi8vZm9udGVsbG8uY29tAHcAZQB1AGkAUgBlAGcAdQBsAGEAcgB3AGUAdQBpAHcAZQB1AGkAVgBlAHIAcwBpAG8AbgAgADEALgAwAHcAZQB1AGkARwBlAG4AZQByAGEAdABlAGQAIABiAHkAIABzAHYAZwAyAHQAdABmACAAZgByAG8AbQAgAEYAbwBuAHQAZQBsAGwAbwAgAHAAcgBvAGoAZQBjAHQALgBoAHQAdABwADoALwAvAGYAbwBuAHQAZQBsAGwAbwAuAGMAbwBtAAAAAgAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASAQIBAwEEAQUBBgEHAQgBCQEKAQsBDAENAQ4BDwEQAREBEgETAAZjaXJjbGUIZG93bmxvYWQEaW5mbwxzYWZlX3N1Y2Nlc3MJc2FmZV93YXJuB3N1Y2Nlc3MOc3VjY2Vzcy1jaXJjbGURc3VjY2Vzcy1uby1jaXJjbGUHd2FpdGluZw53YWl0aW5nLWNpcmNsZQR3YXJuC2luZm8tY2lyY2xlBmNhbmNlbAZzZWFyY2gFY2xlYXIEYmFjawZkZWxldGUAAAAA" }, "4285": function (c, u, d) { "use strict"; c.exports = d(4324) }, "4324": function (c) { "use strict"; var u; !function (c) { c[c.HIGH_SURROGATE_START = 55296] = "HIGH_SURROGATE_START", c[c.HIGH_SURROGATE_END = 56319] = "HIGH_SURROGATE_END", c[c.LOW_SURROGATE_START = 56320] = "LOW_SURROGATE_START", c[c.REGIONAL_INDICATOR_START = 127462] = "REGIONAL_INDICATOR_START", c[c.REGIONAL_INDICATOR_END = 127487] = "REGIONAL_INDICATOR_END", c[c.FITZPATRICK_MODIFIER_START = 127995] = "FITZPATRICK_MODIFIER_START", c[c.FITZPATRICK_MODIFIER_END = 127999] = "FITZPATRICK_MODIFIER_END", c[c.VARIATION_MODIFIER_START = 65024] = "VARIATION_MODIFIER_START", c[c.VARIATION_MODIFIER_END = 65039] = "VARIATION_MODIFIER_END", c[c.DIACRITICAL_MARKS_START = 8400] = "DIACRITICAL_MARKS_START", c[c.DIACRITICAL_MARKS_END = 8447] = "DIACRITICAL_MARKS_END", c[c.SUBDIVISION_INDICATOR_START = 127988] = "SUBDIVISION_INDICATOR_START", c[c.TAGS_START = 917504] = "TAGS_START", c[c.TAGS_END = 917631] = "TAGS_END", c[c.ZWJ = 8205] = "ZWJ" }(u || (u = {})); const d = Object.freeze([776, 2359, 2367, 2984, 3007, 3021, 3633, 3635, 3648, 3657, 4352, 4449, 4520]); var v; function runes(c) { if ("string" != typeof c) throw new TypeError("string cannot be undefined or null"); const u = []; let d = 0, v = 0; for (; d < c.length;)v += nextUnits(d + v, c), isGrapheme(c[d + v]) && v++, isVariationSelector(c[d + v]) && v++, isDiacriticalMark(c[d + v]) && v++, isZeroWidthJoiner(c[d + v]) ? v++ : (u.push(c.substring(d, d + v)), d += v, v = 0); return u } function nextUnits(c, u) { const d = u[c]; if (!function isFirstOfSurrogatePair(c) { return c && betweenInclusive(c[0].charCodeAt(0), 55296, 56319) }(d) || c === u.length - 1) return 1; const v = d + u[c + 1]; let E = u.substring(c + 2, c + 5); return isRegionalIndicator(v) && isRegionalIndicator(E) ? 4 : function isSubdivisionFlag(c) { return betweenInclusive(codePointFromSurrogatePair(c), 127988, 127988) }(v) && function isSupplementarySpecialpurposePlane(c) { const u = c.codePointAt(0); return "string" == typeof c && "number" == typeof u && betweenInclusive(u, 917504, 917631) }(E) ? u.slice(c).indexOf(String.fromCodePoint(917631)) + 2 : function isFitzpatrickModifier(c) { return betweenInclusive(codePointFromSurrogatePair(c), 127995, 127999) }(E) ? 4 : 2 } function isRegionalIndicator(c) { return betweenInclusive(codePointFromSurrogatePair(c), 127462, 127487) } function isVariationSelector(c) { return "string" == typeof c && betweenInclusive(c.charCodeAt(0), 65024, 65039) } function isDiacriticalMark(c) { return "string" == typeof c && betweenInclusive(c.charCodeAt(0), 8400, 8447) } function isGrapheme(c) { return "string" == typeof c && d.includes(c.charCodeAt(0)) } function isZeroWidthJoiner(c) { return "string" == typeof c && 8205 === c.charCodeAt(0) } function codePointFromSurrogatePair(c) { return (c.charCodeAt(0) - 55296 << 10) + (c.charCodeAt(1) - 56320) + 65536 } function betweenInclusive(c, u, d) { return c >= u && c <= d } function substring(c, u, d) { const v = runes(c); if (void 0 === u) return c; if (u >= v.length) return ""; const E = v.length - u; let k = u + (void 0 === d ? E : d); return k > u + E && (k = void 0), v.slice(u, k).join("") } !function (c) { c[c.unit_1 = 1] = "unit_1", c[c.unit_2 = 2] = "unit_2", c[c.unit_4 = 4] = "unit_4" }(v || (v = {})), Object.defineProperty(runes, "runes", { "value": runes }), Object.defineProperty(runes, "default", { "value": runes }), Object.defineProperty(runes, "__esModule", { "value": !0 }), Object.defineProperty(runes, "substr", { "value": substring }), Object.defineProperty(runes, "substring", { "value": substring }), Object.defineProperty(runes, "EnumRunesCode", { "value": u }), Object.defineProperty(runes, "EnumCodeUnits", { "value": v }), Object.defineProperty(runes, "GRAPHEMES", { "value": d }), c.exports = runes }, "907": function (c, u, d) { "use strict"; function _arrayLikeToArray(c, u) { (null == u || u > c.length) && (u = c.length); for (var d = 0, v = Array(u); d < u; d++)v[d] = c[d]; return v } d.d(u, { "Z": function () { return _arrayLikeToArray } }) }, "5861": function (c, u, d) { "use strict"; function asyncGeneratorStep(c, u, d, v, E, k, R) { try { var U = c[k](R), H = U.value } catch (c) { return void d(c) } U.done ? u(H) : Promise.resolve(H).then(v, E) } function _asyncToGenerator(c) { return function () { var u = this, d = arguments; return new Promise((function (v, E) { var k = c.apply(u, d); function _next(c) { asyncGeneratorStep(k, v, E, _next, _throw, "next", c) } function _throw(c) { asyncGeneratorStep(k, v, E, _next, _throw, "throw", c) } _next(void 0) })) } } d.d(u, { "Z": function () { return _asyncToGenerator } }) }, "8361": function (c, u, d) { "use strict"; d.d(u, { "Z": function () { return _callSuper } }); var v = d(1120); function _isNativeReflectConstruct() { try { var c = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))) } catch (c) { } return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!c })() } var E = d(1002); function _possibleConstructorReturn(c, u) { if (u && ("object" == (0, E.Z)(u) || "function" == typeof u)) return u; if (void 0 !== u) throw new TypeError("Derived constructors may only return object or undefined"); return function _assertThisInitialized(c) { if (void 0 === c) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return c }(c) } function _callSuper(c, u, d) { return u = (0, v.Z)(u), _possibleConstructorReturn(c, _isNativeReflectConstruct() ? Reflect.construct(u, d || [], (0, v.Z)(c).constructor) : u.apply(c, d)) } }, "5671": function (c, u, d) { "use strict"; function _classCallCheck(c, u) { if (!(c instanceof u)) throw new TypeError("Cannot call a class as a function") } d.d(u, { "Z": function () { return _classCallCheck } }) }, "3144": function (c, u, d) { "use strict"; d.d(u, { "Z": function () { return _createClass } }); var v = d(9142); function _defineProperties(c, u) { for (var d = 0; d < u.length; d++) { var E = u[d]; E.enumerable = E.enumerable || !1, E.configurable = !0, "value" in E && (E.writable = !0), Object.defineProperty(c, (0, v.Z)(E.key), E) } } function _createClass(c, u, d) { return u && _defineProperties(c.prototype, u), d && _defineProperties(c, d), Object.defineProperty(c, "prototype", { "writable": !1 }), c } }, "7762": function (c, u, d) { "use strict"; d.d(u, { "Z": function () { return _createForOfIteratorHelper } }); var v = d(181); function _createForOfIteratorHelper(c, u) { var d = "undefined" != typeof Symbol && c[Symbol.iterator] || c["@@iterator"]; if (!d) { if (Array.isArray(c) || (d = (0, v.Z)(c)) || u && c && "number" == typeof c.length) { d && (c = d); var E = 0, k = function F() { }; return { "s": k, "n": function n() { return E >= c.length ? { "done": !0 } : { "done": !1, "value": c[E++] } }, "e": function e(c) { throw c }, "f": k } } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } var R, U = !0, H = !1; return { "s": function s() { d = d.call(c) }, "n": function n() { var c = d.next(); return U = c.done, c }, "e": function e(c) { H = !0, R = c }, "f": function f() { try { U || null == d.return || d.return() } finally { if (H) throw R } } } } }, "4942": function (c, u, d) { "use strict"; d.d(u, { "Z": function () { return _defineProperty } }); var v = d(9142); function _defineProperty(c, u, d) { return (u = (0, v.Z)(u)) in c ? Object.defineProperty(c, u, { "value": d, "enumerable": !0, "configurable": !0, "writable": !0 }) : c[u] = d, c } }, "1752": function (c, u, d) { "use strict"; d.d(u, { "Z": function () { return _get } }); var v = d(1120); function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (c, u, d) { var E = function _superPropBase(c, u) { for (; !{}.hasOwnProperty.call(c, u) && null !== (c = (0, v.Z)(c));); return c }(c, u); if (E) { var k = Object.getOwnPropertyDescriptor(E, u); return k.get ? k.get.call(arguments.length < 3 ? c : d) : k.value } }, _get.apply(null, arguments) } }, "1120": function (c, u, d) { "use strict"; function _getPrototypeOf(c) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (c) { return c.__proto__ || Object.getPrototypeOf(c) }, _getPrototypeOf(c) } d.d(u, { "Z": function () { return _getPrototypeOf } }) }, "9340": function (c, u, d) { "use strict"; function _setPrototypeOf(c, u) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (c, u) { return c.__proto__ = u, c }, _setPrototypeOf(c, u) } function _inherits(c, u) { if ("function" != typeof u && null !== u) throw new TypeError("Super expression must either be null or a function"); c.prototype = Object.create(u && u.prototype, { "constructor": { "value": c, "writable": !0, "configurable": !0 } }), Object.defineProperty(c, "prototype", { "writable": !1 }), u && _setPrototypeOf(c, u) } d.d(u, { "Z": function () { return _inherits } }) }, "1413": function (c, u, d) { "use strict"; d.d(u, { "Z": function () { return _objectSpread2 } }); var v = d(4942); function ownKeys(c, u) { var d = Object.keys(c); if (Object.getOwnPropertySymbols) { var v = Object.getOwnPropertySymbols(c); u && (v = v.filter((function (u) { return Object.getOwnPropertyDescriptor(c, u).enumerable }))), d.push.apply(d, v) } return d } function _objectSpread2(c) { for (var u = 1; u < arguments.length; u++) { var d = null != arguments[u] ? arguments[u] : {}; u % 2 ? ownKeys(Object(d), !0).forEach((function (u) { (0, v.Z)(c, u, d[u]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(c, Object.getOwnPropertyDescriptors(d)) : ownKeys(Object(d)).forEach((function (u) { Object.defineProperty(c, u, Object.getOwnPropertyDescriptor(d, u)) })) } return c } }, "4165": function (c, u, d) { "use strict"; d.d(u, { "Z": function () { return _regeneratorRuntime } }); var v = d(1002); function _regeneratorRuntime() { _regeneratorRuntime = function _regeneratorRuntime() { return u }; var c, u = {}, d = Object.prototype, E = d.hasOwnProperty, k = Object.defineProperty || function (c, u, d) { c[u] = d.value }, R = "function" == typeof Symbol ? Symbol : {}, U = R.iterator || "@@iterator", H = R.asyncIterator || "@@asyncIterator", G = R.toStringTag || "@@toStringTag"; function define(c, u, d) { return Object.defineProperty(c, u, { "value": d, "enumerable": !0, "configurable": !0, "writable": !0 }), c[u] } try { define({}, "") } catch (c) { define = function define(c, u, d) { return c[u] = d } } function wrap(c, u, d, v) { var E = u && u.prototype instanceof Generator ? u : Generator, R = Object.create(E.prototype), U = new Context(v || []); return k(R, "_invoke", { "value": makeInvokeMethod(c, d, U) }), R } function tryCatch(c, u, d) { try { return { "type": "normal", "arg": c.call(u, d) } } catch (c) { return { "type": "throw", "arg": c } } } u.wrap = wrap; var W = "suspendedStart", Z = "suspendedYield", Y = "executing", J = "completed", K = {}; function Generator() { } function GeneratorFunction() { } function GeneratorFunctionPrototype() { } var X = {}; define(X, U, (function () { return this })); var Q = Object.getPrototypeOf, ee = Q && Q(Q(values([]))); ee && ee !== d && E.call(ee, U) && (X = ee); var te = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(X); function defineIteratorMethods(c) { ["next", "throw", "return"].forEach((function (u) { define(c, u, (function (c) { return this._invoke(u, c) })) })) } function AsyncIterator(c, u) { function invoke(d, k, R, U) { var H = tryCatch(c[d], c, k); if ("throw" !== H.type) { var G = H.arg, W = G.value; return W && "object" == (0, v.Z)(W) && E.call(W, "__await") ? u.resolve(W.__await).then((function (c) { invoke("next", c, R, U) }), (function (c) { invoke("throw", c, R, U) })) : u.resolve(W).then((function (c) { G.value = c, R(G) }), (function (c) { return invoke("throw", c, R, U) })) } U(H.arg) } var d; k(this, "_invoke", { "value": function value(c, v) { function callInvokeWithMethodAndArg() { return new u((function (u, d) { invoke(c, v, u, d) })) } return d = d ? d.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg() } }) } function makeInvokeMethod(u, d, v) { var E = W; return function (k, R) { if (E === Y) throw Error("Generator is already running"); if (E === J) { if ("throw" === k) throw R; return { "value": c, "done": !0 } } for (v.method = k, v.arg = R; ;) { var U = v.delegate; if (U) { var H = maybeInvokeDelegate(U, v); if (H) { if (H === K) continue; return H } } if ("next" === v.method) v.sent = v._sent = v.arg; else if ("throw" === v.method) { if (E === W) throw E = J, v.arg; v.dispatchException(v.arg) } else "return" === v.method && v.abrupt("return", v.arg); E = Y; var G = tryCatch(u, d, v); if ("normal" === G.type) { if (E = v.done ? J : Z, G.arg === K) continue; return { "value": G.arg, "done": v.done } } "throw" === G.type && (E = J, v.method = "throw", v.arg = G.arg) } } } function maybeInvokeDelegate(u, d) { var v = d.method, E = u.iterator[v]; if (E === c) return d.delegate = null, "throw" === v && u.iterator.return && (d.method = "return", d.arg = c, maybeInvokeDelegate(u, d), "throw" === d.method) || "return" !== v && (d.method = "throw", d.arg = new TypeError("The iterator does not provide a '" + v + "' method")), K; var k = tryCatch(E, u.iterator, d.arg); if ("throw" === k.type) return d.method = "throw", d.arg = k.arg, d.delegate = null, K; var R = k.arg; return R ? R.done ? (d[u.resultName] = R.value, d.next = u.nextLoc, "return" !== d.method && (d.method = "next", d.arg = c), d.delegate = null, K) : R : (d.method = "throw", d.arg = new TypeError("iterator result is not an object"), d.delegate = null, K) } function pushTryEntry(c) { var u = { "tryLoc": c[0] }; 1 in c && (u.catchLoc = c[1]), 2 in c && (u.finallyLoc = c[2], u.afterLoc = c[3]), this.tryEntries.push(u) } function resetTryEntry(c) { var u = c.completion || {}; u.type = "normal", delete u.arg, c.completion = u } function Context(c) { this.tryEntries = [{ "tryLoc": "root" }], c.forEach(pushTryEntry, this), this.reset(!0) } function values(u) { if (u || "" === u) { var d = u[U]; if (d) return d.call(u); if ("function" == typeof u.next) return u; if (!isNaN(u.length)) { var k = -1, R = function next() { for (; ++k < u.length;)if (E.call(u, k)) return next.value = u[k], next.done = !1, next; return next.value = c, next.done = !0, next }; return R.next = R } } throw new TypeError((0, v.Z)(u) + " is not iterable") } return GeneratorFunction.prototype = GeneratorFunctionPrototype, k(te, "constructor", { "value": GeneratorFunctionPrototype, "configurable": !0 }), k(GeneratorFunctionPrototype, "constructor", { "value": GeneratorFunction, "configurable": !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, G, "GeneratorFunction"), u.isGeneratorFunction = function (c) { var u = "function" == typeof c && c.constructor; return !!u && (u === GeneratorFunction || "GeneratorFunction" === (u.displayName || u.name)) }, u.mark = function (c) { return Object.setPrototypeOf ? Object.setPrototypeOf(c, GeneratorFunctionPrototype) : (c.__proto__ = GeneratorFunctionPrototype, define(c, G, "GeneratorFunction")), c.prototype = Object.create(te), c }, u.awrap = function (c) { return { "__await": c } }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, H, (function () { return this })), u.AsyncIterator = AsyncIterator, u.async = function (c, d, v, E, k) { void 0 === k && (k = Promise); var R = new AsyncIterator(wrap(c, d, v, E), k); return u.isGeneratorFunction(d) ? R : R.next().then((function (c) { return c.done ? c.value : R.next() })) }, defineIteratorMethods(te), define(te, G, "Generator"), define(te, U, (function () { return this })), define(te, "toString", (function () { return "[object Generator]" })), u.keys = function (c) { var u = Object(c), d = []; for (var v in u) d.push(v); return d.reverse(), function next() { for (; d.length;) { var c = d.pop(); if (c in u) return next.value = c, next.done = !1, next } return next.done = !0, next } }, u.values = values, Context.prototype = { "constructor": Context, "reset": function reset(u) { if (this.prev = 0, this.next = 0, this.sent = this._sent = c, this.done = !1, this.delegate = null, this.method = "next", this.arg = c, this.tryEntries.forEach(resetTryEntry), !u) for (var d in this) "t" === d.charAt(0) && E.call(this, d) && !isNaN(+d.slice(1)) && (this[d] = c) }, "stop": function stop() { this.done = !0; var c = this.tryEntries[0].completion; if ("throw" === c.type) throw c.arg; return this.rval }, "dispatchException": function dispatchException(u) { if (this.done) throw u; var d = this; function handle(v, E) { return R.type = "throw", R.arg = u, d.next = v, E && (d.method = "next", d.arg = c), !!E } for (var v = this.tryEntries.length - 1; v >= 0; --v) { var k = this.tryEntries[v], R = k.completion; if ("root" === k.tryLoc) return handle("end"); if (k.tryLoc <= this.prev) { var U = E.call(k, "catchLoc"), H = E.call(k, "finallyLoc"); if (U && H) { if (this.prev < k.catchLoc) return handle(k.catchLoc, !0); if (this.prev < k.finallyLoc) return handle(k.finallyLoc) } else if (U) { if (this.prev < k.catchLoc) return handle(k.catchLoc, !0) } else { if (!H) throw Error("try statement without catch or finally"); if (this.prev < k.finallyLoc) return handle(k.finallyLoc) } } } }, "abrupt": function abrupt(c, u) { for (var d = this.tryEntries.length - 1; d >= 0; --d) { var v = this.tryEntries[d]; if (v.tryLoc <= this.prev && E.call(v, "finallyLoc") && this.prev < v.finallyLoc) { var k = v; break } } k && ("break" === c || "continue" === c) && k.tryLoc <= u && u <= k.finallyLoc && (k = null); var R = k ? k.completion : {}; return R.type = c, R.arg = u, k ? (this.method = "next", this.next = k.finallyLoc, K) : this.complete(R) }, "complete": function complete(c, u) { if ("throw" === c.type) throw c.arg; return "break" === c.type || "continue" === c.type ? this.next = c.arg : "return" === c.type ? (this.rval = this.arg = c.arg, this.method = "return", this.next = "end") : "normal" === c.type && u && (this.next = u), K }, "finish": function finish(c) { for (var u = this.tryEntries.length - 1; u >= 0; --u) { var d = this.tryEntries[u]; if (d.finallyLoc === c) return this.complete(d.completion, d.afterLoc), resetTryEntry(d), K } }, "catch": function _catch(c) { for (var u = this.tryEntries.length - 1; u >= 0; --u) { var d = this.tryEntries[u]; if (d.tryLoc === c) { var v = d.completion; if ("throw" === v.type) { var E = v.arg; resetTryEntry(d) } return E } } throw Error("illegal catch attempt") }, "delegateYield": function delegateYield(u, d, v) { return this.delegate = { "iterator": values(u), "resultName": d, "nextLoc": v }, "next" === this.method && (this.arg = c), K } }, u } }, "885": function (c, u, d) { "use strict"; d.d(u, { "Z": function () { return _slicedToArray } }); var v = d(181); function _slicedToArray(c, u) { return function _arrayWithHoles(c) { if (Array.isArray(c)) return c }(c) || function _iterableToArrayLimit(c, u) { var d = null == c ? null : "undefined" != typeof Symbol && c[Symbol.iterator] || c["@@iterator"]; if (null != d) { var v, E, k, R, U = [], H = !0, G = !1; try { if (k = (d = d.call(c)).next, 0 === u) { if (Object(d) !== d) return; H = !1 } else for (; !(H = (v = k.call(d)).done) && (U.push(v.value), U.length !== u); H = !0); } catch (c) { G = !0, E = c } finally { try { if (!H && null != d.return && (R = d.return(), Object(R) !== R)) return } finally { if (G) throw E } } return U } }(c, u) || (0, v.Z)(c, u) || function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }() } }, "2982": function (c, u, d) { "use strict"; d.d(u, { "Z": function () { return _toConsumableArray } }); var v = d(907); var E = d(181); function _toConsumableArray(c) { return function _arrayWithoutHoles(c) { if (Array.isArray(c)) return (0, v.Z)(c) }(c) || function _iterableToArray(c) { if ("undefined" != typeof Symbol && null != c[Symbol.iterator] || null != c["@@iterator"]) return Array.from(c) }(c) || (0, E.Z)(c) || function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }() } }, "9142": function (c, u, d) { "use strict"; d.d(u, { "Z": function () { return toPropertyKey } }); var v = d(1002); function toPropertyKey(c) { var u = function toPrimitive(c, u) { if ("object" != (0, v.Z)(c) || !c) return c; var d = c[Symbol.toPrimitive]; if (void 0 !== d) { var E = d.call(c, u || "default"); if ("object" != (0, v.Z)(E)) return E; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === u ? String : Number)(c) }(c, "string"); return "symbol" == (0, v.Z)(u) ? u : u + "" } }, "1002": function (c, u, d) { "use strict"; function _typeof(c) { return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (c) { return typeof c } : function (c) { return c && "function" == typeof Symbol && c.constructor === Symbol && c !== Symbol.prototype ? "symbol" : typeof c }, _typeof(c) } d.d(u, { "Z": function () { return _typeof } }) }, "181": function (c, u, d) { "use strict"; d.d(u, { "Z": function () { return _unsupportedIterableToArray } }); var v = d(907); function _unsupportedIterableToArray(c, u) { if (c) { if ("string" == typeof c) return (0, v.Z)(c, u); var d = {}.toString.call(c).slice(8, -1); return "Object" === d && c.constructor && (d = c.constructor.name), "Map" === d || "Set" === d ? Array.from(c) : "Arguments" === d || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(d) ? (0, v.Z)(c, u) : void 0 } } }, "238": function (c, u, d) { "use strict"; d.d(u, { "Z": function () { return ut } }); var v = {}; function bind(c, u) { return function wrap() { return c.apply(u, arguments) } } d.r(v), d.d(v, { "hasBrowserEnv": function () { return Ae }, "hasStandardBrowserEnv": function () { return Ie }, "hasStandardBrowserWebWorkerEnv": function () { return Oe }, "origin": function () { return Pe } }); const { "toString": E } = Object.prototype, { "getPrototypeOf": k } = Object, R = (U = Object.create(null), c => { const u = E.call(c); return U[u] || (U[u] = u.slice(8, -1).toLowerCase()) }); var U; const kindOfTest = c => (c = c.toLowerCase(), u => R(u) === c), typeOfTest = c => u => typeof u === c, { "isArray": H } = Array, G = typeOfTest("undefined"); const W = kindOfTest("ArrayBuffer"); const Z = typeOfTest("string"), Y = typeOfTest("function"), J = typeOfTest("number"), isObject = c => null !== c && "object" == typeof c, isPlainObject = c => { if ("object" !== R(c)) return !1; const u = k(c); return !(null !== u && u !== Object.prototype && null !== Object.getPrototypeOf(u) || Symbol.toStringTag in c || Symbol.iterator in c) }, K = kindOfTest("Date"), X = kindOfTest("File"), Q = kindOfTest("Blob"), ee = kindOfTest("FileList"), te = kindOfTest("URLSearchParams"), [ne, re, oe, ie] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest); function forEach(c, u, { "allOwnKeys": d = !1 } = {}) { if (null == c) return; let v, E; if ("object" != typeof c && (c = [c]), H(c)) for (v = 0, E = c.length; v < E; v++)u.call(null, c[v], v, c); else { const E = d ? Object.getOwnPropertyNames(c) : Object.keys(c), k = E.length; let R; for (v = 0; v < k; v++)R = E[v], u.call(null, c[R], R, c) } } function findKey(c, u) { u = u.toLowerCase(); const d = Object.keys(c); let v, E = d.length; for (; E-- > 0;)if (v = d[E], u === v.toLowerCase()) return v; return null } const ae = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : global, isContextDefined = c => !G(c) && c !== ae; const se = (ce = "undefined" != typeof Uint8Array && k(Uint8Array), c => ce && c instanceof ce); var ce; const le = kindOfTest("HTMLFormElement"), ue = (({ "hasOwnProperty": c }) => (u, d) => c.call(u, d))(Object.prototype), de = kindOfTest("RegExp"), reduceDescriptors = (c, u) => { const d = Object.getOwnPropertyDescriptors(c), v = {}; forEach(d, ((d, E) => { let k; !1 !== (k = u(d, E, c)) && (v[E] = k || d) })), Object.defineProperties(c, v) }, pe = "abcdefghijklmnopqrstuvwxyz", fe = "0123456789", he = { "DIGIT": fe, "ALPHA": pe, "ALPHA_DIGIT": pe + pe.toUpperCase() + fe }; const me = kindOfTest("AsyncFunction"); var ge = { "isArray": H, "isArrayBuffer": W, "isBuffer": function isBuffer(c) { return null !== c && !G(c) && null !== c.constructor && !G(c.constructor) && Y(c.constructor.isBuffer) && c.constructor.isBuffer(c) }, "isFormData": c => { let u; return c && ("function" == typeof FormData && c instanceof FormData || Y(c.append) && ("formdata" === (u = R(c)) || "object" === u && Y(c.toString) && "[object FormData]" === c.toString())) }, "isArrayBufferView": function isArrayBufferView(c) { let u; return u = "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(c) : c && c.buffer && W(c.buffer), u }, "isString": Z, "isNumber": J, "isBoolean": c => !0 === c || !1 === c, "isObject": isObject, "isPlainObject": isPlainObject, "isReadableStream": ne, "isRequest": re, "isResponse": oe, "isHeaders": ie, "isUndefined": G, "isDate": K, "isFile": X, "isBlob": Q, "isRegExp": de, "isFunction": Y, "isStream": c => isObject(c) && Y(c.pipe), "isURLSearchParams": te, "isTypedArray": se, "isFileList": ee, "forEach": forEach, "merge": function merge() { const { "caseless": c } = isContextDefined(this) && this || {}, u = {}, assignValue = (d, v) => { const E = c && findKey(u, v) || v; isPlainObject(u[E]) && isPlainObject(d) ? u[E] = merge(u[E], d) : isPlainObject(d) ? u[E] = merge({}, d) : H(d) ? u[E] = d.slice() : u[E] = d }; for (let c = 0, u = arguments.length; c < u; c++)arguments[c] && forEach(arguments[c], assignValue); return u }, "extend": (c, u, d, { "allOwnKeys": v } = {}) => (forEach(u, ((u, v) => { d && Y(u) ? c[v] = bind(u, d) : c[v] = u }), { "allOwnKeys": v }), c), "trim": c => c.trim ? c.trim() : c.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""), "stripBOM": c => (65279 === c.charCodeAt(0) && (c = c.slice(1)), c), "inherits": (c, u, d, v) => { c.prototype = Object.create(u.prototype, v), c.prototype.constructor = c, Object.defineProperty(c, "super", { "value": u.prototype }), d && Object.assign(c.prototype, d) }, "toFlatObject": (c, u, d, v) => { let E, R, U; const H = {}; if (u = u || {}, null == c) return u; do { for (E = Object.getOwnPropertyNames(c), R = E.length; R-- > 0;)U = E[R], v && !v(U, c, u) || H[U] || (u[U] = c[U], H[U] = !0); c = !1 !== d && k(c) } while (c && (!d || d(c, u)) && c !== Object.prototype); return u }, "kindOf": R, "kindOfTest": kindOfTest, "endsWith": (c, u, d) => { c = String(c), (void 0 === d || d > c.length) && (d = c.length), d -= u.length; const v = c.indexOf(u, d); return -1 !== v && v === d }, "toArray": c => { if (!c) return null; if (H(c)) return c; let u = c.length; if (!J(u)) return null; const d = new Array(u); for (; u-- > 0;)d[u] = c[u]; return d }, "forEachEntry": (c, u) => { const d = (c && c[Symbol.iterator]).call(c); let v; for (; (v = d.next()) && !v.done;) { const d = v.value; u.call(c, d[0], d[1]) } }, "matchAll": (c, u) => { let d; const v = []; for (; null !== (d = c.exec(u));)v.push(d); return v }, "isHTMLForm": le, "hasOwnProperty": ue, "hasOwnProp": ue, "reduceDescriptors": reduceDescriptors, "freezeMethods": c => { reduceDescriptors(c, ((u, d) => { if (Y(c) && -1 !== ["arguments", "caller", "callee"].indexOf(d)) return !1; const v = c[d]; Y(v) && (u.enumerable = !1, "writable" in u ? u.writable = !1 : u.set || (u.set = () => { throw Error("Can not rewrite read-only method '" + d + "'") })) })) }, "toObjectSet": (c, u) => { const d = {}, define = c => { c.forEach((c => { d[c] = !0 })) }; return H(c) ? define(c) : define(String(c).split(u)), d }, "toCamelCase": c => c.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, (function replacer(c, u, d) { return u.toUpperCase() + d })), "noop": () => { }, "toFiniteNumber": (c, u) => null != c && Number.isFinite(c = +c) ? c : u, "findKey": findKey, "global": ae, "isContextDefined": isContextDefined, "ALPHABET": he, "generateString": (c = 16, u = he.ALPHA_DIGIT) => { let d = ""; const { "length": v } = u; for (; c--;)d += u[Math.random() * v | 0]; return d }, "isSpecCompliantForm": function isSpecCompliantForm(c) { return !!(c && Y(c.append) && "FormData" === c[Symbol.toStringTag] && c[Symbol.iterator]) }, "toJSONObject": c => { const u = new Array(10), visit = (c, d) => { if (isObject(c)) { if (u.indexOf(c) >= 0) return; if (!("toJSON" in c)) { u[d] = c; const v = H(c) ? [] : {}; return forEach(c, ((c, u) => { const E = visit(c, d + 1); !G(E) && (v[u] = E) })), u[d] = void 0, v } } return c }; return visit(c, 0) }, "isAsyncFn": me, "isThenable": c => c && (isObject(c) || Y(c)) && Y(c.then) && Y(c.catch) }; function AxiosError(c, u, d, v, E) { Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = (new Error).stack, this.message = c, this.name = "AxiosError", u && (this.code = u), d && (this.config = d), v && (this.request = v), E && (this.response = E) } ge.inherits(AxiosError, Error, { "toJSON": function toJSON() { return { "message": this.message, "name": this.name, "description": this.description, "number": this.number, "fileName": this.fileName, "lineNumber": this.lineNumber, "columnNumber": this.columnNumber, "stack": this.stack, "config": ge.toJSONObject(this.config), "code": this.code, "status": this.response && this.response.status ? this.response.status : null } } }); const _e = AxiosError.prototype, ve = {};["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach((c => { ve[c] = { "value": c } })), Object.defineProperties(AxiosError, ve), Object.defineProperty(_e, "isAxiosError", { "value": !0 }), AxiosError.from = (c, u, d, v, E, k) => { const R = Object.create(_e); return ge.toFlatObject(c, R, (function filter(c) { return c !== Error.prototype }), (c => "isAxiosError" !== c)), AxiosError.call(R, c.message, u, d, v, E), R.cause = c, R.name = c.name, k && Object.assign(R, k), R }; var ye = AxiosError; function isVisitable(c) { return ge.isPlainObject(c) || ge.isArray(c) } function removeBrackets(c) { return ge.endsWith(c, "[]") ? c.slice(0, -2) : c } function renderKey(c, u, d) { return c ? c.concat(u).map((function each(c, u) { return c = removeBrackets(c), !d && u ? "[" + c + "]" : c })).join(d ? "." : "") : u } const be = ge.toFlatObject(ge, {}, null, (function filter(c) { return /^is[A-Z]/.test(c) })); var Se = function toFormData(c, u, d) { if (!ge.isObject(c)) throw new TypeError("target must be an object"); u = u || new FormData; const v = (d = ge.toFlatObject(d, { "metaTokens": !0, "dots": !1, "indexes": !1 }, !1, (function defined(c, u) { return !ge.isUndefined(u[c]) }))).metaTokens, E = d.visitor || defaultVisitor, k = d.dots, R = d.indexes, U = (d.Blob || "undefined" != typeof Blob && Blob) && ge.isSpecCompliantForm(u); if (!ge.isFunction(E)) throw new TypeError("visitor must be a function"); function convertValue(c) { if (null === c) return ""; if (ge.isDate(c)) return c.toISOString(); if (!U && ge.isBlob(c)) throw new ye("Blob is not supported. Use a Buffer instead."); return ge.isArrayBuffer(c) || ge.isTypedArray(c) ? U && "function" == typeof Blob ? new Blob([c]) : Buffer.from(c) : c } function defaultVisitor(c, d, E) { let U = c; if (c && !E && "object" == typeof c) if (ge.endsWith(d, "{}")) d = v ? d : d.slice(0, -2), c = JSON.stringify(c); else if (ge.isArray(c) && function isFlatArray(c) { return ge.isArray(c) && !c.some(isVisitable) }(c) || (ge.isFileList(c) || ge.endsWith(d, "[]")) && (U = ge.toArray(c))) return d = removeBrackets(d), U.forEach((function each(c, v) { !ge.isUndefined(c) && null !== c && u.append(!0 === R ? renderKey([d], v, k) : null === R ? d : d + "[]", convertValue(c)) })), !1; return !!isVisitable(c) || (u.append(renderKey(E, d, k), convertValue(c)), !1) } const H = [], G = Object.assign(be, { "defaultVisitor": defaultVisitor, "convertValue": convertValue, "isVisitable": isVisitable }); if (!ge.isObject(c)) throw new TypeError("data must be an object"); return function build(c, d) { if (!ge.isUndefined(c)) { if (-1 !== H.indexOf(c)) throw Error("Circular reference detected in " + d.join(".")); H.push(c), ge.forEach(c, (function each(c, v) { !0 === (!(ge.isUndefined(c) || null === c) && E.call(u, c, ge.isString(v) ? v.trim() : v, d, G)) && build(c, d ? d.concat(v) : [v]) })), H.pop() } }(c), u }; function encode(c) { const u = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", "%00": "\0" }; return encodeURIComponent(c).replace(/[!'()~]|%20|%00/g, (function replacer(c) { return u[c] })) } function AxiosURLSearchParams(c, u) { this._pairs = [], c && Se(c, this, u) } const we = AxiosURLSearchParams.prototype; we.append = function append(c, u) { this._pairs.push([c, u]) }, we.toString = function toString(c) { const u = c ? function (u) { return c.call(this, u, encode) } : encode; return this._pairs.map((function each(c) { return u(c[0]) + "=" + u(c[1]) }), "").join("&") }; var Ee = AxiosURLSearchParams; function buildURL_encode(c) { return encodeURIComponent(c).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]") } function buildURL(c, u, d) { if (!u) return c; const v = d && d.encode || buildURL_encode, E = d && d.serialize; let k; if (k = E ? E(u, d) : ge.isURLSearchParams(u) ? u.toString() : new Ee(u, d).toString(v), k) { const u = c.indexOf("#"); -1 !== u && (c = c.slice(0, u)), c += (-1 === c.indexOf("?") ? "?" : "&") + k } return c } var Ce = class InterceptorManager { "constructor"() { this.handlers = [] } "use"(c, u, d) { return this.handlers.push({ "fulfilled": c, "rejected": u, "synchronous": !!d && d.synchronous, "runWhen": d ? d.runWhen : null }), this.handlers.length - 1 } "eject"(c) { this.handlers[c] && (this.handlers[c] = null) } "clear"() { this.handlers && (this.handlers = []) } "forEach"(c) { ge.forEach(this.handlers, (function forEachHandler(u) { null !== u && c(u) })) } }, Te = { "silentJSONParsing": !0, "forcedJSONParsing": !0, "clarifyTimeoutError": !1 }, xe = { "isBrowser": !0, "classes": { "URLSearchParams": "undefined" != typeof URLSearchParams ? URLSearchParams : Ee, "FormData": "undefined" != typeof FormData ? FormData : null, "Blob": "undefined" != typeof Blob ? Blob : null }, "protocols": ["http", "https", "file", "blob", "url", "data"] }; const Ae = "undefined" != typeof window && "undefined" != typeof document, Ie = (ke = "undefined" != typeof navigator && navigator.product, Ae && ["ReactNative", "NativeScript", "NS"].indexOf(ke) < 0); var ke; const Oe = "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && "function" == typeof self.importScripts, Pe = Ae && window.location.href || "http://localhost"; var Re = { ...v, ...xe }; var Me = function formDataToJSON(c) { function buildPath(c, u, d, v) { let E = c[v++]; if ("__proto__" === E) return !0; const k = Number.isFinite(+E), R = v >= c.length; if (E = !E && ge.isArray(d) ? d.length : E, R) return ge.hasOwnProp(d, E) ? d[E] = [d[E], u] : d[E] = u, !k; d[E] && ge.isObject(d[E]) || (d[E] = []); return buildPath(c, u, d[E], v) && ge.isArray(d[E]) && (d[E] = function arrayToObject(c) { const u = {}, d = Object.keys(c); let v; const E = d.length; let k; for (v = 0; v < E; v++)k = d[v], u[k] = c[k]; return u }(d[E])), !k } if (ge.isFormData(c) && ge.isFunction(c.entries)) { const u = {}; return ge.forEachEntry(c, ((c, d) => { buildPath(function parsePropPath(c) { return ge.matchAll(/\w+|\[(\w*)]/g, c).map((c => "[]" === c[0] ? "" : c[1] || c[0])) }(c), d, u, 0) })), u } return null }; const Ne = { "transitional": Te, "adapter": ["xhr", "http", "fetch"], "transformRequest": [function transformRequest(c, u) { const d = u.getContentType() || "", v = d.indexOf("application/json") > -1, E = ge.isObject(c); E && ge.isHTMLForm(c) && (c = new FormData(c)); if (ge.isFormData(c)) return v ? JSON.stringify(Me(c)) : c; if (ge.isArrayBuffer(c) || ge.isBuffer(c) || ge.isStream(c) || ge.isFile(c) || ge.isBlob(c) || ge.isReadableStream(c)) return c; if (ge.isArrayBufferView(c)) return c.buffer; if (ge.isURLSearchParams(c)) return u.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), c.toString(); let k; if (E) { if (d.indexOf("application/x-www-form-urlencoded") > -1) return function toURLEncodedForm(c, u) { return Se(c, new Re.classes.URLSearchParams, Object.assign({ "visitor": function (c, u, d, v) { return Re.isNode && ge.isBuffer(c) ? (this.append(u, c.toString("base64")), !1) : v.defaultVisitor.apply(this, arguments) } }, u)) }(c, this.formSerializer).toString(); if ((k = ge.isFileList(c)) || d.indexOf("multipart/form-data") > -1) { const u = this.env && this.env.FormData; return Se(k ? { "files[]": c } : c, u && new u, this.formSerializer) } } return E || v ? (u.setContentType("application/json", !1), function stringifySafely(c, u, d) { if (ge.isString(c)) try { return (u || JSON.parse)(c), ge.trim(c) } catch (c) { if ("SyntaxError" !== c.name) throw c } return (d || JSON.stringify)(c) }(c)) : c }], "transformResponse": [function transformResponse(c) { const u = this.transitional || Ne.transitional, d = u && u.forcedJSONParsing, v = "json" === this.responseType; if (ge.isResponse(c) || ge.isReadableStream(c)) return c; if (c && ge.isString(c) && (d && !this.responseType || v)) { const d = !(u && u.silentJSONParsing) && v; try { return JSON.parse(c) } catch (c) { if (d) { if ("SyntaxError" === c.name) throw ye.from(c, ye.ERR_BAD_RESPONSE, this, null, this.response); throw c } } } return c }], "timeout": 0, "xsrfCookieName": "XSRF-TOKEN", "xsrfHeaderName": "X-XSRF-TOKEN", "maxContentLength": -1, "maxBodyLength": -1, "env": { "FormData": Re.classes.FormData, "Blob": Re.classes.Blob }, "validateStatus": function validateStatus(c) { return c >= 200 && c < 300 }, "headers": { "common": { "Accept": "application/json, text/plain, */*", "Content-Type": void 0 } } }; ge.forEach(["delete", "get", "head", "post", "put", "patch"], (c => { Ne.headers[c] = {} })); var De = Ne; const $e = ge.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]); const Le = Symbol("internals"); function normalizeHeader(c) { return c && String(c).trim().toLowerCase() } function normalizeValue(c) { return !1 === c || null == c ? c : ge.isArray(c) ? c.map(normalizeValue) : String(c) } function matchHeaderValue(c, u, d, v, E) { return ge.isFunction(v) ? v.call(this, u, d) : (E && (u = d), ge.isString(u) ? ge.isString(v) ? -1 !== u.indexOf(v) : ge.isRegExp(v) ? v.test(u) : void 0 : void 0) } class AxiosHeaders { "constructor"(c) { c && this.set(c) } "set"(c, u, d) { const v = this; function setHeader(c, u, d) { const E = normalizeHeader(u); if (!E) throw new Error("header name must be a non-empty string"); const k = ge.findKey(v, E); (!k || void 0 === v[k] || !0 === d || void 0 === d && !1 !== v[k]) && (v[k || u] = normalizeValue(c)) } const setHeaders = (c, u) => ge.forEach(c, ((c, d) => setHeader(c, d, u))); if (ge.isPlainObject(c) || c instanceof this.constructor) setHeaders(c, u); else if (ge.isString(c) && (c = c.trim()) && !/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(c.trim())) setHeaders((c => { const u = {}; let d, v, E; return c && c.split("\n").forEach((function parser(c) { E = c.indexOf(":"), d = c.substring(0, E).trim().toLowerCase(), v = c.substring(E + 1).trim(), !d || u[d] && $e[d] || ("set-cookie" === d ? u[d] ? u[d].push(v) : u[d] = [v] : u[d] = u[d] ? u[d] + ", " + v : v) })), u })(c), u); else if (ge.isHeaders(c)) for (const [u, v] of c.entries()) setHeader(v, u, d); else null != c && setHeader(u, c, d); return this } "get"(c, u) { if (c = normalizeHeader(c)) { const d = ge.findKey(this, c); if (d) { const c = this[d]; if (!u) return c; if (!0 === u) return function parseTokens(c) { const u = Object.create(null), d = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g; let v; for (; v = d.exec(c);)u[v[1]] = v[2]; return u }(c); if (ge.isFunction(u)) return u.call(this, c, d); if (ge.isRegExp(u)) return u.exec(c); throw new TypeError("parser must be boolean|regexp|function") } } } "has"(c, u) { if (c = normalizeHeader(c)) { const d = ge.findKey(this, c); return !(!d || void 0 === this[d] || u && !matchHeaderValue(0, this[d], d, u)) } return !1 } "delete"(c, u) { const d = this; let v = !1; function deleteHeader(c) { if (c = normalizeHeader(c)) { const E = ge.findKey(d, c); !E || u && !matchHeaderValue(0, d[E], E, u) || (delete d[E], v = !0) } } return ge.isArray(c) ? c.forEach(deleteHeader) : deleteHeader(c), v } "clear"(c) { const u = Object.keys(this); let d = u.length, v = !1; for (; d--;) { const E = u[d]; c && !matchHeaderValue(0, this[E], E, c, !0) || (delete this[E], v = !0) } return v } "normalize"(c) { const u = this, d = {}; return ge.forEach(this, ((v, E) => { const k = ge.findKey(d, E); if (k) return u[k] = normalizeValue(v), void delete u[E]; const R = c ? function formatHeader(c) { return c.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, ((c, u, d) => u.toUpperCase() + d)) }(E) : String(E).trim(); R !== E && delete u[E], u[R] = normalizeValue(v), d[R] = !0 })), this } "concat"(...c) { return this.constructor.concat(this, ...c) } "toJSON"(c) { const u = Object.create(null); return ge.forEach(this, ((d, v) => { null != d && !1 !== d && (u[v] = c && ge.isArray(d) ? d.join(", ") : d) })), u } [Symbol.iterator]() { return Object.entries(this.toJSON())[Symbol.iterator]() } "toString"() { return Object.entries(this.toJSON()).map((([c, u]) => c + ": " + u)).join("\n") } get [Symbol.toStringTag]() { return "AxiosHeaders" } static "from"(c) { return c instanceof this ? c : new this(c) } static "concat"(c, ...u) { const d = new this(c); return u.forEach((c => d.set(c))), d } static "accessor"(c) { const u = (this[Le] = this[Le] = { "accessors": {} }).accessors, d = this.prototype; function defineAccessor(c) { const v = normalizeHeader(c); u[v] || (!function buildAccessors(c, u) { const d = ge.toCamelCase(" " + u);["get", "set", "has"].forEach((v => { Object.defineProperty(c, v + d, { "value": function (c, d, E) { return this[v].call(this, u, c, d, E) }, "configurable": !0 }) })) }(d, c), u[v] = !0) } return ge.isArray(c) ? c.forEach(defineAccessor) : defineAccessor(c), this } } AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]), ge.reduceDescriptors(AxiosHeaders.prototype, (({ "value": c }, u) => { let d = u[0].toUpperCase() + u.slice(1); return { "get": () => c, "set"(c) { this[d] = c } } })), ge.freezeMethods(AxiosHeaders); var Fe = AxiosHeaders; function transformData(c, u) { const d = this || De, v = u || d, E = Fe.from(v.headers); let k = v.data; return ge.forEach(c, (function transform(c) { k = c.call(d, k, E.normalize(), u ? u.status : void 0) })), E.normalize(), k } function isCancel(c) { return !(!c || !c.__CANCEL__) } function CanceledError(c, u, d) { ye.call(this, null == c ? "canceled" : c, ye.ERR_CANCELED, u, d), this.name = "CanceledError" } ge.inherits(CanceledError, ye, { "__CANCEL__": !0 }); var je = CanceledError; function settle(c, u, d) { const v = d.config.validateStatus; d.status && v && !v(d.status) ? u(new ye("Request failed with status code " + d.status, [ye.ERR_BAD_REQUEST, ye.ERR_BAD_RESPONSE][Math.floor(d.status / 100) - 4], d.config, d.request, d)) : c(d) } var Be = function speedometer(c, u) { c = c || 10; const d = new Array(c), v = new Array(c); let E, k = 0, R = 0; return u = void 0 !== u ? u : 1e3, function push(U) { const H = Date.now(), G = v[R]; E || (E = H), d[k] = U, v[k] = H; let W = R, Z = 0; for (; W !== k;)Z += d[W++], W %= c; if (k = (k + 1) % c, k === R && (R = (R + 1) % c), H - E < u) return; const Y = G && H - G; return Y ? Math.round(1e3 * Z / Y) : void 0 } }; var Ue = function throttle(c, u) { let d = 0; const v = 1e3 / u; let E = null; return function throttled() { const u = !0 === this, k = Date.now(); if (u || k - d > v) return E && (clearTimeout(E), E = null), d = k, c.apply(null, arguments); E || (E = setTimeout((() => (E = null, d = Date.now(), c.apply(null, arguments))), v - (k - d))) } }, progressEventReducer = (c, u, d = 3) => { let v = 0; const E = Be(50, 250); return Ue((d => { const k = d.loaded, R = d.lengthComputable ? d.total : void 0, U = k - v, H = E(U); v = k; const G = { "loaded": k, "total": R, "progress": R ? k / R : void 0, "bytes": U, "rate": H || void 0, "estimated": H && R && k <= R ? (R - k) / H : void 0, "event": d, "lengthComputable": null != R }; G[u ? "download" : "upload"] = !0, c(G) }), d) }, He = Re.hasStandardBrowserEnv ? function standardBrowserEnv() { const c = /(msie|trident)/i.test(navigator.userAgent), u = document.createElement("a"); let d; function resolveURL(d) { let v = d; return c && (u.setAttribute("href", v), v = u.href), u.setAttribute("href", v), { "href": u.href, "protocol": u.protocol ? u.protocol.replace(/:$/, "") : "", "host": u.host, "search": u.search ? u.search.replace(/^\?/, "") : "", "hash": u.hash ? u.hash.replace(/^#/, "") : "", "hostname": u.hostname, "port": u.port, "pathname": "/" === u.pathname.charAt(0) ? u.pathname : "/" + u.pathname } } return d = resolveURL(window.location.href), function isURLSameOrigin(c) { const u = ge.isString(c) ? resolveURL(c) : c; return u.protocol === d.protocol && u.host === d.host } }() : function isURLSameOrigin() { return !0 }, ze = Re.hasStandardBrowserEnv ? { "write"(c, u, d, v, E, k) { const R = [c + "=" + encodeURIComponent(u)]; ge.isNumber(d) && R.push("expires=" + new Date(d).toGMTString()), ge.isString(v) && R.push("path=" + v), ge.isString(E) && R.push("domain=" + E), !0 === k && R.push("secure"), document.cookie = R.join("; ") }, "read"(c) { const u = document.cookie.match(new RegExp("(^|;\\s*)(" + c + ")=([^;]*)")); return u ? decodeURIComponent(u[3]) : null }, "remove"(c) { this.write(c, "", Date.now() - 864e5) } } : { "write"() { }, "read"() { return null }, "remove"() { } }; function buildFullPath(c, u) { return c && !function isAbsoluteURL(c) { return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(c) }(u) ? function combineURLs(c, u) { return u ? c.replace(/\/?\/$/, "") + "/" + u.replace(/^\/+/, "") : c }(c, u) : u } const headersToObject = c => c instanceof Fe ? { ...c } : c; function mergeConfig(c, u) { u = u || {}; const d = {}; function getMergedValue(c, u, d) { return ge.isPlainObject(c) && ge.isPlainObject(u) ? ge.merge.call({ "caseless": d }, c, u) : ge.isPlainObject(u) ? ge.merge({}, u) : ge.isArray(u) ? u.slice() : u } function mergeDeepProperties(c, u, d) { return ge.isUndefined(u) ? ge.isUndefined(c) ? void 0 : getMergedValue(void 0, c, d) : getMergedValue(c, u, d) } function valueFromConfig2(c, u) { if (!ge.isUndefined(u)) return getMergedValue(void 0, u) } function defaultToConfig2(c, u) { return ge.isUndefined(u) ? ge.isUndefined(c) ? void 0 : getMergedValue(void 0, c) : getMergedValue(void 0, u) } function mergeDirectKeys(d, v, E) { return E in u ? getMergedValue(d, v) : E in c ? getMergedValue(void 0, d) : void 0 } const v = { "url": valueFromConfig2, "method": valueFromConfig2, "data": valueFromConfig2, "baseURL": defaultToConfig2, "transformRequest": defaultToConfig2, "transformResponse": defaultToConfig2, "paramsSerializer": defaultToConfig2, "timeout": defaultToConfig2, "timeoutMessage": defaultToConfig2, "withCredentials": defaultToConfig2, "withXSRFToken": defaultToConfig2, "adapter": defaultToConfig2, "responseType": defaultToConfig2, "xsrfCookieName": defaultToConfig2, "xsrfHeaderName": defaultToConfig2, "onUploadProgress": defaultToConfig2, "onDownloadProgress": defaultToConfig2, "decompress": defaultToConfig2, "maxContentLength": defaultToConfig2, "maxBodyLength": defaultToConfig2, "beforeRedirect": defaultToConfig2, "transport": defaultToConfig2, "httpAgent": defaultToConfig2, "httpsAgent": defaultToConfig2, "cancelToken": defaultToConfig2, "socketPath": defaultToConfig2, "responseEncoding": defaultToConfig2, "validateStatus": mergeDirectKeys, "headers": (c, u) => mergeDeepProperties(headersToObject(c), headersToObject(u), !0) }; return ge.forEach(Object.keys(Object.assign({}, c, u)), (function computeConfigValue(E) { const k = v[E] || mergeDeepProperties, R = k(c[E], u[E], E); ge.isUndefined(R) && k !== mergeDirectKeys || (d[E] = R) })), d } var resolveConfig = c => { const u = mergeConfig({}, c); let d, { "data": v, "withXSRFToken": E, "xsrfHeaderName": k, "xsrfCookieName": R, "headers": U, "auth": H } = u; if (u.headers = U = Fe.from(U), u.url = buildURL(buildFullPath(u.baseURL, u.url), c.params, c.paramsSerializer), H && U.set("Authorization", "Basic " + btoa((H.username || "") + ":" + (H.password ? unescape(encodeURIComponent(H.password)) : ""))), ge.isFormData(v)) if (Re.hasStandardBrowserEnv || Re.hasStandardBrowserWebWorkerEnv) U.setContentType(void 0); else if (!1 !== (d = U.getContentType())) { const [c, ...u] = d ? d.split(";").map((c => c.trim())).filter(Boolean) : []; U.setContentType([c || "multipart/form-data", ...u].join("; ")) } if (Re.hasStandardBrowserEnv && (E && ge.isFunction(E) && (E = E(u)), E || !1 !== E && He(u.url))) { const c = k && R && ze.read(R); c && U.set(k, c) } return u }; var qe = "undefined" != typeof XMLHttpRequest && function (c) { return new Promise((function dispatchXhrRequest(u, d) { const v = resolveConfig(c); let E = v.data; const k = Fe.from(v.headers).normalize(); let R, { "responseType": U } = v; function done() { v.cancelToken && v.cancelToken.unsubscribe(R), v.signal && v.signal.removeEventListener("abort", R) } let H = new XMLHttpRequest; function onloadend() { if (!H) return; const v = Fe.from("getAllResponseHeaders" in H && H.getAllResponseHeaders()); settle((function _resolve(c) { u(c), done() }), (function _reject(c) { d(c), done() }), { "data": U && "text" !== U && "json" !== U ? H.response : H.responseText, "status": H.status, "statusText": H.statusText, "headers": v, "config": c, "request": H }), H = null } H.open(v.method.toUpperCase(), v.url, !0), H.timeout = v.timeout, "onloadend" in H ? H.onloadend = onloadend : H.onreadystatechange = function handleLoad() { H && 4 === H.readyState && (0 !== H.status || H.responseURL && 0 === H.responseURL.indexOf("file:")) && setTimeout(onloadend) }, H.onabort = function handleAbort() { H && (d(new ye("Request aborted", ye.ECONNABORTED, v, H)), H = null) }, H.onerror = function handleError() { d(new ye("Network Error", ye.ERR_NETWORK, v, H)), H = null }, H.ontimeout = function handleTimeout() { let c = v.timeout ? "timeout of " + v.timeout + "ms exceeded" : "timeout exceeded"; const u = v.transitional || Te; v.timeoutErrorMessage && (c = v.timeoutErrorMessage), d(new ye(c, u.clarifyTimeoutError ? ye.ETIMEDOUT : ye.ECONNABORTED, v, H)), H = null }, void 0 === E && k.setContentType(null), "setRequestHeader" in H && ge.forEach(k.toJSON(), (function setRequestHeader(c, u) { H.setRequestHeader(u, c) })), ge.isUndefined(v.withCredentials) || (H.withCredentials = !!v.withCredentials), U && "json" !== U && (H.responseType = v.responseType), "function" == typeof v.onDownloadProgress && H.addEventListener("progress", progressEventReducer(v.onDownloadProgress, !0)), "function" == typeof v.onUploadProgress && H.upload && H.upload.addEventListener("progress", progressEventReducer(v.onUploadProgress)), (v.cancelToken || v.signal) && (R = u => { H && (d(!u || u.type ? new je(null, c, H) : u), H.abort(), H = null) }, v.cancelToken && v.cancelToken.subscribe(R), v.signal && (v.signal.aborted ? R() : v.signal.addEventListener("abort", R))); const G = function parseProtocol(c) { const u = /^([-+\w]{1,25})(:?\/\/|:)/.exec(c); return u && u[1] || "" }(v.url); G && -1 === Re.protocols.indexOf(G) ? d(new ye("Unsupported protocol " + G + ":", ye.ERR_BAD_REQUEST, c)) : H.send(E || null) })) }; var helpers_composeSignals = (c, u) => { let d, v = new AbortController; const onabort = function (c) { if (!d) { d = !0, unsubscribe(); const u = c instanceof Error ? c : this.reason; v.abort(u instanceof ye ? u : new je(u instanceof Error ? u.message : u)) } }; let E = u && setTimeout((() => { onabort(new ye(`timeout ${u} of ms exceeded`, ye.ETIMEDOUT)) }), u); const unsubscribe = () => { c && (E && clearTimeout(E), E = null, c.forEach((c => { c && (c.removeEventListener ? c.removeEventListener("abort", onabort) : c.unsubscribe(onabort)) })), c = null) }; c.forEach((c => c && c.addEventListener && c.addEventListener("abort", onabort))); const { "signal": k } = v; return k.unsubscribe = unsubscribe, [k, () => { E && clearTimeout(E), E = null }] }; const streamChunk = function* (c, u) { let d = c.byteLength; if (!u || d < u) return void (yield c); let v, E = 0; for (; E < d;)v = E + u, yield c.slice(E, v), E = v }, trackStream = (c, u, d, v, E) => { const k = async function* (c, u, d) { for await (const v of c) yield* streamChunk(ArrayBuffer.isView(v) ? v : await d(String(v)), u) }(c, u, E); let R = 0; return new ReadableStream({ "type": "bytes", async"pull"(c) { const { "done": u, "value": E } = await k.next(); if (u) return c.close(), void v(); let U = E.byteLength; d && d(R += U), c.enqueue(new Uint8Array(E)) }, "cancel"(c) { return v(c), k.return() } }, { "highWaterMark": 2 }) }, fetchProgressDecorator = (c, u) => { const d = null != c; return v => setTimeout((() => u({ "lengthComputable": d, "total": c, "loaded": v }))) }, Ge = "function" == typeof fetch && "function" == typeof Request && "function" == typeof Response, Ve = Ge && "function" == typeof ReadableStream, We = Ge && ("function" == typeof TextEncoder ? (Ze = new TextEncoder, c => Ze.encode(c)) : async c => new Uint8Array(await new Response(c).arrayBuffer())); var Ze; const Ye = Ve && (() => { let c = !1; const u = new Request(Re.origin, { "body": new ReadableStream, "method": "POST", get "duplex"() { return c = !0, "half" } }).headers.has("Content-Type"); return c && !u })(), Je = Ve && !!(() => { try { return ge.isReadableStream(new Response("").body) } catch (c) { } })(), Ke = { "stream": Je && (c => c.body) }; var Xe; Ge && (Xe = new Response, ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((c => { !Ke[c] && (Ke[c] = ge.isFunction(Xe[c]) ? u => u[c]() : (u, d) => { throw new ye(`Response type '${c}' is not supported`, ye.ERR_NOT_SUPPORT, d) }) }))); const resolveBodyLength = async (c, u) => { const d = ge.toFiniteNumber(c.getContentLength()); return null == d ? (async c => null == c ? 0 : ge.isBlob(c) ? c.size : ge.isSpecCompliantForm(c) ? (await new Request(c).arrayBuffer()).byteLength : ge.isArrayBufferView(c) ? c.byteLength : (ge.isURLSearchParams(c) && (c += ""), ge.isString(c) ? (await We(c)).byteLength : void 0))(u) : d }; const Qe = { "http": null, "xhr": qe, "fetch": Ge && (async c => { let { "url": u, "method": d, "data": v, "signal": E, "cancelToken": k, "timeout": R, "onDownloadProgress": U, "onUploadProgress": H, "responseType": G, "headers": W, "withCredentials": Z = "same-origin", "fetchOptions": Y } = resolveConfig(c); G = G ? (G + "").toLowerCase() : "text"; let J, K, [X, Q] = E || k || R ? helpers_composeSignals([E, k], R) : []; const onFinish = () => { !J && setTimeout((() => { X && X.unsubscribe() })), J = !0 }; let ee; try { if (H && Ye && "get" !== d && "head" !== d && 0 !== (ee = await resolveBodyLength(W, v))) { let c, d = new Request(u, { "method": "POST", "body": v, "duplex": "half" }); ge.isFormData(v) && (c = d.headers.get("content-type")) && W.setContentType(c), d.body && (v = trackStream(d.body, 65536, fetchProgressDecorator(ee, progressEventReducer(H)), null, We)) } ge.isString(Z) || (Z = Z ? "cors" : "omit"), K = new Request(u, { ...Y, "signal": X, "method": d.toUpperCase(), "headers": W.normalize().toJSON(), "body": v, "duplex": "half", "withCredentials": Z }); let E = await fetch(K); const k = Je && ("stream" === G || "response" === G); if (Je && (U || k)) { const c = {};["status", "statusText", "headers"].forEach((u => { c[u] = E[u] })); const u = ge.toFiniteNumber(E.headers.get("content-length")); E = new Response(trackStream(E.body, 65536, U && fetchProgressDecorator(u, progressEventReducer(U, !0)), k && onFinish, We), c) } G = G || "text"; let R = await Ke[ge.findKey(Ke, G) || "text"](E, c); return !k && onFinish(), Q && Q(), await new Promise(((u, d) => { settle(u, d, { "data": R, "headers": Fe.from(E.headers), "status": E.status, "statusText": E.statusText, "config": c, "request": K }) })) } catch (u) { if (onFinish(), u && "TypeError" === u.name && /fetch/i.test(u.message)) throw Object.assign(new ye("Network Error", ye.ERR_NETWORK, c, K), { "cause": u.cause || u }); throw ye.from(u, u && u.code, c, K) } }) }; ge.forEach(Qe, ((c, u) => { if (c) { try { Object.defineProperty(c, "name", { "value": u }) } catch (c) { } Object.defineProperty(c, "adapterName", { "value": u }) } })); const renderReason = c => `- ${c}`, isResolvedHandle = c => ge.isFunction(c) || null === c || !1 === c; var adapters_getAdapter = c => { c = ge.isArray(c) ? c : [c]; const { "length": u } = c; let d, v; const E = {}; for (let k = 0; k < u; k++) { let u; if (d = c[k], v = d, !isResolvedHandle(d) && (v = Qe[(u = String(d)).toLowerCase()], void 0 === v)) throw new ye(`Unknown adapter '${u}'`); if (v) break; E[u || "#" + k] = v } if (!v) { const c = Object.entries(E).map((([c, u]) => `adapter ${c} ` + (!1 === u ? "is not supported by the environment" : "is not available in the build"))); let d = u ? c.length > 1 ? "since :\n" + c.map(renderReason).join("\n") : " " + renderReason(c[0]) : "as no adapter specified"; throw new ye("There is no suitable adapter to dispatch the request " + d, "ERR_NOT_SUPPORT") } return v }; function throwIfCancellationRequested(c) { if (c.cancelToken && c.cancelToken.throwIfRequested(), c.signal && c.signal.aborted) throw new je(null, c) } function dispatchRequest(c) { throwIfCancellationRequested(c), c.headers = Fe.from(c.headers), c.data = transformData.call(c, c.transformRequest), -1 !== ["post", "put", "patch"].indexOf(c.method) && c.headers.setContentType("application/x-www-form-urlencoded", !1); return adapters_getAdapter(c.adapter || De.adapter)(c).then((function onAdapterResolution(u) { return throwIfCancellationRequested(c), u.data = transformData.call(c, c.transformResponse, u), u.headers = Fe.from(u.headers), u }), (function onAdapterRejection(u) { return isCancel(u) || (throwIfCancellationRequested(c), u && u.response && (u.response.data = transformData.call(c, c.transformResponse, u.response), u.response.headers = Fe.from(u.response.headers))), Promise.reject(u) })) } const et = "1.7.2", tt = {};["object", "boolean", "number", "function", "string", "symbol"].forEach(((c, u) => { tt[c] = function validator(d) { return typeof d === c || "a" + (u < 1 ? "n " : " ") + c } })); const nt = {}; tt.transitional = function transitional(c, u, d) { function formatMessage(c, u) { return "[Axios v1.7.2] Transitional option '" + c + "'" + u + (d ? ". " + d : "") } return (d, v, E) => { if (!1 === c) throw new ye(formatMessage(v, " has been removed" + (u ? " in " + u : "")), ye.ERR_DEPRECATED); return u && !nt[v] && (nt[v] = !0, console.warn(formatMessage(v, " has been deprecated since v" + u + " and will be removed in the near future"))), !c || c(d, v, E) } }; var rt = { "assertOptions": function assertOptions(c, u, d) { if ("object" != typeof c) throw new ye("options must be an object", ye.ERR_BAD_OPTION_VALUE); const v = Object.keys(c); let E = v.length; for (; E-- > 0;) { const k = v[E], R = u[k]; if (R) { const u = c[k], d = void 0 === u || R(u, k, c); if (!0 !== d) throw new ye("option " + k + " must be " + d, ye.ERR_BAD_OPTION_VALUE) } else if (!0 !== d) throw new ye("Unknown option " + k, ye.ERR_BAD_OPTION) } }, "validators": tt }; const ot = rt.validators; class Axios { "constructor"(c) { this.defaults = c, this.interceptors = { "request": new Ce, "response": new Ce } } async"request"(c, u) { try { return await this._request(c, u) } catch (c) { if (c instanceof Error) { let u; Error.captureStackTrace ? Error.captureStackTrace(u = {}) : u = new Error; const d = u.stack ? u.stack.replace(/^.+\n/, "") : ""; try { c.stack ? d && !String(c.stack).endsWith(d.replace(/^.+\n.+\n/, "")) && (c.stack += "\n" + d) : c.stack = d } catch (c) { } } throw c } } "_request"(c, u) { "string" == typeof c ? (u = u || {}).url = c : u = c || {}, u = mergeConfig(this.defaults, u); const { "transitional": d, "paramsSerializer": v, "headers": E } = u; void 0 !== d && rt.assertOptions(d, { "silentJSONParsing": ot.transitional(ot.boolean), "forcedJSONParsing": ot.transitional(ot.boolean), "clarifyTimeoutError": ot.transitional(ot.boolean) }, !1), null != v && (ge.isFunction(v) ? u.paramsSerializer = { "serialize": v } : rt.assertOptions(v, { "encode": ot.function, "serialize": ot.function }, !0)), u.method = (u.method || this.defaults.method || "get").toLowerCase(); let k = E && ge.merge(E.common, E[u.method]); E && ge.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (c => { delete E[c] })), u.headers = Fe.concat(k, E); const R = []; let U = !0; this.interceptors.request.forEach((function unshiftRequestInterceptors(c) { "function" == typeof c.runWhen && !1 === c.runWhen(u) || (U = U && c.synchronous, R.unshift(c.fulfilled, c.rejected)) })); const H = []; let G; this.interceptors.response.forEach((function pushResponseInterceptors(c) { H.push(c.fulfilled, c.rejected) })); let W, Z = 0; if (!U) { const c = [dispatchRequest.bind(this), void 0]; for (c.unshift.apply(c, R), c.push.apply(c, H), W = c.length, G = Promise.resolve(u); Z < W;)G = G.then(c[Z++], c[Z++]); return G } W = R.length; let Y = u; for (Z = 0; Z < W;) { const c = R[Z++], u = R[Z++]; try { Y = c(Y) } catch (c) { u.call(this, c); break } } try { G = dispatchRequest.call(this, Y) } catch (c) { return Promise.reject(c) } for (Z = 0, W = H.length; Z < W;)G = G.then(H[Z++], H[Z++]); return G } "getUri"(c) { return buildURL(buildFullPath((c = mergeConfig(this.defaults, c)).baseURL, c.url), c.params, c.paramsSerializer) } } ge.forEach(["delete", "get", "head", "options"], (function forEachMethodNoData(c) { Axios.prototype[c] = function (u, d) { return this.request(mergeConfig(d || {}, { "method": c, "url": u, "data": (d || {}).data })) } })), ge.forEach(["post", "put", "patch"], (function forEachMethodWithData(c) { function generateHTTPMethod(u) { return function httpMethod(d, v, E) { return this.request(mergeConfig(E || {}, { "method": c, "headers": u ? { "Content-Type": "multipart/form-data" } : {}, "url": d, "data": v })) } } Axios.prototype[c] = generateHTTPMethod(), Axios.prototype[c + "Form"] = generateHTTPMethod(!0) })); var it = Axios; class CancelToken { "constructor"(c) { if ("function" != typeof c) throw new TypeError("executor must be a function."); let u; this.promise = new Promise((function promiseExecutor(c) { u = c })); const d = this; this.promise.then((c => { if (!d._listeners) return; let u = d._listeners.length; for (; u-- > 0;)d._listeners[u](c); d._listeners = null })), this.promise.then = c => { let u; const v = new Promise((c => { d.subscribe(c), u = c })).then(c); return v.cancel = function reject() { d.unsubscribe(u) }, v }, c((function cancel(c, v, E) { d.reason || (d.reason = new je(c, v, E), u(d.reason)) })) } "throwIfRequested"() { if (this.reason) throw this.reason } "subscribe"(c) { this.reason ? c(this.reason) : this._listeners ? this._listeners.push(c) : this._listeners = [c] } "unsubscribe"(c) { if (!this._listeners) return; const u = this._listeners.indexOf(c); -1 !== u && this._listeners.splice(u, 1) } static "source"() { let c; return { "token": new CancelToken((function executor(u) { c = u })), "cancel": c } } } var at = CancelToken; const st = { "Continue": 100, "SwitchingProtocols": 101, "Processing": 102, "EarlyHints": 103, "Ok": 200, "Created": 201, "Accepted": 202, "NonAuthoritativeInformation": 203, "NoContent": 204, "ResetContent": 205, "PartialContent": 206, "MultiStatus": 207, "AlreadyReported": 208, "ImUsed": 226, "MultipleChoices": 300, "MovedPermanently": 301, "Found": 302, "SeeOther": 303, "NotModified": 304, "UseProxy": 305, "Unused": 306, "TemporaryRedirect": 307, "PermanentRedirect": 308, "BadRequest": 400, "Unauthorized": 401, "PaymentRequired": 402, "Forbidden": 403, "NotFound": 404, "MethodNotAllowed": 405, "NotAcceptable": 406, "ProxyAuthenticationRequired": 407, "RequestTimeout": 408, "Conflict": 409, "Gone": 410, "LengthRequired": 411, "PreconditionFailed": 412, "PayloadTooLarge": 413, "UriTooLong": 414, "UnsupportedMediaType": 415, "RangeNotSatisfiable": 416, "ExpectationFailed": 417, "ImATeapot": 418, "MisdirectedRequest": 421, "UnprocessableEntity": 422, "Locked": 423, "FailedDependency": 424, "TooEarly": 425, "UpgradeRequired": 426, "PreconditionRequired": 428, "TooManyRequests": 429, "RequestHeaderFieldsTooLarge": 431, "UnavailableForLegalReasons": 451, "InternalServerError": 500, "NotImplemented": 501, "BadGateway": 502, "ServiceUnavailable": 503, "GatewayTimeout": 504, "HttpVersionNotSupported": 505, "VariantAlsoNegotiates": 506, "InsufficientStorage": 507, "LoopDetected": 508, "NotExtended": 510, "NetworkAuthenticationRequired": 511 }; Object.entries(st).forEach((([c, u]) => { st[u] = c })); var ct = st; const lt = function createInstance(c) { const u = new it(c), d = bind(it.prototype.request, u); return ge.extend(d, it.prototype, u, { "allOwnKeys": !0 }), ge.extend(d, u, null, { "allOwnKeys": !0 }), d.create = function create(u) { return createInstance(mergeConfig(c, u)) }, d }(De); lt.Axios = it, lt.CanceledError = je, lt.CancelToken = at, lt.isCancel = isCancel, lt.VERSION = et, lt.toFormData = Se, lt.AxiosError = ye, lt.Cancel = lt.CanceledError, lt.all = function all(c) { return Promise.all(c) }, lt.spread = function spread(c) { return function wrap(u) { return c.apply(null, u) } }, lt.isAxiosError = function isAxiosError(c) { return ge.isObject(c) && !0 === c.isAxiosError }, lt.mergeConfig = mergeConfig, lt.AxiosHeaders = Fe, lt.formToJSON = c => Me(ge.isHTMLForm(c) ? new FormData(c) : c), lt.getAdapter = adapters_getAdapter, lt.HttpStatusCode = ct, lt.default = lt; var ut = lt }, "7601": function (c, u) { "use strict"; u.Z = function isNil(c) { return null == c } }, "7950": function (c, u, d) { "use strict"; d.d(u, { "Z": function () { return he } }); var v = function isObject(c) { var u = typeof c; return null != c && ("object" == u || "function" == u) }, E = "object" == typeof global && global && global.Object === Object && global, k = "object" == typeof self && self && self.Object === Object && self, R = E || k || Function("return this")(), lodash_es_now = function () { return R.Date.now() }, U = /\s/; var H = function trimmedEndIndex(c) { for (var u = c.length; u-- && U.test(c.charAt(u));); return u }, G = /^\s+/; var W = function baseTrim(c) { return c ? c.slice(0, H(c) + 1).replace(G, "") : c }, Z = R.Symbol, Y = Object.prototype, J = Y.hasOwnProperty, K = Y.toString, X = Z ? Z.toStringTag : void 0; var Q = function getRawTag(c) { var u = J.call(c, X), d = c[X]; try { c[X] = void 0; var v = !0 } catch (c) { } var E = K.call(c); return v && (u ? c[X] = d : delete c[X]), E }, ee = Object.prototype.toString; var te = function objectToString(c) { return ee.call(c) }, ne = Z ? Z.toStringTag : void 0; var re = function baseGetTag(c) { return null == c ? void 0 === c ? "[object Undefined]" : "[object Null]" : ne && ne in Object(c) ? Q(c) : te(c) }; var oe = function isObjectLike(c) { return null != c && "object" == typeof c }; var ie = function isSymbol(c) { return "symbol" == typeof c || oe(c) && "[object Symbol]" == re(c) }, ae = /^[-+]0x[0-9a-f]+$/i, se = /^0b[01]+$/i, ce = /^0o[0-7]+$/i, le = parseInt; var ue = function toNumber(c) { if ("number" == typeof c) return c; if (ie(c)) return NaN; if (v(c)) { var u = "function" == typeof c.valueOf ? c.valueOf() : c; c = v(u) ? u + "" : u } if ("string" != typeof c) return 0 === c ? c : +c; c = W(c); var d = se.test(c); return d || ce.test(c) ? le(c.slice(2), d ? 2 : 8) : ae.test(c) ? NaN : +c }, de = Math.max, pe = Math.min; var fe = function debounce(c, u, d) { var E, k, R, U, H, G, W = 0, Z = !1, Y = !1, J = !0; if ("function" != typeof c) throw new TypeError("Expected a function"); function invokeFunc(u) { var d = E, v = k; return E = k = void 0, W = u, U = c.apply(v, d) } function shouldInvoke(c) { var d = c - G; return void 0 === G || d >= u || d < 0 || Y && c - W >= R } function timerExpired() { var c = lodash_es_now(); if (shouldInvoke(c)) return trailingEdge(c); H = setTimeout(timerExpired, function remainingWait(c) { var d = u - (c - G); return Y ? pe(d, R - (c - W)) : d }(c)) } function trailingEdge(c) { return H = void 0, J && E ? invokeFunc(c) : (E = k = void 0, U) } function debounced() { var c = lodash_es_now(), d = shouldInvoke(c); if (E = arguments, k = this, G = c, d) { if (void 0 === H) return function leadingEdge(c) { return W = c, H = setTimeout(timerExpired, u), Z ? invokeFunc(c) : U }(G); if (Y) return clearTimeout(H), H = setTimeout(timerExpired, u), invokeFunc(G) } return void 0 === H && (H = setTimeout(timerExpired, u)), U } return u = ue(u) || 0, v(d) && (Z = !!d.leading, R = (Y = "maxWait" in d) ? de(ue(d.maxWait) || 0, u) : R, J = "trailing" in d ? !!d.trailing : J), debounced.cancel = function cancel() { void 0 !== H && clearTimeout(H), W = 0, E = G = k = H = void 0 }, debounced.flush = function flush() { return void 0 === H ? U : trailingEdge(lodash_es_now()) }, debounced }; var he = function throttle(c, u, d) { var E = !0, k = !0; if ("function" != typeof c) throw new TypeError("Expected a function"); return v(d) && (E = "leading" in d ? !!d.leading : E, k = "trailing" in d ? !!d.trailing : k), fe(c, u, { "leading": E, "maxWait": u, "trailing": k }) } }, "4296": function (c, u, d) { "use strict"; d.r(u), d.d(u, { "customAlphabet": function () { return customAlphabet }, "customRandom": function () { return customRandom }, "nanoid": function () { return nanoid }, "random": function () { return random }, "urlAlphabet": function () { return v } }); let v = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", random = c => crypto.getRandomValues(new Uint8Array(c)), customRandom = (c, u, d) => { let v = (2 << Math.log(c.length - 1) / Math.LN2) - 1, E = -~(1.6 * v * u / c.length); return (k = u) => { let R = ""; for (; ;) { let u = d(E), U = E; for (; U--;)if (R += c[u[U] & v] || "", R.length === k) return R } } }, customAlphabet = (c, u = 21) => customRandom(c, u, random), nanoid = (c = 21) => crypto.getRandomValues(new Uint8Array(c)).reduce(((c, u) => c += (u &= 63) < 36 ? u.toString(36) : u < 62 ? (u - 26).toString(36).toUpperCase() : u > 62 ? "-" : "_"), "") }, "7582": function (c, u, d) { "use strict"; d.d(u, { "Q_": function () { return __classPrivateFieldGet }, "YH": function () { return __classPrivateFieldSet }, "_T": function () { return __rest }, "mG": function () { return __awaiter } }); function __rest(c, u) { var d = {}; for (var v in c) Object.prototype.hasOwnProperty.call(c, v) && u.indexOf(v) < 0 && (d[v] = c[v]); if (null != c && "function" == typeof Object.getOwnPropertySymbols) { var E = 0; for (v = Object.getOwnPropertySymbols(c); E < v.length; E++)u.indexOf(v[E]) < 0 && Object.prototype.propertyIsEnumerable.call(c, v[E]) && (d[v[E]] = c[v[E]]) } return d } function __awaiter(c, u, d, v) { return new (d || (d = Promise))((function (E, k) { function fulfilled(c) { try { step(v.next(c)) } catch (c) { k(c) } } function rejected(c) { try { step(v.throw(c)) } catch (c) { k(c) } } function step(c) { c.done ? E(c.value) : function adopt(c) { return c instanceof d ? c : new d((function (u) { u(c) })) }(c.value).then(fulfilled, rejected) } step((v = v.apply(c, u || [])).next()) })) } Object.create; Object.create; function __classPrivateFieldGet(c, u, d, v) { if ("a" === d && !v) throw new TypeError("Private accessor was defined without a getter"); if ("function" == typeof u ? c !== u || !v : !u.has(c)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return "m" === d ? v : "a" === d ? v.call(c) : v ? v.value : u.get(c) } function __classPrivateFieldSet(c, u, d, v, E) { if ("m" === v) throw new TypeError("Private method is not writable"); if ("a" === v && !E) throw new TypeError("Private accessor was defined without a setter"); if ("function" == typeof u ? c !== u || !E : !u.has(c)) throw new TypeError("Cannot write private member to an object whose class did not declare it"); return "a" === v ? E.call(c, d) : E ? E.value = d : u.set(c, d), d } "function" == typeof SuppressedError && SuppressedError } }, R = {}; function __webpack_require__(c) { var u = R[c]; if (void 0 !== u) return u.exports; var d = R[c] = { "id": c, "loaded": !1, "exports": {} }; return k[c].call(d.exports, d, d.exports, __webpack_require__), d.loaded = !0, d.exports } __webpack_require__.m = k, c = [], __webpack_require__.O = function (u, d, v, E) { if (!d) { var k = 1 / 0; for (G = 0; G < c.length; G++) { d = c[G][0], v = c[G][1], E = c[G][2]; for (var R = !0, U = 0; U < d.length; U++)(!1 & E || k >= E) && Object.keys(__webpack_require__.O).every((function (c) { return __webpack_require__.O[c](d[U]) })) ? d.splice(U--, 1) : (R = !1, E < k && (k = E)); if (R) { c.splice(G--, 1); var H = v(); void 0 !== H && (u = H) } } return u } E = E || 0; for (var G = c.length; G > 0 && c[G - 1][2] > E; G--)c[G] = c[G - 1]; c[G] = [d, v, E] }, __webpack_require__.n = function (c) { var u = c && c.__esModule ? function () { return c.default } : function () { return c }; return __webpack_require__.d(u, { "a": u }), u }, __webpack_require__.d = function (c, u) { for (var d in u) __webpack_require__.o(u, d) && !__webpack_require__.o(c, d) && Object.defineProperty(c, d, { "enumerable": !0, "get": u[d] }) }, __webpack_require__.f = {}, __webpack_require__.e = function (c) { return Promise.all(Object.keys(__webpack_require__.f).reduce((function (u, d) { return __webpack_require__.f[d](c, u), u }), [])) }, __webpack_require__.u = function (c) { return "js/" + c + "." + { "24": "a00377693b8e7af2f40f", "39": "048bae3ef1f6d3259ed3", "41": "28f2c3a8c792c6bb2e00", "157": "089a098644d00ed5b475", "224": "5a5dedec55fcf5686d8a", "242": "5aaa5a761d8b12161213", "267": "859f29118f68b0f8fe70", "311": "8d4f88007ffc31bbfded", "318": "b11fbaf230257fd180c5", "328": "65596c3215d6fbfbd480", "333": "f914cf9a4f8c1e14128a", "347": "663636bb7b0cacb56308", "371": "41a8158442ad909f0626", "443": "b88c53f3941a66214552", "475": "d6d953c817772a4abadf", "491": "ecd037f1ed0528c008e8", "512": "c8de517be48544d4f208", "518": "d0956225c9b1f21acd45", "573": "1ab57cafa164e28656b4", "576": "53b90b8c03bec390bcf0", "583": "63dd12f6ebf8e2e07a33", "616": "8339d05efd7c5fe6af1d", "650": "71a65963b986b4da3da6", "681": "d2bf853eab82153b7df6", "741": "1c5891cbf8f6bffb0479", "813": "80c295b12b778531f5c9", "833": "713d804507bde2ac5450", "866": "f005501715234632be92", "929": "861c9c20ad9e791200f1", "953": "0aaa4c1cedb5d108fe6e", "983": "0a22285ff3b1e171fc8e" }[c] + ".js" }, __webpack_require__.miniCssF = function (c) { return "css/" + c + "." + { "24": "a00377693b8e7af2f40f", "39": "048bae3ef1f6d3259ed3", "157": "089a098644d00ed5b475", "224": "5a5dedec55fcf5686d8a", "242": "5aaa5a761d8b12161213", "267": "859f29118f68b0f8fe70", "311": "8d4f88007ffc31bbfded", "318": "b11fbaf230257fd180c5", "328": "65596c3215d6fbfbd480", "333": "f914cf9a4f8c1e14128a", "347": "663636bb7b0cacb56308", "371": "41a8158442ad909f0626", "443": "b88c53f3941a66214552", "475": "d6d953c817772a4abadf", "491": "ecd037f1ed0528c008e8", "512": "c8de517be48544d4f208", "518": "d0956225c9b1f21acd45", "573": "1ab57cafa164e28656b4", "583": "63dd12f6ebf8e2e07a33", "616": "8339d05efd7c5fe6af1d", "650": "71a65963b986b4da3da6", "681": "d2bf853eab82153b7df6", "741": "1c5891cbf8f6bffb0479", "813": "80c295b12b778531f5c9", "833": "713d804507bde2ac5450", "866": "f005501715234632be92", "929": "861c9c20ad9e791200f1", "953": "0aaa4c1cedb5d108fe6e", "983": "0a22285ff3b1e171fc8e" }[c] + ".css" }, __webpack_require__.g = function () { if ("object" == typeof globalThis) return globalThis; try { return this || new Function("return this")() } catch (c) { if ("object" == typeof window) return window } }(), __webpack_require__.o = function (c, u) { return Object.prototype.hasOwnProperty.call(c, u) }, u = {}, d = "ai-community-applet-uni:", __webpack_require__.l = function (c, v, E, k) { if (u[c]) u[c].push(v); else { var R, U; if (void 0 !== E) for (var H = document.getElementsByTagName("script"), G = 0; G < H.length; G++) { var W = H[G]; if (W.getAttribute("src") == c || W.getAttribute("data-webpack") == d + E) { R = W; break } } R || (U = !0, (R = document.createElement("script")).charset = "utf-8", R.timeout = 120, __webpack_require__.nc && R.setAttribute("nonce", __webpack_require__.nc), R.setAttribute("data-webpack", d + E), R.src = c), u[c] = [v]; var onScriptComplete = function (d, v) { R.onerror = R.onload = null, clearTimeout(Z); var E = u[c]; if (delete u[c], R.parentNode && R.parentNode.removeChild(R), E && E.forEach((function (c) { return c(v) })), d) return d(v) }, Z = setTimeout(onScriptComplete.bind(null, void 0, { "type": "timeout", "target": R }), 12e4); R.onerror = onScriptComplete.bind(null, R.onerror), R.onload = onScriptComplete.bind(null, R.onload), U && document.head.appendChild(R) } }, __webpack_require__.r = function (c) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(c, Symbol.toStringTag, { "value": "Module" }), Object.defineProperty(c, "__esModule", { "value": !0 }) }, __webpack_require__.nmd = function (c) { return c.paths = [], c.children || (c.children = []), c }, __webpack_require__.p = "https://g1.itc.cn/aife-easyai-test/202412171133/assets/", v = function (c) { return new Promise((function (u, d) { var v = __webpack_require__.miniCssF(c), E = __webpack_require__.p + v; if (function (c, u) { for (var d = document.getElementsByTagName("link"), v = 0; v < d.length; v++) { var E = (R = d[v]).getAttribute("data-href") || R.getAttribute("href"); if ("stylesheet" === R.rel && (E === c || E === u)) return R } var k = document.getElementsByTagName("style"); for (v = 0; v < k.length; v++) { var R; if ((E = (R = k[v]).getAttribute("data-href")) === c || E === u) return R } }(v, E)) return u(); !function (c, u, d, v) { var E = document.createElement("link"); E.rel = "stylesheet", E.type = "text/css", E.onerror = E.onload = function (k) { if (E.onerror = E.onload = null, "load" === k.type) d(); else { var R = k && ("load" === k.type ? "missing" : k.type), U = k && k.target && k.target.href || u, H = new Error("Loading CSS chunk " + c + " failed.\n(" + U + ")"); H.code = "CSS_CHUNK_LOAD_FAILED", H.type = R, H.request = U, E.parentNode.removeChild(E), v(H) } }, E.href = u, document.head.appendChild(E) }(c, E, u, d) })) }, E = { "143": 0 }, __webpack_require__.f.miniCss = function (c, u) { E[c] ? u.push(E[c]) : 0 !== E[c] && { "24": 1, "39": 1, "157": 1, "224": 1, "242": 1, "267": 1, "311": 1, "318": 1, "328": 1, "333": 1, "347": 1, "371": 1, "443": 1, "475": 1, "491": 1, "512": 1, "518": 1, "573": 1, "583": 1, "616": 1, "650": 1, "681": 1, "741": 1, "813": 1, "833": 1, "866": 1, "929": 1, "953": 1, "983": 1 }[c] && u.push(E[c] = v(c).then((function () { E[c] = 0 }), (function (u) { throw delete E[c], u }))) }, function () { __webpack_require__.b = document.baseURI || self.location.href; var c = { "143": 0 }; __webpack_require__.f.j = function (u, d) { var v = __webpack_require__.o(c, u) ? c[u] : void 0; if (0 !== v) if (v) d.push(v[2]); else { var E = new Promise((function (d, E) { v = c[u] = [d, E] })); d.push(v[2] = E); var k = __webpack_require__.p + __webpack_require__.u(u), R = new Error; __webpack_require__.l(k, (function (d) { if (__webpack_require__.o(c, u) && (0 !== (v = c[u]) && (c[u] = void 0), v)) { var E = d && ("load" === d.type ? "missing" : d.type), k = d && d.target && d.target.src; R.message = "Loading chunk " + u + " failed.\n(" + E + ": " + k + ")", R.name = "ChunkLoadError", R.type = E, R.request = k, v[1](R) } }), "chunk-" + u, u) } }, __webpack_require__.O.j = function (u) { return 0 === c[u] }; var webpackJsonpCallback = function (u, d) { var v, E, k = d[0], R = d[1], U = d[2], H = 0; if (k.some((function (u) { return 0 !== c[u] }))) { for (v in R) __webpack_require__.o(R, v) && (__webpack_require__.m[v] = R[v]); if (U) var G = U(__webpack_require__) } for (u && u(d); H < k.length; H++)E = k[H], __webpack_require__.o(c, E) && c[E] && c[E][0](), c[E] = 0; return __webpack_require__.O(G) }, u = self.webpackJsonp = self.webpackJsonp || []; u.forEach(webpackJsonpCallback.bind(null, 0)), u.push = webpackJsonpCallback.bind(null, u.push.bind(u)) }(), __webpack_require__.nc = void 0; var U = __webpack_require__.O(void 0, [823], (function () { return __webpack_require__(2723) })); U = __webpack_require__.O(U) }();
